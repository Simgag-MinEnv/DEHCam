
c:/Users/gagsi01/Documents/GitHub/DEHCam/target/1.5.2/boron/DEHCam.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  000d4000  000d4000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  000d4018  000d4018  00004018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000eb60  000d4020  000d4020  00004020  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM.exidx    00000008  000e2b80  000e2b80  00012b80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .backup       00000004  2003f400  000e2b88  0001f400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000048c  2003d66c  000e2b8c  0002d66c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000cf8  2003daf8  2003daf8  0003daf8  2**2
                  ALLOC
  7 .module_info_suffix 00000028  000e3018  000e3018  00033018  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .module_info_crc 00000004  000e3040  000e3040  00033040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .debug_info   0017cad7  00000000  00000000  00033044  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0001d15a  00000000  00000000  001afb1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00036a74  00000000  00000000  001ccc75  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00003d08  00000000  00000000  002036e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00007820  00000000  00000000  002073f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  00048984  00000000  00000000  0020ec11  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0004cbb6  00000000  00000000  00257595  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00124262  00000000  00000000  002a414b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00011754  00000000  00000000  003c83b0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

000d4020 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   d4020:	4809      	ldr	r0, [pc, #36]	; (d4048 <module_user_pre_init+0x28>)
   d4022:	490a      	ldr	r1, [pc, #40]	; (d404c <module_user_pre_init+0x2c>)
   d4024:	4288      	cmp	r0, r1
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
   d4026:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   d4028:	d005      	beq.n	d4036 <module_user_pre_init+0x16>
   d402a:	4a09      	ldr	r2, [pc, #36]	; (d4050 <module_user_pre_init+0x30>)
   d402c:	4282      	cmp	r2, r0
   d402e:	d002      	beq.n	d4036 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
   d4030:	1a12      	subs	r2, r2, r0
   d4032:	f00b ff8e 	bl	dff52 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
   d4036:	4807      	ldr	r0, [pc, #28]	; (d4054 <module_user_pre_init+0x34>)
   d4038:	4a07      	ldr	r2, [pc, #28]	; (d4058 <module_user_pre_init+0x38>)
   d403a:	2100      	movs	r1, #0
   d403c:	1a12      	subs	r2, r2, r0
   d403e:	f00b ff93 	bl	dff68 <memset>
    return &link_global_data_start;
}
   d4042:	4801      	ldr	r0, [pc, #4]	; (d4048 <module_user_pre_init+0x28>)
   d4044:	bd08      	pop	{r3, pc}
   d4046:	bf00      	nop
   d4048:	2003d66c 	.word	0x2003d66c
   d404c:	000e2b8c 	.word	0x000e2b8c
   d4050:	2003daf8 	.word	0x2003daf8
   d4054:	2003daf8 	.word	0x2003daf8
   d4058:	2003e7f0 	.word	0x2003e7f0

000d405c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
   d405c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
   d405e:	f009 fb07 	bl	dd670 <module_user_init_hook>
   d4062:	4c07      	ldr	r4, [pc, #28]	; (d4080 <module_user_init+0x24>)
   d4064:	4b07      	ldr	r3, [pc, #28]	; (d4084 <module_user_init+0x28>)
   d4066:	1ae4      	subs	r4, r4, r3
   d4068:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   d406a:	2500      	movs	r5, #0
   d406c:	461e      	mov	r6, r3
   d406e:	42a5      	cmp	r5, r4
   d4070:	d004      	beq.n	d407c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
   d4072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   d4076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   d4078:	3501      	adds	r5, #1
   d407a:	e7f8      	b.n	d406e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
   d407c:	bd70      	pop	{r4, r5, r6, pc}
   d407e:	bf00      	nop
   d4080:	000e2b74 	.word	0x000e2b74
   d4084:	000e2b1c 	.word	0x000e2b1c

000d4088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
   d4088:	f005 b88c 	b.w	d91a4 <setup>

000d408c <module_user_loop>:
}

void module_user_loop() {
   d408c:	b508      	push	{r3, lr}
    loop();
   d408e:	f004 f919 	bl	d82c4 <loop>
    _post_loop();
}
   d4092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
   d4096:	f009 baad 	b.w	dd5f4 <_post_loop>

000d409a <_Znwj>:
   d409a:	f007 be8d 	b.w	dbdb8 <malloc>

000d409e <_ZdlPv>:
   d409e:	f007 be93 	b.w	dbdc8 <free>

000d40a2 <_ZdaPv>:
	free(p);
}

void operator delete[](void *p)
{
	free(p);
   d40a2:	f007 be91 	b.w	dbdc8 <free>
	...

000d40a8 <__cxa_pure_virtual>:
char* strerror(int errnum) {
    return (char*)"";
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
   d40a8:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
   d40aa:	4a03      	ldr	r2, [pc, #12]	; (d40b8 <__cxa_pure_virtual+0x10>)
   d40ac:	2100      	movs	r1, #0
   d40ae:	200c      	movs	r0, #12
   d40b0:	f007 fd74 	bl	dbb9c <panic_>
   d40b4:	e7fe      	b.n	d40b4 <__cxa_pure_virtual+0xc>
   d40b6:	bf00      	nop
   d40b8:	000db7c5 	.word	0x000db7c5

000d40bc <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
   d40bc:	7800      	ldrb	r0, [r0, #0]
   d40be:	fab0 f080 	clz	r0, r0
   d40c2:	0940      	lsrs	r0, r0, #5
   d40c4:	4770      	bx	lr

000d40c6 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
   d40c6:	2301      	movs	r3, #1
   d40c8:	7003      	strb	r3, [r0, #0]
   d40ca:	4770      	bx	lr

000d40cc <_ZN8SdVolume21cacheMirrorBlockFlushEh>:
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheMirrorBlockFlush(uint8_t blocking) {
   d40cc:	b510      	push	{r4, lr}
  if (cacheMirrorBlock_) {
   d40ce:	4c07      	ldr	r4, [pc, #28]	; (d40ec <_ZN8SdVolume21cacheMirrorBlockFlushEh+0x20>)
   d40d0:	6821      	ldr	r1, [r4, #0]
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheMirrorBlockFlush(uint8_t blocking) {
   d40d2:	4603      	mov	r3, r0
  if (cacheMirrorBlock_) {
   d40d4:	b139      	cbz	r1, d40e6 <_ZN8SdVolume21cacheMirrorBlockFlushEh+0x1a>
    if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data, blocking)) {
   d40d6:	4806      	ldr	r0, [pc, #24]	; (d40f0 <_ZN8SdVolume21cacheMirrorBlockFlushEh+0x24>)
   d40d8:	4a06      	ldr	r2, [pc, #24]	; (d40f4 <_ZN8SdVolume21cacheMirrorBlockFlushEh+0x28>)
   d40da:	6800      	ldr	r0, [r0, #0]
   d40dc:	f006 f960 	bl	da3a0 <_ZN7Sd2Card10writeBlockEmPKhh>
   d40e0:	b110      	cbz	r0, d40e8 <_ZN8SdVolume21cacheMirrorBlockFlushEh+0x1c>
      return false;
    }
    cacheMirrorBlock_ = 0;
   d40e2:	2300      	movs	r3, #0
   d40e4:	6023      	str	r3, [r4, #0]
  }
  return true;
   d40e6:	2001      	movs	r0, #1
}
   d40e8:	bd10      	pop	{r4, pc}
   d40ea:	bf00      	nop
   d40ec:	2003dafc 	.word	0x2003dafc
   d40f0:	2003db00 	.word	0x2003db00
   d40f4:	2003db04 	.word	0x2003db04

000d40f8 <_ZN8SdVolume10cacheFlushEh>:
  }

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(uint8_t blocking) {
   d40f8:	b538      	push	{r3, r4, r5, lr}
  if (cacheDirty_) {
   d40fa:	4d0c      	ldr	r5, [pc, #48]	; (d412c <_ZN8SdVolume10cacheFlushEh+0x34>)
   d40fc:	782b      	ldrb	r3, [r5, #0]
  }

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(uint8_t blocking) {
   d40fe:	4604      	mov	r4, r0
  if (cacheDirty_) {
   d4100:	b193      	cbz	r3, d4128 <_ZN8SdVolume10cacheFlushEh+0x30>
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data, blocking)) {
   d4102:	4603      	mov	r3, r0
   d4104:	490a      	ldr	r1, [pc, #40]	; (d4130 <_ZN8SdVolume10cacheFlushEh+0x38>)
   d4106:	480b      	ldr	r0, [pc, #44]	; (d4134 <_ZN8SdVolume10cacheFlushEh+0x3c>)
   d4108:	4a0b      	ldr	r2, [pc, #44]	; (d4138 <_ZN8SdVolume10cacheFlushEh+0x40>)
   d410a:	6809      	ldr	r1, [r1, #0]
   d410c:	6800      	ldr	r0, [r0, #0]
   d410e:	f006 f947 	bl	da3a0 <_ZN7Sd2Card10writeBlockEmPKhh>
   d4112:	b908      	cbnz	r0, d4118 <_ZN8SdVolume10cacheFlushEh+0x20>
      return false;
   d4114:	2000      	movs	r0, #0
   d4116:	bd38      	pop	{r3, r4, r5, pc}
    }

    if (!blocking) {
   d4118:	b134      	cbz	r4, d4128 <_ZN8SdVolume10cacheFlushEh+0x30>
      return true;
    }

    // mirror FAT tables
    if (!cacheMirrorBlockFlush(blocking)) {
   d411a:	4620      	mov	r0, r4
   d411c:	f7ff ffd6 	bl	d40cc <_ZN8SdVolume21cacheMirrorBlockFlushEh>
   d4120:	2800      	cmp	r0, #0
   d4122:	d0f7      	beq.n	d4114 <_ZN8SdVolume10cacheFlushEh+0x1c>
      return false;
    }
    cacheDirty_ = 0;
   d4124:	2300      	movs	r3, #0
   d4126:	702b      	strb	r3, [r5, #0]
  }
  return true;
   d4128:	2001      	movs	r0, #1
}
   d412a:	bd38      	pop	{r3, r4, r5, pc}
   d412c:	2003dd04 	.word	0x2003dd04
   d4130:	2003d66c 	.word	0x2003d66c
   d4134:	2003db00 	.word	0x2003db00
   d4138:	2003db04 	.word	0x2003db04

000d413c <_ZN8SdVolume13cacheRawBlockEmh>:
    cacheMirrorBlock_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
   d413c:	b570      	push	{r4, r5, r6, lr}
  if (cacheBlockNumber_ != blockNumber) {
   d413e:	4d0d      	ldr	r5, [pc, #52]	; (d4174 <_ZN8SdVolume13cacheRawBlockEmh+0x38>)
   d4140:	682b      	ldr	r3, [r5, #0]
   d4142:	4283      	cmp	r3, r0
    cacheMirrorBlock_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
   d4144:	4604      	mov	r4, r0
   d4146:	460e      	mov	r6, r1
  if (cacheBlockNumber_ != blockNumber) {
   d4148:	d00e      	beq.n	d4168 <_ZN8SdVolume13cacheRawBlockEmh+0x2c>
    if (!cacheFlush()) {
   d414a:	2001      	movs	r0, #1
   d414c:	f7ff ffd4 	bl	d40f8 <_ZN8SdVolume10cacheFlushEh>
   d4150:	b908      	cbnz	r0, d4156 <_ZN8SdVolume13cacheRawBlockEmh+0x1a>
      return false;
   d4152:	2000      	movs	r0, #0
   d4154:	bd70      	pop	{r4, r5, r6, pc}
    }
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
   d4156:	4b08      	ldr	r3, [pc, #32]	; (d4178 <_ZN8SdVolume13cacheRawBlockEmh+0x3c>)
   d4158:	4a08      	ldr	r2, [pc, #32]	; (d417c <_ZN8SdVolume13cacheRawBlockEmh+0x40>)
   d415a:	6818      	ldr	r0, [r3, #0]
   d415c:	4621      	mov	r1, r4
   d415e:	f006 f915 	bl	da38c <_ZN7Sd2Card9readBlockEmPh>
   d4162:	2800      	cmp	r0, #0
   d4164:	d0f5      	beq.n	d4152 <_ZN8SdVolume13cacheRawBlockEmh+0x16>
      return false;
    }
    cacheBlockNumber_ = blockNumber;
   d4166:	602c      	str	r4, [r5, #0]
  }
  cacheDirty_ |= action;
   d4168:	4b05      	ldr	r3, [pc, #20]	; (d4180 <_ZN8SdVolume13cacheRawBlockEmh+0x44>)
   d416a:	7819      	ldrb	r1, [r3, #0]
   d416c:	4331      	orrs	r1, r6
   d416e:	7019      	strb	r1, [r3, #0]
  return true;
   d4170:	2001      	movs	r0, #1
}
   d4172:	bd70      	pop	{r4, r5, r6, pc}
   d4174:	2003d66c 	.word	0x2003d66c
   d4178:	2003db00 	.word	0x2003db00
   d417c:	2003db04 	.word	0x2003db04
   d4180:	2003dd04 	.word	0x2003dd04

000d4184 <_ZN8SdVolume14cacheZeroBlockEm>:
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
   d4184:	b510      	push	{r4, lr}
   d4186:	4604      	mov	r4, r0
  if (!cacheFlush()) {
   d4188:	2001      	movs	r0, #1
   d418a:	f7ff ffb5 	bl	d40f8 <_ZN8SdVolume10cacheFlushEh>
   d418e:	b178      	cbz	r0, d41b0 <_ZN8SdVolume14cacheZeroBlockEm+0x2c>
   d4190:	2300      	movs	r3, #0
    return false;
  }

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
    cacheBuffer_.data[i] = 0;
   d4192:	4a08      	ldr	r2, [pc, #32]	; (d41b4 <_ZN8SdVolume14cacheZeroBlockEm+0x30>)
   d4194:	4619      	mov	r1, r3
   d4196:	5499      	strb	r1, [r3, r2]
   d4198:	3301      	adds	r3, #1
  if (!cacheFlush()) {
    return false;
  }

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
   d419a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   d419e:	d1fa      	bne.n	d4196 <_ZN8SdVolume14cacheZeroBlockEm+0x12>
    cacheBuffer_.data[i] = 0;
  }
  cacheBlockNumber_ = blockNumber;
   d41a0:	4b05      	ldr	r3, [pc, #20]	; (d41b8 <_ZN8SdVolume14cacheZeroBlockEm+0x34>)
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
   d41a2:	4a06      	ldr	r2, [pc, #24]	; (d41bc <_ZN8SdVolume14cacheZeroBlockEm+0x38>)
   d41a4:	601c      	str	r4, [r3, #0]
   d41a6:	7813      	ldrb	r3, [r2, #0]
   d41a8:	f043 0301 	orr.w	r3, r3, #1
   d41ac:	7013      	strb	r3, [r2, #0]
  cacheSetDirty();
  return true;
   d41ae:	2001      	movs	r0, #1
}
   d41b0:	bd10      	pop	{r4, pc}
   d41b2:	bf00      	nop
   d41b4:	2003db04 	.word	0x2003db04
   d41b8:	2003d66c 	.word	0x2003d66c
   d41bc:	2003dd04 	.word	0x2003dd04

000d41c0 <_ZNK8SdVolume6fatGetEmPm>:
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
   d41c0:	b570      	push	{r4, r5, r6, lr}
  if (cluster > (clusterCount_ + 1)) {
   d41c2:	68c3      	ldr	r3, [r0, #12]
   d41c4:	3301      	adds	r3, #1
   d41c6:	428b      	cmp	r3, r1
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
   d41c8:	4605      	mov	r5, r0
   d41ca:	460c      	mov	r4, r1
   d41cc:	4616      	mov	r6, r2
  if (cluster > (clusterCount_ + 1)) {
   d41ce:	d201      	bcs.n	d41d4 <_ZNK8SdVolume6fatGetEmPm+0x14>
    return false;
   d41d0:	2000      	movs	r0, #0
   d41d2:	bd70      	pop	{r4, r5, r6, pc}
  }
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   d41d4:	f890 2020 	ldrb.w	r2, [r0, #32]
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) {
    return false;
  }
  uint32_t lba = fatStartBlock_;
   d41d8:	69c3      	ldr	r3, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   d41da:	2a10      	cmp	r2, #16
   d41dc:	bf0c      	ite	eq
   d41de:	0a08      	lsreq	r0, r1, #8
   d41e0:	09c8      	lsrne	r0, r1, #7
   d41e2:	4418      	add	r0, r3
  if (lba != cacheBlockNumber_) {
   d41e4:	4b0d      	ldr	r3, [pc, #52]	; (d421c <_ZNK8SdVolume6fatGetEmPm+0x5c>)
   d41e6:	681b      	ldr	r3, [r3, #0]
   d41e8:	4298      	cmp	r0, r3
   d41ea:	d108      	bne.n	d41fe <_ZNK8SdVolume6fatGetEmPm+0x3e>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
      return false;
    }
  }
  if (fatType_ == 16) {
   d41ec:	f895 3020 	ldrb.w	r3, [r5, #32]
   d41f0:	2b10      	cmp	r3, #16
   d41f2:	4b0b      	ldr	r3, [pc, #44]	; (d4220 <_ZNK8SdVolume6fatGetEmPm+0x60>)
   d41f4:	d109      	bne.n	d420a <_ZNK8SdVolume6fatGetEmPm+0x4a>
    *value = cacheBuffer_.fat16[cluster & 0XFF];
   d41f6:	b2e4      	uxtb	r4, r4
   d41f8:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   d41fc:	e00b      	b.n	d4216 <_ZNK8SdVolume6fatGetEmPm+0x56>
    return false;
  }
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
   d41fe:	2100      	movs	r1, #0
   d4200:	f7ff ff9c 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d4204:	2800      	cmp	r0, #0
   d4206:	d1f1      	bne.n	d41ec <_ZNK8SdVolume6fatGetEmPm+0x2c>
   d4208:	e7e2      	b.n	d41d0 <_ZNK8SdVolume6fatGetEmPm+0x10>
    }
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
   d420a:	f004 047f 	and.w	r4, r4, #127	; 0x7f
   d420e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   d4212:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
   d4216:	6033      	str	r3, [r6, #0]
   d4218:	2001      	movs	r0, #1
  }
  return true;
}
   d421a:	bd70      	pop	{r4, r5, r6, pc}
   d421c:	2003d66c 	.word	0x2003d66c
   d4220:	2003db04 	.word	0x2003db04

000d4224 <_ZNK8SdVolume9chainSizeEmPm>:
  cacheSetDirty();
  return true;
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
   d4224:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   d4228:	ae02      	add	r6, sp, #8
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   d422a:	f8df 8044 	ldr.w	r8, [pc, #68]	; d4270 <_ZNK8SdVolume9chainSizeEmPm+0x4c>
   d422e:	f846 1d04 	str.w	r1, [r6, #-4]!
   d4232:	4605      	mov	r5, r0
   d4234:	4617      	mov	r7, r2
  uint32_t s = 0;
   d4236:	2400      	movs	r4, #0
  do {
    if (!fatGet(cluster, &cluster)) {
      return false;
    }
    s += 512UL << clusterSizeShift_;
   d4238:	f44f 7900 	mov.w	r9, #512	; 0x200
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) {
   d423c:	4632      	mov	r2, r6
   d423e:	9901      	ldr	r1, [sp, #4]
   d4240:	4628      	mov	r0, r5
   d4242:	f7ff ffbd 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d4246:	b178      	cbz	r0, d4268 <_ZNK8SdVolume9chainSizeEmPm+0x44>
      return false;
    }
    s += 512UL << clusterSizeShift_;
   d4248:	7c2b      	ldrb	r3, [r5, #16]
   d424a:	f895 2020 	ldrb.w	r2, [r5, #32]
   d424e:	fa09 f303 	lsl.w	r3, r9, r3
   d4252:	441c      	add	r4, r3
   d4254:	f64f 73f8 	movw	r3, #65528	; 0xfff8
   d4258:	2a10      	cmp	r2, #16
   d425a:	bf18      	it	ne
   d425c:	4643      	movne	r3, r8
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
   d425e:	9a01      	ldr	r2, [sp, #4]
   d4260:	429a      	cmp	r2, r3
   d4262:	d3eb      	bcc.n	d423c <_ZNK8SdVolume9chainSizeEmPm+0x18>
    if (!fatGet(cluster, &cluster)) {
      return false;
    }
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
   d4264:	603c      	str	r4, [r7, #0]
  return true;
   d4266:	2001      	movs	r0, #1
}
   d4268:	b003      	add	sp, #12
   d426a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d426e:	bf00      	nop
   d4270:	0ffffff8 	.word	0x0ffffff8

000d4274 <_ZN8SdVolume6fatPutEmm>:
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) {
   d4274:	2901      	cmp	r1, #1
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   d4276:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d4278:	4606      	mov	r6, r0
   d427a:	460c      	mov	r4, r1
   d427c:	4617      	mov	r7, r2
  // error if reserved cluster
  if (cluster < 2) {
   d427e:	d801      	bhi.n	d4284 <_ZN8SdVolume6fatPutEmm+0x10>
    return false;
   d4280:	2000      	movs	r0, #0
   d4282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) {
   d4284:	68c3      	ldr	r3, [r0, #12]
   d4286:	3301      	adds	r3, #1
   d4288:	4299      	cmp	r1, r3
   d428a:	d8f9      	bhi.n	d4280 <_ZN8SdVolume6fatPutEmm+0xc>
    return false;
  }

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   d428c:	f890 3020 	ldrb.w	r3, [r0, #32]
  if (cluster > (clusterCount_ + 1)) {
    return false;
  }

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
   d4290:	69c5      	ldr	r5, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   d4292:	2b10      	cmp	r3, #16
   d4294:	bf0c      	ite	eq
   d4296:	0a0b      	lsreq	r3, r1, #8
   d4298:	09cb      	lsrne	r3, r1, #7
   d429a:	441d      	add	r5, r3

  if (lba != cacheBlockNumber_) {
   d429c:	4b12      	ldr	r3, [pc, #72]	; (d42e8 <_ZN8SdVolume6fatPutEmm+0x74>)
   d429e:	681b      	ldr	r3, [r3, #0]
   d42a0:	429d      	cmp	r5, r3
   d42a2:	d108      	bne.n	d42b6 <_ZN8SdVolume6fatPutEmm+0x42>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
      return false;
    }
  }
  // store entry
  if (fatType_ == 16) {
   d42a4:	f896 3020 	ldrb.w	r3, [r6, #32]
   d42a8:	2b10      	cmp	r3, #16
   d42aa:	4b10      	ldr	r3, [pc, #64]	; (d42ec <_ZN8SdVolume6fatPutEmm+0x78>)
   d42ac:	d10a      	bne.n	d42c4 <_ZN8SdVolume6fatPutEmm+0x50>
    cacheBuffer_.fat16[cluster & 0XFF] = value;
   d42ae:	b2e4      	uxtb	r4, r4
   d42b0:	f823 7014 	strh.w	r7, [r3, r4, lsl #1]
   d42b4:	e00a      	b.n	d42cc <_ZN8SdVolume6fatPutEmm+0x58>
  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;

  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
   d42b6:	2100      	movs	r1, #0
   d42b8:	4628      	mov	r0, r5
   d42ba:	f7ff ff3f 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d42be:	2800      	cmp	r0, #0
   d42c0:	d1f0      	bne.n	d42a4 <_ZN8SdVolume6fatPutEmm+0x30>
   d42c2:	e7dd      	b.n	d4280 <_ZN8SdVolume6fatPutEmm+0xc>
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
   d42c4:	f004 047f 	and.w	r4, r4, #127	; 0x7f
   d42c8:	f843 7024 	str.w	r7, [r3, r4, lsl #2]
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
   d42cc:	4a08      	ldr	r2, [pc, #32]	; (d42f0 <_ZN8SdVolume6fatPutEmm+0x7c>)
   d42ce:	7813      	ldrb	r3, [r2, #0]
   d42d0:	f043 0301 	orr.w	r3, r3, #1
   d42d4:	7013      	strb	r3, [r2, #0]
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) {
   d42d6:	7e33      	ldrb	r3, [r6, #24]
   d42d8:	2b01      	cmp	r3, #1
    cacheMirrorBlock_ = lba + blocksPerFat_;
   d42da:	bf81      	itttt	hi
   d42dc:	68b3      	ldrhi	r3, [r6, #8]
   d42de:	18ed      	addhi	r5, r5, r3
   d42e0:	4b04      	ldrhi	r3, [pc, #16]	; (d42f4 <_ZN8SdVolume6fatPutEmm+0x80>)
   d42e2:	601d      	strhi	r5, [r3, #0]
  }
  return true;
   d42e4:	2001      	movs	r0, #1
}
   d42e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d42e8:	2003d66c 	.word	0x2003d66c
   d42ec:	2003db04 	.word	0x2003db04
   d42f0:	2003dd04 	.word	0x2003dd04
   d42f4:	2003dafc 	.word	0x2003dafc

000d42f8 <_ZN8SdVolume15allocContiguousEmPm>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   d42f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
   d42fc:	6814      	ldr	r4, [r2, #0]
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   d42fe:	4606      	mov	r6, r0
   d4300:	468b      	mov	fp, r1
   d4302:	4617      	mov	r7, r2

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
   d4304:	b11c      	cbz	r4, d430e <_ZN8SdVolume15allocContiguousEmPm+0x16>
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
   d4306:	3401      	adds	r4, #1

    // don't save new start location
    setStart = false;
   d4308:	f04f 0a00 	mov.w	sl, #0
   d430c:	e005      	b.n	d431a <_ZN8SdVolume15allocContiguousEmPm+0x22>
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;

    // save next search start if one cluster
    setStart = 1 == count;
   d430e:	1e4b      	subs	r3, r1, #1
   d4310:	f1d3 0a00 	rsbs	sl, r3, #0

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
   d4314:	6804      	ldr	r4, [r0, #0]

    // save next search start if one cluster
    setStart = 1 == count;
   d4316:	eb4a 0a03 	adc.w	sl, sl, r3
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
   d431a:	68f3      	ldr	r3, [r6, #12]

    // save next search start if one cluster
    setStart = 1 == count;
  }
  // end of group
  uint32_t endCluster = bgnCluster;
   d431c:	4625      	mov	r5, r4

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
   d431e:	f103 0901 	add.w	r9, r3, #1

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   d4322:	f04f 0800 	mov.w	r8, #0
    // can't find space checked all clusters
    if (n >= clusterCount_) {
   d4326:	68f3      	ldr	r3, [r6, #12]
   d4328:	4598      	cmp	r8, r3
   d432a:	d21d      	bcs.n	d4368 <_ZN8SdVolume15allocContiguousEmPm+0x70>
      return false;
    }

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
   d432c:	454d      	cmp	r5, r9
      bgnCluster = endCluster = 2;
   d432e:	bf88      	it	hi
   d4330:	2502      	movhi	r5, #2
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) {
   d4332:	aa01      	add	r2, sp, #4
   d4334:	4629      	mov	r1, r5
   d4336:	4630      	mov	r0, r6
      return false;
    }

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
      bgnCluster = endCluster = 2;
   d4338:	bf88      	it	hi
   d433a:	462c      	movhi	r4, r5
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) {
   d433c:	f7ff ff40 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d4340:	b190      	cbz	r0, d4368 <_ZN8SdVolume15allocContiguousEmPm+0x70>
      return false;
    }

    if (f != 0) {
   d4342:	9a01      	ldr	r2, [sp, #4]
   d4344:	1c6b      	adds	r3, r5, #1
   d4346:	b10a      	cbz	r2, d434c <_ZN8SdVolume15allocContiguousEmPm+0x54>
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
   d4348:	461c      	mov	r4, r3
   d434a:	e002      	b.n	d4352 <_ZN8SdVolume15allocContiguousEmPm+0x5a>
    } else if ((endCluster - bgnCluster + 1) == count) {
   d434c:	1b1a      	subs	r2, r3, r4
   d434e:	4593      	cmp	fp, r2
   d4350:	d003      	beq.n	d435a <_ZN8SdVolume15allocContiguousEmPm+0x62>

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   d4352:	f108 0801 	add.w	r8, r8, #1
   d4356:	461d      	mov	r5, r3
   d4358:	e7e5      	b.n	d4326 <_ZN8SdVolume15allocContiguousEmPm+0x2e>
    static uint8_t cacheZeroBlock(uint32_t blockNumber);
    uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
    uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
    uint8_t fatPut(uint32_t cluster, uint32_t value);
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
   d435a:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
   d435e:	4629      	mov	r1, r5
   d4360:	4630      	mov	r0, r6
   d4362:	f7ff ff87 	bl	d4274 <_ZN8SdVolume6fatPutEmm>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) {
   d4366:	b958      	cbnz	r0, d4380 <_ZN8SdVolume15allocContiguousEmPm+0x88>
    return false;
   d4368:	2000      	movs	r0, #0
   d436a:	e01c      	b.n	d43a6 <_ZN8SdVolume15allocContiguousEmPm+0xae>
  }

  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) {
   d436c:	f105 38ff 	add.w	r8, r5, #4294967295
   d4370:	462a      	mov	r2, r5
   d4372:	4641      	mov	r1, r8
   d4374:	4630      	mov	r0, r6
   d4376:	f7ff ff7d 	bl	d4274 <_ZN8SdVolume6fatPutEmm>
   d437a:	2800      	cmp	r0, #0
   d437c:	d0f4      	beq.n	d4368 <_ZN8SdVolume15allocContiguousEmPm+0x70>
      return false;
    }
    endCluster--;
   d437e:	4645      	mov	r5, r8
  if (!fatPutEOC(endCluster)) {
    return false;
  }

  // link clusters
  while (endCluster > bgnCluster) {
   d4380:	42ac      	cmp	r4, r5
   d4382:	d3f3      	bcc.n	d436c <_ZN8SdVolume15allocContiguousEmPm+0x74>
    if (!fatPut(endCluster - 1, endCluster)) {
      return false;
    }
    endCluster--;
  }
  if (*curCluster != 0) {
   d4384:	6839      	ldr	r1, [r7, #0]
   d4386:	b931      	cbnz	r1, d4396 <_ZN8SdVolume15allocContiguousEmPm+0x9e>
    if (!fatPut(*curCluster, bgnCluster)) {
      return false;
    }
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
   d4388:	603c      	str	r4, [r7, #0]

  // remember possible next free cluster
  if (setStart) {
   d438a:	f1ba 0f00 	cmp.w	sl, #0
   d438e:	d009      	beq.n	d43a4 <_ZN8SdVolume15allocContiguousEmPm+0xac>
    allocSearchStart_ = bgnCluster + 1;
   d4390:	3401      	adds	r4, #1
   d4392:	6034      	str	r4, [r6, #0]
   d4394:	e006      	b.n	d43a4 <_ZN8SdVolume15allocContiguousEmPm+0xac>
    }
    endCluster--;
  }
  if (*curCluster != 0) {
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) {
   d4396:	4622      	mov	r2, r4
   d4398:	4630      	mov	r0, r6
   d439a:	f7ff ff6b 	bl	d4274 <_ZN8SdVolume6fatPutEmm>
   d439e:	2800      	cmp	r0, #0
   d43a0:	d1f2      	bne.n	d4388 <_ZN8SdVolume15allocContiguousEmPm+0x90>
   d43a2:	e7e1      	b.n	d4368 <_ZN8SdVolume15allocContiguousEmPm+0x70>
  // remember possible next free cluster
  if (setStart) {
    allocSearchStart_ = bgnCluster + 1;
  }

  return true;
   d43a4:	2001      	movs	r0, #1
}
   d43a6:	b003      	add	sp, #12
   d43a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000d43ac <_ZN8SdVolume9freeChainEm>:
  }
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
   d43ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
  // clear free cluster location
  allocSearchStart_ = 2;
   d43ae:	2302      	movs	r3, #2
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   d43b0:	4e0f      	ldr	r6, [pc, #60]	; (d43f0 <_ZN8SdVolume9freeChainEm+0x44>)
   d43b2:	6003      	str	r3, [r0, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
   d43b4:	4605      	mov	r5, r0
   d43b6:	460c      	mov	r4, r1
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) {
   d43b8:	aa01      	add	r2, sp, #4
   d43ba:	4621      	mov	r1, r4
   d43bc:	4628      	mov	r0, r5
   d43be:	f7ff feff 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d43c2:	b188      	cbz	r0, d43e8 <_ZN8SdVolume9freeChainEm+0x3c>
      return false;
    }

    // free cluster
    if (!fatPut(cluster, 0)) {
   d43c4:	2200      	movs	r2, #0
   d43c6:	4621      	mov	r1, r4
   d43c8:	4628      	mov	r0, r5
   d43ca:	f7ff ff53 	bl	d4274 <_ZN8SdVolume6fatPutEmm>
   d43ce:	b158      	cbz	r0, d43e8 <_ZN8SdVolume9freeChainEm+0x3c>
   d43d0:	f895 2020 	ldrb.w	r2, [r5, #32]
      return false;
    }

    cluster = next;
   d43d4:	9c01      	ldr	r4, [sp, #4]
   d43d6:	f64f 73f8 	movw	r3, #65528	; 0xfff8
   d43da:	2a10      	cmp	r2, #16
   d43dc:	bf18      	it	ne
   d43de:	4633      	movne	r3, r6
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
   d43e0:	429c      	cmp	r4, r3
   d43e2:	d3e9      	bcc.n	d43b8 <_ZN8SdVolume9freeChainEm+0xc>
    }

    cluster = next;
  } while (!isEOC(cluster));

  return true;
   d43e4:	2001      	movs	r0, #1
   d43e6:	e000      	b.n	d43ea <_ZN8SdVolume9freeChainEm+0x3e>
  allocSearchStart_ = 2;

  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) {
      return false;
   d43e8:	2000      	movs	r0, #0

    cluster = next;
  } while (!isEOC(cluster));

  return true;
}
   d43ea:	b002      	add	sp, #8
   d43ec:	bd70      	pop	{r4, r5, r6, pc}
   d43ee:	bf00      	nop
   d43f0:	0ffffff8 	.word	0x0ffffff8

000d43f4 <_ZN8SdVolume4initEP7Sd2Cardh>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  Reasons for
   failure include not finding a valid partition, not finding a valid
   FAT file system in the specified partition or an I/O error.
*/
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   d43f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
   d43f6:	4b3d      	ldr	r3, [pc, #244]	; (d44ec <_ZN8SdVolume4initEP7Sd2Cardh+0xf8>)
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  Reasons for
   failure include not finding a valid partition, not finding a valid
   FAT file system in the specified partition or an I/O error.
*/
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   d43f8:	4604      	mov	r4, r0
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
   d43fa:	6019      	str	r1, [r3, #0]
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
   d43fc:	4615      	mov	r5, r2
   d43fe:	b1da      	cbz	r2, d4438 <_ZN8SdVolume4initEP7Sd2Cardh+0x44>
    if (part > 4) {
   d4400:	2a04      	cmp	r2, #4
   d4402:	d901      	bls.n	d4408 <_ZN8SdVolume4initEP7Sd2Cardh+0x14>
      return false;
   d4404:	2000      	movs	r0, #0
   d4406:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
   d4408:	2100      	movs	r1, #0
   d440a:	4608      	mov	r0, r1
   d440c:	f7ff fe96 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d4410:	2800      	cmp	r0, #0
   d4412:	d0f7      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      return false;
    }
    part_t* p = &cacheBuffer_.mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0  ||
   d4414:	4a36      	ldr	r2, [pc, #216]	; (d44f0 <_ZN8SdVolume4initEP7Sd2Cardh+0xfc>)
   d4416:	eb02 1305 	add.w	r3, r2, r5, lsl #4
   d441a:	f893 31ae 	ldrb.w	r3, [r3, #430]	; 0x1ae
   d441e:	065b      	lsls	r3, r3, #25
   d4420:	d1f0      	bne.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
        p->totalSectors < 100 ||
   d4422:	351b      	adds	r5, #27
   d4424:	eb02 1505 	add.w	r5, r2, r5, lsl #4
   d4428:	f8d5 300a 	ldr.w	r3, [r5, #10]
    }
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
      return false;
    }
    part_t* p = &cacheBuffer_.mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0  ||
   d442c:	2b63      	cmp	r3, #99	; 0x63
   d442e:	d9e9      	bls.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
        p->totalSectors < 100 ||
        p->firstSector == 0) {
   d4430:	f8d5 5006 	ldr.w	r5, [r5, #6]
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
      return false;
    }
    part_t* p = &cacheBuffer_.mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0  ||
        p->totalSectors < 100 ||
   d4434:	2d00      	cmp	r5, #0
   d4436:	d0e5      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
   d4438:	2100      	movs	r1, #0
   d443a:	4628      	mov	r0, r5
   d443c:	f7ff fe7e 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d4440:	2800      	cmp	r0, #0
   d4442:	d0df      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
   d4444:	4b2a      	ldr	r3, [pc, #168]	; (d44f0 <_ZN8SdVolume4initEP7Sd2Cardh+0xfc>)
   d4446:	f8b3 200b 	ldrh.w	r2, [r3, #11]
   d444a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   d444e:	d1d9      	bne.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      bpb->fatCount == 0 ||
   d4450:	7c19      	ldrb	r1, [r3, #16]
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
   d4452:	2900      	cmp	r1, #0
   d4454:	d0d6      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      bpb->fatCount == 0 ||
   d4456:	89da      	ldrh	r2, [r3, #14]
   d4458:	2a00      	cmp	r2, #0
   d445a:	d0d3      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      bpb->reservedSectorCount == 0 ||
      bpb->sectorsPerCluster == 0) {
   d445c:	7b5a      	ldrb	r2, [r3, #13]
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
      bpb->fatCount == 0 ||
      bpb->reservedSectorCount == 0 ||
   d445e:	2a00      	cmp	r2, #0
   d4460:	d0d0      	beq.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      bpb->sectorsPerCluster == 0) {
    // not valid FAT volume
    return false;
  }
  fatCount_ = bpb->fatCount;
   d4462:	7621      	strb	r1, [r4, #24]
  blocksPerCluster_ = bpb->sectorsPerCluster;

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
   d4464:	2100      	movs	r1, #0
      bpb->sectorsPerCluster == 0) {
    // not valid FAT volume
    return false;
  }
  fatCount_ = bpb->fatCount;
  blocksPerCluster_ = bpb->sectorsPerCluster;
   d4466:	7122      	strb	r2, [r4, #4]

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
   d4468:	7421      	strb	r1, [r4, #16]
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
   d446a:	2001      	movs	r0, #1
   d446c:	f894 e010 	ldrb.w	lr, [r4, #16]
   d4470:	fa00 f10e 	lsl.w	r1, r0, lr
   d4474:	428a      	cmp	r2, r1
   d4476:	d006      	beq.n	d4486 <_ZN8SdVolume4initEP7Sd2Cardh+0x92>
    // error if not power of 2
    if (clusterSizeShift_++ > 7) {
   d4478:	f10e 0101 	add.w	r1, lr, #1
   d447c:	f1be 0f07 	cmp.w	lr, #7
   d4480:	7421      	strb	r1, [r4, #16]
   d4482:	d9f3      	bls.n	d446c <_ZN8SdVolume4initEP7Sd2Cardh+0x78>
   d4484:	e7be      	b.n	d4404 <_ZN8SdVolume4initEP7Sd2Cardh+0x10>
      return false;
    }
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
   d4486:	8ad8      	ldrh	r0, [r3, #22]
                  bpb->sectorsPerFat16 : bpb->sectorsPerFat32;
   d4488:	b108      	cbz	r0, d448e <_ZN8SdVolume4initEP7Sd2Cardh+0x9a>
   d448a:	4601      	mov	r1, r0
   d448c:	e001      	b.n	d4492 <_ZN8SdVolume4initEP7Sd2Cardh+0x9e>
   d448e:	4a18      	ldr	r2, [pc, #96]	; (d44f0 <_ZN8SdVolume4initEP7Sd2Cardh+0xfc>)
   d4490:	6a51      	ldr	r1, [r2, #36]	; 0x24
   d4492:	60a1      	str	r1, [r4, #8]

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
   d4494:	89da      	ldrh	r2, [r3, #14]

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
   d4496:	7c1e      	ldrb	r6, [r3, #16]
    }
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
                  bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
   d4498:	442a      	add	r2, r5
   d449a:	61e2      	str	r2, [r4, #28]

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
   d449c:	f8b3 7011 	ldrh.w	r7, [r3, #17]
   d44a0:	8467      	strh	r7, [r4, #34]	; 0x22

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
   d44a2:	fb01 2006 	mla	r0, r1, r6, r2

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511) / 512);
   d44a6:	017a      	lsls	r2, r7, #5
   d44a8:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
   d44ac:	eb00 2262 	add.w	r2, r0, r2, asr #9

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
   d44b0:	6260      	str	r0, [r4, #36]	; 0x24

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511) / 512);
   d44b2:	6162      	str	r2, [r4, #20]

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
   d44b4:	f8b3 1013 	ldrh.w	r1, [r3, #19]
                         bpb->totalSectors16 : bpb->totalSectors32;
   d44b8:	b909      	cbnz	r1, d44be <_ZN8SdVolume4initEP7Sd2Cardh+0xca>
   d44ba:	490d      	ldr	r1, [pc, #52]	; (d44f0 <_ZN8SdVolume4initEP7Sd2Cardh+0xfc>)
   d44bc:	6a09      	ldr	r1, [r1, #32]
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
   d44be:	1aad      	subs	r5, r5, r2
   d44c0:	4429      	add	r1, r5
   d44c2:	fa21 f50e 	lsr.w	r5, r1, lr

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
   d44c6:	f640 72f4 	movw	r2, #4084	; 0xff4
   d44ca:	4295      	cmp	r5, r2
                         bpb->totalSectors16 : bpb->totalSectors32;
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
   d44cc:	60e5      	str	r5, [r4, #12]

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
   d44ce:	d801      	bhi.n	d44d4 <_ZN8SdVolume4initEP7Sd2Cardh+0xe0>
    fatType_ = 12;
   d44d0:	230c      	movs	r3, #12
   d44d2:	e007      	b.n	d44e4 <_ZN8SdVolume4initEP7Sd2Cardh+0xf0>
  } else if (clusterCount_ < 65525) {
   d44d4:	f64f 72f4 	movw	r2, #65524	; 0xfff4
   d44d8:	4295      	cmp	r5, r2
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
   d44da:	bf85      	ittet	hi
   d44dc:	6adb      	ldrhi	r3, [r3, #44]	; 0x2c
   d44de:	6263      	strhi	r3, [r4, #36]	; 0x24

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
   d44e0:	2310      	movls	r3, #16
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
   d44e2:	2320      	movhi	r3, #32
   d44e4:	f884 3020 	strb.w	r3, [r4, #32]
  }
  return true;
   d44e8:	2001      	movs	r0, #1
}
   d44ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d44ec:	2003db00 	.word	0x2003db00
   d44f0:	2003db04 	.word	0x2003db04

000d44f4 <_GLOBAL__sub_I__ZN8SdVolume17cacheBlockNumber_E>:

inline void pinSetFast(pin_t _pin) __attribute__((always_inline));
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
   d44f4:	f007 b8de 	b.w	db6b4 <HAL_Pin_Map>

000d44f8 <nrf_gpio_pin_port_decode>:
 *
 * @return Pointer to port register set.
 *
 */
__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
   d44f8:	b510      	push	{r4, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   d44fa:	6803      	ldr	r3, [r0, #0]
   d44fc:	2b2f      	cmp	r3, #47	; 0x2f
 *
 * @return Pointer to port register set.
 *
 */
__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
   d44fe:	4604      	mov	r4, r0
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   d4500:	d904      	bls.n	d450c <nrf_gpio_pin_port_decode+0x14>
   d4502:	4a07      	ldr	r2, [pc, #28]	; (d4520 <nrf_gpio_pin_port_decode+0x28>)
   d4504:	2100      	movs	r1, #0
   d4506:	200a      	movs	r0, #10
   d4508:	f007 fb48 	bl	dbb9c <panic_>
#if (GPIO_COUNT == 1)
    return NRF_P0;
#else
    if (*p_pin < P0_PIN_NUM)
   d450c:	6823      	ldr	r3, [r4, #0]
   d450e:	2b1f      	cmp	r3, #31
    {
        return NRF_P0;
    }
    else
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   d4510:	bf83      	ittte	hi
   d4512:	f003 031f 	andhi.w	r3, r3, #31
   d4516:	6023      	strhi	r3, [r4, #0]
        return NRF_P1;
   d4518:	4802      	ldrhi	r0, [pc, #8]	; (d4524 <nrf_gpio_pin_port_decode+0x2c>)
#if (GPIO_COUNT == 1)
    return NRF_P0;
#else
    if (*p_pin < P0_PIN_NUM)
    {
        return NRF_P0;
   d451a:	f04f 40a0 	movls.w	r0, #1342177280	; 0x50000000
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
        return NRF_P1;
    }
#endif
}
   d451e:	bd10      	pop	{r4, pc}
   d4520:	000db7c5 	.word	0x000db7c5
   d4524:	50000300 	.word	0x50000300

000d4528 <nrf_gpio_pin_set>:
    }
}


__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
{
   d4528:	b507      	push	{r0, r1, r2, lr}
   d452a:	ab02      	add	r3, sp, #8
   d452c:	f843 0d04 	str.w	r0, [r3, #-4]!
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   d4530:	4618      	mov	r0, r3
   d4532:	f7ff ffe1 	bl	d44f8 <nrf_gpio_pin_port_decode>

    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   d4536:	9a01      	ldr	r2, [sp, #4]
   d4538:	2301      	movs	r3, #1
   d453a:	4093      	lsls	r3, r2
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   d453c:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    nrf_gpio_port_out_set(reg, 1UL << pin_number);
}
   d4540:	b003      	add	sp, #12
   d4542:	f85d fb04 	ldr.w	pc, [sp], #4

000d4546 <nrf_gpio_pin_clear>:


__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
{
   d4546:	b507      	push	{r0, r1, r2, lr}
   d4548:	ab02      	add	r3, sp, #8
   d454a:	f843 0d04 	str.w	r0, [r3, #-4]!
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   d454e:	4618      	mov	r0, r3
   d4550:	f7ff ffd2 	bl	d44f8 <nrf_gpio_pin_port_decode>

    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   d4554:	9a01      	ldr	r2, [sp, #4]
   d4556:	2301      	movs	r3, #1
   d4558:	4093      	lsls	r3, r2
}


__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   d455a:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
}
   d455e:	b003      	add	sp, #12
   d4560:	f85d fb04 	ldr.w	pc, [sp], #4

000d4564 <_ZNK8particle13__SPISettings7printToER5Print>:
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
   d4564:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   d4566:	4602      	mov	r2, r0
   d4568:	4608      	mov	r0, r1
  {
    if (default_ && clock_ == 0)
   d456a:	7913      	ldrb	r3, [r2, #4]
   d456c:	6895      	ldr	r5, [r2, #8]
   d456e:	b133      	cbz	r3, d457e <_ZNK8particle13__SPISettings7printToER5Print+0x1a>
   d4570:	b93d      	cbnz	r5, d4582 <_ZNK8particle13__SPISettings7printToER5Print+0x1e>
      return p.print("<SPISettings default>");
   d4572:	490c      	ldr	r1, [pc, #48]	; (d45a4 <_ZNK8particle13__SPISettings7printToER5Print+0x40>)
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
  }
   d4574:	b004      	add	sp, #16
   d4576:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  virtual size_t printTo(Print& p) const
  {
    if (default_ && clock_ == 0)
      return p.print("<SPISettings default>");
   d457a:	f008 bc63 	b.w	dce44 <_ZN5Print5printEPKc>
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
   d457e:	4b0a      	ldr	r3, [pc, #40]	; (d45a8 <_ZNK8particle13__SPISettings7printToER5Print+0x44>)
   d4580:	e000      	b.n	d4584 <_ZNK8particle13__SPISettings7printToER5Print+0x20>
   d4582:	4b0a      	ldr	r3, [pc, #40]	; (d45ac <_ZNK8particle13__SPISettings7printToER5Print+0x48>)
   d4584:	7b16      	ldrb	r6, [r2, #12]
   d4586:	4c0a      	ldr	r4, [pc, #40]	; (d45b0 <_ZNK8particle13__SPISettings7printToER5Print+0x4c>)
   d4588:	490a      	ldr	r1, [pc, #40]	; (d45b4 <_ZNK8particle13__SPISettings7printToER5Print+0x50>)
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
   d458a:	7b52      	ldrb	r2, [r2, #13]
   d458c:	9202      	str	r2, [sp, #8]
   d458e:	2e01      	cmp	r6, #1
   d4590:	bf08      	it	eq
   d4592:	4621      	moveq	r1, r4
   d4594:	9101      	str	r1, [sp, #4]
   d4596:	9500      	str	r5, [sp, #0]
   d4598:	4a07      	ldr	r2, [pc, #28]	; (d45b8 <_ZNK8particle13__SPISettings7printToER5Print+0x54>)
   d459a:	2100      	movs	r1, #0
   d459c:	f008 fc8f 	bl	dcebe <_ZN5Print11printf_implEbPKcz>
  }
   d45a0:	b004      	add	sp, #16
   d45a2:	bd70      	pop	{r4, r5, r6, pc}
   d45a4:	000e0d5d 	.word	0x000e0d5d
   d45a8:	000e1eea 	.word	0x000e1eea
   d45ac:	000e0d4c 	.word	0x000e0d4c
   d45b0:	000e0d55 	.word	0x000e0d55
   d45b4:	000e0d59 	.word	0x000e0d59
   d45b8:	000e0d73 	.word	0x000e0d73

000d45bc <_ZN7TwoWire5writeEi>:
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
   d45bc:	6803      	ldr	r3, [r0, #0]
   d45be:	b2c9      	uxtb	r1, r1
   d45c0:	689b      	ldr	r3, [r3, #8]
   d45c2:	4718      	bx	r3

000d45c4 <_ZN7ArduCAMC1Ehi>:
ArduCAM::ArduCAM()
{
  sensor_model = OV7670;
  sensor_addr = 0x42;
}
ArduCAM::ArduCAM(byte model ,int CS)
   d45c4:	b538      	push	{r3, r4, r5, lr}
   d45c6:	4604      	mov	r4, r0
   d45c8:	460d      	mov	r5, r1
		#endif
	#endif
 #if defined (RASPBERRY_PI)
   pinMode(CS, OUTPUT);
 #else
	  pinMode(CS, OUTPUT);
   d45ca:	b290      	uxth	r0, r2
   d45cc:	2101      	movs	r1, #1
   d45ce:	f00a faaf 	bl	deb30 <pinMode>

inline void pinSetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d45d2:	4b13      	ldr	r3, [pc, #76]	; (d4620 <_ZN7ArduCAMC1Ehi+0x5c>)
   d45d4:	681b      	ldr	r3, [r3, #0]
    nrf_gpio_pin_set(nrf_pin);
   d45d6:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d45da:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d45de:	f003 031f 	and.w	r3, r3, #31
   d45e2:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d45e6:	f7ff ff9f 	bl	d4528 <nrf_gpio_pin_set>
      sbi(P_CS, B_CS);
	#endif
	sensor_model = model;
   d45ea:	7265      	strb	r5, [r4, #9]
	switch (sensor_model)
   d45ec:	2d10      	cmp	r5, #16
   d45ee:	d812      	bhi.n	d4616 <_ZN7ArduCAMC1Ehi+0x52>
   d45f0:	e8df f005 	tbb	[pc, r5]
   d45f4:	0d110b11 	.word	0x0d110b11
   d45f8:	090f0f0d 	.word	0x090f0f0d
   d45fc:	0d0b1111 	.word	0x0d0b1111
   d4600:	0d110f09 	.word	0x0d110f09
   d4604:	0d          	.byte	0x0d
   d4605:	00          	.byte	0x00
    break;
    case MT9M112:
    	#if defined (RASPBERRY_PI)
    		sensor_addr = 0x5d;
    	#else
      	sensor_addr = 0x90;
   d4606:	2390      	movs	r3, #144	; 0x90
   d4608:	e006      	b.n	d4618 <_ZN7ArduCAMC1Ehi+0x54>
      #endif
    break;
    case MT9M001:
      sensor_addr = 0xba;
   d460a:	23ba      	movs	r3, #186	; 0xba
   d460c:	e004      	b.n	d4618 <_ZN7ArduCAMC1Ehi+0x54>
    case MT9T112:
    case MT9D112:
    	#if defined (RASPBERRY_PI)
    		sensor_addr = 0x3c;
    	#else
      	sensor_addr = 0x78;
   d460e:	2378      	movs	r3, #120	; 0x78
   d4610:	e002      	b.n	d4618 <_ZN7ArduCAMC1Ehi+0x54>
    case OV9650:
    case OV9655:
    	#if defined (RASPBERRY_PI)
    		sensor_addr = 0x30;
    	#else
      	sensor_addr = 0x60;
   d4612:	2360      	movs	r3, #96	; 0x60
   d4614:	e000      	b.n	d4618 <_ZN7ArduCAMC1Ehi+0x54>
    break;
		default:
			#if defined (RASPBERRY_PI)
		 		sensor_addr = 0x21;
		 	#else
		 		sensor_addr = 0x42;
   d4616:	2342      	movs	r3, #66	; 0x42
   d4618:	72a3      	strb	r3, [r4, #10]
		// initialize i2c:
	if (!arducam_i2c_init(sensor_addr)) {
		printf("ERROR: I2C init failed\n");
	}
	#endif
}
   d461a:	4620      	mov	r0, r4
   d461c:	bd38      	pop	{r3, r4, r5, pc}
   d461e:	bf00      	nop
   d4620:	2003dd14 	.word	0x2003dd14

000d4624 <_ZN7ArduCAM7CS_HIGHEv>:

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();

inline void pinSetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4624:	4b05      	ldr	r3, [pc, #20]	; (d463c <_ZN7ArduCAM7CS_HIGHEv+0x18>)
   d4626:	681b      	ldr	r3, [r3, #0]
    nrf_gpio_pin_set(nrf_pin);
   d4628:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d462c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d4630:	f003 031f 	and.w	r3, r3, #31
   d4634:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4638:	f7ff bf76 	b.w	d4528 <nrf_gpio_pin_set>
   d463c:	2003dd14 	.word	0x2003dd14

000d4640 <_ZN7ArduCAM6CS_LOWEv>:
}

inline void pinResetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4640:	4b05      	ldr	r3, [pc, #20]	; (d4658 <_ZN7ArduCAM6CS_LOWEv+0x18>)
   d4642:	681b      	ldr	r3, [r3, #0]
    nrf_gpio_pin_clear(nrf_pin);
   d4644:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d4648:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d464c:	f003 031f 	and.w	r3, r3, #31
   d4650:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4654:	f7ff bf77 	b.w	d4546 <nrf_gpio_pin_clear>
   d4658:	2003dd14 	.word	0x2003dd14

000d465c <_ZN7ArduCAM10set_formatEh>:

}

void ArduCAM::set_format(byte fmt)
{
  if (fmt == BMP)
   d465c:	b909      	cbnz	r1, d4662 <_ZN7ArduCAM10set_formatEh+0x6>
    m_fmt = BMP;
   d465e:	7201      	strb	r1, [r0, #8]
   d4660:	4770      	bx	lr
  else
    m_fmt = JPEG;
   d4662:	2301      	movs	r3, #1
   d4664:	7203      	strb	r3, [r0, #8]
   d4666:	4770      	bx	lr

000d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>:



// Read/write 8 bit value to/from 8 bit register address	
byte ArduCAM::wrSensorReg8_8(int regID, int regDat)
{
   d4668:	b570      	push	{r4, r5, r6, lr}
   d466a:	4606      	mov	r6, r0
   d466c:	4614      	mov	r4, r2
   d466e:	460d      	mov	r5, r1
	#if defined (RASPBERRY_PI)
		arducam_i2c_write( regID , regDat );
	#else
		Wire.beginTransmission(sensor_addr >> 1);
   d4670:	f00a fb14 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4674:	7ab1      	ldrb	r1, [r6, #10]
   d4676:	0849      	lsrs	r1, r1, #1
   d4678:	f009 fddb 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
	  Wire.write(regID & 0x00FF);
   d467c:	f00a fb0e 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4680:	b2e9      	uxtb	r1, r5
   d4682:	f7ff ff9b 	bl	d45bc <_ZN7TwoWire5writeEi>
	  Wire.write(regDat & 0x00FF);
   d4686:	f00a fb09 	bl	dec9c <_Z19__fetch_global_Wirev>
   d468a:	b2e1      	uxtb	r1, r4
   d468c:	f7ff ff96 	bl	d45bc <_ZN7TwoWire5writeEi>
	  if (Wire.endTransmission())
   d4690:	f00a fb04 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4694:	f009 fdd4 	bl	de240 <_ZN7TwoWire15endTransmissionEv>
   d4698:	b920      	cbnz	r0, d46a4 <_ZN7ArduCAM14wrSensorReg8_8Eii+0x3c>
	  {
	    return 0;
	  }
	  delay(1);
   d469a:	2001      	movs	r0, #1
   d469c:	f008 fd4e 	bl	dd13c <delay>
	#endif
	return 1;
   d46a0:	2001      	movs	r0, #1
   d46a2:	bd70      	pop	{r4, r5, r6, pc}
		Wire.beginTransmission(sensor_addr >> 1);
	  Wire.write(regID & 0x00FF);
	  Wire.write(regDat & 0x00FF);
	  if (Wire.endTransmission())
	  {
	    return 0;
   d46a4:	2000      	movs	r0, #0
	  }
	  delay(1);
	#endif
	return 1;
	
}
   d46a6:	bd70      	pop	{r4, r5, r6, pc}

000d46a8 <_ZN7ArduCAM14set_Light_ModeEh>:
  else
    m_fmt = JPEG;
}

	void ArduCAM::set_Light_Mode(uint8_t Light_Mode)
	{
   d46a8:	b510      	push	{r4, lr}
			  wrSensorReg8_8(0xcc, 0x42);
			  wrSensorReg8_8(0xcd, 0x3f);
			  wrSensorReg8_8(0xce, 0x71);
			  break;
			  default :
				wrSensorReg8_8(0xff, 0x00);
   d46aa:	2200      	movs	r2, #0
  else
    m_fmt = JPEG;
}

	void ArduCAM::set_Light_Mode(uint8_t Light_Mode)
	{
   d46ac:	4604      	mov	r4, r0
 #if (defined (OV2640_CAM)||defined (OV2640_MINI_2MP)||defined (OV2640_MINI_2MP_PLUS))
		 switch(Light_Mode)
   d46ae:	2904      	cmp	r1, #4
   d46b0:	d855      	bhi.n	d475e <_ZN7ArduCAM14set_Light_ModeEh+0xb6>
   d46b2:	e8df f001 	tbb	[pc, r1]
   d46b6:	0354      	.short	0x0354
   d46b8:	2b17      	.short	0x2b17
   d46ba:	3f          	.byte	0x3f
   d46bb:	00          	.byte	0x00
			  case Auto:
				wrSensorReg8_8(0xff, 0x00);
				wrSensorReg8_8(0xc7, 0x00); //AWB on
			  break;
			  case Sunny:
				wrSensorReg8_8(0xff, 0x00);
   d46bc:	21ff      	movs	r1, #255	; 0xff
   d46be:	f7ff ffd3 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xc7, 0x40); //AWB off
   d46c2:	2240      	movs	r2, #64	; 0x40
   d46c4:	21c7      	movs	r1, #199	; 0xc7
   d46c6:	4620      	mov	r0, r4
   d46c8:	f7ff ffce 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xcc, 0x5e);
   d46cc:	225e      	movs	r2, #94	; 0x5e
   d46ce:	21cc      	movs	r1, #204	; 0xcc
   d46d0:	4620      	mov	r0, r4
   d46d2:	f7ff ffc9 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xcd, 0x41);
   d46d6:	2241      	movs	r2, #65	; 0x41
   d46d8:	21cd      	movs	r1, #205	; 0xcd
   d46da:	4620      	mov	r0, r4
   d46dc:	f7ff ffc4 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xce, 0x54);
   d46e0:	2254      	movs	r2, #84	; 0x54
   d46e2:	e03a      	b.n	d475a <_ZN7ArduCAM14set_Light_ModeEh+0xb2>
			  break;
			  case Cloudy:
				wrSensorReg8_8(0xff, 0x00);
   d46e4:	21ff      	movs	r1, #255	; 0xff
   d46e6:	f7ff ffbf 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xc7, 0x40); //AWB off
   d46ea:	2240      	movs	r2, #64	; 0x40
   d46ec:	21c7      	movs	r1, #199	; 0xc7
   d46ee:	4620      	mov	r0, r4
   d46f0:	f7ff ffba 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xcc, 0x65);
   d46f4:	2265      	movs	r2, #101	; 0x65
   d46f6:	21cc      	movs	r1, #204	; 0xcc
   d46f8:	4620      	mov	r0, r4
   d46fa:	f7ff ffb5 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xcd, 0x41);
   d46fe:	2241      	movs	r2, #65	; 0x41
   d4700:	21cd      	movs	r1, #205	; 0xcd
   d4702:	4620      	mov	r0, r4
   d4704:	f7ff ffb0 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xce, 0x4f);  
   d4708:	224f      	movs	r2, #79	; 0x4f
   d470a:	e026      	b.n	d475a <_ZN7ArduCAM14set_Light_ModeEh+0xb2>
			  break;
			  case Office:
			  wrSensorReg8_8(0xff, 0x00);
   d470c:	21ff      	movs	r1, #255	; 0xff
   d470e:	f7ff ffab 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xc7, 0x40); //AWB off
   d4712:	2240      	movs	r2, #64	; 0x40
   d4714:	21c7      	movs	r1, #199	; 0xc7
   d4716:	4620      	mov	r0, r4
   d4718:	f7ff ffa6 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xcc, 0x52);
   d471c:	2252      	movs	r2, #82	; 0x52
   d471e:	21cc      	movs	r1, #204	; 0xcc
   d4720:	4620      	mov	r0, r4
   d4722:	f7ff ffa1 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xcd, 0x41);
   d4726:	2241      	movs	r2, #65	; 0x41
   d4728:	21cd      	movs	r1, #205	; 0xcd
   d472a:	4620      	mov	r0, r4
   d472c:	f7ff ff9c 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xce, 0x66);
   d4730:	2266      	movs	r2, #102	; 0x66
   d4732:	e012      	b.n	d475a <_ZN7ArduCAM14set_Light_ModeEh+0xb2>
			  break;
			  case Home:
			  wrSensorReg8_8(0xff, 0x00);
   d4734:	21ff      	movs	r1, #255	; 0xff
   d4736:	f7ff ff97 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xc7, 0x40); //AWB off
   d473a:	2240      	movs	r2, #64	; 0x40
   d473c:	21c7      	movs	r1, #199	; 0xc7
   d473e:	4620      	mov	r0, r4
   d4740:	f7ff ff92 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xcc, 0x42);
   d4744:	2242      	movs	r2, #66	; 0x42
   d4746:	21cc      	movs	r1, #204	; 0xcc
   d4748:	4620      	mov	r0, r4
   d474a:	f7ff ff8d 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xcd, 0x3f);
   d474e:	223f      	movs	r2, #63	; 0x3f
   d4750:	21cd      	movs	r1, #205	; 0xcd
   d4752:	4620      	mov	r0, r4
   d4754:	f7ff ff88 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
			  wrSensorReg8_8(0xce, 0x71);
   d4758:	2271      	movs	r2, #113	; 0x71
   d475a:	21ce      	movs	r1, #206	; 0xce
   d475c:	e004      	b.n	d4768 <_ZN7ArduCAM14set_Light_ModeEh+0xc0>
			  break;
			  default :
				wrSensorReg8_8(0xff, 0x00);
   d475e:	21ff      	movs	r1, #255	; 0xff
   d4760:	f7ff ff82 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0xc7, 0x00); //AWB on
   d4764:	2200      	movs	r2, #0
   d4766:	21c7      	movs	r1, #199	; 0xc7
   d4768:	4620      	mov	r0, r4
			  break; 
		 }	
#endif
	}
   d476a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			  wrSensorReg8_8(0xcd, 0x3f);
			  wrSensorReg8_8(0xce, 0x71);
			  break;
			  default :
				wrSensorReg8_8(0xff, 0x00);
				wrSensorReg8_8(0xc7, 0x00); //AWB on
   d476e:	f7ff bf7b 	b.w	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>

000d4772 <_ZN7ArduCAM19set_Special_effectsEh>:
		}
#endif		
	}

	void ArduCAM::set_Special_effects(uint8_t Special_effect)
	{
   d4772:	b510      	push	{r4, lr}
   d4774:	4604      	mov	r4, r0
#if (defined (OV2640_CAM)||defined (OV2640_MINI_2MP)||defined (OV2640_MINI_2MP_PLUS))	
		switch(Special_effect)
   d4776:	2907      	cmp	r1, #7
   d4778:	f200 80a9 	bhi.w	d48ce <_ZN7ArduCAM19set_Special_effectsEh+0x15c>
   d477c:	e8df f001 	tbb	[pc, r1]
   d4780:	4d331e04 	.word	0x4d331e04
   d4784:	887d7267 	.word	0x887d7267
		{
			case Antique:
	
				wrSensorReg8_8(0xff, 0x00);
   d4788:	2200      	movs	r2, #0
   d478a:	21ff      	movs	r1, #255	; 0xff
   d478c:	f7ff ff6c 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d4790:	2200      	movs	r2, #0
   d4792:	217c      	movs	r1, #124	; 0x7c
   d4794:	4620      	mov	r0, r4
   d4796:	f7ff ff67 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x18);
   d479a:	2218      	movs	r2, #24
   d479c:	217d      	movs	r1, #125	; 0x7d
   d479e:	4620      	mov	r0, r4
   d47a0:	f7ff ff62 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x05);
   d47a4:	2205      	movs	r2, #5
   d47a6:	217c      	movs	r1, #124	; 0x7c
   d47a8:	4620      	mov	r0, r4
   d47aa:	f7ff ff5d 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x40);
   d47ae:	2240      	movs	r2, #64	; 0x40
   d47b0:	217d      	movs	r1, #125	; 0x7d
   d47b2:	4620      	mov	r0, r4
   d47b4:	f7ff ff58 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0xa6);
   d47b8:	22a6      	movs	r2, #166	; 0xa6
   d47ba:	e082      	b.n	d48c2 <_ZN7ArduCAM19set_Special_effectsEh+0x150>
			break;
			case Bluish:
				wrSensorReg8_8(0xff, 0x00);
   d47bc:	2200      	movs	r2, #0
   d47be:	21ff      	movs	r1, #255	; 0xff
   d47c0:	f7ff ff52 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d47c4:	2200      	movs	r2, #0
   d47c6:	217c      	movs	r1, #124	; 0x7c
   d47c8:	4620      	mov	r0, r4
   d47ca:	f7ff ff4d 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x18);
   d47ce:	2218      	movs	r2, #24
   d47d0:	217d      	movs	r1, #125	; 0x7d
   d47d2:	4620      	mov	r0, r4
   d47d4:	f7ff ff48 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x05);
   d47d8:	2205      	movs	r2, #5
   d47da:	217c      	movs	r1, #124	; 0x7c
   d47dc:	4620      	mov	r0, r4
   d47de:	f7ff ff43 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0xa0);
   d47e2:	22a0      	movs	r2, #160	; 0xa0
   d47e4:	e013      	b.n	d480e <_ZN7ArduCAM19set_Special_effectsEh+0x9c>
				wrSensorReg8_8(0x7d, 0x40);
			break;
			case Greenish:
				wrSensorReg8_8(0xff, 0x00);
   d47e6:	2200      	movs	r2, #0
   d47e8:	21ff      	movs	r1, #255	; 0xff
   d47ea:	f7ff ff3d 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d47ee:	2200      	movs	r2, #0
   d47f0:	217c      	movs	r1, #124	; 0x7c
   d47f2:	4620      	mov	r0, r4
   d47f4:	f7ff ff38 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x18);
   d47f8:	2218      	movs	r2, #24
   d47fa:	217d      	movs	r1, #125	; 0x7d
   d47fc:	4620      	mov	r0, r4
   d47fe:	f7ff ff33 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x05);
   d4802:	2205      	movs	r2, #5
   d4804:	217c      	movs	r1, #124	; 0x7c
   d4806:	4620      	mov	r0, r4
   d4808:	f7ff ff2e 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x40);
   d480c:	2240      	movs	r2, #64	; 0x40
   d480e:	217d      	movs	r1, #125	; 0x7d
   d4810:	4620      	mov	r0, r4
   d4812:	f7ff ff29 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x40);
   d4816:	2240      	movs	r2, #64	; 0x40
   d4818:	e053      	b.n	d48c2 <_ZN7ArduCAM19set_Special_effectsEh+0x150>
			break;
			case Reddish:
				wrSensorReg8_8(0xff, 0x00);
   d481a:	2200      	movs	r2, #0
   d481c:	21ff      	movs	r1, #255	; 0xff
   d481e:	f7ff ff23 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d4822:	2200      	movs	r2, #0
   d4824:	217c      	movs	r1, #124	; 0x7c
   d4826:	4620      	mov	r0, r4
   d4828:	f7ff ff1e 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x18);
   d482c:	2218      	movs	r2, #24
   d482e:	217d      	movs	r1, #125	; 0x7d
   d4830:	4620      	mov	r0, r4
   d4832:	f7ff ff19 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x05);
   d4836:	2205      	movs	r2, #5
   d4838:	217c      	movs	r1, #124	; 0x7c
   d483a:	4620      	mov	r0, r4
   d483c:	f7ff ff14 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x40);
   d4840:	2240      	movs	r2, #64	; 0x40
   d4842:	217d      	movs	r1, #125	; 0x7d
   d4844:	4620      	mov	r0, r4
   d4846:	f7ff ff0f 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0xc0);
   d484a:	22c0      	movs	r2, #192	; 0xc0
   d484c:	e039      	b.n	d48c2 <_ZN7ArduCAM19set_Special_effectsEh+0x150>
			break;
			case BW:
				wrSensorReg8_8(0xff, 0x00);
   d484e:	2200      	movs	r2, #0
   d4850:	21ff      	movs	r1, #255	; 0xff
   d4852:	f7ff ff09 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d4856:	2200      	movs	r2, #0
   d4858:	217c      	movs	r1, #124	; 0x7c
   d485a:	4620      	mov	r0, r4
   d485c:	f7ff ff04 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x18);
   d4860:	2218      	movs	r2, #24
   d4862:	e01f      	b.n	d48a4 <_ZN7ArduCAM19set_Special_effectsEh+0x132>
				wrSensorReg8_8(0x7c, 0x05);
				wrSensorReg8_8(0x7d, 0x80);
				wrSensorReg8_8(0x7d, 0x80);
			break;
			case Negative:
				wrSensorReg8_8(0xff, 0x00);
   d4864:	2200      	movs	r2, #0
   d4866:	21ff      	movs	r1, #255	; 0xff
   d4868:	f7ff fefe 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d486c:	2200      	movs	r2, #0
   d486e:	217c      	movs	r1, #124	; 0x7c
   d4870:	4620      	mov	r0, r4
   d4872:	f7ff fef9 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x40);
   d4876:	2240      	movs	r2, #64	; 0x40
   d4878:	e014      	b.n	d48a4 <_ZN7ArduCAM19set_Special_effectsEh+0x132>
				wrSensorReg8_8(0x7c, 0x05);
				wrSensorReg8_8(0x7d, 0x80);
				wrSensorReg8_8(0x7d, 0x80);
			break;
			case BWnegative:
				wrSensorReg8_8(0xff, 0x00);
   d487a:	2200      	movs	r2, #0
   d487c:	21ff      	movs	r1, #255	; 0xff
   d487e:	f7ff fef3 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d4882:	2200      	movs	r2, #0
   d4884:	217c      	movs	r1, #124	; 0x7c
   d4886:	4620      	mov	r0, r4
   d4888:	f7ff feee 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x58);
   d488c:	2258      	movs	r2, #88	; 0x58
   d488e:	e009      	b.n	d48a4 <_ZN7ArduCAM19set_Special_effectsEh+0x132>
			  wrSensorReg8_8(0x7d, 0x80);
	
			break;
			case Normal:
		
				wrSensorReg8_8(0xff, 0x00);
   d4890:	2200      	movs	r2, #0
   d4892:	21ff      	movs	r1, #255	; 0xff
   d4894:	f7ff fee8 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x00);
   d4898:	2200      	movs	r2, #0
   d489a:	217c      	movs	r1, #124	; 0x7c
   d489c:	4620      	mov	r0, r4
   d489e:	f7ff fee3 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x00);
   d48a2:	2200      	movs	r2, #0
   d48a4:	217d      	movs	r1, #125	; 0x7d
   d48a6:	4620      	mov	r0, r4
   d48a8:	f7ff fede 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7c, 0x05);
   d48ac:	2205      	movs	r2, #5
   d48ae:	217c      	movs	r1, #124	; 0x7c
   d48b0:	4620      	mov	r0, r4
   d48b2:	f7ff fed9 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x80);
   d48b6:	2280      	movs	r2, #128	; 0x80
   d48b8:	217d      	movs	r1, #125	; 0x7d
   d48ba:	4620      	mov	r0, r4
   d48bc:	f7ff fed4 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
				wrSensorReg8_8(0x7d, 0x80);
   d48c0:	2280      	movs	r2, #128	; 0x80
   d48c2:	4620      	mov	r0, r4
   d48c4:	217d      	movs	r1, #125	; 0x7d
			
			break;
					
		}
	#endif
	}
   d48c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				wrSensorReg8_8(0xff, 0x00);
				wrSensorReg8_8(0x7c, 0x00);
				wrSensorReg8_8(0x7d, 0x00);
				wrSensorReg8_8(0x7c, 0x05);
				wrSensorReg8_8(0x7d, 0x80);
				wrSensorReg8_8(0x7d, 0x80);
   d48ca:	f7ff becd 	b.w	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
   d48ce:	bd10      	pop	{r4, pc}

000d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>:
	#endif
	}

	// Write 8 bit values to 8 bit register address
int ArduCAM::wrSensorRegs8_8(const struct sensor_reg reglist[])
{
   d48d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	#if defined (RASPBERRY_PI)
		arducam_i2c_write_regs(reglist);
	#else
		int err = 0;
	  uint16_t reg_addr = 0;
	  uint16_t reg_val = 0;
   d48d2:	2400      	movs	r4, #0
	#endif
	}

	// Write 8 bit values to 8 bit register address
int ArduCAM::wrSensorRegs8_8(const struct sensor_reg reglist[])
{
   d48d4:	4607      	mov	r7, r0
   d48d6:	460d      	mov	r5, r1
	#if defined (RASPBERRY_PI)
		arducam_i2c_write_regs(reglist);
	#else
		int err = 0;
	  uint16_t reg_addr = 0;
   d48d8:	4626      	mov	r6, r4
	  uint16_t reg_val = 0;
	  const struct sensor_reg *next = reglist;
	  while ((reg_addr != 0xff) | (reg_val != 0xff))
   d48da:	2eff      	cmp	r6, #255	; 0xff
   d48dc:	f105 0504 	add.w	r5, r5, #4
   d48e0:	d101      	bne.n	d48e6 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg+0x16>
   d48e2:	2cff      	cmp	r4, #255	; 0xff
   d48e4:	d009      	beq.n	d48fa <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg+0x2a>
	  {
	    reg_addr = pgm_read_word(&next->reg);
   d48e6:	f835 6c04 	ldrh.w	r6, [r5, #-4]
	    reg_val = pgm_read_word(&next->val);
   d48ea:	f835 4c02 	ldrh.w	r4, [r5, #-2]
	    err = wrSensorReg8_8(reg_addr, reg_val);
   d48ee:	4631      	mov	r1, r6
   d48f0:	4622      	mov	r2, r4
   d48f2:	4638      	mov	r0, r7
   d48f4:	f7ff feb8 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
	#else
		int err = 0;
	  uint16_t reg_addr = 0;
	  uint16_t reg_val = 0;
	  const struct sensor_reg *next = reglist;
	  while ((reg_addr != 0xff) | (reg_val != 0xff))
   d48f8:	e7ef      	b.n	d48da <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg+0xa>
		    yield();
		#endif
	  }
 #endif  
	return 1;
}
   d48fa:	2001      	movs	r0, #1
   d48fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000d4900 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh>:


void ArduCAM::OV2640_set_JPEG_size(uint8_t size)
{
 #if (defined (OV2640_CAM)||defined (OV2640_MINI_2MP))
	switch(size)
   d4900:	2908      	cmp	r1, #8
   d4902:	d816      	bhi.n	d4932 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x32>
   d4904:	e8df f001 	tbb	[pc, r1]
   d4908:	09150705 	.word	0x09150705
   d490c:	110f0d0b 	.word	0x110f0d0b
   d4910:	13          	.byte	0x13
   d4911:	00          	.byte	0x00
	{
		case OV2640_160x120:
			wrSensorRegs8_8(OV2640_160x120_JPEG);
   d4912:	4909      	ldr	r1, [pc, #36]	; (d4938 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x38>)
   d4914:	e00e      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_176x144:
			wrSensorRegs8_8(OV2640_176x144_JPEG);
   d4916:	4909      	ldr	r1, [pc, #36]	; (d493c <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x3c>)
   d4918:	e00c      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_320x240:
			wrSensorRegs8_8(OV2640_320x240_JPEG);
			break;
		case OV2640_352x288:
	  	wrSensorRegs8_8(OV2640_352x288_JPEG);
   d491a:	4909      	ldr	r1, [pc, #36]	; (d4940 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x40>)
   d491c:	e00a      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_640x480:
			wrSensorRegs8_8(OV2640_640x480_JPEG);
   d491e:	4909      	ldr	r1, [pc, #36]	; (d4944 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x44>)
   d4920:	e008      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_800x600:
			wrSensorRegs8_8(OV2640_800x600_JPEG);
   d4922:	4909      	ldr	r1, [pc, #36]	; (d4948 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x48>)
   d4924:	e006      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_1024x768:
			wrSensorRegs8_8(OV2640_1024x768_JPEG);
   d4926:	4909      	ldr	r1, [pc, #36]	; (d494c <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x4c>)
   d4928:	e004      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_1280x1024:
			wrSensorRegs8_8(OV2640_1280x1024_JPEG);
   d492a:	4909      	ldr	r1, [pc, #36]	; (d4950 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x50>)
   d492c:	e002      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		case OV2640_1600x1200:
			wrSensorRegs8_8(OV2640_1600x1200_JPEG);
   d492e:	4909      	ldr	r1, [pc, #36]	; (d4954 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x54>)
   d4930:	e000      	b.n	d4934 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x34>
			break;
		default:
			wrSensorRegs8_8(OV2640_320x240_JPEG);
   d4932:	4909      	ldr	r1, [pc, #36]	; (d4958 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh+0x58>)
   d4934:	f7ff bfcc 	b.w	d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>
   d4938:	000e0a98 	.word	0x000e0a98
   d493c:	000e145e 	.word	0x000e145e
   d4940:	000e09f8 	.word	0x000e09f8
   d4944:	000e0c80 	.word	0x000e0c80
   d4948:	000e0b38 	.word	0x000e0b38
   d494c:	000e14fe 	.word	0x000e14fe
   d4950:	000e0bdc 	.word	0x000e0bdc
   d4954:	000e13ba 	.word	0x000e13ba
   d4958:	000e159a 	.word	0x000e159a

000d495c <_ZN7ArduCAM7InitCAMEv>:
	}
	#endif
}

void ArduCAM::InitCAM()
{
   d495c:	b538      	push	{r3, r4, r5, lr}
 
  switch (sensor_model)
   d495e:	7a43      	ldrb	r3, [r0, #9]
   d4960:	2b05      	cmp	r3, #5
	}
	#endif
}

void ArduCAM::InitCAM()
{
   d4962:	4604      	mov	r4, r0
 
  switch (sensor_model)
   d4964:	d12c      	bne.n	d49c0 <_ZN7ArduCAM7InitCAMEv+0x64>
        break;
      }
    case OV2640:
      {
#if (defined(OV2640_CAM) || defined(OV2640_MINI_2MP))
        wrSensorReg8_8(0xff, 0x01);
   d4966:	2201      	movs	r2, #1
   d4968:	21ff      	movs	r1, #255	; 0xff
   d496a:	f7ff fe7d 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
        wrSensorReg8_8(0x12, 0x80);
   d496e:	2280      	movs	r2, #128	; 0x80
   d4970:	2112      	movs	r1, #18
   d4972:	4620      	mov	r0, r4
   d4974:	f7ff fe78 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
        delay(100);
   d4978:	2064      	movs	r0, #100	; 0x64
   d497a:	f008 fbdf 	bl	dd13c <delay>
        if (m_fmt == JPEG)
   d497e:	7a25      	ldrb	r5, [r4, #8]
   d4980:	2d01      	cmp	r5, #1
   d4982:	d117      	bne.n	d49b4 <_ZN7ArduCAM7InitCAMEv+0x58>
        {
          wrSensorRegs8_8(OV2640_JPEG_INIT);
   d4984:	490f      	ldr	r1, [pc, #60]	; (d49c4 <_ZN7ArduCAM7InitCAMEv+0x68>)
   d4986:	4620      	mov	r0, r4
   d4988:	f7ff ffa2 	bl	d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>
          wrSensorRegs8_8(OV2640_YUV422);
   d498c:	490e      	ldr	r1, [pc, #56]	; (d49c8 <_ZN7ArduCAM7InitCAMEv+0x6c>)
   d498e:	4620      	mov	r0, r4
   d4990:	f7ff ff9e 	bl	d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>
          wrSensorRegs8_8(OV2640_JPEG);
   d4994:	490d      	ldr	r1, [pc, #52]	; (d49cc <_ZN7ArduCAM7InitCAMEv+0x70>)
   d4996:	4620      	mov	r0, r4
   d4998:	f7ff ff9a 	bl	d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>
          wrSensorReg8_8(0xff, 0x01);
   d499c:	462a      	mov	r2, r5
   d499e:	21ff      	movs	r1, #255	; 0xff
   d49a0:	4620      	mov	r0, r4
   d49a2:	f7ff fe61 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
          wrSensorReg8_8(0x15, 0x00);
   d49a6:	2115      	movs	r1, #21
   d49a8:	2200      	movs	r2, #0
   d49aa:	4620      	mov	r0, r4
   d49ac:	f7ff fe5c 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
          wrSensorRegs8_8(OV2640_320x240_JPEG);
   d49b0:	4907      	ldr	r1, [pc, #28]	; (d49d0 <_ZN7ArduCAM7InitCAMEv+0x74>)
   d49b2:	e000      	b.n	d49b6 <_ZN7ArduCAM7InitCAMEv+0x5a>
          //wrSensorReg8_8(0xff, 0x00);
          //wrSensorReg8_8(0x44, 0x32);
        }
        else
        {
          wrSensorRegs8_8(OV2640_QVGA);
   d49b4:	4907      	ldr	r1, [pc, #28]	; (d49d4 <_ZN7ArduCAM7InitCAMEv+0x78>)
   d49b6:	4620      	mov	r0, r4
      }
    default:

      break;
  }
}
   d49b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
          //wrSensorReg8_8(0xff, 0x00);
          //wrSensorReg8_8(0x44, 0x32);
        }
        else
        {
          wrSensorRegs8_8(OV2640_QVGA);
   d49bc:	f7ff bf88 	b.w	d48d0 <_ZN7ArduCAM15wrSensorRegs8_8EPK10sensor_reg>
   d49c0:	bd38      	pop	{r3, r4, r5, pc}
   d49c2:	bf00      	nop
   d49c4:	000e0db6 	.word	0x000e0db6
   d49c8:	000e0d24 	.word	0x000e0d24
   d49cc:	000e0d92 	.word	0x000e0d92
   d49d0:	000e159a 	.word	0x000e159a
   d49d4:	000e10b2 	.word	0x000e10b2

000d49d8 <_ZN7ArduCAM14rdSensorReg8_8EhPh>:
	#endif
	return 1;
	
}
byte ArduCAM::rdSensorReg8_8(uint8_t regID, uint8_t* regDat)
{	
   d49d8:	b570      	push	{r4, r5, r6, lr}
   d49da:	4604      	mov	r4, r0
   d49dc:	4615      	mov	r5, r2
   d49de:	460e      	mov	r6, r1
	#if defined (RASPBERRY_PI) 
		arducam_i2c_read(regID,regDat);
	#else
		Wire.beginTransmission(sensor_addr >> 1);
   d49e0:	f00a f95c 	bl	dec9c <_Z19__fetch_global_Wirev>
   d49e4:	7aa1      	ldrb	r1, [r4, #10]
   d49e6:	0849      	lsrs	r1, r1, #1
   d49e8:	f009 fc23 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
	  Wire.write(regID & 0x00FF);
   d49ec:	f00a f956 	bl	dec9c <_Z19__fetch_global_Wirev>
   d49f0:	4631      	mov	r1, r6
   d49f2:	f7ff fde3 	bl	d45bc <_ZN7TwoWire5writeEi>
	  Wire.endTransmission();
   d49f6:	f00a f951 	bl	dec9c <_Z19__fetch_global_Wirev>
   d49fa:	f009 fc21 	bl	de240 <_ZN7TwoWire15endTransmissionEv>
	
	  Wire.requestFrom((sensor_addr >> 1), 1);
   d49fe:	f00a f94d 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4a02:	7aa1      	ldrb	r1, [r4, #10]
   d4a04:	2201      	movs	r2, #1
   d4a06:	40d1      	lsrs	r1, r2
   d4a08:	f009 fc0c 	bl	de224 <_ZN7TwoWire11requestFromEhj>
	  if (Wire.available())
   d4a0c:	f00a f946 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4a10:	6803      	ldr	r3, [r0, #0]
   d4a12:	691b      	ldr	r3, [r3, #16]
   d4a14:	4798      	blx	r3
   d4a16:	b128      	cbz	r0, d4a24 <_ZN7ArduCAM14rdSensorReg8_8EhPh+0x4c>
	    *regDat = Wire.read();
   d4a18:	f00a f940 	bl	dec9c <_Z19__fetch_global_Wirev>
   d4a1c:	6803      	ldr	r3, [r0, #0]
   d4a1e:	695b      	ldr	r3, [r3, #20]
   d4a20:	4798      	blx	r3
   d4a22:	7028      	strb	r0, [r5, #0]
	  delay(1);
   d4a24:	2001      	movs	r0, #1
   d4a26:	f008 fb89 	bl	dd13c <delay>
	#endif
	return 1;
	
}
   d4a2a:	2001      	movs	r0, #1
   d4a2c:	bd70      	pop	{r4, r5, r6, pc}
	...

000d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>:
namespace particle {

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
   d4a30:	b510      	push	{r4, lr}
        static SPIClass instance(Interface);
   d4a32:	4c08      	ldr	r4, [pc, #32]	; (d4a54 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv+0x24>)
   d4a34:	6823      	ldr	r3, [r4, #0]
   d4a36:	07db      	lsls	r3, r3, #31
   d4a38:	d40a      	bmi.n	d4a50 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv+0x20>
   d4a3a:	4620      	mov	r0, r4
   d4a3c:	f7ff fb3e 	bl	d40bc <__cxa_guard_acquire>
   d4a40:	b130      	cbz	r0, d4a50 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv+0x20>
   d4a42:	2101      	movs	r1, #1
   d4a44:	4804      	ldr	r0, [pc, #16]	; (d4a58 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv+0x28>)
   d4a46:	f007 fae5 	bl	dc014 <_ZN8SPIClassC1E17HAL_SPI_Interface>
   d4a4a:	4620      	mov	r0, r4
   d4a4c:	f7ff fb3b 	bl	d40c6 <__cxa_guard_release>
        return instance;
    }
   d4a50:	4801      	ldr	r0, [pc, #4]	; (d4a58 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv+0x28>)
   d4a52:	bd10      	pop	{r4, pc}
   d4a54:	2003dd08 	.word	0x2003dd08
   d4a58:	2003dd0c 	.word	0x2003dd0c

000d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>:
        return instance().setClockSpeed(value, scale);
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
   d4a5c:	b510      	push	{r4, lr}
   d4a5e:	4604      	mov	r4, r0
        return instance().transfer(data);
   d4a60:	f7ff ffe6 	bl	d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>
   d4a64:	4621      	mov	r1, r4
    }
   d4a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
        return instance().transfer(data);
   d4a6a:	f007 bb8b 	b.w	dc184 <_ZN8SPIClass8transferEh>

000d4a6e <_ZN7ArduCAM14set_fifo_burstEv>:
void ArduCAM::set_fifo_burst()
{
	#if defined (RASPBERRY_PI)
	transfer(BURST_FIFO_READ);
	#else
    SPI1.transfer(BURST_FIFO_READ);
   d4a6e:	203c      	movs	r0, #60	; 0x3c
   d4a70:	f7ff bff4 	b.w	d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>

000d4a74 <_ZN7ArduCAM8bus_readEi>:

	return 1;
}

uint8_t ArduCAM:: bus_read(int address)
{
   d4a74:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
public:
  __SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
    : default_{false},
      clock_{clock},
      bitOrder_{bitOrder},
      dataMode_{dataMode}
   d4a76:	4b1b      	ldr	r3, [pc, #108]	; (d4ae4 <_ZN7ArduCAM8bus_readEi+0x70>)
   d4a78:	9300      	str	r3, [sp, #0]
   d4a7a:	4b1b      	ldr	r3, [pc, #108]	; (d4ae8 <_ZN7ArduCAM8bus_readEi+0x74>)
   d4a7c:	9302      	str	r3, [sp, #8]
   d4a7e:	2400      	movs	r4, #0
   d4a80:	2301      	movs	r3, #1
    nrf_gpio_pin_set(nrf_pin);
}

inline void pinResetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4a82:	4d1a      	ldr	r5, [pc, #104]	; (d4aec <_ZN7ArduCAM8bus_readEi+0x78>)
   d4a84:	f88d 300c 	strb.w	r3, [sp, #12]
   d4a88:	460e      	mov	r6, r1
   d4a8a:	f88d 4004 	strb.w	r4, [sp, #4]
   d4a8e:	f88d 400d 	strb.w	r4, [sp, #13]
    }
    int32_t beginTransaction() {
        return instance().beginTransaction();
    }
    int32_t beginTransaction(const particle::__SPISettings& settings) {
        return instance().beginTransaction(settings);
   d4a92:	f7ff ffcd 	bl	d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>
   d4a96:	4669      	mov	r1, sp
   d4a98:	f007 fb04 	bl	dc0a4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
   d4a9c:	682b      	ldr	r3, [r5, #0]
    nrf_gpio_pin_clear(nrf_pin);
   d4a9e:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d4aa2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d4aa6:	f003 031f 	and.w	r3, r3, #31
   d4aaa:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4aae:	f7ff fd4a 	bl	d4546 <nrf_gpio_pin_clear>
		  #if defined (PARTICLE)
                SPI1.endTransaction();
            #endif
		  return value;
		#else
		  SPI1.transfer(address);
   d4ab2:	b2f0      	uxtb	r0, r6
   d4ab4:	f7ff ffd2 	bl	d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>
		  value = SPI1.transfer(0x00);
   d4ab8:	4620      	mov	r0, r4
   d4aba:	f7ff ffcf 	bl	d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();

inline void pinSetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4abe:	682b      	ldr	r3, [r5, #0]
   d4ac0:	4604      	mov	r4, r0
    nrf_gpio_pin_set(nrf_pin);
   d4ac2:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d4ac6:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d4aca:	f003 031f 	and.w	r3, r3, #31
   d4ace:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4ad2:	f7ff fd29 	bl	d4528 <nrf_gpio_pin_set>
    }
    void endTransaction() {
        instance().endTransaction();
   d4ad6:	f7ff ffab 	bl	d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>
   d4ada:	f007 faca 	bl	dc072 <_ZN8SPIClass14endTransactionEv>
                SPI1.endTransaction();
            #endif
		  return value;
		#endif
#endif
}
   d4ade:	4620      	mov	r0, r4
   d4ae0:	b004      	add	sp, #16
   d4ae2:	bd70      	pop	{r4, r5, r6, pc}
   d4ae4:	000e09f4 	.word	0x000e09f4
   d4ae8:	007a1200 	.word	0x007a1200
   d4aec:	2003dd14 	.word	0x2003dd14

000d4af0 <_ZN7ArduCAM9read_fifoEv>:
}

uint8_t ArduCAM::read_fifo(void)
{
	uint8_t data;
	data = bus_read(SINGLE_FIFO_READ);
   d4af0:	213d      	movs	r1, #61	; 0x3d
   d4af2:	f7ff bfbf 	b.w	d4a74 <_ZN7ArduCAM8bus_readEi>

000d4af6 <_ZN7ArduCAM8read_regEh>:
{
	uint8_t data;
	#if defined (RASPBERRY_PI)
		data = bus_read(addr);	
	#else
		data = bus_read(addr & 0x7F);
   d4af6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
   d4afa:	f7ff bfbb 	b.w	d4a74 <_ZN7ArduCAM8bus_readEi>

000d4afe <_ZN7ArduCAM7get_bitEhh>:
	write_reg(addr, temp & (~bit));
}

//Get corresponding bit status
uint8_t ArduCAM::get_bit(uint8_t addr, uint8_t bit)
{
   d4afe:	b510      	push	{r4, lr}
   d4b00:	4614      	mov	r4, r2
  uint8_t temp;
  temp = read_reg(addr);
   d4b02:	f7ff fff8 	bl	d4af6 <_ZN7ArduCAM8read_regEh>
  temp = temp & bit;
  return temp;
}
   d4b06:	4020      	ands	r0, r4
   d4b08:	bd10      	pop	{r4, pc}

000d4b0a <_ZN7ArduCAM16read_fifo_lengthEv>:
{
	write_reg(ARDUCHIP_FIFO, FIFO_CLEAR_MASK);
}

uint32_t ArduCAM::read_fifo_length(void)
{
   d4b0a:	b570      	push	{r4, r5, r6, lr}
{
	uint8_t data;
	#if defined (RASPBERRY_PI)
		data = bus_read(addr);	
	#else
		data = bus_read(addr & 0x7F);
   d4b0c:	2142      	movs	r1, #66	; 0x42
{
	write_reg(ARDUCHIP_FIFO, FIFO_CLEAR_MASK);
}

uint32_t ArduCAM::read_fifo_length(void)
{
   d4b0e:	4605      	mov	r5, r0
{
	uint8_t data;
	#if defined (RASPBERRY_PI)
		data = bus_read(addr);	
	#else
		data = bus_read(addr & 0x7F);
   d4b10:	f7ff ffb0 	bl	d4a74 <_ZN7ArduCAM8bus_readEi>
   d4b14:	2143      	movs	r1, #67	; 0x43
   d4b16:	4604      	mov	r4, r0
   d4b18:	4628      	mov	r0, r5
   d4b1a:	f7ff ffab 	bl	d4a74 <_ZN7ArduCAM8bus_readEi>
   d4b1e:	2144      	movs	r1, #68	; 0x44
   d4b20:	4606      	mov	r6, r0
   d4b22:	4628      	mov	r0, r5
   d4b24:	f7ff ffa6 	bl	d4a74 <_ZN7ArduCAM8bus_readEi>
	uint32_t len1,len2,len3,length=0;
	len1 = read_reg(FIFO_SIZE1);
  len2 = read_reg(FIFO_SIZE2);
  len3 = read_reg(FIFO_SIZE3) & 0x7f;
  length = ((len3 << 16) | (len2 << 8) | len1) & 0x07fffff;
	return length;	
   d4b28:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
   d4b2c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
}
   d4b30:	ea44 4000 	orr.w	r0, r4, r0, lsl #16
   d4b34:	bd70      	pop	{r4, r5, r6, pc}
	...

000d4b38 <_ZN7ArduCAM9bus_writeEii>:
      break;
  }
}

uint8_t ArduCAM::bus_write(int address,int value)
{
   d4b38:	b5f0      	push	{r4, r5, r6, r7, lr}
   d4b3a:	b085      	sub	sp, #20
   d4b3c:	4b1b      	ldr	r3, [pc, #108]	; (d4bac <_ZN7ArduCAM9bus_writeEii+0x74>)
   d4b3e:	9300      	str	r3, [sp, #0]
   d4b40:	4616      	mov	r6, r2
   d4b42:	2300      	movs	r3, #0
   d4b44:	4a1a      	ldr	r2, [pc, #104]	; (d4bb0 <_ZN7ArduCAM9bus_writeEii+0x78>)
}

inline void pinResetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4b46:	4d1b      	ldr	r5, [pc, #108]	; (d4bb4 <_ZN7ArduCAM9bus_writeEii+0x7c>)
   d4b48:	9202      	str	r2, [sp, #8]
   d4b4a:	2401      	movs	r4, #1
   d4b4c:	460f      	mov	r7, r1
   d4b4e:	f88d 3004 	strb.w	r3, [sp, #4]
   d4b52:	f88d 300d 	strb.w	r3, [sp, #13]
   d4b56:	f88d 400c 	strb.w	r4, [sp, #12]
    }
    int32_t beginTransaction() {
        return instance().beginTransaction();
    }
    int32_t beginTransaction(const particle::__SPISettings& settings) {
        return instance().beginTransaction(settings);
   d4b5a:	f7ff ff69 	bl	d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>
   d4b5e:	4669      	mov	r1, sp
   d4b60:	f007 faa0 	bl	dc0a4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
   d4b64:	682b      	ldr	r3, [r5, #0]
    nrf_gpio_pin_clear(nrf_pin);
   d4b66:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d4b6a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d4b6e:	f003 031f 	and.w	r3, r3, #31
   d4b72:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4b76:	f7ff fce6 	bl	d4546 <nrf_gpio_pin_clear>

	cbi(P_CS, B_CS);
	#if defined (RASPBERRY_PI)
		arducam_spi_write(address | 0x80, value);
	#else
		SPI1.transfer(address);
   d4b7a:	b2f8      	uxtb	r0, r7
   d4b7c:	f7ff ff6e 	bl	d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>
		SPI1.transfer(value);
   d4b80:	b2f0      	uxtb	r0, r6
   d4b82:	f7ff ff6b 	bl	d4a5c <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8transferEh.isra.1>

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();

inline void pinSetFast(pin_t _pin)
{
    uint32_t nrf_pin = NRF_GPIO_PIN_MAP(PIN_MAP[_pin].gpio_port, PIN_MAP[_pin].gpio_pin);
   d4b86:	682b      	ldr	r3, [r5, #0]
    nrf_gpio_pin_set(nrf_pin);
   d4b88:	f893 0050 	ldrb.w	r0, [r3, #80]	; 0x50
   d4b8c:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
   d4b90:	f003 031f 	and.w	r3, r3, #31
   d4b94:	ea43 1040 	orr.w	r0, r3, r0, lsl #5
   d4b98:	f7ff fcc6 	bl	d4528 <nrf_gpio_pin_set>
    }
    void endTransaction() {
        instance().endTransaction();
   d4b9c:	f7ff ff48 	bl	d4a30 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface1EE8instanceEv>
   d4ba0:	f007 fa67 	bl	dc072 <_ZN8SPIClass14endTransactionEv>
#if defined (PARTICLE)
	SPI1.endTransaction();
#endif

	return 1;
}
   d4ba4:	4620      	mov	r0, r4
   d4ba6:	b005      	add	sp, #20
   d4ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d4baa:	bf00      	nop
   d4bac:	000e09f4 	.word	0x000e09f4
   d4bb0:	007a1200 	.word	0x007a1200
   d4bb4:	2003dd14 	.word	0x2003dd14

000d4bb8 <_ZN7ArduCAM9write_regEhh>:
void ArduCAM::write_reg(uint8_t addr, uint8_t data)
{
	#if defined (RASPBERRY_PI)
		bus_write(addr , data);
	#else
	 bus_write(addr | 0x80, data);
   d4bb8:	f041 0180 	orr.w	r1, r1, #128	; 0x80
   d4bbc:	f7ff bfbc 	b.w	d4b38 <_ZN7ArduCAM9bus_writeEii>

000d4bc0 <_ZN7ArduCAM13start_captureEv>:
   d4bc0:	2202      	movs	r2, #2
   d4bc2:	2184      	movs	r1, #132	; 0x84
   d4bc4:	f7ff bfb8 	b.w	d4b38 <_ZN7ArduCAM9bus_writeEii>

000d4bc8 <_ZN7ArduCAM15clear_fifo_flagEv>:
   d4bc8:	2201      	movs	r2, #1
   d4bca:	2184      	movs	r1, #132	; 0x84
   d4bcc:	f7ff bfb4 	b.w	d4b38 <_ZN7ArduCAM9bus_writeEii>

000d4bd0 <_ZN7ArduCAM10flush_fifoEv>:
   d4bd0:	f7ff bffa 	b.w	d4bc8 <_ZN7ArduCAM15clear_fifo_flagEv>

000d4bd4 <_GLOBAL__sub_I__ZN7ArduCAMC2Ev>:
	    *regDat = (temp << 8) | Wire.read();
	  }
	  delay(1);
	#endif 
  return (1);
}
   d4bd4:	b508      	push	{r3, lr}

inline void pinSetFast(pin_t _pin) __attribute__((always_inline));
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
   d4bd6:	f006 fd6d 	bl	db6b4 <HAL_Pin_Map>
   d4bda:	4b01      	ldr	r3, [pc, #4]	; (d4be0 <_GLOBAL__sub_I__ZN7ArduCAMC2Ev+0xc>)
   d4bdc:	6018      	str	r0, [r3, #0]
   d4bde:	bd08      	pop	{r3, pc}
   d4be0:	2003dd14 	.word	0x2003dd14

000d4be4 <_ZNK22ArduinoJson6130_00000120DeserializationError14safeBoolHelperEv>:
namespace ARDUINOJSON_NAMESPACE {

class DeserializationError {
  // safe bool idiom
  typedef void (DeserializationError::*bool_type)() const;
  void safeBoolHelper() const {}
   d4be4:	4770      	bx	lr

000d4be6 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
   d4be6:	6803      	ldr	r3, [r0, #0]
   d4be8:	4718      	bx	r3

000d4bea <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
   d4bea:	2a01      	cmp	r2, #1
   d4bec:	d002      	beq.n	d4bf4 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xa>
   d4bee:	2a02      	cmp	r2, #2
   d4bf0:	d002      	beq.n	d4bf8 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xe>
   d4bf2:	e004      	b.n	d4bfe <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
   d4bf4:	6001      	str	r1, [r0, #0]
	      break;
   d4bf6:	e002      	b.n	d4bfe <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
   d4bf8:	680b      	ldr	r3, [r1, #0]
   d4bfa:	b100      	cbz	r0, d4bfe <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
   d4bfc:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
   d4bfe:	2000      	movs	r0, #0
   d4c00:	4770      	bx	lr

000d4c02 <_ZN5SDLib4FileD1Ev>:
#define FILE_READ O_READ
#define FILE_WRITE (O_READ | O_WRITE | O_CREAT | O_APPEND)

namespace SDLib {

  class File : public Stream {
   d4c02:	4770      	bx	lr

000d4c04 <__tcf_0>:

String configFileName = "CONFIG.JSN";

const int LogEntries = 50;
int logBufIndex = 0;
String logbuffer[LogEntries];
   d4c04:	b538      	push	{r3, r4, r5, lr}
   d4c06:	4d06      	ldr	r5, [pc, #24]	; (d4c20 <__tcf_0+0x1c>)
   d4c08:	2400      	movs	r4, #0
   d4c0a:	f504 7044 	add.w	r0, r4, #784	; 0x310
   d4c0e:	4428      	add	r0, r5
   d4c10:	3c10      	subs	r4, #16
   d4c12:	f007 fc87 	bl	dc524 <_ZN6StringD1Ev>
   d4c16:	f514 7f48 	cmn.w	r4, #800	; 0x320
   d4c1a:	d1f6      	bne.n	d4c0a <__tcf_0+0x6>
   d4c1c:	bd38      	pop	{r3, r4, r5, pc}
   d4c1e:	bf00      	nop
   d4c20:	2003df88 	.word	0x2003df88

000d4c24 <_ZN6Thread3runEPv>:
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
   d4c24:	b510      	push	{r4, lr}
        Data* th = (Data*)param;
        th->started = true;
   d4c26:	2301      	movs	r3, #1
   d4c28:	7403      	strb	r3, [r0, #16]
        if (th->func) {
   d4c2a:	6883      	ldr	r3, [r0, #8]
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
   d4c2c:	4604      	mov	r4, r0
        Data* th = (Data*)param;
        th->started = true;
        if (th->func) {
   d4c2e:	b10b      	cbz	r3, d4c34 <_ZN6Thread3runEPv+0x10>
            (*(th->func))(th->func_param);
   d4c30:	68c0      	ldr	r0, [r0, #12]
   d4c32:	e006      	b.n	d4c42 <_ZN6Thread3runEPv+0x1e>
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
   d4c34:	6800      	ldr	r0, [r0, #0]
        } else if (th->wrapper) {
   d4c36:	b128      	cbz	r0, d4c44 <_ZN6Thread3runEPv+0x20>
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   d4c38:	6883      	ldr	r3, [r0, #8]
   d4c3a:	b90b      	cbnz	r3, d4c40 <_ZN6Thread3runEPv+0x1c>
	__throw_bad_function_call();
   d4c3c:	f00a f89b 	bl	ded76 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   d4c40:	68c3      	ldr	r3, [r0, #12]
   d4c42:	4798      	blx	r3
            (*(th->wrapper))();
        }
        th->exited = true;
   d4c44:	2301      	movs	r3, #1
   d4c46:	7463      	strb	r3, [r4, #17]
        os_thread_exit(nullptr);
   d4c48:	2000      	movs	r0, #0
    }
   d4c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            (*(th->func))(th->func_param);
        } else if (th->wrapper) {
            (*(th->wrapper))();
        }
        th->exited = true;
        os_thread_exit(nullptr);
   d4c4e:	f006 be65 	b.w	db91c <os_thread_exit>

000d4c52 <_ZN10CloudClass12syncTimeDoneEv.isra.14>:
    bool syncTimePending(void)
    {
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
   d4c52:	b508      	push	{r3, lr}
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   d4c54:	2000      	movs	r0, #0
   d4c56:	f007 f897 	bl	dbd88 <spark_sync_time_pending>
   d4c5a:	b128      	cbz	r0, d4c68 <_ZN10CloudClass12syncTimeDoneEv.isra.14+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   d4c5c:	f007 f874 	bl	dbd48 <spark_cloud_flag_connected>
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   d4c60:	f080 0001 	eor.w	r0, r0, #1
   d4c64:	b2c0      	uxtb	r0, r0
   d4c66:	bd08      	pop	{r3, pc}
   d4c68:	2001      	movs	r0, #1
    }
   d4c6a:	bd08      	pop	{r3, pc}

000d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>:
    return _flags & VALUE_MASK;
  }

  void setType(uint8_t t) {
    _flags &= KEY_IS_OWNED;
    _flags |= t;
   d4c6c:	7803      	ldrb	r3, [r0, #0]
   d4c6e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   d4c72:	4319      	orrs	r1, r3
   d4c74:	7001      	strb	r1, [r0, #0]
   d4c76:	4770      	bx	lr

000d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>:
// Deprecated methods
inline particle::Future<bool> CloudClass::publish(const char* name) {
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
   d4c78:	b513      	push	{r0, r1, r4, lr}
   d4c7a:	4b05      	ldr	r3, [pc, #20]	; (d4c90 <_ZN10CloudClass7publishEPKcS1_.isra.42+0x18>)
   d4c7c:	781b      	ldrb	r3, [r3, #0]
        return publish(eventName, eventData, DEFAULT_CLOUD_EVENT_TTL, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
   d4c7e:	f88d 3000 	strb.w	r3, [sp]
   d4c82:	233c      	movs	r3, #60	; 0x3c
// Deprecated methods
inline particle::Future<bool> CloudClass::publish(const char* name) {
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
   d4c84:	4604      	mov	r4, r0
        return publish(eventName, eventData, DEFAULT_CLOUD_EVENT_TTL, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
   d4c86:	f008 fe91 	bl	dd9ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
    return publish(name, data, PUBLIC);
}
   d4c8a:	4620      	mov	r0, r4
   d4c8c:	b002      	add	sp, #8
   d4c8e:	bd10      	pop	{r4, pc}
   d4c90:	2003df04 	.word	0x2003df04

000d4c94 <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
   d4c94:	b510      	push	{r4, lr}
   d4c96:	4604      	mov	r4, r0
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
        if (wakeupSource_) {
   d4c98:	6800      	ldr	r0, [r0, #0]
   d4c9a:	b108      	cbz	r0, d4ca0 <_ZN11SystemClassD1Ev+0xc>
            free(wakeupSource_);
   d4c9c:	f007 f894 	bl	dbdc8 <free>
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
   d4ca0:	4620      	mov	r0, r4
   d4ca2:	bd10      	pop	{r4, pc}

000d4ca4 <_ZN5spark13CellularClass2onEv>:

    IPAddress localIP() {
        return IPAddress(((CellularConfig*)network_config(*this, 0, NULL))->nw.aucIP);
    }
    void on() {
        network_on(*this, 0, 0, NULL);
   d4ca4:	2300      	movs	r3, #0
   d4ca6:	461a      	mov	r2, r3
   d4ca8:	4619      	mov	r1, r3
   d4caa:	6840      	ldr	r0, [r0, #4]
   d4cac:	f006 bffc 	b.w	dbca8 <network_on>

000d4cb0 <_ZN5spark13CellularClass3offEv>:
    }
    void off() {
        network_off(*this, 0, 0, NULL);
   d4cb0:	2300      	movs	r3, #0
   d4cb2:	461a      	mov	r2, r3
   d4cb4:	4619      	mov	r1, r3
   d4cb6:	6840      	ldr	r0, [r0, #4]
   d4cb8:	f006 bffe 	b.w	dbcb8 <network_off>

000d4cbc <_ZN5spark13CellularClass5readyEv>:
        return network_listening(*this, 0, NULL);
    }

    bool ready()
    {
        return network_ready(*this, 0,  NULL);
   d4cbc:	2200      	movs	r2, #0
   d4cbe:	4611      	mov	r1, r2
   d4cc0:	6840      	ldr	r0, [r0, #4]
   d4cc2:	f006 bfe9 	b.w	dbc98 <network_ready>

000d4cc6 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
   d4cc6:	b510      	push	{r4, lr}
    {
      if (_M_manager)
   d4cc8:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
   d4cca:	4604      	mov	r4, r0
    {
      if (_M_manager)
   d4ccc:	b113      	cbz	r3, d4cd4 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   d4cce:	2203      	movs	r2, #3
   d4cd0:	4601      	mov	r1, r0
   d4cd2:	4798      	blx	r3
    }
   d4cd4:	4620      	mov	r0, r4
   d4cd6:	bd10      	pop	{r4, pc}

000d4cd8 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35>:
	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      /// Calls @c delete @p __ptr
      void
      operator()(_Tp* __ptr) const
   d4cd8:	b538      	push	{r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d4cda:	4604      	mov	r4, r0
   d4cdc:	b170      	cbz	r0, d4cfc <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35+0x24>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d4cde:	6805      	ldr	r5, [r0, #0]
   d4ce0:	b135      	cbz	r5, d4cf0 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35+0x18>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   d4ce2:	4628      	mov	r0, r5
   d4ce4:	f7ff ffef 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d4ce8:	2110      	movs	r1, #16
   d4cea:	4628      	mov	r0, r5
   d4cec:	f00a f830 	bl	ded50 <_ZdlPvj>
   d4cf0:	4620      	mov	r0, r4
   d4cf2:	2114      	movs	r1, #20
      }
   d4cf4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   d4cf8:	f00a b82a 	b.w	ded50 <_ZdlPvj>
   d4cfc:	bd38      	pop	{r3, r4, r5, pc}

000d4cfe <_ZN19ApplicationWatchdogD1Ev>:
#include "timer_hal.h"

#if PLATFORM_THREADING


class ApplicationWatchdog
   d4cfe:	b510      	push	{r4, lr}
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
   d4d00:	6943      	ldr	r3, [r0, #20]
   d4d02:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (!isValid())
   d4d04:	b1bb      	cbz	r3, d4d36 <_ZN19ApplicationWatchdogD1Ev+0x38>
        return isCurrent();
    }

    bool isCurrent() const
    {
        return isValid() && os_thread_is_current(d_->handle);
   d4d06:	6858      	ldr	r0, [r3, #4]
   d4d08:	f006 fdd0 	bl	db8ac <os_thread_is_current>
   d4d0c:	b978      	cbnz	r0, d4d2e <_ZN19ApplicationWatchdogD1Ev+0x30>
   d4d0e:	6963      	ldr	r3, [r4, #20]

        // We shouldn't dispose of current thread
        if (isCurrent())
            return;

        if (!d_->exited) {
   d4d10:	7c5a      	ldrb	r2, [r3, #17]
   d4d12:	b912      	cbnz	r2, d4d1a <_ZN19ApplicationWatchdogD1Ev+0x1c>
        d_.reset();
    }

    bool join()
    {
        return isValid() && os_thread_join(d_->handle)==0;
   d4d14:	6858      	ldr	r0, [r3, #4]
   d4d16:	f006 fdd1 	bl	db8bc <os_thread_join>

        if (!d_->exited) {
            join();
        }

        os_thread_cleanup(d_->handle);
   d4d1a:	6963      	ldr	r3, [r4, #20]
   d4d1c:	6858      	ldr	r0, [r3, #4]
   d4d1e:	f006 fdd5 	bl	db8cc <os_thread_cleanup>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   d4d22:	6960      	ldr	r0, [r4, #20]
      __a = _GLIBCXX_MOVE(__b);
   d4d24:	2300      	movs	r3, #0
   d4d26:	6163      	str	r3, [r4, #20]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
   d4d28:	b128      	cbz	r0, d4d36 <_ZN19ApplicationWatchdogD1Ev+0x38>
	  get_deleter()(__p);
   d4d2a:	f7ff ffd5 	bl	d4cd8 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   d4d2e:	6960      	ldr	r0, [r4, #20]
   d4d30:	b108      	cbz	r0, d4d36 <_ZN19ApplicationWatchdogD1Ev+0x38>
	  get_deleter()(__ptr);
   d4d32:	f7ff ffd1 	bl	d4cd8 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35>
   d4d36:	1d20      	adds	r0, r4, #4
   d4d38:	f7ff ffc5 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
   d4d3c:	4620      	mov	r0, r4
   d4d3e:	bd10      	pop	{r4, pc}

000d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>:
    inline static SleepResult sleep(Spark_Sleep_TypeDef sleepMode, SleepOptionFlags flag, std::chrono::seconds s) { return sleep(sleepMode, flag, s.count()); }

    inline static SleepResult sleep(long seconds) { return sleep(SLEEP_MODE_WLAN, seconds); }
    inline static SleepResult sleep(std::chrono::seconds s) { return sleep(s.count()); }

    inline static SleepResult sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0, SleepOptionFlags flag=SLEEP_NETWORK_OFF) { return sleepPinImpl(&wakeUpPin, 1, &edgeTriggerMode, 1, seconds, flag); }
   d4d40:	b510      	push	{r4, lr}
   d4d42:	b086      	sub	sp, #24
   d4d44:	4604      	mov	r4, r0
   d4d46:	f8ad 1016 	strh.w	r1, [sp, #22]
   d4d4a:	a906      	add	r1, sp, #24
   d4d4c:	f801 2d03 	strb.w	r2, [r1, #-3]!
   d4d50:	9a08      	ldr	r2, [sp, #32]
   d4d52:	9202      	str	r2, [sp, #8]
   d4d54:	2201      	movs	r2, #1
   d4d56:	9301      	str	r3, [sp, #4]
   d4d58:	9200      	str	r2, [sp, #0]
   d4d5a:	460b      	mov	r3, r1
   d4d5c:	f10d 0116 	add.w	r1, sp, #22
   d4d60:	f007 fa78 	bl	dc254 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE>
   d4d64:	4620      	mov	r0, r4
   d4d66:	b006      	add	sp, #24
   d4d68:	bd10      	pop	{r4, pc}
	...

000d4d6c <_ZN11SystemClass11sleepResultEv>:
    inline pin_t wakeUpPin() {
        return sleepResult().pin();
    }

    // FIXME: SystemSleepResult
    SleepResult sleepResult() {
   d4d6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        //         // Woken up from standby mode
        //         sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
        //     }
        // });
        static bool f = false;
        if (!f) {
   d4d6e:	4b1e      	ldr	r3, [pc, #120]	; (d4de8 <_ZN11SystemClass11sleepResultEv+0x7c>)
   d4d70:	781d      	ldrb	r5, [r3, #0]
    inline pin_t wakeUpPin() {
        return sleepResult().pin();
    }

    // FIXME: SystemSleepResult
    SleepResult sleepResult() {
   d4d72:	4606      	mov	r6, r0
   d4d74:	460c      	mov	r4, r1
        //         // Woken up from standby mode
        //         sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
        //     }
        // });
        static bool f = false;
        if (!f) {
   d4d76:	b9b5      	cbnz	r5, d4da6 <_ZN11SystemClass11sleepResultEv+0x3a>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
   d4d78:	a802      	add	r0, sp, #8
        //         sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
        //     }
        // });
        static bool f = false;
        if (!f) {
            f = true;
   d4d7a:	2201      	movs	r2, #1
   d4d7c:	701a      	strb	r2, [r3, #0]
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
   d4d7e:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
   d4d82:	462a      	mov	r2, r5
   d4d84:	4629      	mov	r1, r5
   d4d86:	f006 fd4d 	bl	db824 <HAL_Core_Get_Last_Reset_Info>
        return reason;
   d4d8a:	9b01      	ldr	r3, [sp, #4]
        //     }
        // });
        static bool f = false;
        if (!f) {
            f = true;
            if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
   d4d8c:	2b1e      	cmp	r3, #30
   d4d8e:	d10a      	bne.n	d4da6 <_ZN11SystemClass11sleepResultEv+0x3a>
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
        error_ = result.error_;
        compatResult_ = result.compatResult_;
   d4d90:	2303      	movs	r3, #3
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
        if (wakeupSource_) {
   d4d92:	6820      	ldr	r0, [r4, #0]
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
        error_ = result.error_;
        compatResult_ = result.compatResult_;
   d4d94:	71a3      	strb	r3, [r4, #6]
   d4d96:	2308      	movs	r3, #8
            result.wakeupSource_ = nullptr;
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
        error_ = result.error_;
   d4d98:	80a5      	strh	r5, [r4, #4]
        compatResult_ = result.compatResult_;
   d4d9a:	8125      	strh	r5, [r4, #8]
   d4d9c:	8163      	strh	r3, [r4, #10]
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
        if (wakeupSource_) {
   d4d9e:	b110      	cbz	r0, d4da6 <_ZN11SystemClass11sleepResultEv+0x3a>
            free(wakeupSource_);
   d4da0:	f007 f812 	bl	dbdc8 <free>
            wakeupSource_ = nullptr;
   d4da4:	6025      	str	r5, [r4, #0]
    system_error_t error() const {
        return error_;
    }

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
   d4da6:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
   d4daa:	b90b      	cbnz	r3, d4db0 <_ZN11SystemClass11sleepResultEv+0x44>
   d4dac:	6822      	ldr	r2, [r4, #0]
   d4dae:	b19a      	cbz	r2, d4dd8 <_ZN11SystemClass11sleepResultEv+0x6c>
   d4db0:	6821      	ldr	r1, [r4, #0]
    hal_wakeup_source_base_t** halWakeupSource() {
        return &wakeupSource_;
    }

    SystemSleepWakeupReason wakeupReason() const {
        if (wakeupSource_) {
   d4db2:	b159      	cbz	r1, d4dcc <_ZN11SystemClass11sleepResultEv+0x60>
        return error_;
    }

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
            switch (wakeupReason()) {
   d4db4:	888a      	ldrh	r2, [r1, #4]
   d4db6:	2a01      	cmp	r2, #1
   d4db8:	d003      	beq.n	d4dc2 <_ZN11SystemClass11sleepResultEv+0x56>
   d4dba:	2a04      	cmp	r2, #4
   d4dbc:	d106      	bne.n	d4dcc <_ZN11SystemClass11sleepResultEv+0x60>
                case SystemSleepWakeupReason::BY_GPIO: {
                    compatResult_ = SleepResult(WAKEUP_REASON_PIN, error(), wakeupPin());
                    break;
                }
                case SystemSleepWakeupReason::BY_RTC: {
                    compatResult_ = SleepResult(WAKEUP_REASON_RTC, error());
   d4dbe:	2202      	movs	r2, #2
   d4dc0:	e005      	b.n	d4dce <_ZN11SystemClass11sleepResultEv+0x62>
        }
    }

    pin_t wakeupPin() const {
        if (wakeupReason() == SystemSleepWakeupReason::BY_GPIO) {
            return reinterpret_cast<hal_wakeup_source_gpio_t*>(wakeupSource_)->pin;
   d4dc2:	8989      	ldrh	r1, [r1, #12]

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
            switch (wakeupReason()) {
                case SystemSleepWakeupReason::BY_GPIO: {
                    compatResult_ = SleepResult(WAKEUP_REASON_PIN, error(), wakeupPin());
   d4dc4:	8161      	strh	r1, [r4, #10]
   d4dc6:	71a2      	strb	r2, [r4, #6]
   d4dc8:	8123      	strh	r3, [r4, #8]
   d4dca:	e005      	b.n	d4dd8 <_ZN11SystemClass11sleepResultEv+0x6c>
                case SystemSleepWakeupReason::BY_RTC: {
                    compatResult_ = SleepResult(WAKEUP_REASON_RTC, error());
                    break;
                }
                default: {
                    compatResult_ = SleepResult(WAKEUP_REASON_UNKNOWN, error());
   d4dcc:	2204      	movs	r2, #4
   d4dce:	8123      	strh	r3, [r4, #8]
   d4dd0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   d4dd4:	71a2      	strb	r2, [r4, #6]
   d4dd6:	8163      	strh	r3, [r4, #10]
                    break;
                }
            }
        }
        return compatResult_;
   d4dd8:	f854 3f06 	ldr.w	r3, [r4, #6]!
   d4ddc:	6033      	str	r3, [r6, #0]
   d4dde:	88a3      	ldrh	r3, [r4, #4]
   d4de0:	80b3      	strh	r3, [r6, #4]
                // Woken up from standby mode
                systemSleepResult_ = SystemSleepResult(SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP));
            }
        }
        return systemSleepResult_;
    }
   d4de2:	4630      	mov	r0, r6
   d4de4:	b002      	add	sp, #8
   d4de6:	bd70      	pop	{r4, r5, r6, pc}
   d4de8:	2003dd18 	.word	0x2003dd18

000d4dec <_ZN19ApplicationWatchdog7checkinEv>:
	}

	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
   d4dec:	b508      	push	{r3, lr}
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   d4dee:	f006 fcf1 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   d4df2:	4b01      	ldr	r3, [pc, #4]	; (d4df8 <_ZN19ApplicationWatchdog7checkinEv+0xc>)
   d4df4:	6018      	str	r0, [r3, #0]
   d4df6:	bd08      	pop	{r3, pc}
   d4df8:	2003e6ec 	.word	0x2003e6ec

000d4dfc <_ZN19ApplicationWatchdogC1EjPFvvEj>:
	}
	ApplicationWatchdog(std::chrono::milliseconds ms, std::function<void(void)> fn, unsigned stack_size=DEFAULT_STACK_SIZE) : ApplicationWatchdog(ms.count(), fn, stack_size) {}

    // This constuctor helps to resolve overloaded function types, such as System.reset(), which is not always
    // possible in case of std::function
    ApplicationWatchdog(unsigned timeout_ms, void (*fn)(), unsigned stack_size=DEFAULT_STACK_SIZE) :
   d4dfc:	b530      	push	{r4, r5, lr}
   d4dfe:	b087      	sub	sp, #28
   d4e00:	461d      	mov	r5, r3
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   d4e02:	2300      	movs	r3, #0
   d4e04:	4604      	mov	r4, r0
   d4e06:	9304      	str	r3, [sp, #16]
      function(_Functor __f)
      : _Function_base()
      {
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
   d4e08:	b122      	cbz	r2, d4e14 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x18>
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
   d4e0a:	4b21      	ldr	r3, [pc, #132]	; (d4e90 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x94>)
   d4e0c:	9305      	str	r3, [sp, #20]
	    _M_manager = &_My_handler::_M_manager;
   d4e0e:	4b21      	ldr	r3, [pc, #132]	; (d4e94 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x98>)
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
   d4e10:	9202      	str	r2, [sp, #8]

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
   d4e12:	9304      	str	r3, [sp, #16]
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   d4e14:	2300      	movs	r3, #0
   d4e16:	60e3      	str	r3, [r4, #12]
   d4e18:	9b04      	ldr	r3, [sp, #16]
    static const unsigned DEFAULT_STACK_SIZE = 512;

	ApplicationWatchdog(unsigned timeout_ms, std::function<void(void)> fn, unsigned stack_size=DEFAULT_STACK_SIZE) :
		timeout(timeout_ms),
		timeout_fn(fn),
		thread("appwdt", start, this, OS_THREAD_PRIORITY_CRITICAL, stack_size)
   d4e1a:	6021      	str	r1, [r4, #0]
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
   d4e1c:	b13b      	cbz	r3, d4e2e <_ZN19ApplicationWatchdogC1EjPFvvEj+0x32>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   d4e1e:	2202      	movs	r2, #2
   d4e20:	a902      	add	r1, sp, #8
   d4e22:	1d20      	adds	r0, r4, #4
   d4e24:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   d4e26:	9b05      	ldr	r3, [sp, #20]
   d4e28:	6123      	str	r3, [r4, #16]
	  _M_manager = __x._M_manager;
   d4e2a:	9b04      	ldr	r3, [sp, #16]
   d4e2c:	60e3      	str	r3, [r4, #12]
    {
    }

    Thread(const char* name, os_thread_fn_t function, void* function_param=NULL,
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
   d4e2e:	491a      	ldr	r1, [pc, #104]	; (d4e98 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x9c>)
   d4e30:	2014      	movs	r0, #20
   d4e32:	f009 ff91 	bl	ded58 <_ZnwjRKSt9nothrow_t>
   d4e36:	b130      	cbz	r0, d4e46 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x4a>

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }
   d4e38:	2300      	movs	r3, #0
        Data() :
            handle(OS_THREAD_INVALID_HANDLE),
            func(nullptr),
            func_param(nullptr),
            started(false),
            exited(false) {
   d4e3a:	7403      	strb	r3, [r0, #16]
   d4e3c:	6003      	str	r3, [r0, #0]
   d4e3e:	6043      	str	r3, [r0, #4]
   d4e40:	6083      	str	r3, [r0, #8]
   d4e42:	60c3      	str	r3, [r0, #12]
   d4e44:	7443      	strb	r3, [r0, #17]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   d4e46:	6160      	str	r0, [r4, #20]

    Thread(const char* name, os_thread_fn_t function, void* function_param=NULL,
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
    {
        if (!d_) {
   d4e48:	b1a0      	cbz	r0, d4e74 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x78>
            goto error;
        }
        d_->func = function;
   d4e4a:	4b14      	ldr	r3, [pc, #80]	; (d4e9c <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa0>)
   d4e4c:	6083      	str	r3, [r0, #8]
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
   d4e4e:	6963      	ldr	r3, [r4, #20]
        d_->func_param = function_param;
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
   d4e50:	4913      	ldr	r1, [pc, #76]	; (d4ea0 <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa4>)
    {
        if (!d_) {
            goto error;
        }
        d_->func = function;
        d_->func_param = function_param;
   d4e52:	60dc      	str	r4, [r3, #12]
   d4e54:	6960      	ldr	r0, [r4, #20]
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
   d4e56:	4b13      	ldr	r3, [pc, #76]	; (d4ea4 <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa8>)
   d4e58:	e88d 0021 	stmia.w	sp, {r0, r5}
   d4e5c:	2209      	movs	r2, #9
   d4e5e:	3004      	adds	r0, #4
   d4e60:	f006 fd1c 	bl	db89c <os_thread_create>
   d4e64:	b930      	cbnz	r0, d4e74 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x78>
   d4e66:	6963      	ldr	r3, [r4, #20]
            goto error;
        }
        while (!d_->started) {
   d4e68:	7c1b      	ldrb	r3, [r3, #16]
   d4e6a:	b94b      	cbnz	r3, d4e80 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x84>
            // FIXME: This used to be os_thread_yield() but for some unknown reasons sometimes
            // it doesn't let the new thread to run.
            HAL_Delay_Milliseconds(1);
   d4e6c:	2001      	movs	r0, #1
   d4e6e:	f006 fca1 	bl	db7b4 <HAL_Delay_Milliseconds>
   d4e72:	e7f8      	b.n	d4e66 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x6a>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   d4e74:	6960      	ldr	r0, [r4, #20]
      __a = _GLIBCXX_MOVE(__b);
   d4e76:	2300      	movs	r3, #0
   d4e78:	6163      	str	r3, [r4, #20]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
   d4e7a:	b108      	cbz	r0, d4e80 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x84>
	  get_deleter()(__p);
   d4e7c:	f7ff ff2c 	bl	d4cd8 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.35>
	{
		checkin();
   d4e80:	f7ff ffb4 	bl	d4dec <_ZN19ApplicationWatchdog7checkinEv>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   d4e84:	a802      	add	r0, sp, #8
   d4e86:	f7ff ff1e 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
    // This constuctor helps to resolve overloaded function types, such as System.reset(), which is not always
    // possible in case of std::function
    ApplicationWatchdog(unsigned timeout_ms, void (*fn)(), unsigned stack_size=DEFAULT_STACK_SIZE) :
        ApplicationWatchdog(timeout_ms, std::function<void()>(fn), stack_size)
    {
    }
   d4e8a:	4620      	mov	r0, r4
   d4e8c:	b007      	add	sp, #28
   d4e8e:	bd30      	pop	{r4, r5, pc}
   d4e90:	000d4be7 	.word	0x000d4be7
   d4e94:	000d4beb 	.word	0x000d4beb
   d4e98:	000e291c 	.word	0x000e291c
   d4e9c:	000dec25 	.word	0x000dec25
   d4ea0:	000e1aba 	.word	0x000e1aba
   d4ea4:	000d4c25 	.word	0x000d4c25

000d4ea8 <_ZN10CloudClass7processEv>:
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
   d4ea8:	b508      	push	{r3, lr}
		last_checkin = current_time();
	}

};

inline void application_checkin() { ApplicationWatchdog::checkin(); }
   d4eaa:	f7ff ff9f 	bl	d4dec <_ZN19ApplicationWatchdog7checkinEv>
    		application_checkin();
    		spark_process();
    }
   d4eae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
    		application_checkin();
    		spark_process();
   d4eb2:	f006 bf31 	b.w	dbd18 <spark_process>

000d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>:
  const VariantData* data() const {
    return reinterpret_cast<const VariantData*>(&_content);
  }

  VariantSlot* next() {
    return _next ? this + _next : 0;
   d4eb6:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
   d4eba:	b113      	cbz	r3, d4ec2 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv+0xc>
   d4ebc:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   d4ec0:	4770      	bx	lr
   d4ec2:	4618      	mov	r0, r3
  }
   d4ec4:	4770      	bx	lr

000d4ec6 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE>:
#include <ArduinoJson/Collection/CollectionData.hpp>
#include <ArduinoJson/Variant/VariantData.hpp>

namespace ARDUINOJSON_NAMESPACE {

inline VariantSlot* CollectionData::addSlot(MemoryPool* pool) {
   d4ec6:	b510      	push	{r4, lr}
  T* allocRight() {
    return reinterpret_cast<T*>(allocRight(sizeof(T)));
  }

  void* allocRight(size_t bytes) {
    if (!canAlloc(bytes)) return 0;
   d4ec8:	684b      	ldr	r3, [r1, #4]
    _left = _begin;
    _right = _end;
  }

  bool canAlloc(size_t bytes) const {
    return _left + bytes <= _right;
   d4eca:	688a      	ldr	r2, [r1, #8]
  T* allocRight() {
    return reinterpret_cast<T*>(allocRight(sizeof(T)));
  }

  void* allocRight(size_t bytes) {
    if (!canAlloc(bytes)) return 0;
   d4ecc:	3310      	adds	r3, #16
   d4ece:	429a      	cmp	r2, r3
   d4ed0:	d201      	bcs.n	d4ed6 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE+0x10>
  VariantSlot* slot = pool->allocVariant();
  if (!slot) return 0;
   d4ed2:	2000      	movs	r0, #0
   d4ed4:	bd10      	pop	{r4, pc}
    _right -= bytes;
   d4ed6:	f1a2 0310 	sub.w	r3, r2, #16
   d4eda:	608b      	str	r3, [r1, #8]
   d4edc:	2b00      	cmp	r3, #0
   d4ede:	d0f8      	beq.n	d4ed2 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE+0xc>

  if (_tail) {
   d4ee0:	6841      	ldr	r1, [r0, #4]
   d4ee2:	b119      	cbz	r1, d4eec <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE+0x26>
    _next = VariantSlotDiff(slot ? slot - this : 0);
  }

  void setNextNotNull(VariantSlot* slot) {
    ARDUINOJSON_ASSERT(slot != 0);
    _next = VariantSlotDiff(slot - this);
   d4ee4:	1a5c      	subs	r4, r3, r1
   d4ee6:	1124      	asrs	r4, r4, #4
   d4ee8:	814c      	strh	r4, [r1, #10]
   d4eea:	e000      	b.n	d4eee <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE+0x28>
    _tail->setNextNotNull(slot);
    _tail = slot;
  } else {
    _head = slot;
   d4eec:	6003      	str	r3, [r0, #0]
  bool ownsKey() const {
    return (_flags & KEY_IS_OWNED) != 0;
  }

  void clear() {
    _next = 0;
   d4eee:	2100      	movs	r1, #0
    _tail = slot;
   d4ef0:	6043      	str	r3, [r0, #4]
   d4ef2:	f822 1c06 	strh.w	r1, [r2, #-6]
    _flags = 0;
   d4ef6:	f802 1c08 	strb.w	r1, [r2, #-8]
    _key = 0;
   d4efa:	f842 1c04 	str.w	r1, [r2, #-4]
  }

  slot->clear();
  return slot;
   d4efe:	4618      	mov	r0, r3
}
   d4f00:	bd10      	pop	{r4, pc}
	...

000d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>:
    return lhs != rhs._code;
  }

  // Behaves like a bool
  operator bool_type() const {
    return _code != Ok ? &DeserializationError::safeBoolHelper : 0;
   d4f04:	780b      	ldrb	r3, [r1, #0]
   d4f06:	b90b      	cbnz	r3, d4f0c <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv+0x8>
   d4f08:	6003      	str	r3, [r0, #0]
   d4f0a:	e002      	b.n	d4f12 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv+0xe>
   d4f0c:	4b02      	ldr	r3, [pc, #8]	; (d4f18 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv+0x14>)
   d4f0e:	6003      	str	r3, [r0, #0]
   d4f10:	2300      	movs	r3, #0
   d4f12:	6043      	str	r3, [r0, #4]
  }
   d4f14:	4770      	bx	lr
   d4f16:	bf00      	nop
   d4f18:	000d4be5 	.word	0x000d4be5

000d4f1c <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc>:
  void append(const char* s, size_t n) {
    while (n-- > 0) append(*s++);
  }

  void append(char c) {
    if (!_slot.value) return;
   d4f1c:	6882      	ldr	r2, [r0, #8]

  void append(const char* s, size_t n) {
    while (n-- > 0) append(*s++);
  }

  void append(char c) {
   d4f1e:	b510      	push	{r4, lr}
    if (!_slot.value) return;
   d4f20:	b14a      	cbz	r2, d4f36 <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc+0x1a>

    if (_size >= _slot.size) {
   d4f22:	6843      	ldr	r3, [r0, #4]
   d4f24:	68c4      	ldr	r4, [r0, #12]
   d4f26:	42a3      	cmp	r3, r4
   d4f28:	d302      	bcc.n	d4f30 <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc+0x14>
      _slot.value = 0;
   d4f2a:	2300      	movs	r3, #0
   d4f2c:	6083      	str	r3, [r0, #8]
      return;
   d4f2e:	bd10      	pop	{r4, pc}
    }

    _slot.value[_size++] = c;
   d4f30:	1c5c      	adds	r4, r3, #1
   d4f32:	6044      	str	r4, [r0, #4]
   d4f34:	54d1      	strb	r1, [r2, r3]
   d4f36:	bd10      	pop	{r4, pc}

000d4f38 <_ZN22ArduinoJson6130_00000113StringBuilder8completeEv>:
  }

  char* complete() {
   d4f38:	b510      	push	{r4, lr}
   d4f3a:	4604      	mov	r4, r0
    append('\0');
   d4f3c:	2100      	movs	r1, #0
   d4f3e:	f7ff ffed 	bl	d4f1c <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc>
    if (_slot.value) {
   d4f42:	68a3      	ldr	r3, [r4, #8]
   d4f44:	b13b      	cbz	r3, d4f56 <_ZN22ArduinoJson6130_00000113StringBuilder8completeEv+0x1e>
      _parent->freezeString(_slot, _size);
   d4f46:	e894 0006 	ldmia.w	r4, {r1, r2}
    checkInvariants();
    return s;
  }

  void freezeString(StringSlot& s, size_t newSize) {
    _left -= (s.size - newSize);
   d4f4a:	68e3      	ldr	r3, [r4, #12]
   d4f4c:	6848      	ldr	r0, [r1, #4]
   d4f4e:	1ad3      	subs	r3, r2, r3
   d4f50:	4403      	add	r3, r0
   d4f52:	604b      	str	r3, [r1, #4]
    s.size = newSize;
   d4f54:	60e2      	str	r2, [r4, #12]
    }
    return _slot.value;
  }
   d4f56:	68a0      	ldr	r0, [r4, #8]
   d4f58:	bd10      	pop	{r4, pc}

000d4f5a <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj>:
  size_t write(uint8_t c) {
    _str->operator+=(static_cast<char>(c));
    return 1;
  }

  size_t write(const uint8_t *s, size_t n) {
   d4f5a:	b570      	push	{r4, r5, r6, lr}
   d4f5c:	4606      	mov	r6, r0
    // CAUTION: Arduino String doesn't have append()
    // and old version doesn't have size() either
    _str->reserve(_str->length() + n);
   d4f5e:	6800      	ldr	r0, [r0, #0]
  size_t write(uint8_t c) {
    _str->operator+=(static_cast<char>(c));
    return 1;
  }

  size_t write(const uint8_t *s, size_t n) {
   d4f60:	460c      	mov	r4, r1
    // CAUTION: Arduino String doesn't have append()
    // and old version doesn't have size() either
    _str->reserve(_str->length() + n);
   d4f62:	6881      	ldr	r1, [r0, #8]
   d4f64:	4411      	add	r1, r2
  size_t write(uint8_t c) {
    _str->operator+=(static_cast<char>(c));
    return 1;
  }

  size_t write(const uint8_t *s, size_t n) {
   d4f66:	4615      	mov	r5, r2
    // CAUTION: Arduino String doesn't have append()
    // and old version doesn't have size() either
    _str->reserve(_str->length() + n);
   d4f68:	f007 fafa 	bl	dc560 <_ZN6String7reserveEj>
   d4f6c:	4425      	add	r5, r4
    while (n > 0) {
   d4f6e:	42ac      	cmp	r4, r5
   d4f70:	d005      	beq.n	d4f7e <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj+0x24>

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
   d4f72:	f814 1b01 	ldrb.w	r1, [r4], #1
   d4f76:	6830      	ldr	r0, [r6, #0]
   d4f78:	f007 fbe9 	bl	dc74e <_ZN6String6concatEc>
   d4f7c:	e7f7      	b.n	d4f6e <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj+0x14>
      _str->operator+=(static_cast<char>(*s++));
      n--;
    }
    return n;
  }
   d4f7e:	2000      	movs	r0, #0
   d4f80:	bd70      	pop	{r4, r5, r6, pc}

000d4f82 <_Z7startupv>:
        return HAL_Feature_Get(feature);
    }

    inline int enableFeature(HAL_Feature feature)
    {
        return HAL_Feature_Set(feature, true);
   d4f82:	2101      	movs	r1, #1
   d4f84:	2004      	movs	r0, #4
   d4f86:	f006 bc3d 	b.w	db804 <HAL_Feature_Set>
	...

000d4f8c <_Z6initSDv>:
/* 
* Fonction qui initialise la Carte SD et allume le Led Bleu si une faute d'initialisation a lieu
* V1.0 2019-11-14 
*/

void initSD() {
   d4f8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (!SD.begin(SD_CS)) {
   d4f8e:	210e      	movs	r1, #14
   d4f90:	4818      	ldr	r0, [pc, #96]	; (d4ff4 <_Z6initSDv+0x68>)
   d4f92:	f006 fa07 	bl	db3a4 <_ZN5SDLib7SDClass5beginEh>
   d4f96:	4604      	mov	r4, r0
   d4f98:	bb50      	cbnz	r0, d4ff0 <_Z6initSDv+0x64>
    Serial.println("SD Card initialization failed!! Resetting in 15 seconds");
   d4f9a:	f008 ff81 	bl	ddea0 <_Z16_fetch_usbserialv>
   d4f9e:	4916      	ldr	r1, [pc, #88]	; (d4ff8 <_Z6initSDv+0x6c>)
   d4fa0:	f007 ff63 	bl	dce6a <_ZN5Print7printlnEPKc>
    digitalWrite(statusLed, HIGH);
   d4fa4:	2101      	movs	r1, #1
   d4fa6:	2007      	movs	r0, #7
   d4fa8:	f009 fdd3 	bl	deb52 <digitalWrite>
    delay(5000);
   d4fac:	f241 3088 	movw	r0, #5000	; 0x1388
   d4fb0:	f008 f8c4 	bl	dd13c <delay>
    digitalWrite(statusLed, LOW);
   d4fb4:	4621      	mov	r1, r4
   d4fb6:	2007      	movs	r0, #7
   d4fb8:	f009 fdcb 	bl	deb52 <digitalWrite>
    delay(15000);
   d4fbc:	f643 2098 	movw	r0, #15000	; 0x3a98
   d4fc0:	f008 f8bc 	bl	dd13c <delay>
    delay(100);
   d4fc4:	2064      	movs	r0, #100	; 0x64
   d4fc6:	f008 f8b9 	bl	dd13c <delay>
   d4fca:	4b0c      	ldr	r3, [pc, #48]	; (d4ffc <_Z6initSDv+0x70>)
        val_(0) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
   d4fcc:	681b      	ldr	r3, [r3, #0]
    System.sleep(SS_Button, FALLING, 300);
   d4fce:	9300      	str	r3, [sp, #0]
   d4fd0:	2202      	movs	r2, #2
   d4fd2:	f44f 7396 	mov.w	r3, #300	; 0x12c
   d4fd6:	2106      	movs	r1, #6
   d4fd8:	a802      	add	r0, sp, #8
   d4fda:	f7ff feb1 	bl	d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>
    delay(1000);
   d4fde:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d4fe2:	f008 f8ab 	bl	dd13c <delay>
    System.reset();
  }
}
   d4fe6:	b004      	add	sp, #16
   d4fe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    digitalWrite(statusLed, LOW);
    delay(15000);
    delay(100);
    System.sleep(SS_Button, FALLING, 300);
    delay(1000);
    System.reset();
   d4fec:	f007 b917 	b.w	dc21e <_ZN11SystemClass5resetEv>
  }
}
   d4ff0:	b004      	add	sp, #16
   d4ff2:	bd10      	pop	{r4, pc}
   d4ff4:	2003e3d4 	.word	0x2003e3d4
   d4ff8:	000e1ac1 	.word	0x000e1ac1
   d4ffc:	2003e2a8 	.word	0x2003e2a8

000d5000 <_ZN5SDLib4FileaSEOS0_>:
   d5000:	684b      	ldr	r3, [r1, #4]
const unsigned char BIN = 2;

class String;
class __FlashStringHelper;

class Print
   d5002:	6043      	str	r3, [r0, #4]
#define   getFloat(skipChar)  parseFloat(skipChar)
#define   getString( pre_string, post_string, buffer, length)
readBytesBetween( pre_string, terminator, buffer, length)
*/

class Stream : public Print
   d5004:	688b      	ldr	r3, [r1, #8]
   d5006:	6083      	str	r3, [r0, #8]
   d5008:	68cb      	ldr	r3, [r1, #12]
   d500a:	60c3      	str	r3, [r0, #12]
   d500c:	b530      	push	{r4, r5, lr}
   d500e:	f100 0310 	add.w	r3, r0, #16
   d5012:	f101 020f 	add.w	r2, r1, #15
   d5016:	f100 041d 	add.w	r4, r0, #29
   d501a:	f812 5f01 	ldrb.w	r5, [r2, #1]!
   d501e:	f803 5b01 	strb.w	r5, [r3], #1
   d5022:	429c      	cmp	r4, r3
   d5024:	d1f9      	bne.n	d501a <_ZN5SDLib4FileaSEOS0_+0x1a>
   d5026:	6a0b      	ldr	r3, [r1, #32]
   d5028:	6203      	str	r3, [r0, #32]
   d502a:	bd30      	pop	{r4, r5, pc}

000d502c <_Z3log6Stringi>:

/* 
* Fonctions inscrivant les entres dans le log
* V1.1 2019-12-05
*/
void log(String msg, int Loglevel) {
   d502c:	b570      	push	{r4, r5, r6, lr}
   d502e:	4605      	mov	r5, r0
   d5030:	b0a4      	sub	sp, #144	; 0x90
   d5032:	460c      	mov	r4, r1
  // Tout ce qui est envoy au log est galement envoy au port srie
  Serial.println(msg);
   d5034:	f008 ff34 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5038:	6829      	ldr	r1, [r5, #0]
   d503a:	f007 ff16 	bl	dce6a <_ZN5Print7printlnEPKc>

  // Dans le dossier logs/
  String dir ="LOGS/" ;
   d503e:	4963      	ldr	r1, [pc, #396]	; (d51cc <_Z3log6Stringi+0x1a0>)
   d5040:	a806      	add	r0, sp, #24
   d5042:	f007 fab6 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  char buffer[20];
  // On prend l'heure actuelle
  DateTime logtime = rtc.now();
   d5046:	a804      	add	r0, sp, #16
   d5048:	f005 ffe9 	bl	db01e <_ZN7PCF85233nowEv>
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d504c:	a906      	add	r1, sp, #24
   d504e:	a812      	add	r0, sp, #72	; 0x48
   d5050:	f007 fad1 	bl	dc5f6 <_ZN6StringC1ERKS_>
  String logFileName = dir + String(monthOfTheYear[logtime.month()-1]) + String(logtime.year()) + ".TXT";
   d5054:	f89d 1011 	ldrb.w	r1, [sp, #17]
   d5058:	4b5d      	ldr	r3, [pc, #372]	; (d51d0 <_Z3log6Stringi+0x1a4>)
   d505a:	3901      	subs	r1, #1
   d505c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   d5060:	4419      	add	r1, r3
   d5062:	a80e      	add	r0, sp, #56	; 0x38
   d5064:	f007 faa5 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5068:	a90e      	add	r1, sp, #56	; 0x38
   d506a:	a812      	add	r0, sp, #72	; 0x48
   d506c:	f007 fb7c 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5070:	f89d 1010 	ldrb.w	r1, [sp, #16]
   d5074:	220a      	movs	r2, #10
   d5076:	4606      	mov	r6, r0
   d5078:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d507c:	a81b      	add	r0, sp, #108	; 0x6c
   d507e:	f007 fae8 	bl	dc652 <_ZN6StringC1Eih>
   d5082:	a91b      	add	r1, sp, #108	; 0x6c
   d5084:	4630      	mov	r0, r6
   d5086:	f007 fb6f 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d508a:	4952      	ldr	r1, [pc, #328]	; (d51d4 <_Z3log6Stringi+0x1a8>)
   d508c:	f007 fb78 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5090:	4601      	mov	r1, r0
   d5092:	a80a      	add	r0, sp, #40	; 0x28
   d5094:	f007 faaf 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5098:	a81b      	add	r0, sp, #108	; 0x6c
   d509a:	f007 fa43 	bl	dc524 <_ZN6StringD1Ev>
   d509e:	a80e      	add	r0, sp, #56	; 0x38
   d50a0:	f007 fa40 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d50a4:	a812      	add	r0, sp, #72	; 0x48
   d50a6:	f007 fa3d 	bl	dc524 <_ZN6StringD1Ev>
  File file;
   d50aa:	a812      	add	r0, sp, #72	; 0x48
   d50ac:	f005 faf2 	bl	da694 <_ZN5SDLib4FileC1Ev>
      // Open the specified file/directory with the supplied mode (e.g. read or
      // write, etc). Returns a File object for interacting with the file.
      // Note that currently only one file can be open at a time.
      File open(const char *filename, uint8_t mode = FILE_READ);
      File open(const String &filename, uint8_t mode = FILE_READ) {
        return open(filename.c_str(), mode);
   d50b0:	2301      	movs	r3, #1
   d50b2:	9a06      	ldr	r2, [sp, #24]
   d50b4:	4948      	ldr	r1, [pc, #288]	; (d51d8 <_Z3log6Stringi+0x1ac>)
   d50b6:	a81b      	add	r0, sp, #108	; 0x6c
   d50b8:	f006 fa14 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>

  // on cre le rpertoire s'il n'existe pas
  file = SD.open(dir);
   d50bc:	a91b      	add	r1, sp, #108	; 0x6c
   d50be:	a812      	add	r0, sp, #72	; 0x48
   d50c0:	f7ff ff9e 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  if(file) {
   d50c4:	a812      	add	r0, sp, #72	; 0x48
   d50c6:	f005 fb2b 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d50ca:	b1a0      	cbz	r0, d50f6 <_Z3log6Stringi+0xca>
    if(!file.isDirectory()) {
   d50cc:	a812      	add	r0, sp, #72	; 0x48
   d50ce:	f005 faef 	bl	da6b0 <_ZN5SDLib4File11isDirectoryEv>
   d50d2:	b960      	cbnz	r0, d50ee <_Z3log6Stringi+0xc2>
      Serial.println("Error in log dir...");
   d50d4:	f008 fee4 	bl	ddea0 <_Z16_fetch_usbserialv>
   d50d8:	4940      	ldr	r1, [pc, #256]	; (d51dc <_Z3log6Stringi+0x1b0>)
   d50da:	f007 fec6 	bl	dce6a <_ZN5Print7printlnEPKc>
      file.close();
   d50de:	a812      	add	r0, sp, #72	; 0x48
   d50e0:	f005 fb12 	bl	da708 <_ZN5SDLib4File5closeEv>
      }

      // Delete the file.
      bool remove(const char *filepath);
      bool remove(const String &filepath) {
        return remove(filepath.c_str());
   d50e4:	9906      	ldr	r1, [sp, #24]
   d50e6:	483c      	ldr	r0, [pc, #240]	; (d51d8 <_Z3log6Stringi+0x1ac>)
   d50e8:	f006 fa6a 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>
   d50ec:	e008      	b.n	d5100 <_Z3log6Stringi+0xd4>
      SD.remove(dir);
      if(!SD.mkdir(dir)) {
        Serial.println("SD mkdir failed");
      }         
    } else {
        file.close();
   d50ee:	a812      	add	r0, sp, #72	; 0x48
   d50f0:	f005 fb0a 	bl	da708 <_ZN5SDLib4File5closeEv>
   d50f4:	e00e      	b.n	d5114 <_Z3log6Stringi+0xe8>
      }
  } else {
      Serial.println("No Log dir.");
   d50f6:	f008 fed3 	bl	ddea0 <_Z16_fetch_usbserialv>
   d50fa:	4939      	ldr	r1, [pc, #228]	; (d51e0 <_Z3log6Stringi+0x1b4>)
   d50fc:	f007 feb5 	bl	dce6a <_ZN5Print7printlnEPKc>

      // Create the requested directory heirarchy--if intermediate directories
      // do not exist they will be created.
      bool mkdir(const char *filepath);
      bool mkdir(const String &filepath) {
        return mkdir(filepath.c_str());
   d5100:	9906      	ldr	r1, [sp, #24]
   d5102:	4835      	ldr	r0, [pc, #212]	; (d51d8 <_Z3log6Stringi+0x1ac>)
   d5104:	f006 fa40 	bl	db588 <_ZN5SDLib7SDClass5mkdirEPKc>
      if(!SD.mkdir(dir)) {
   d5108:	b920      	cbnz	r0, d5114 <_Z3log6Stringi+0xe8>
        Serial.println("SD mkdir failed");
   d510a:	f008 fec9 	bl	ddea0 <_Z16_fetch_usbserialv>
   d510e:	4935      	ldr	r1, [pc, #212]	; (d51e4 <_Z3log6Stringi+0x1b8>)
   d5110:	f007 feab 	bl	dce6a <_ZN5Print7printlnEPKc>
      // Open the specified file/directory with the supplied mode (e.g. read or
      // write, etc). Returns a File object for interacting with the file.
      // Note that currently only one file can be open at a time.
      File open(const char *filename, uint8_t mode = FILE_READ);
      File open(const String &filename, uint8_t mode = FILE_READ) {
        return open(filename.c_str(), mode);
   d5114:	2317      	movs	r3, #23
   d5116:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   d5118:	492f      	ldr	r1, [pc, #188]	; (d51d8 <_Z3log6Stringi+0x1ac>)
   d511a:	a81b      	add	r0, sp, #108	; 0x6c
   d511c:	f006 f9e2 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
      }
    }
  file = SD.open(logFileName, FILE_WRITE);
   d5120:	a91b      	add	r1, sp, #108	; 0x6c
   d5122:	a812      	add	r0, sp, #72	; 0x48
   d5124:	f7ff ff6c 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  if(!file) {
   d5128:	a812      	add	r0, sp, #72	; 0x48
   d512a:	f005 faf9 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d512e:	b990      	cbnz	r0, d5156 <_Z3log6Stringi+0x12a>
    Serial.println("could not open log file: " + logFileName);
   d5130:	f008 feb6 	bl	ddea0 <_Z16_fetch_usbserialv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5134:	492c      	ldr	r1, [pc, #176]	; (d51e8 <_Z3log6Stringi+0x1bc>)
   d5136:	4604      	mov	r4, r0
   d5138:	a81b      	add	r0, sp, #108	; 0x6c
   d513a:	f007 fa3a 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d513e:	a90a      	add	r1, sp, #40	; 0x28
   d5140:	a81b      	add	r0, sp, #108	; 0x6c
   d5142:	f007 fb11 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5146:	6801      	ldr	r1, [r0, #0]
   d5148:	4620      	mov	r0, r4
   d514a:	f007 fe8e 	bl	dce6a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d514e:	a81b      	add	r0, sp, #108	; 0x6c
   d5150:	f007 f9e8 	bl	dc524 <_ZN6StringD1Ev>
   d5154:	e031      	b.n	d51ba <_Z3log6Stringi+0x18e>
    * 2: error, erreur affectant le bon fonctionnement de l'appareil
    * 3: warning, situation anormale pouvant aider le dpannage
    * 4: info, information gnrale pouvant aider le dpannage
    */

    switch (Loglevel)
   d5156:	1e61      	subs	r1, r4, #1
   d5158:	2903      	cmp	r1, #3
   d515a:	d80d      	bhi.n	d5178 <_Z3log6Stringi+0x14c>
   d515c:	e8df f001 	tbb	[pc, r1]
   d5160:	08060402 	.word	0x08060402
    {
      case 1:
        file.print("CRITICAL ERROR    ;");
   d5164:	4921      	ldr	r1, [pc, #132]	; (d51ec <_Z3log6Stringi+0x1c0>)
   d5166:	e004      	b.n	d5172 <_Z3log6Stringi+0x146>
        break;

      case 2:
        file.print("ERROR    ;");
   d5168:	4921      	ldr	r1, [pc, #132]	; (d51f0 <_Z3log6Stringi+0x1c4>)
   d516a:	e002      	b.n	d5172 <_Z3log6Stringi+0x146>
        break;

      case 3:
        file.print("WARNING    ;");
   d516c:	4921      	ldr	r1, [pc, #132]	; (d51f4 <_Z3log6Stringi+0x1c8>)
   d516e:	e000      	b.n	d5172 <_Z3log6Stringi+0x146>
        break;

      case 4:
        file.print("INFO    ;");
   d5170:	4921      	ldr	r1, [pc, #132]	; (d51f8 <_Z3log6Stringi+0x1cc>)
   d5172:	a812      	add	r0, sp, #72	; 0x48
   d5174:	f007 fe66 	bl	dce44 <_ZN5Print5printEPKc>
        break;
    }
    
    //On imprime dans le log sous le format suivant
    //"LOGLEVEL"     ;AAAAMMDD;HHMMSS; "MSG"
    sprintf(buffer,"%04d%02d%02d;%02d%02d%02d;", logtime.year(),logtime.month(), logtime.day(), logtime.hour(), logtime.minute(), logtime.second());
   d5178:	f89d 1015 	ldrb.w	r1, [sp, #21]
   d517c:	9103      	str	r1, [sp, #12]
   d517e:	f89d 1014 	ldrb.w	r1, [sp, #20]
   d5182:	f89d 2010 	ldrb.w	r2, [sp, #16]
   d5186:	9102      	str	r1, [sp, #8]
   d5188:	f89d 1013 	ldrb.w	r1, [sp, #19]
   d518c:	9101      	str	r1, [sp, #4]
   d518e:	f89d 1012 	ldrb.w	r1, [sp, #18]
   d5192:	f89d 3011 	ldrb.w	r3, [sp, #17]
   d5196:	9100      	str	r1, [sp, #0]
   d5198:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
   d519c:	4917      	ldr	r1, [pc, #92]	; (d51fc <_Z3log6Stringi+0x1d0>)
   d519e:	a81b      	add	r0, sp, #108	; 0x6c
   d51a0:	f006 fe22 	bl	dbde8 <sprintf>
    file.print(buffer);
   d51a4:	a91b      	add	r1, sp, #108	; 0x6c
   d51a6:	a812      	add	r0, sp, #72	; 0x48
   d51a8:	f007 fe4c 	bl	dce44 <_ZN5Print5printEPKc>
    file.println(msg);
   d51ac:	6829      	ldr	r1, [r5, #0]
   d51ae:	a812      	add	r0, sp, #72	; 0x48
   d51b0:	f007 fe5b 	bl	dce6a <_ZN5Print7printlnEPKc>
    
    file.close();
   d51b4:	a812      	add	r0, sp, #72	; 0x48
   d51b6:	f005 faa7 	bl	da708 <_ZN5SDLib4File5closeEv>
  // Dans le dossier logs/
  String dir ="LOGS/" ;
  char buffer[20];
  // On prend l'heure actuelle
  DateTime logtime = rtc.now();
  String logFileName = dir + String(monthOfTheYear[logtime.month()-1]) + String(logtime.year()) + ".TXT";
   d51ba:	a80a      	add	r0, sp, #40	; 0x28
   d51bc:	f007 f9b2 	bl	dc524 <_ZN6StringD1Ev>
void log(String msg, int Loglevel) {
  // Tout ce qui est envoy au log est galement envoy au port srie
  Serial.println(msg);

  // Dans le dossier logs/
  String dir ="LOGS/" ;
   d51c0:	a806      	add	r0, sp, #24
   d51c2:	f007 f9af 	bl	dc524 <_ZN6StringD1Ev>
    file.print(buffer);
    file.println(msg);
    
    file.close();
  }
}
   d51c6:	b024      	add	sp, #144	; 0x90
   d51c8:	bd70      	pop	{r4, r5, r6, pc}
   d51ca:	bf00      	nop
   d51cc:	000e1af9 	.word	0x000e1af9
   d51d0:	2003d780 	.word	0x2003d780
   d51d4:	000e1aff 	.word	0x000e1aff
   d51d8:	2003e3d4 	.word	0x2003e3d4
   d51dc:	000e1b04 	.word	0x000e1b04
   d51e0:	000e1b28 	.word	0x000e1b28
   d51e4:	000e1b18 	.word	0x000e1b18
   d51e8:	000e1b34 	.word	0x000e1b34
   d51ec:	000e1b4e 	.word	0x000e1b4e
   d51f0:	000e1b57 	.word	0x000e1b57
   d51f4:	000e1b62 	.word	0x000e1b62
   d51f8:	000e1b6f 	.word	0x000e1b6f
   d51fc:	000e1b79 	.word	0x000e1b79

000d5200 <_Z7WDeventv>:
void startup() {
  System.enableFeature(FEATURE_RESET_INFO);
}


void WDevent() {
   d5200:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  log("Watchdog timeout", 1);
   d5202:	4908      	ldr	r1, [pc, #32]	; (d5224 <_Z7WDeventv+0x24>)
   d5204:	4668      	mov	r0, sp
   d5206:	f007 f9d4 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d520a:	2101      	movs	r1, #1
   d520c:	4668      	mov	r0, sp
   d520e:	f7ff ff0d 	bl	d502c <_Z3log6Stringi>
   d5212:	4668      	mov	r0, sp
   d5214:	f007 f986 	bl	dc524 <_ZN6StringD1Ev>
  System.reset();
   d5218:	f007 f801 	bl	dc21e <_ZN11SystemClass5resetEv>
}
   d521c:	b005      	add	sp, #20
   d521e:	f85d fb04 	ldr.w	pc, [sp], #4
   d5222:	bf00      	nop
   d5224:	000e1b94 	.word	0x000e1b94

000d5228 <_Z7handlerPKcS0_>:

/* 
* Fonction Callback tant appele automatiquement lorsque des informations sont reues du cloud Particle
* V1.0 2019-11-14 
*/
void handler(const char *topic, const char *data) {
   d5228:	b570      	push	{r4, r5, r6, lr}
   d522a:	b090      	sub	sp, #64	; 0x40
   d522c:	4605      	mov	r5, r0
   d522e:	460c      	mov	r4, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5230:	a804      	add	r0, sp, #16
   d5232:	4927      	ldr	r1, [pc, #156]	; (d52d0 <_Z7handlerPKcS0_+0xa8>)
   d5234:	f007 f9bd 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
 
    log("FPC " + String(topic) + ": " + String(data), 4);
   d5238:	4629      	mov	r1, r5
   d523a:	4668      	mov	r0, sp
   d523c:	f007 f9b9 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5240:	4669      	mov	r1, sp
   d5242:	a804      	add	r0, sp, #16
   d5244:	f007 fa90 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5248:	4922      	ldr	r1, [pc, #136]	; (d52d4 <_Z7handlerPKcS0_+0xac>)
   d524a:	f007 fa99 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d524e:	4621      	mov	r1, r4
   d5250:	4606      	mov	r6, r0
   d5252:	a808      	add	r0, sp, #32
   d5254:	f007 f9ad 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5258:	a908      	add	r1, sp, #32
   d525a:	4630      	mov	r0, r6
   d525c:	f007 fa84 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5260:	4601      	mov	r1, r0
   d5262:	a80c      	add	r0, sp, #48	; 0x30
   d5264:	f007 f9c7 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5268:	2104      	movs	r1, #4
   d526a:	a80c      	add	r0, sp, #48	; 0x30
   d526c:	f7ff fede 	bl	d502c <_Z3log6Stringi>
   d5270:	a80c      	add	r0, sp, #48	; 0x30
   d5272:	f007 f957 	bl	dc524 <_ZN6StringD1Ev>
   d5276:	a808      	add	r0, sp, #32
   d5278:	f007 f954 	bl	dc524 <_ZN6StringD1Ev>
   d527c:	4668      	mov	r0, sp
   d527e:	f007 f951 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5282:	a804      	add	r0, sp, #16
   d5284:	f007 f94e 	bl	dc524 <_ZN6StringD1Ev>

    //Si le sujet (topic) de l'info a trait Au nom de l'appareil...  
    if(String(topic) == "particle/device/name") {
   d5288:	4629      	mov	r1, r5
   d528a:	a80c      	add	r0, sp, #48	; 0x30
   d528c:	f007 f991 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
   d5290:	4911      	ldr	r1, [pc, #68]	; (d52d8 <_Z7handlerPKcS0_+0xb0>)
   d5292:	a80c      	add	r0, sp, #48	; 0x30
   d5294:	f007 fa86 	bl	dc7a4 <_ZNK6String6equalsEPKc>
   d5298:	4606      	mov	r6, r0
   d529a:	a80c      	add	r0, sp, #48	; 0x30
   d529c:	f007 f942 	bl	dc524 <_ZN6StringD1Ev>
   d52a0:	b11e      	cbz	r6, d52aa <_Z7handlerPKcS0_+0x82>
      BDH = data;
   d52a2:	4621      	mov	r1, r4
   d52a4:	480d      	ldr	r0, [pc, #52]	; (d52dc <_Z7handlerPKcS0_+0xb4>)
   d52a6:	f007 f9b1 	bl	dc60c <_ZN6StringaSEPKc>
      }
    //Si le sujet (topic) de l'info a trait  l'adresse IP...  
    if(String(topic) == "particle/device/ip") {
   d52aa:	4629      	mov	r1, r5
   d52ac:	a80c      	add	r0, sp, #48	; 0x30
   d52ae:	f007 f980 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d52b2:	490b      	ldr	r1, [pc, #44]	; (d52e0 <_Z7handlerPKcS0_+0xb8>)
   d52b4:	a80c      	add	r0, sp, #48	; 0x30
   d52b6:	f007 fa75 	bl	dc7a4 <_ZNK6String6equalsEPKc>
   d52ba:	4605      	mov	r5, r0
   d52bc:	a80c      	add	r0, sp, #48	; 0x30
   d52be:	f007 f931 	bl	dc524 <_ZN6StringD1Ev>
   d52c2:	b11d      	cbz	r5, d52cc <_Z7handlerPKcS0_+0xa4>
      PublicIP = data;
   d52c4:	4621      	mov	r1, r4
   d52c6:	4807      	ldr	r0, [pc, #28]	; (d52e4 <_Z7handlerPKcS0_+0xbc>)
   d52c8:	f007 f9a0 	bl	dc60c <_ZN6StringaSEPKc>
      }
}
   d52cc:	b010      	add	sp, #64	; 0x40
   d52ce:	bd70      	pop	{r4, r5, r6, pc}
   d52d0:	000e1ba5 	.word	0x000e1ba5
   d52d4:	000e1cf4 	.word	0x000e1cf4
   d52d8:	000e1baa 	.word	0x000e1baa
   d52dc:	2003df78 	.word	0x2003df78
   d52e0:	000e1bbf 	.word	0x000e1bbf
   d52e4:	2003df68 	.word	0x2003df68

000d52e8 <_Z22printNclearSDlogBufferv>:
  logbuffer[logBufIndex] += buffer;
  logbuffer[logBufIndex] += msg;
  logBufIndex++;
}*/

void printNclearSDlogBuffer() {
   d52e8:	b570      	push	{r4, r5, r6, lr}
  if(logBufIndex > 0) {
   d52ea:	4b47      	ldr	r3, [pc, #284]	; (d5408 <_Z22printNclearSDlogBufferv+0x120>)
   d52ec:	681a      	ldr	r2, [r3, #0]
   d52ee:	2a00      	cmp	r2, #0
  logbuffer[logBufIndex] += buffer;
  logbuffer[logBufIndex] += msg;
  logBufIndex++;
}*/

void printNclearSDlogBuffer() {
   d52f0:	b0a4      	sub	sp, #144	; 0x90
   d52f2:	461d      	mov	r5, r3
  if(logBufIndex > 0) {
   d52f4:	f340 8086 	ble.w	d5404 <_Z22printNclearSDlogBufferv+0x11c>
    String dir ="LOGS/" ;
   d52f8:	4944      	ldr	r1, [pc, #272]	; (d540c <_Z22printNclearSDlogBufferv+0x124>)
   d52fa:	a802      	add	r0, sp, #8
   d52fc:	f007 f959 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    File file;
   d5300:	a812      	add	r0, sp, #72	; 0x48
   d5302:	f005 f9c7 	bl	da694 <_ZN5SDLib4FileC1Ev>
    DateTime logtime = rtc.now();
   d5306:	4668      	mov	r0, sp
   d5308:	f005 fe89 	bl	db01e <_ZN7PCF85233nowEv>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d530c:	4940      	ldr	r1, [pc, #256]	; (d5410 <_Z22printNclearSDlogBufferv+0x128>)
   d530e:	a80a      	add	r0, sp, #40	; 0x28
   d5310:	f007 f94f 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    String logFileName = "/" + dir + String(monthOfTheYear[logtime.month()-1]) + String(logtime.year()) + ".TXT";  
   d5314:	a902      	add	r1, sp, #8
   d5316:	a80a      	add	r0, sp, #40	; 0x28
   d5318:	f007 fa26 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d531c:	f89d 1001 	ldrb.w	r1, [sp, #1]
   d5320:	4b3c      	ldr	r3, [pc, #240]	; (d5414 <_Z22printNclearSDlogBufferv+0x12c>)
   d5322:	3901      	subs	r1, #1
   d5324:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   d5328:	4419      	add	r1, r3
   d532a:	4604      	mov	r4, r0
   d532c:	a80e      	add	r0, sp, #56	; 0x38
   d532e:	f007 f940 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5332:	a90e      	add	r1, sp, #56	; 0x38
   d5334:	4620      	mov	r0, r4
   d5336:	f007 fa17 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d533a:	f89d 1000 	ldrb.w	r1, [sp]
   d533e:	220a      	movs	r2, #10
   d5340:	4604      	mov	r4, r0
   d5342:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d5346:	a81b      	add	r0, sp, #108	; 0x6c
   d5348:	f007 f983 	bl	dc652 <_ZN6StringC1Eih>
   d534c:	a91b      	add	r1, sp, #108	; 0x6c
   d534e:	4620      	mov	r0, r4
   d5350:	f007 fa0a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5354:	4930      	ldr	r1, [pc, #192]	; (d5418 <_Z22printNclearSDlogBufferv+0x130>)
   d5356:	f007 fa13 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d535a:	4601      	mov	r1, r0
   d535c:	a806      	add	r0, sp, #24
   d535e:	f007 f94a 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5362:	a81b      	add	r0, sp, #108	; 0x6c
   d5364:	f007 f8de 	bl	dc524 <_ZN6StringD1Ev>
   d5368:	a80e      	add	r0, sp, #56	; 0x38
   d536a:	f007 f8db 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d536e:	a80a      	add	r0, sp, #40	; 0x28
   d5370:	f007 f8d8 	bl	dc524 <_ZN6StringD1Ev>
      }

      // Methods to determine if the requested file path exists.
      bool exists(const char *filepath);
      bool exists(const String &filepath) {
        return exists(filepath.c_str());
   d5374:	9902      	ldr	r1, [sp, #8]
   d5376:	4829      	ldr	r0, [pc, #164]	; (d541c <_Z22printNclearSDlogBufferv+0x134>)
   d5378:	f006 f8f8 	bl	db56c <_ZN5SDLib7SDClass6existsEPKc>

    // on cre le rpertoire s'il n'existe pas
    if(!SD.exists(dir)){
   d537c:	b970      	cbnz	r0, d539c <_Z22printNclearSDlogBufferv+0xb4>
        Serial.println("Directory does not exist, trying to create it...PNSDLB");
   d537e:	f008 fd8f 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5382:	4927      	ldr	r1, [pc, #156]	; (d5420 <_Z22printNclearSDlogBufferv+0x138>)
   d5384:	f007 fd71 	bl	dce6a <_ZN5Print7printlnEPKc>

      // Create the requested directory heirarchy--if intermediate directories
      // do not exist they will be created.
      bool mkdir(const char *filepath);
      bool mkdir(const String &filepath) {
        return mkdir(filepath.c_str());
   d5388:	9902      	ldr	r1, [sp, #8]
   d538a:	4824      	ldr	r0, [pc, #144]	; (d541c <_Z22printNclearSDlogBufferv+0x134>)
   d538c:	f006 f8fc 	bl	db588 <_ZN5SDLib7SDClass5mkdirEPKc>
      if(!SD.mkdir(dir)){
   d5390:	b920      	cbnz	r0, d539c <_Z22printNclearSDlogBufferv+0xb4>
        Serial.println("SD mkdir failed PNSDLB");
   d5392:	f008 fd85 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5396:	4923      	ldr	r1, [pc, #140]	; (d5424 <_Z22printNclearSDlogBufferv+0x13c>)
   d5398:	f007 fd67 	bl	dce6a <_ZN5Print7printlnEPKc>
      // Open the specified file/directory with the supplied mode (e.g. read or
      // write, etc). Returns a File object for interacting with the file.
      // Note that currently only one file can be open at a time.
      File open(const char *filename, uint8_t mode = FILE_READ);
      File open(const String &filename, uint8_t mode = FILE_READ) {
        return open(filename.c_str(), mode);
   d539c:	2317      	movs	r3, #23
   d539e:	9a06      	ldr	r2, [sp, #24]
   d53a0:	491e      	ldr	r1, [pc, #120]	; (d541c <_Z22printNclearSDlogBufferv+0x134>)
   d53a2:	a81b      	add	r0, sp, #108	; 0x6c
   d53a4:	f006 f89e 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
      } 
    }
    file = SD.open(logFileName,  FILE_WRITE);
   d53a8:	a91b      	add	r1, sp, #108	; 0x6c
   d53aa:	a812      	add	r0, sp, #72	; 0x48
   d53ac:	f7ff fe28 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
    if(!file) {
   d53b0:	a812      	add	r0, sp, #72	; 0x48
   d53b2:	f005 f9b5 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d53b6:	b950      	cbnz	r0, d53ce <_Z22printNclearSDlogBufferv+0xe6>
      Serial.println("could not open log file");
   d53b8:	f008 fd72 	bl	ddea0 <_Z16_fetch_usbserialv>
   d53bc:	491a      	ldr	r1, [pc, #104]	; (d5428 <_Z22printNclearSDlogBufferv+0x140>)
   d53be:	f007 fd54 	bl	dce6a <_ZN5Print7printlnEPKc>
      Serial.println(logFileName);
   d53c2:	f008 fd6d 	bl	ddea0 <_Z16_fetch_usbserialv>
   d53c6:	9906      	ldr	r1, [sp, #24]
   d53c8:	f007 fd4f 	bl	dce6a <_ZN5Print7printlnEPKc>
   d53cc:	e014      	b.n	d53f8 <_Z22printNclearSDlogBufferv+0x110>
      return;
    } else {
      while (logBufIndex > 0)
   d53ce:	4c0e      	ldr	r4, [pc, #56]	; (d5408 <_Z22printNclearSDlogBufferv+0x120>)
   d53d0:	4e16      	ldr	r6, [pc, #88]	; (d542c <_Z22printNclearSDlogBufferv+0x144>)
   d53d2:	682b      	ldr	r3, [r5, #0]
   d53d4:	2b00      	cmp	r3, #0
   d53d6:	dd0c      	ble.n	d53f2 <_Z22printNclearSDlogBufferv+0x10a>
      {
        file.println(logbuffer[LogEntries]);
   d53d8:	f8d6 1320 	ldr.w	r1, [r6, #800]	; 0x320
   d53dc:	a812      	add	r0, sp, #72	; 0x48
   d53de:	f007 fd44 	bl	dce6a <_ZN5Print7printlnEPKc>
        logbuffer[LogEntries] = "";
   d53e2:	4913      	ldr	r1, [pc, #76]	; (d5430 <_Z22printNclearSDlogBufferv+0x148>)
   d53e4:	4813      	ldr	r0, [pc, #76]	; (d5434 <_Z22printNclearSDlogBufferv+0x14c>)
   d53e6:	f007 f911 	bl	dc60c <_ZN6StringaSEPKc>
        logBufIndex--;
   d53ea:	6823      	ldr	r3, [r4, #0]
   d53ec:	3b01      	subs	r3, #1
   d53ee:	6023      	str	r3, [r4, #0]
   d53f0:	e7ef      	b.n	d53d2 <_Z22printNclearSDlogBufferv+0xea>
      }
      file.close();
   d53f2:	a812      	add	r0, sp, #72	; 0x48
   d53f4:	f005 f988 	bl	da708 <_ZN5SDLib4File5closeEv>
void printNclearSDlogBuffer() {
  if(logBufIndex > 0) {
    String dir ="LOGS/" ;
    File file;
    DateTime logtime = rtc.now();
    String logFileName = "/" + dir + String(monthOfTheYear[logtime.month()-1]) + String(logtime.year()) + ".TXT";  
   d53f8:	a806      	add	r0, sp, #24
   d53fa:	f007 f893 	bl	dc524 <_ZN6StringD1Ev>
  logBufIndex++;
}*/

void printNclearSDlogBuffer() {
  if(logBufIndex > 0) {
    String dir ="LOGS/" ;
   d53fe:	a802      	add	r0, sp, #8
   d5400:	f007 f890 	bl	dc524 <_ZN6StringD1Ev>
        logBufIndex--;
      }
      file.close();
    }
  }
}
   d5404:	b024      	add	sp, #144	; 0x90
   d5406:	bd70      	pop	{r4, r5, r6, pc}
   d5408:	2003df50 	.word	0x2003df50
   d540c:	000e1af9 	.word	0x000e1af9
   d5410:	000e1afd 	.word	0x000e1afd
   d5414:	2003d780 	.word	0x2003d780
   d5418:	000e1aff 	.word	0x000e1aff
   d541c:	2003e3d4 	.word	0x2003e3d4
   d5420:	000e1bd2 	.word	0x000e1bd2
   d5424:	000e1c09 	.word	0x000e1c09
   d5428:	000e1c20 	.word	0x000e1c20
   d542c:	2003df88 	.word	0x2003df88
   d5430:	000e1eea 	.word	0x000e1eea
   d5434:	2003e2a8 	.word	0x2003e2a8

000d5438 <_Z7syncFTP6StringbS_i>:
/* 
* Fonction qui envoie un fichier sur le site ftp spcifi
* V1.1 2019-12-17, Cell reset after tryouts
* V1.2 2020-02-07, Ttype instead of isLog, 0= regular img, 1= log, 2= offline img (temp folder) 
*/
bool syncFTP(String SDfilename, bool retry, String dir, int Ttype) { 
   d5438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d543c:	b0c1      	sub	sp, #260	; 0x104
   d543e:	af02      	add	r7, sp, #8
   d5440:	4604      	mov	r4, r0
   d5442:	468a      	mov	sl, r1
  
  //Dclaration de variable temporaire
  static const size_t bufferSize = 256;// grosseur des blocs de donnes  envoyer 
  static uint8_t buffer[bufferSize] = {0xFF}; //Terminer le bloc par un 0xFF
  String DestFilename = "";
   d5444:	f107 000c 	add.w	r0, r7, #12
   d5448:	49ba      	ldr	r1, [pc, #744]	; (d5734 <_Z7syncFTP6StringbS_i+0x2fc>)
/* 
* Fonction qui envoie un fichier sur le site ftp spcifi
* V1.1 2019-12-17, Cell reset after tryouts
* V1.2 2020-02-07, Ttype instead of isLog, 0= regular img, 1= log, 2= offline img (temp folder) 
*/
bool syncFTP(String SDfilename, bool retry, String dir, int Ttype) { 
   d544a:	4615      	mov	r5, r2
   d544c:	461e      	mov	r6, r3
  
  //Dclaration de variable temporaire
  static const size_t bufferSize = 256;// grosseur des blocs de donnes  envoyer 
  static uint8_t buffer[bufferSize] = {0xFF}; //Terminer le bloc par un 0xFF
  String DestFilename = "";
   d544e:	f007 f8b0 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  char buffersprint1 [50]; // Variables temporaires pour gnrer les noms de fichiers et 
  char buffersprint2 [50]; // chemins d'arborescence
  uint32_t len = 0;

  // Connection  l'hte FTP avec les infos fournies
  if (!ftp.open(config.ftp_hostname, port, timeout)) {
   d5452:	49b9      	ldr	r1, [pc, #740]	; (d5738 <_Z7syncFTP6StringbS_i+0x300>)
   d5454:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5458:	f007 f8ab 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d545c:	4bb7      	ldr	r3, [pc, #732]	; (d573c <_Z7syncFTP6StringbS_i+0x304>)
   d545e:	4ab8      	ldr	r2, [pc, #736]	; (d5740 <_Z7syncFTP6StringbS_i+0x308>)
   d5460:	681b      	ldr	r3, [r3, #0]
   d5462:	8812      	ldrh	r2, [r2, #0]
   d5464:	48b7      	ldr	r0, [pc, #732]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d5466:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d546a:	f005 f9ab 	bl	da7c4 <_ZN17particleftpclient17ParticleFtpClient4openE6Stringti>
   d546e:	4680      	mov	r8, r0
   d5470:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5474:	f007 f856 	bl	dc524 <_ZN6StringD1Ev>
   d5478:	f1b8 0f00 	cmp.w	r8, #0
   d547c:	d120      	bne.n	d54c0 <_Z7syncFTP6StringbS_i+0x88>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d547e:	49b2      	ldr	r1, [pc, #712]	; (d5748 <_Z7syncFTP6StringbS_i+0x310>)
   d5480:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d5484:	f007 f895 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("Couldn't connect to " + String(config.ftp_hostname), 2);
   d5488:	49ab      	ldr	r1, [pc, #684]	; (d5738 <_Z7syncFTP6StringbS_i+0x300>)
   d548a:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d548e:	f007 f890 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5492:	f107 016c 	add.w	r1, r7, #108	; 0x6c
   d5496:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d549a:	f007 f965 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d549e:	4601      	mov	r1, r0
   d54a0:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54a4:	f007 f8a7 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d54a8:	2102      	movs	r1, #2
   d54aa:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54ae:	f7ff fdbd 	bl	d502c <_Z3log6Stringi>
   d54b2:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54b6:	f007 f835 	bl	dc524 <_ZN6StringD1Ev>
   d54ba:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d54be:	e07c      	b.n	d55ba <_Z7syncFTP6StringbS_i+0x182>
    return 0;
  }
  if (!ftp.user(username)) {
   d54c0:	49a2      	ldr	r1, [pc, #648]	; (d574c <_Z7syncFTP6StringbS_i+0x314>)
   d54c2:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54c6:	f007 f896 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d54ca:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d54ce:	489d      	ldr	r0, [pc, #628]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d54d0:	f005 f9da 	bl	da888 <_ZN17particleftpclient17ParticleFtpClient4userE6String>
   d54d4:	4680      	mov	r8, r0
   d54d6:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54da:	f007 f823 	bl	dc524 <_ZN6StringD1Ev>
   d54de:	f1b8 0f00 	cmp.w	r8, #0
   d54e2:	d101      	bne.n	d54e8 <_Z7syncFTP6StringbS_i+0xb0>
    log("Bad ftp username", 2);
   d54e4:	499a      	ldr	r1, [pc, #616]	; (d5750 <_Z7syncFTP6StringbS_i+0x318>)
   d54e6:	e012      	b.n	d550e <_Z7syncFTP6StringbS_i+0xd6>
    return 0;
  }
  if (!ftp.pass(password)) {
   d54e8:	499a      	ldr	r1, [pc, #616]	; (d5754 <_Z7syncFTP6StringbS_i+0x31c>)
   d54ea:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d54ee:	f007 f882 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d54f2:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d54f6:	4893      	ldr	r0, [pc, #588]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d54f8:	f005 f9e8 	bl	da8cc <_ZN17particleftpclient17ParticleFtpClient4passE6String>
   d54fc:	4680      	mov	r8, r0
   d54fe:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5502:	f007 f80f 	bl	dc524 <_ZN6StringD1Ev>
   d5506:	f1b8 0f00 	cmp.w	r8, #0
   d550a:	d10e      	bne.n	d552a <_Z7syncFTP6StringbS_i+0xf2>
    log("Bad ftp password", 2);
   d550c:	4992      	ldr	r1, [pc, #584]	; (d5758 <_Z7syncFTP6StringbS_i+0x320>)
   d550e:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5512:	f007 f84e 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5516:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d551a:	2102      	movs	r1, #2
   d551c:	f7ff fd86 	bl	d502c <_Z3log6Stringi>
   d5520:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5524:	f006 fffe 	bl	dc524 <_ZN6StringD1Ev>
    return 0;
   d5528:	e277      	b.n	d5a1a <_Z7syncFTP6StringbS_i+0x5e2>
  }

  // On "navigue" vers le chemin de dossier pass en paramtre (dir)
  if (!ftp.cwd(dir)){
   d552a:	4629      	mov	r1, r5
   d552c:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5530:	f007 f861 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5534:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d5538:	4882      	ldr	r0, [pc, #520]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d553a:	f005 f9e9 	bl	da910 <_ZN17particleftpclient17ParticleFtpClient3cwdE6String>
   d553e:	4680      	mov	r8, r0
   d5540:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5544:	f006 ffee 	bl	dc524 <_ZN6StringD1Ev>
   d5548:	f1b8 0f00 	cmp.w	r8, #0
   d554c:	d158      	bne.n	d5600 <_Z7syncFTP6StringbS_i+0x1c8>
    log("could not set directory", 3);
   d554e:	4983      	ldr	r1, [pc, #524]	; (d575c <_Z7syncFTP6StringbS_i+0x324>)
   d5550:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5554:	f007 f82d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5558:	2103      	movs	r1, #3
   d555a:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d555e:	f7ff fd65 	bl	d502c <_Z3log6Stringi>
   d5562:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5566:	f006 ffdd 	bl	dc524 <_ZN6StringD1Ev>
    if(!ftp.mkd(dir)){ //S'il n'existe pas on le cre
   d556a:	4629      	mov	r1, r5
   d556c:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5570:	f007 f841 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5574:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d5578:	4872      	ldr	r0, [pc, #456]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d557a:	f005 f9eb 	bl	da954 <_ZN17particleftpclient17ParticleFtpClient3mkdE6String>
   d557e:	4680      	mov	r8, r0
   d5580:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d5584:	f006 ffce 	bl	dc524 <_ZN6StringD1Ev>
   d5588:	f1b8 0f00 	cmp.w	r8, #0
   d558c:	d11c      	bne.n	d55c8 <_Z7syncFTP6StringbS_i+0x190>
   d558e:	4974      	ldr	r1, [pc, #464]	; (d5760 <_Z7syncFTP6StringbS_i+0x328>)
   d5590:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d5594:	f007 f80d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      log("ftp mkdir failed: " + dir, 2);
   d5598:	4629      	mov	r1, r5
   d559a:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d559e:	f007 f8e3 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d55a2:	4601      	mov	r1, r0
   d55a4:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55a8:	f007 f825 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d55ac:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55b0:	2102      	movs	r1, #2
   d55b2:	f7ff fd3b 	bl	d502c <_Z3log6Stringi>
   d55b6:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55ba:	f006 ffb3 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d55be:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d55c2:	f006 ffaf 	bl	dc524 <_ZN6StringD1Ev>
      return 0; // retour de la fonction en erreur si le dossier n'a pu tre cr
   d55c6:	e228      	b.n	d5a1a <_Z7syncFTP6StringbS_i+0x5e2>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d55c8:	4966      	ldr	r1, [pc, #408]	; (d5764 <_Z7syncFTP6StringbS_i+0x32c>)
   d55ca:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d55ce:	f006 fff0 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    }
    log("ftp mkdir success: " + dir, 3);
   d55d2:	4629      	mov	r1, r5
   d55d4:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d55d8:	f007 f8c6 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d55dc:	4601      	mov	r1, r0
   d55de:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55e2:	f007 f808 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d55e6:	2103      	movs	r1, #3
   d55e8:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55ec:	f7ff fd1e 	bl	d502c <_Z3log6Stringi>
   d55f0:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d55f4:	f006 ff96 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d55f8:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d55fc:	f006 ff92 	bl	dc524 <_ZN6StringD1Ev>
  }

  // Si le fichier pass en paramtre n'est pas un log (typiquement une image), 
  // on configure les chemins d'arborescence et les noms de fichiers
  if(Ttype == 0) {
   d5600:	bb36      	cbnz	r6, d5650 <_Z7syncFTP6StringbS_i+0x218>
   d5602:	f8df 817c 	ldr.w	r8, [pc, #380]	; d5780 <_Z7syncFTP6StringbS_i+0x348>
    //Nom de l'image  destination
    sprintf(buffersprint1,"%s_%d%02d%s",stationName.c_str(), now.year(),now.month(),SDfilename.c_str());
   d5606:	6822      	ldr	r2, [r4, #0]
   d5608:	f898 3000 	ldrb.w	r3, [r8]
   d560c:	9201      	str	r2, [sp, #4]
   d560e:	f898 2001 	ldrb.w	r2, [r8, #1]
   d5612:	f8df 9170 	ldr.w	r9, [pc, #368]	; d5784 <_Z7syncFTP6StringbS_i+0x34c>
   d5616:	9200      	str	r2, [sp, #0]
   d5618:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
   d561c:	f8d9 2000 	ldr.w	r2, [r9]
   d5620:	4951      	ldr	r1, [pc, #324]	; (d5768 <_Z7syncFTP6StringbS_i+0x330>)
   d5622:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d5626:	f006 fbdf 	bl	dbde8 <sprintf>
    DestFilename = buffersprint1;
   d562a:	f107 0190 	add.w	r1, r7, #144	; 0x90
   d562e:	f107 000c 	add.w	r0, r7, #12
   d5632:	f006 ffeb 	bl	dc60c <_ZN6StringaSEPKc>

    //nom et chemin de l'image sur la carte SD 
    sprintf(buffersprint2,"/%s/%d/%d/%s",stationName.c_str(),now.year(), now.month(),SDfilename.c_str());
   d5636:	6822      	ldr	r2, [r4, #0]
   d5638:	f898 3000 	ldrb.w	r3, [r8]
   d563c:	9201      	str	r2, [sp, #4]
   d563e:	f898 2001 	ldrb.w	r2, [r8, #1]
   d5642:	9200      	str	r2, [sp, #0]
   d5644:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
   d5648:	f8d9 2000 	ldr.w	r2, [r9]
   d564c:	4947      	ldr	r1, [pc, #284]	; (d576c <_Z7syncFTP6StringbS_i+0x334>)
   d564e:	e036      	b.n	d56be <_Z7syncFTP6StringbS_i+0x286>
    SDfilename = buffersprint2;
  } else if(Ttype == 1)   {
   d5650:	2e01      	cmp	r6, #1
   d5652:	d10c      	bne.n	d566e <_Z7syncFTP6StringbS_i+0x236>
      // S'il s'agit d'un log, le nom du fichier  destination ne change pas et l'arborescence 
      // dans la carte SD n'est pas la mme (/LOGS/moisAnne.txt)
      sprintf(buffersprint2,"/%s/%s", "LOGS",SDfilename.c_str());
   d5654:	6823      	ldr	r3, [r4, #0]
   d5656:	4a46      	ldr	r2, [pc, #280]	; (d5770 <_Z7syncFTP6StringbS_i+0x338>)
   d5658:	4946      	ldr	r1, [pc, #280]	; (d5774 <_Z7syncFTP6StringbS_i+0x33c>)
   d565a:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d565e:	f006 fbc3 	bl	dbde8 <sprintf>
      DestFilename = SDfilename;
   d5662:	4621      	mov	r1, r4
   d5664:	f107 000c 	add.w	r0, r7, #12
   d5668:	f006 ffb6 	bl	dc5d8 <_ZN6StringaSERKS_>
   d566c:	e02b      	b.n	d56c6 <_Z7syncFTP6StringbS_i+0x28e>
      SDfilename = buffersprint2;
    } else if(Ttype == 2)   {
   d566e:	2e02      	cmp	r6, #2
   d5670:	d12e      	bne.n	d56d0 <_Z7syncFTP6StringbS_i+0x298>
   d5672:	f8df 810c 	ldr.w	r8, [pc, #268]	; d5780 <_Z7syncFTP6StringbS_i+0x348>
      //Nom de l'image  destination
      sprintf(buffersprint1,"%s_%d%02d%s",stationName.c_str(), now.year(),now.month(),SDfilename.c_str());
   d5676:	6822      	ldr	r2, [r4, #0]
   d5678:	f898 3000 	ldrb.w	r3, [r8]
   d567c:	9201      	str	r2, [sp, #4]
   d567e:	f898 2001 	ldrb.w	r2, [r8, #1]
   d5682:	f8df 9100 	ldr.w	r9, [pc, #256]	; d5784 <_Z7syncFTP6StringbS_i+0x34c>
   d5686:	9200      	str	r2, [sp, #0]
   d5688:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
   d568c:	f8d9 2000 	ldr.w	r2, [r9]
   d5690:	4935      	ldr	r1, [pc, #212]	; (d5768 <_Z7syncFTP6StringbS_i+0x330>)
   d5692:	f107 0090 	add.w	r0, r7, #144	; 0x90
   d5696:	f006 fba7 	bl	dbde8 <sprintf>
      DestFilename = buffersprint1;
   d569a:	f107 0190 	add.w	r1, r7, #144	; 0x90
   d569e:	f107 000c 	add.w	r0, r7, #12
   d56a2:	f006 ffb3 	bl	dc60c <_ZN6StringaSEPKc>

      //nom et chemin de l'image sur la carte SD 
      sprintf(buffersprint2,"/%s/%d/%d/TEMP/%s",stationName.c_str(),now.year(), now.month(),SDfilename.c_str());
   d56a6:	6822      	ldr	r2, [r4, #0]
   d56a8:	f898 3000 	ldrb.w	r3, [r8]
   d56ac:	9201      	str	r2, [sp, #4]
   d56ae:	f898 2001 	ldrb.w	r2, [r8, #1]
   d56b2:	9200      	str	r2, [sp, #0]
   d56b4:	f8d9 2000 	ldr.w	r2, [r9]
   d56b8:	492f      	ldr	r1, [pc, #188]	; (d5778 <_Z7syncFTP6StringbS_i+0x340>)
   d56ba:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
   d56be:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
   d56c2:	f006 fb91 	bl	dbde8 <sprintf>
      SDfilename = buffersprint2;
   d56c6:	f107 01c4 	add.w	r1, r7, #196	; 0xc4
   d56ca:	4620      	mov	r0, r4
   d56cc:	f006 ff9e 	bl	dc60c <_ZN6StringaSEPKc>
    }

 
  //Voir si notre fichier existe dj sur le serveur
  if (!ftp.list(DestFilename)) {
   d56d0:	f107 010c 	add.w	r1, r7, #12
   d56d4:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d56d8:	f006 ff8d 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d56dc:	f107 016c 	add.w	r1, r7, #108	; 0x6c
   d56e0:	4818      	ldr	r0, [pc, #96]	; (d5744 <_Z7syncFTP6StringbS_i+0x30c>)
   d56e2:	f005 fa63 	bl	dabac <_ZN17particleftpclient17ParticleFtpClient4listE6String>
   d56e6:	4680      	mov	r8, r0
   d56e8:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d56ec:	f006 ff1a 	bl	dc524 <_ZN6StringD1Ev>
   d56f0:	f1b8 0f00 	cmp.w	r8, #0
   d56f4:	d148      	bne.n	d5788 <_Z7syncFTP6StringbS_i+0x350>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d56f6:	4921      	ldr	r1, [pc, #132]	; (d577c <_Z7syncFTP6StringbS_i+0x344>)
   d56f8:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d56fc:	f006 ff59 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("could not find : " + DestFilename, 4);
   d5700:	f107 010c 	add.w	r1, r7, #12
   d5704:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5708:	f007 f82e 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d570c:	4601      	mov	r1, r0
   d570e:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5712:	f006 ff70 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5716:	2104      	movs	r1, #4
   d5718:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d571c:	f7ff fc86 	bl	d502c <_Z3log6Stringi>
   d5720:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5724:	f006 fefe 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5728:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d572c:	f006 fefa 	bl	dc524 <_ZN6StringD1Ev>
   d5730:	e030      	b.n	d5794 <_Z7syncFTP6StringbS_i+0x35c>
   d5732:	bf00      	nop
   d5734:	000e1eea 	.word	0x000e1eea
   d5738:	2003d6f4 	.word	0x2003d6f4
   d573c:	2003d7bc 	.word	0x2003d7bc
   d5740:	2003da3c 	.word	0x2003da3c
   d5744:	2003dd48 	.word	0x2003dd48
   d5748:	000e1c38 	.word	0x000e1c38
   d574c:	2003df40 	.word	0x2003df40
   d5750:	000e1c4d 	.word	0x000e1c4d
   d5754:	2003df54 	.word	0x2003df54
   d5758:	000e1c5e 	.word	0x000e1c5e
   d575c:	000e1c6f 	.word	0x000e1c6f
   d5760:	000e1c87 	.word	0x000e1c87
   d5764:	000e1c9a 	.word	0x000e1c9a
   d5768:	000e1cae 	.word	0x000e1cae
   d576c:	000e1cba 	.word	0x000e1cba
   d5770:	000e1cc7 	.word	0x000e1cc7
   d5774:	000e1ccc 	.word	0x000e1ccc
   d5778:	000e1cd3 	.word	0x000e1cd3
   d577c:	000e1ce5 	.word	0x000e1ce5
   d5780:	2003debc 	.word	0x2003debc
   d5784:	2003dea4 	.word	0x2003dea4
  } else {
      ftp.data.flush();
   d5788:	48a7      	ldr	r0, [pc, #668]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d578a:	f008 fe51 	bl	de430 <_ZN9TCPClient5flushEv>
      ftp.finish();
   d578e:	48a6      	ldr	r0, [pc, #664]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d5790:	f005 f85a 	bl	da848 <_ZN17particleftpclient17ParticleFtpClient6finishEv>
  }

  // Si le dernier transfert  chou, tenter de supprimer le fichier avort
  if(retry == true) {
   d5794:	f1ba 0f00 	cmp.w	sl, #0
   d5798:	d02e      	beq.n	d57f8 <_Z7syncFTP6StringbS_i+0x3c0>
    if(!ftp.dele(DestFilename)){
   d579a:	f107 010c 	add.w	r1, r7, #12
   d579e:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57a2:	f006 ff28 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d57a6:	f107 016c 	add.w	r1, r7, #108	; 0x6c
   d57aa:	489f      	ldr	r0, [pc, #636]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d57ac:	f005 f916 	bl	da9dc <_ZN17particleftpclient17ParticleFtpClient4deleE6String>
   d57b0:	4680      	mov	r8, r0
   d57b2:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57b6:	f006 feb5 	bl	dc524 <_ZN6StringD1Ev>
   d57ba:	f1b8 0f00 	cmp.w	r8, #0
   d57be:	d10d      	bne.n	d57dc <_Z7syncFTP6StringbS_i+0x3a4>
      log("could not delete file", 2);
   d57c0:	499a      	ldr	r1, [pc, #616]	; (d5a2c <_Z7syncFTP6StringbS_i+0x5f4>)
   d57c2:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57c6:	f006 fef4 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d57ca:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57ce:	2102      	movs	r1, #2
   d57d0:	f7ff fc2c 	bl	d502c <_Z3log6Stringi>
   d57d4:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57d8:	f006 fea4 	bl	dc524 <_ZN6StringD1Ev>
    }
    log("Fd", 4);
   d57dc:	4994      	ldr	r1, [pc, #592]	; (d5a30 <_Z7syncFTP6StringbS_i+0x5f8>)
   d57de:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57e2:	f006 fee6 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d57e6:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57ea:	2104      	movs	r1, #4
   d57ec:	f7ff fc1e 	bl	d502c <_Z3log6Stringi>
   d57f0:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d57f4:	f006 fe96 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d57f8:	498e      	ldr	r1, [pc, #568]	; (d5a34 <_Z7syncFTP6StringbS_i+0x5fc>)
   d57fa:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d57fe:	f006 fed8 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  }

  //On ouvre le fichier dans la carte SD, si l'opration russie, initier le transfert
  log("Tfile: " + DestFilename + " SD:" +  SDfilename, 4);
   d5802:	f107 010c 	add.w	r1, r7, #12
   d5806:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d580a:	f006 ffad 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d580e:	498a      	ldr	r1, [pc, #552]	; (d5a38 <_Z7syncFTP6StringbS_i+0x600>)
   d5810:	f006 ffb6 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5814:	4621      	mov	r1, r4
   d5816:	f006 ffa7 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d581a:	4601      	mov	r1, r0
   d581c:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5820:	f006 fee9 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5824:	2104      	movs	r1, #4
   d5826:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d582a:	f7ff fbff 	bl	d502c <_Z3log6Stringi>
   d582e:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5832:	f006 fe77 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5836:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d583a:	f006 fe73 	bl	dc524 <_ZN6StringD1Ev>
   d583e:	2301      	movs	r3, #1
   d5840:	6822      	ldr	r2, [r4, #0]
   d5842:	497e      	ldr	r1, [pc, #504]	; (d5a3c <_Z7syncFTP6StringbS_i+0x604>)
   d5844:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5848:	f005 fe4c 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
  File SDfile = SD.open(SDfilename);
  delay(100);
   d584c:	2064      	movs	r0, #100	; 0x64
   d584e:	f007 fc75 	bl	dd13c <delay>
  if (SDfile) {
   d5852:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5856:	f004 ff63 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d585a:	2800      	cmp	r0, #0
   d585c:	d06b      	beq.n	d5936 <_Z7syncFTP6StringbS_i+0x4fe>
    if(Ttype == 0 || Ttype == 2 ) {
   d585e:	f036 0302 	bics.w	r3, r6, #2
      }
        
    SDfile.close(); // On ferme notre fichier
    transferTime = millis() - previousMillis;
    log("TT " + String(transferTime/1000) + " " + String(len/(transferTime/1000)) + " Bps, retries: " + String(retries), 4);
    Particle.process(); //On donne signe de vie au cloud
   d5862:	46e8      	mov	r8, sp
  //On ouvre le fichier dans la carte SD, si l'opration russie, initier le transfert
  log("Tfile: " + DestFilename + " SD:" +  SDfilename, 4);
  File SDfile = SD.open(SDfilename);
  delay(100);
  if (SDfile) {
    if(Ttype == 0 || Ttype == 2 ) {
   d5864:	d101      	bne.n	d586a <_Z7syncFTP6StringbS_i+0x432>
      if (!ftp.type("I")) { //Si image mettre type "I" pour binary transfer
   d5866:	4976      	ldr	r1, [pc, #472]	; (d5a40 <_Z7syncFTP6StringbS_i+0x608>)
   d5868:	e002      	b.n	d5870 <_Z7syncFTP6StringbS_i+0x438>
        //log("Couldn't STOR file: " + DestFilename, 2,1);
        SDfile.close();
        printNclearSDlogBuffer();
        return 0;
      }
    } else if (Ttype == 1) {
   d586a:	2e01      	cmp	r6, #1
   d586c:	d127      	bne.n	d58be <_Z7syncFTP6StringbS_i+0x486>
        if (!ftp.type("A")) { //Si log, utiliser le type "A" pour transfert standard
   d586e:	4975      	ldr	r1, [pc, #468]	; (d5a44 <_Z7syncFTP6StringbS_i+0x60c>)
   d5870:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5874:	f006 fe9d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5878:	f107 015c 	add.w	r1, r7, #92	; 0x5c
   d587c:	486a      	ldr	r0, [pc, #424]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d587e:	f005 f88b 	bl	da998 <_ZN17particleftpclient17ParticleFtpClient4typeE6String>
   d5882:	4604      	mov	r4, r0
   d5884:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5888:	f006 fe4c 	bl	dc524 <_ZN6StringD1Ev>
   d588c:	b1bc      	cbz	r4, d58be <_Z7syncFTP6StringbS_i+0x486>
  delay(100);
  if (SDfile) {
    if(Ttype == 0 || Ttype == 2 ) {
      if (!ftp.type("I")) { //Si image mettre type "I" pour binary transfer
        //log("Couldn't set file type", 2,1);
      } else if (!ftp.stor(DestFilename)) {
   d588e:	f107 010c 	add.w	r1, r7, #12
   d5892:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5896:	f006 feae 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d589a:	f107 015c 	add.w	r1, r7, #92	; 0x5c
   d589e:	4862      	ldr	r0, [pc, #392]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d58a0:	f005 f9a6 	bl	dabf0 <_ZN17particleftpclient17ParticleFtpClient4storE6String>
   d58a4:	4604      	mov	r4, r0
   d58a6:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d58aa:	f006 fe3b 	bl	dc524 <_ZN6StringD1Ev>
   d58ae:	b934      	cbnz	r4, d58be <_Z7syncFTP6StringbS_i+0x486>
        //log("Couldn't STOR file: " + DestFilename, 2,1);
        SDfile.close();
   d58b0:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d58b4:	f004 ff28 	bl	da708 <_ZN5SDLib4File5closeEv>
        printNclearSDlogBuffer();
   d58b8:	f7ff fd16 	bl	d52e8 <_Z22printNclearSDlogBufferv>
        return 0;
   d58bc:	e039      	b.n	d5932 <_Z7syncFTP6StringbS_i+0x4fa>
        return 0;
      }  
    }

    //Vrifier la taille du fichier, 524287 bytes est trop gros, 0 indique un fichier vide
    len = SDfile.size();
   d58be:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d58c2:	f004 ff0a 	bl	da6da <_ZN5SDLib4File4sizeEv>
    if (len >= 0x07ffff) {
        //log("Over size file.", 2,1);
        SDfile.close();
        printNclearSDlogBuffer();
        return 0;
      } else if (len == 0 ){
   d58c6:	4b60      	ldr	r3, [pc, #384]	; (d5a48 <_Z7syncFTP6StringbS_i+0x610>)
   d58c8:	1e42      	subs	r2, r0, #1
   d58ca:	429a      	cmp	r2, r3
        return 0;
      }  
    }

    //Vrifier la taille du fichier, 524287 bytes est trop gros, 0 indique un fichier vide
    len = SDfile.size();
   d58cc:	4606      	mov	r6, r0
    if (len >= 0x07ffff) {
        //log("Over size file.", 2,1);
        SDfile.close();
        printNclearSDlogBuffer();
        return 0;
      } else if (len == 0 ){
   d58ce:	d8ef      	bhi.n	d58b0 <_Z7syncFTP6StringbS_i+0x478>

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   d58d0:	f005 ff80 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
    unsigned long previousMillis = millis();
    unsigned long transferTime = 0;
    int ClientTries = 10;
    //char buf;
    int bufsize = 256;
    uint8_t buf[bufsize];
   d58d4:	b0c0      	sub	sp, #256	; 0x100
   d58d6:	4604      	mov	r4, r0
    static bool connected(void) { return spark_cloud_flag_connected(); }
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
   d58d8:	f006 fa2e 	bl	dbd38 <spark_cloud_flag_disconnect>
        }
        digitalWrite(statusLed, HIGH);
        bytesRead = 0;
        delay(200); //
        // Si on dpasse 600000 bytes, il y a un problme...
        if (TotbytesRead > 200000) {
   d58dc:	f8df b180 	ldr.w	fp, [pc, #384]	; d5a60 <_Z7syncFTP6StringbS_i+0x628>
    unsigned long previousMillis = millis();
    unsigned long transferTime = 0;
    int ClientTries = 10;
    //char buf;
    int bufsize = 256;
    uint8_t buf[bufsize];
   d58e0:	f10d 0a08 	add.w	sl, sp, #8
        return 0;
      } 

    //Variables temporaires pour la gestion du transfert
    int bytesRead = 0;
    int TotbytesRead = 0;
   d58e4:	f04f 0900 	mov.w	r9, #0
    long retries = 0;
    int writeerror = 0;

    //Tant que le fichier n'est pas vide
    Particle.disconnect();
    while(SDfile.available() && TotbytesRead <= len) { 
   d58e8:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d58ec:	f004 fef9 	bl	da6e2 <_ZN5SDLib4File9availableEv>
   d58f0:	b318      	cbz	r0, d593a <_Z7syncFTP6StringbS_i+0x502>
   d58f2:	454e      	cmp	r6, r9
   d58f4:	d321      	bcc.n	d593a <_Z7syncFTP6StringbS_i+0x502>
      bytesRead += SDfile.read(buf,bufsize);
   d58f6:	f44f 7280 	mov.w	r2, #256	; 0x100
   d58fa:	4651      	mov	r1, sl
   d58fc:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d5900:	f004 fede 	bl	da6c0 <_ZN5SDLib4File4readEPvt>
      TotbytesRead += bytesRead;
   d5904:	4481      	add	r9, r0
   d5906:	6078      	str	r0, [r7, #4]
      wd.checkin();
   d5908:	f7ff fa70 	bl	d4dec <_ZN19ApplicationWatchdog7checkinEv>
      // Quand l'incrment est rendu au max, on transfre le contenu du buffer vers 
      // le site ftp, On fait scintiller la Led pour indiquer le transfert en cours
        digitalWrite(statusLed, LOW);
   d590c:	2100      	movs	r1, #0
   d590e:	2007      	movs	r0, #7
   d5910:	f009 f91f 	bl	deb52 <digitalWrite>
        bytesWritten = ftp.data.write(buf,bytesRead,0);
   d5914:	2300      	movs	r3, #0
   d5916:	687a      	ldr	r2, [r7, #4]
   d5918:	4843      	ldr	r0, [pc, #268]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d591a:	4651      	mov	r1, sl
   d591c:	f008 fdb6 	bl	de48c <_ZN9TCPClient5writeEPKhjm>
              }
              return 0;
            }
          }
        }
        digitalWrite(statusLed, HIGH);
   d5920:	2101      	movs	r1, #1
   d5922:	2007      	movs	r0, #7
   d5924:	f009 f915 	bl	deb52 <digitalWrite>
        bytesRead = 0;
        delay(200); //
   d5928:	20c8      	movs	r0, #200	; 0xc8
   d592a:	f007 fc07 	bl	dd13c <delay>
        // Si on dpasse 600000 bytes, il y a un problme...
        if (TotbytesRead > 200000) {
   d592e:	45d9      	cmp	r9, fp
   d5930:	ddda      	ble.n	d58e8 <_Z7syncFTP6StringbS_i+0x4b0>
        //log("Couldn't set file type", 2,1);
      } else if (!ftp.stor(DestFilename)) {
        //log("Couldn't STOR file: " + DestFilename, 2,1);
        SDfile.close();
        printNclearSDlogBuffer();
        return 0;
   d5932:	46c5      	mov	sp, r8
   d5934:	e071      	b.n	d5a1a <_Z7syncFTP6StringbS_i+0x5e2>
    log("TT " + String(transferTime/1000) + " " + String(len/(transferTime/1000)) + " Bps, retries: " + String(retries), 4);
    Particle.process(); //On donne signe de vie au cloud
    //printNclearSDlogBuffer();
  } else {
    // Si nous n'avons pas pu ouvrir le fichier
    log("Could not open File on SD... Aborting", 2);
   d5936:	4945      	ldr	r1, [pc, #276]	; (d5a4c <_Z7syncFTP6StringbS_i+0x614>)
   d5938:	e063      	b.n	d5a02 <_Z7syncFTP6StringbS_i+0x5ca>
        if (TotbytesRead > 200000) {
            return 0;
        }     
      }
        
    SDfile.close(); // On ferme notre fichier
   d593a:	f107 006c 	add.w	r0, r7, #108	; 0x6c
   d593e:	f004 fee3 	bl	da708 <_ZN5SDLib4File5closeEv>
   d5942:	f005 ff47 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5946:	4942      	ldr	r1, [pc, #264]	; (d5a50 <_Z7syncFTP6StringbS_i+0x618>)
    transferTime = millis() - previousMillis;
   d5948:	1b04      	subs	r4, r0, r4
   d594a:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   d594e:	f006 fe30 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("TT " + String(transferTime/1000) + " " + String(len/(transferTime/1000)) + " Bps, retries: " + String(retries), 4);
   d5952:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   d5956:	220a      	movs	r2, #10
   d5958:	fbb4 f4f3 	udiv	r4, r4, r3
   d595c:	f107 001c 	add.w	r0, r7, #28
   d5960:	4621      	mov	r1, r4
   d5962:	f006 fe9c 	bl	dc69e <_ZN6StringC1Emh>
   d5966:	f107 011c 	add.w	r1, r7, #28
   d596a:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   d596e:	f006 fefb 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5972:	4938      	ldr	r1, [pc, #224]	; (d5a54 <_Z7syncFTP6StringbS_i+0x61c>)
   d5974:	f006 ff04 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5978:	fbb6 f1f4 	udiv	r1, r6, r4
   d597c:	220a      	movs	r2, #10
   d597e:	4681      	mov	r9, r0
   d5980:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d5984:	f006 fe8b 	bl	dc69e <_ZN6StringC1Emh>
   d5988:	f107 013c 	add.w	r1, r7, #60	; 0x3c
   d598c:	4648      	mov	r0, r9
   d598e:	f006 feeb 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5992:	4931      	ldr	r1, [pc, #196]	; (d5a58 <_Z7syncFTP6StringbS_i+0x620>)
   d5994:	f006 fef4 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5998:	220a      	movs	r2, #10
   d599a:	4604      	mov	r4, r0
   d599c:	2100      	movs	r1, #0
   d599e:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d59a2:	f006 fe69 	bl	dc678 <_ZN6StringC1Elh>
   d59a6:	f107 014c 	add.w	r1, r7, #76	; 0x4c
   d59aa:	4620      	mov	r0, r4
   d59ac:	f006 fedc 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d59b0:	4601      	mov	r1, r0
   d59b2:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d59b6:	f006 fe1e 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d59ba:	2104      	movs	r1, #4
   d59bc:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d59c0:	f7ff fb34 	bl	d502c <_Z3log6Stringi>
   d59c4:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d59c8:	f006 fdac 	bl	dc524 <_ZN6StringD1Ev>
   d59cc:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d59d0:	f006 fda8 	bl	dc524 <_ZN6StringD1Ev>
   d59d4:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d59d8:	f006 fda4 	bl	dc524 <_ZN6StringD1Ev>
   d59dc:	f107 001c 	add.w	r0, r7, #28
   d59e0:	f006 fda0 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d59e4:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   d59e8:	f006 fd9c 	bl	dc524 <_ZN6StringD1Ev>
    Particle.process(); //On donne signe de vie au cloud
   d59ec:	f7ff fa5c 	bl	d4ea8 <_ZN10CloudClass7processEv>
    log("Could not open File on SD... Aborting", 2);
    return 0;
    }

    //On ferme le transfert, vide le contenu du port ftp et quitte la connexion 
    ftp.data.flush();
   d59f0:	480d      	ldr	r0, [pc, #52]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d59f2:	46c5      	mov	sp, r8
   d59f4:	f008 fd1c 	bl	de430 <_ZN9TCPClient5flushEv>
  if (!ftp.finish()) {
   d59f8:	480b      	ldr	r0, [pc, #44]	; (d5a28 <_Z7syncFTP6StringbS_i+0x5f0>)
   d59fa:	f004 ff25 	bl	da848 <_ZN17particleftpclient17ParticleFtpClient6finishEv>
   d59fe:	bb88      	cbnz	r0, d5a64 <_Z7syncFTP6StringbS_i+0x62c>
    log("Couldn't stop file upload", 2);
   d5a00:	4916      	ldr	r1, [pc, #88]	; (d5a5c <_Z7syncFTP6StringbS_i+0x624>)
   d5a02:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5a06:	f006 fdd4 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5a0a:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5a0e:	2102      	movs	r1, #2
   d5a10:	f7ff fb0c 	bl	d502c <_Z3log6Stringi>
   d5a14:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5a18:	e584      	b.n	d5524 <_Z7syncFTP6StringbS_i+0xec>
  uint32_t len = 0;

  // Connection  l'hte FTP avec les infos fournies
  if (!ftp.open(config.ftp_hostname, port, timeout)) {
    log("Couldn't connect to " + String(config.ftp_hostname), 2);
    return 0;
   d5a1a:	f107 000c 	add.w	r0, r7, #12
   d5a1e:	f006 fd81 	bl	dc524 <_ZN6StringD1Ev>
   d5a22:	2000      	movs	r0, #0
   d5a24:	e09c      	b.n	d5b60 <_Z7syncFTP6StringbS_i+0x728>
   d5a26:	bf00      	nop
   d5a28:	2003dd48 	.word	0x2003dd48
   d5a2c:	000e1cf7 	.word	0x000e1cf7
   d5a30:	000e1d0d 	.word	0x000e1d0d
   d5a34:	000e1d10 	.word	0x000e1d10
   d5a38:	000e1d18 	.word	0x000e1d18
   d5a3c:	2003e3d4 	.word	0x2003e3d4
   d5a40:	000e2162 	.word	0x000e2162
   d5a44:	000e1d1d 	.word	0x000e1d1d
   d5a48:	0007fffd 	.word	0x0007fffd
   d5a4c:	000e1d1f 	.word	0x000e1d1f
   d5a50:	000e1d9b 	.word	0x000e1d9b
   d5a54:	000e20f1 	.word	0x000e20f1
   d5a58:	000e1d9f 	.word	0x000e1d9f
   d5a5c:	000e1d45 	.word	0x000e1d45
   d5a60:	00030d40 	.word	0x00030d40
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5a64:	4940      	ldr	r1, [pc, #256]	; (d5b68 <_Z7syncFTP6StringbS_i+0x730>)
   d5a66:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5a6a:	f006 fda2 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d5a6e:	4629      	mov	r1, r5
   d5a70:	f107 001c 	add.w	r0, r7, #28
   d5a74:	f006 fdbf 	bl	dc5f6 <_ZN6StringC1ERKS_>
  if (!ftp.finish()) {
    log("Couldn't stop file upload", 2);
    return 0;
  }

    log("File size on server : " + String(ftp.size(dir + "/" + DestFilename)), 4);
   d5a78:	493c      	ldr	r1, [pc, #240]	; (d5b6c <_Z7syncFTP6StringbS_i+0x734>)
   d5a7a:	f107 001c 	add.w	r0, r7, #28
   d5a7e:	f006 fe7f 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5a82:	f107 010c 	add.w	r1, r7, #12
   d5a86:	f006 fe6f 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5a8a:	4601      	mov	r1, r0
   d5a8c:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   d5a90:	f006 fdb1 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5a94:	f107 012c 	add.w	r1, r7, #44	; 0x2c
   d5a98:	4835      	ldr	r0, [pc, #212]	; (d5b70 <_Z7syncFTP6StringbS_i+0x738>)
   d5a9a:	f004 feaf 	bl	da7fc <_ZN17particleftpclient17ParticleFtpClient4sizeE6String>
   d5a9e:	220a      	movs	r2, #10
   d5aa0:	4601      	mov	r1, r0
   d5aa2:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d5aa6:	f006 fdd4 	bl	dc652 <_ZN6StringC1Eih>
   d5aaa:	f107 013c 	add.w	r1, r7, #60	; 0x3c
   d5aae:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5ab2:	f006 fe59 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5ab6:	4601      	mov	r1, r0
   d5ab8:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5abc:	f006 fd9b 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5ac0:	2104      	movs	r1, #4
   d5ac2:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5ac6:	f7ff fab1 	bl	d502c <_Z3log6Stringi>
   d5aca:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5ace:	f006 fd29 	bl	dc524 <_ZN6StringD1Ev>
   d5ad2:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d5ad6:	f006 fd25 	bl	dc524 <_ZN6StringD1Ev>
   d5ada:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   d5ade:	f006 fd21 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5ae2:	f107 001c 	add.w	r0, r7, #28
   d5ae6:	f006 fd1d 	bl	dc524 <_ZN6StringD1Ev>
   d5aea:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5aee:	f006 fd19 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5af2:	4920      	ldr	r1, [pc, #128]	; (d5b74 <_Z7syncFTP6StringbS_i+0x73c>)
   d5af4:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5af8:	f006 fd5b 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("Local file size : " + String(len), 4);
   d5afc:	220a      	movs	r2, #10
   d5afe:	4631      	mov	r1, r6
   d5b00:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d5b04:	f006 fdcb 	bl	dc69e <_ZN6StringC1Emh>
   d5b08:	f107 013c 	add.w	r1, r7, #60	; 0x3c
   d5b0c:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5b10:	f006 fe2a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5b14:	4601      	mov	r1, r0
   d5b16:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5b1a:	f006 fd6c 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5b1e:	2104      	movs	r1, #4
   d5b20:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5b24:	f7ff fa82 	bl	d502c <_Z3log6Stringi>
   d5b28:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   d5b2c:	f006 fcfa 	bl	dc524 <_ZN6StringD1Ev>
   d5b30:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   d5b34:	f006 fcf6 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5b38:	f107 004c 	add.w	r0, r7, #76	; 0x4c
   d5b3c:	f006 fcf2 	bl	dc524 <_ZN6StringD1Ev>
      
  if (!ftp.quit()) {
   d5b40:	480b      	ldr	r0, [pc, #44]	; (d5b70 <_Z7syncFTP6StringbS_i+0x738>)
   d5b42:	f004 ff6d 	bl	daa20 <_ZN17particleftpclient17ParticleFtpClient4quitEv>
   d5b46:	b908      	cbnz	r0, d5b4c <_Z7syncFTP6StringbS_i+0x714>
    log("Couldn't quit FTP", 2);
   d5b48:	490b      	ldr	r1, [pc, #44]	; (d5b78 <_Z7syncFTP6StringbS_i+0x740>)
   d5b4a:	e75a      	b.n	d5a02 <_Z7syncFTP6StringbS_i+0x5ca>
    return 0;
  } else {
    digitalWrite(statusLed, LOW);
   d5b4c:	2007      	movs	r0, #7
   d5b4e:	2100      	movs	r1, #0
   d5b50:	f008 ffff 	bl	deb52 <digitalWrite>
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
   d5b54:	f006 f8e8 	bl	dbd28 <spark_cloud_flag_connect>
bool syncFTP(String SDfilename, bool retry, String dir, int Ttype) { 
  
  //Dclaration de variable temporaire
  static const size_t bufferSize = 256;// grosseur des blocs de donnes  envoyer 
  static uint8_t buffer[bufferSize] = {0xFF}; //Terminer le bloc par un 0xFF
  String DestFilename = "";
   d5b58:	f107 000c 	add.w	r0, r7, #12
   d5b5c:	f006 fce2 	bl	dc524 <_ZN6StringD1Ev>
    return 0;
  } else {
    digitalWrite(statusLed, LOW);
  }
  Particle.connect();
}
   d5b60:	37fc      	adds	r7, #252	; 0xfc
   d5b62:	46bd      	mov	sp, r7
   d5b64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d5b68:	000e1d5f 	.word	0x000e1d5f
   d5b6c:	000e1afd 	.word	0x000e1afd
   d5b70:	2003dd48 	.word	0x2003dd48
   d5b74:	000e1d76 	.word	0x000e1d76
   d5b78:	000e1d89 	.word	0x000e1d89

000d5b7c <_Z9softDelaym>:
  softDelay(5000); // Step through the process safely to ensure the lowest Modem Power.
  System.sleep(SS_Button, FALLING, TbeforeWake);
  softDelay(1000);
}

inline void softDelay(uint32_t t) {
   d5b7c:	b538      	push	{r3, r4, r5, lr}
   d5b7e:	4605      	mov	r5, r0
   d5b80:	f005 fe28 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
   d5b84:	4604      	mov	r4, r0
   d5b86:	f005 fe25 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
  for (uint32_t ms = millis(); millis() - ms < t; Particle.process());  //  safer than a delay()
   d5b8a:	1b00      	subs	r0, r0, r4
   d5b8c:	42a8      	cmp	r0, r5
   d5b8e:	d202      	bcs.n	d5b96 <_Z9softDelaym+0x1a>
   d5b90:	f7ff f98a 	bl	d4ea8 <_ZN10CloudClass7processEv>
   d5b94:	e7f7      	b.n	d5b86 <_Z9softDelaym+0xa>
   d5b96:	bd38      	pop	{r3, r4, r5, pc}

000d5b98 <_Z9goToSleepl>:

/* 
* GoToSleep, squence qui minimise la consommation de courant entre les photos
* V1.2 2020-03-18, ajout de BLE.off()
*/
void goToSleep(long TbeforeWake) {
   d5b98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  digitalWrite(statusLed, LOW);
   d5b9a:	2100      	movs	r1, #0

/* 
* GoToSleep, squence qui minimise la consommation de courant entre les photos
* V1.2 2020-03-18, ajout de BLE.off()
*/
void goToSleep(long TbeforeWake) {
   d5b9c:	4604      	mov	r4, r0
  digitalWrite(statusLed, LOW);
   d5b9e:	2007      	movs	r0, #7
   d5ba0:	f008 ffd7 	bl	deb52 <digitalWrite>
  fuel.sleep();
   d5ba4:	4814      	ldr	r0, [pc, #80]	; (d5bf8 <_Z9goToSleepl+0x60>)
   d5ba6:	f007 fccb 	bl	dd540 <_ZN9FuelGauge5sleepEv>
  SD.end();
   d5baa:	4814      	ldr	r0, [pc, #80]	; (d5bfc <_Z9goToSleepl+0x64>)
   d5bac:	f005 fc1c 	bl	db3e8 <_ZN5SDLib7SDClass3endEv>
  BLE.off();
   d5bb0:	f006 fef4 	bl	dc99c <_ZN8particle14BleLocalDevice11getInstanceEv>
   d5bb4:	f006 ffb2 	bl	dcb1c <_ZNK8particle14BleLocalDevice3offEv>
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
   d5bb8:	f006 f8be 	bl	dbd38 <spark_cloud_flag_disconnect>
  Particle.disconnect();
  softDelay(5000);
   d5bbc:	f241 3088 	movw	r0, #5000	; 0x1388
   d5bc0:	f7ff ffdc 	bl	d5b7c <_Z9softDelaym>
  Cellular.off();
   d5bc4:	480e      	ldr	r0, [pc, #56]	; (d5c00 <_Z9goToSleepl+0x68>)
   d5bc6:	f7ff f873 	bl	d4cb0 <_ZN5spark13CellularClass3offEv>
  pmic.disableBuck();
   d5bca:	480e      	ldr	r0, [pc, #56]	; (d5c04 <_Z9goToSleepl+0x6c>)
   d5bcc:	f006 f9c5 	bl	dbf5a <_ZN4PMIC11disableBuckEv>
  softDelay(5000); // Step through the process safely to ensure the lowest Modem Power.
   d5bd0:	f241 3088 	movw	r0, #5000	; 0x1388
   d5bd4:	f7ff ffd2 	bl	d5b7c <_Z9softDelaym>
   d5bd8:	4b0b      	ldr	r3, [pc, #44]	; (d5c08 <_Z9goToSleepl+0x70>)
   d5bda:	681b      	ldr	r3, [r3, #0]
  System.sleep(SS_Button, FALLING, TbeforeWake);
   d5bdc:	9300      	str	r3, [sp, #0]
   d5bde:	2202      	movs	r2, #2
   d5be0:	4623      	mov	r3, r4
   d5be2:	2106      	movs	r1, #6
   d5be4:	a802      	add	r0, sp, #8
   d5be6:	f7ff f8ab 	bl	d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>
  softDelay(1000);
   d5bea:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d5bee:	f7ff ffc5 	bl	d5b7c <_Z9softDelaym>
}
   d5bf2:	b004      	add	sp, #16
   d5bf4:	bd10      	pop	{r4, pc}
   d5bf6:	bf00      	nop
   d5bf8:	2003deb4 	.word	0x2003deb4
   d5bfc:	2003e3d4 	.word	0x2003e3d4
   d5c00:	2003e4c0 	.word	0x2003e4c0
   d5c04:	2003df2c 	.word	0x2003df2c
   d5c08:	2003e2a8 	.word	0x2003e2a8

000d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
   d5c0c:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
   d5c0e:	6804      	ldr	r4, [r0, #0]
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
   d5c10:	4605      	mov	r5, r0
      {
	if (_M_pi != nullptr)
   d5c12:	b17c      	cbz	r4, d5c34 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   d5c14:	6863      	ldr	r3, [r4, #4]
   d5c16:	3b01      	subs	r3, #1
   d5c18:	6063      	str	r3, [r4, #4]
   d5c1a:	b95b      	cbnz	r3, d5c34 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
        {
          _M_dispose();
   d5c1c:	6823      	ldr	r3, [r4, #0]
   d5c1e:	4620      	mov	r0, r4
   d5c20:	689b      	ldr	r3, [r3, #8]
   d5c22:	4798      	blx	r3
          if (--_M_weak_count == 0)
   d5c24:	68a3      	ldr	r3, [r4, #8]
   d5c26:	3b01      	subs	r3, #1
   d5c28:	60a3      	str	r3, [r4, #8]
   d5c2a:	b91b      	cbnz	r3, d5c34 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
   d5c2c:	6823      	ldr	r3, [r4, #0]
   d5c2e:	4620      	mov	r0, r4
   d5c30:	68db      	ldr	r3, [r3, #12]
   d5c32:	4798      	blx	r3

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
   d5c34:	4628      	mov	r0, r5
   d5c36:	bd38      	pop	{r3, r4, r5, pc}

000d5c38 <_Z7cleanSD6String>:

/* 
* Fonction concierge pour viter le trop plein de donnes
*
*/
int cleanSD(String Dummy) {
   d5c38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   d5c3c:	b0b2      	sub	sp, #200	; 0xc8
  int FolderRmvd = 0;
  int FileRmvd = 0;
  Particle.publish("status", "Cleaning old photos on SD...");
   d5c3e:	4a6b      	ldr	r2, [pc, #428]	; (d5dec <_Z7cleanSD6String+0x1b4>)
   d5c40:	496b      	ldr	r1, [pc, #428]	; (d5df0 <_Z7cleanSD6String+0x1b8>)
   d5c42:	a829      	add	r0, sp, #164	; 0xa4
   d5c44:	f7ff f818 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   d5c48:	a82a      	add	r0, sp, #168	; 0xa8
   d5c4a:	f7ff ffdf 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
  log("clSD", 4);
   d5c4e:	4969      	ldr	r1, [pc, #420]	; (d5df4 <_Z7cleanSD6String+0x1bc>)
   d5c50:	a829      	add	r0, sp, #164	; 0xa4
   d5c52:	f006 fcae 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5c56:	2104      	movs	r1, #4
   d5c58:	a829      	add	r0, sp, #164	; 0xa4
   d5c5a:	f7ff f9e7 	bl	d502c <_Z3log6Stringi>
   d5c5e:	a829      	add	r0, sp, #164	; 0xa4
   d5c60:	f006 fc60 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d5c64:	4964      	ldr	r1, [pc, #400]	; (d5df8 <_Z7cleanSD6String+0x1c0>)
   d5c66:	a829      	add	r0, sp, #164	; 0xa4
   d5c68:	f006 fcc5 	bl	dc5f6 <_ZN6StringC1ERKS_>
  File root = SD.open(stationName + "/");
   d5c6c:	4963      	ldr	r1, [pc, #396]	; (d5dfc <_Z7cleanSD6String+0x1c4>)
   d5c6e:	a829      	add	r0, sp, #164	; 0xa4
   d5c70:	f006 fd86 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5c74:	2301      	movs	r3, #1
   d5c76:	6802      	ldr	r2, [r0, #0]
   d5c78:	4961      	ldr	r1, [pc, #388]	; (d5e00 <_Z7cleanSD6String+0x1c8>)
   d5c7a:	a805      	add	r0, sp, #20
   d5c7c:	f005 fc32 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5c80:	a829      	add	r0, sp, #164	; 0xa4
   d5c82:	f006 fc4f 	bl	dc524 <_ZN6StringD1Ev>
  File entry = root.openNextFile();
   d5c86:	2201      	movs	r2, #1
   d5c88:	a905      	add	r1, sp, #20
   d5c8a:	a80e      	add	r0, sp, #56	; 0x38
   d5c8c:	f005 fca6 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d5c90:	4b5c      	ldr	r3, [pc, #368]	; (d5e04 <_Z7cleanSD6String+0x1cc>)
  int nowyear = now.year();
   d5c92:	781f      	ldrb	r7, [r3, #0]
* Fonction concierge pour viter le trop plein de donnes
*
*/
int cleanSD(String Dummy) {
  int FolderRmvd = 0;
  int FileRmvd = 0;
   d5c94:	2600      	movs	r6, #0
  Particle.publish("status", "Cleaning old photos on SD...");
  log("clSD", 4);
  File root = SD.open(stationName + "/");
  File entry = root.openNextFile();
  int nowyear = now.year();
   d5c96:	f507 67fa 	add.w	r7, r7, #2000	; 0x7d0
/* 
* Fonction concierge pour viter le trop plein de donnes
*
*/
int cleanSD(String Dummy) {
  int FolderRmvd = 0;
   d5c9a:	4635      	mov	r5, r6
  log("clSD", 4);
  File root = SD.open(stationName + "/");
  File entry = root.openNextFile();
  int nowyear = now.year();

  while (entry) {
   d5c9c:	a80e      	add	r0, sp, #56	; 0x38
   d5c9e:	f004 fd3f 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d5ca2:	4604      	mov	r4, r0
   d5ca4:	2800      	cmp	r0, #0
   d5ca6:	f000 80af 	beq.w	d5e08 <_Z7cleanSD6String+0x1d0>
    String entryname = entry.name();
   d5caa:	a80e      	add	r0, sp, #56	; 0x38
   d5cac:	f004 fcfe 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5cb0:	4601      	mov	r1, r0
   d5cb2:	a801      	add	r0, sp, #4
   d5cb4:	f006 fc7d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    Serial.println(String(entryname.toInt()));
   d5cb8:	f008 f8f2 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5cbc:	4604      	mov	r4, r0
   d5cbe:	a801      	add	r0, sp, #4
   d5cc0:	f006 fd97 	bl	dc7f2 <_ZNK6String5toIntEv>
   d5cc4:	220a      	movs	r2, #10
   d5cc6:	4601      	mov	r1, r0
   d5cc8:	a829      	add	r0, sp, #164	; 0xa4
   d5cca:	f006 fcd5 	bl	dc678 <_ZN6StringC1Elh>
   d5cce:	9929      	ldr	r1, [sp, #164]	; 0xa4
   d5cd0:	4620      	mov	r0, r4
   d5cd2:	f007 f8ca 	bl	dce6a <_ZN5Print7printlnEPKc>
   d5cd6:	a829      	add	r0, sp, #164	; 0xa4
   d5cd8:	f006 fc24 	bl	dc524 <_ZN6StringD1Ev>
    if (entry.isDirectory()) {
   d5cdc:	a80e      	add	r0, sp, #56	; 0x38
   d5cde:	f004 fce7 	bl	da6b0 <_ZN5SDLib4File11isDirectoryEv>
   d5ce2:	2800      	cmp	r0, #0
   d5ce4:	d072      	beq.n	d5dcc <_Z7cleanSD6String+0x194>
      if(entryname.toInt() != nowyear && entryname.toInt() != nowyear-1){
   d5ce6:	a801      	add	r0, sp, #4
   d5ce8:	f006 fd83 	bl	dc7f2 <_ZNK6String5toIntEv>
   d5cec:	4287      	cmp	r7, r0
   d5cee:	d06d      	beq.n	d5dcc <_Z7cleanSD6String+0x194>
   d5cf0:	a801      	add	r0, sp, #4
   d5cf2:	f006 fd7e 	bl	dc7f2 <_ZNK6String5toIntEv>
   d5cf6:	1e7b      	subs	r3, r7, #1
   d5cf8:	4298      	cmp	r0, r3
   d5cfa:	f040 8155 	bne.w	d5fa8 <_Z7cleanSD6String+0x370>
   d5cfe:	e065      	b.n	d5dcc <_Z7cleanSD6String+0x194>
          File entry1 = entry.openNextFile();
          Serial.println(entry1.name());
          while(entry1){
            if(entry1.isDirectory()){
   d5d00:	a817      	add	r0, sp, #92	; 0x5c
   d5d02:	f004 fcd5 	bl	da6b0 <_ZN5SDLib4File11isDirectoryEv>
   d5d06:	2800      	cmp	r0, #0
   d5d08:	d037      	beq.n	d5d7a <_Z7cleanSD6String+0x142>
              File entry2 = entry1.openNextFile();
   d5d0a:	a917      	add	r1, sp, #92	; 0x5c
   d5d0c:	2201      	movs	r2, #1
   d5d0e:	a820      	add	r0, sp, #128	; 0x80
   d5d10:	f005 fc64 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
              Serial.println(entry2.name());
   d5d14:	f008 f8c4 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5d18:	4604      	mov	r4, r0
   d5d1a:	a820      	add	r0, sp, #128	; 0x80
   d5d1c:	f004 fcc6 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5d20:	4601      	mov	r1, r0
   d5d22:	4620      	mov	r0, r4
   d5d24:	f007 f8a1 	bl	dce6a <_ZN5Print7printlnEPKc>
              while(entry2) {
   d5d28:	a820      	add	r0, sp, #128	; 0x80
   d5d2a:	f004 fcf9 	bl	da720 <_ZN5SDLib4FilecvbEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d5d2e:	4932      	ldr	r1, [pc, #200]	; (d5df8 <_Z7cleanSD6String+0x1c0>)
   d5d30:	2800      	cmp	r0, #0
   d5d32:	f040 8149 	bne.w	d5fc8 <_Z7cleanSD6String+0x390>
   d5d36:	a829      	add	r0, sp, #164	; 0xa4
   d5d38:	f006 fc5d 	bl	dc5f6 <_ZN6StringC1ERKS_>
                    }
                entry2.close();                  
                entry2 = entry1.openNextFile();
                //Serial.println(entry2.name());
              }
              SD.rmdir(stationName + "/" + entry.name() + "/" + entry1.name());
   d5d3c:	492f      	ldr	r1, [pc, #188]	; (d5dfc <_Z7cleanSD6String+0x1c4>)
   d5d3e:	a829      	add	r0, sp, #164	; 0xa4
   d5d40:	f006 fd1e 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5d44:	4604      	mov	r4, r0
   d5d46:	a80e      	add	r0, sp, #56	; 0x38
   d5d48:	f004 fcb0 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5d4c:	4601      	mov	r1, r0
   d5d4e:	4620      	mov	r0, r4
   d5d50:	f006 fd16 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5d54:	4929      	ldr	r1, [pc, #164]	; (d5dfc <_Z7cleanSD6String+0x1c4>)
   d5d56:	f006 fd13 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5d5a:	4604      	mov	r4, r0
   d5d5c:	a817      	add	r0, sp, #92	; 0x5c
   d5d5e:	f004 fca5 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5d62:	4601      	mov	r1, r0
   d5d64:	4620      	mov	r0, r4
   d5d66:	f006 fd0b 	bl	dc780 <_ZplRK15StringSumHelperPKc>
        return remove(filepath.c_str());
      }

      bool rmdir(const char *filepath);
      bool rmdir(const String &filepath) {
        return rmdir(filepath.c_str());
   d5d6a:	6801      	ldr	r1, [r0, #0]
   d5d6c:	4824      	ldr	r0, [pc, #144]	; (d5e00 <_Z7cleanSD6String+0x1c8>)
   d5d6e:	f005 fc19 	bl	db5a4 <_ZN5SDLib7SDClass5rmdirEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5d72:	a829      	add	r0, sp, #164	; 0xa4
   d5d74:	f006 fbd6 	bl	dc524 <_ZN6StringD1Ev>
              FolderRmvd++;
   d5d78:	3501      	adds	r5, #1
            }
            entry1.close();
   d5d7a:	a817      	add	r0, sp, #92	; 0x5c
   d5d7c:	f004 fcc4 	bl	da708 <_ZN5SDLib4File5closeEv>
            entry1 = entry.openNextFile();
   d5d80:	a90e      	add	r1, sp, #56	; 0x38
   d5d82:	a829      	add	r0, sp, #164	; 0xa4
   d5d84:	2201      	movs	r2, #1
   d5d86:	f005 fc29 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d5d8a:	a929      	add	r1, sp, #164	; 0xa4
   d5d8c:	a817      	add	r0, sp, #92	; 0x5c
   d5d8e:	f7ff f937 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
    Serial.println(String(entryname.toInt()));
    if (entry.isDirectory()) {
      if(entryname.toInt() != nowyear && entryname.toInt() != nowyear-1){
          File entry1 = entry.openNextFile();
          Serial.println(entry1.name());
          while(entry1){
   d5d92:	a817      	add	r0, sp, #92	; 0x5c
   d5d94:	f004 fcc4 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d5d98:	2800      	cmp	r0, #0
   d5d9a:	d1b1      	bne.n	d5d00 <_Z7cleanSD6String+0xc8>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d5d9c:	4916      	ldr	r1, [pc, #88]	; (d5df8 <_Z7cleanSD6String+0x1c0>)
   d5d9e:	a829      	add	r0, sp, #164	; 0xa4
   d5da0:	f006 fc29 	bl	dc5f6 <_ZN6StringC1ERKS_>
            }
            entry1.close();
            entry1 = entry.openNextFile();
            //Serial.println(entry1.name());
          }
          SD.rmdir(stationName + "/" + entry.name());
   d5da4:	4915      	ldr	r1, [pc, #84]	; (d5dfc <_Z7cleanSD6String+0x1c4>)
   d5da6:	a829      	add	r0, sp, #164	; 0xa4
   d5da8:	f006 fcea 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5dac:	4604      	mov	r4, r0
   d5dae:	a80e      	add	r0, sp, #56	; 0x38
   d5db0:	f004 fc7c 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5db4:	4601      	mov	r1, r0
   d5db6:	4620      	mov	r0, r4
   d5db8:	f006 fce2 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5dbc:	6801      	ldr	r1, [r0, #0]
   d5dbe:	4810      	ldr	r0, [pc, #64]	; (d5e00 <_Z7cleanSD6String+0x1c8>)
   d5dc0:	f005 fbf0 	bl	db5a4 <_ZN5SDLib7SDClass5rmdirEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5dc4:	a829      	add	r0, sp, #164	; 0xa4
   d5dc6:	f006 fbad 	bl	dc524 <_ZN6StringD1Ev>
          FolderRmvd++;
   d5dca:	3501      	adds	r5, #1
        }
    }
    entry.close();
   d5dcc:	a80e      	add	r0, sp, #56	; 0x38
   d5dce:	f004 fc9b 	bl	da708 <_ZN5SDLib4File5closeEv>
    entry =  root.openNextFile();
   d5dd2:	2201      	movs	r2, #1
   d5dd4:	a905      	add	r1, sp, #20
   d5dd6:	a829      	add	r0, sp, #164	; 0xa4
   d5dd8:	f005 fc00 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d5ddc:	a929      	add	r1, sp, #164	; 0xa4
   d5dde:	a80e      	add	r0, sp, #56	; 0x38
   d5de0:	f7ff f90e 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  File root = SD.open(stationName + "/");
  File entry = root.openNextFile();
  int nowyear = now.year();

  while (entry) {
    String entryname = entry.name();
   d5de4:	a801      	add	r0, sp, #4
   d5de6:	f006 fb9d 	bl	dc524 <_ZN6StringD1Ev>
  log("clSD", 4);
  File root = SD.open(stationName + "/");
  File entry = root.openNextFile();
  int nowyear = now.year();

  while (entry) {
   d5dea:	e757      	b.n	d5c9c <_Z7cleanSD6String+0x64>
   d5dec:	000e1daf 	.word	0x000e1daf
   d5df0:	000e1dcc 	.word	0x000e1dcc
   d5df4:	000e1dd3 	.word	0x000e1dd3
   d5df8:	2003dea4 	.word	0x2003dea4
   d5dfc:	000e1afd 	.word	0x000e1afd
   d5e00:	2003e3d4 	.word	0x2003e3d4
   d5e04:	2003debc 	.word	0x2003debc
        }
    }
    entry.close();
    entry =  root.openNextFile();
  }
  root.close();
   d5e08:	a805      	add	r0, sp, #20
   d5e0a:	f004 fc7d 	bl	da708 <_ZN5SDLib4File5closeEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5e0e:	498c      	ldr	r1, [pc, #560]	; (d6040 <_Z7cleanSD6String+0x408>)
   d5e10:	a820      	add	r0, sp, #128	; 0x80
   d5e12:	f006 fbce 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  Particle.publish("status", "Rd " + String(FolderRmvd) + ", Rf" + String(FileRmvd));
   d5e16:	220a      	movs	r2, #10
   d5e18:	4629      	mov	r1, r5
   d5e1a:	a817      	add	r0, sp, #92	; 0x5c
   d5e1c:	f006 fc19 	bl	dc652 <_ZN6StringC1Eih>
   d5e20:	a917      	add	r1, sp, #92	; 0x5c
   d5e22:	a820      	add	r0, sp, #128	; 0x80
   d5e24:	f006 fca0 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5e28:	4986      	ldr	r1, [pc, #536]	; (d6044 <_Z7cleanSD6String+0x40c>)
   d5e2a:	f006 fca9 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5e2e:	220a      	movs	r2, #10
   d5e30:	4680      	mov	r8, r0
   d5e32:	4631      	mov	r1, r6
   d5e34:	a829      	add	r0, sp, #164	; 0xa4
   d5e36:	f006 fc0c 	bl	dc652 <_ZN6StringC1Eih>
   d5e3a:	a929      	add	r1, sp, #164	; 0xa4
   d5e3c:	4640      	mov	r0, r8
   d5e3e:	f006 fc93 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5e42:	4981      	ldr	r1, [pc, #516]	; (d6048 <_Z7cleanSD6String+0x410>)
   d5e44:	6802      	ldr	r2, [r0, #0]
   d5e46:	a801      	add	r0, sp, #4
   d5e48:	f7fe ff16 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d5e4c:	a802      	add	r0, sp, #8
   d5e4e:	f7ff fedd 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d5e52:	a829      	add	r0, sp, #164	; 0xa4
   d5e54:	f006 fb66 	bl	dc524 <_ZN6StringD1Ev>
   d5e58:	a817      	add	r0, sp, #92	; 0x5c
   d5e5a:	f006 fb63 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5e5e:	a820      	add	r0, sp, #128	; 0x80
   d5e60:	f006 fb60 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5e64:	4976      	ldr	r1, [pc, #472]	; (d6040 <_Z7cleanSD6String+0x408>)
   d5e66:	a817      	add	r0, sp, #92	; 0x5c
   d5e68:	f006 fba3 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  log("Rd " + String(FolderRmvd) + ", Rf" + String(FileRmvd), 4);
   d5e6c:	220a      	movs	r2, #10
   d5e6e:	4629      	mov	r1, r5
   d5e70:	a801      	add	r0, sp, #4
   d5e72:	f006 fbee 	bl	dc652 <_ZN6StringC1Eih>
   d5e76:	a901      	add	r1, sp, #4
   d5e78:	a817      	add	r0, sp, #92	; 0x5c
   d5e7a:	f006 fc75 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5e7e:	4971      	ldr	r1, [pc, #452]	; (d6044 <_Z7cleanSD6String+0x40c>)
   d5e80:	f006 fc7e 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5e84:	220a      	movs	r2, #10
   d5e86:	4605      	mov	r5, r0
   d5e88:	4631      	mov	r1, r6
   d5e8a:	a820      	add	r0, sp, #128	; 0x80
   d5e8c:	f006 fbe1 	bl	dc652 <_ZN6StringC1Eih>
   d5e90:	a920      	add	r1, sp, #128	; 0x80
   d5e92:	4628      	mov	r0, r5
   d5e94:	f006 fc68 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d5e98:	4601      	mov	r1, r0
   d5e9a:	a829      	add	r0, sp, #164	; 0xa4
   d5e9c:	f006 fbab 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d5ea0:	2104      	movs	r1, #4
   d5ea2:	a829      	add	r0, sp, #164	; 0xa4
   d5ea4:	f7ff f8c2 	bl	d502c <_Z3log6Stringi>
   d5ea8:	a829      	add	r0, sp, #164	; 0xa4
   d5eaa:	f006 fb3b 	bl	dc524 <_ZN6StringD1Ev>
   d5eae:	a820      	add	r0, sp, #128	; 0x80
   d5eb0:	f006 fb38 	bl	dc524 <_ZN6StringD1Ev>
   d5eb4:	a801      	add	r0, sp, #4
   d5eb6:	f006 fb35 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5eba:	a817      	add	r0, sp, #92	; 0x5c
   d5ebc:	f006 fb32 	bl	dc524 <_ZN6StringD1Ev>

  // retirer les logs qui datent de plus d'un an
  
  FolderRmvd = 0;
  FileRmvd = 0;
  Particle.publish("status", "Cleaning old logs on SD...");
   d5ec0:	4a62      	ldr	r2, [pc, #392]	; (d604c <_Z7cleanSD6String+0x414>)
   d5ec2:	4961      	ldr	r1, [pc, #388]	; (d6048 <_Z7cleanSD6String+0x410>)
   d5ec4:	a829      	add	r0, sp, #164	; 0xa4
   d5ec6:	f7fe fed7 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d5eca:	a82a      	add	r0, sp, #168	; 0xa8
   d5ecc:	f7ff fe9e 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
  log("clL", 4);
   d5ed0:	495f      	ldr	r1, [pc, #380]	; (d6050 <_Z7cleanSD6String+0x418>)
   d5ed2:	a829      	add	r0, sp, #164	; 0xa4
   d5ed4:	f006 fb6d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5ed8:	2104      	movs	r1, #4
   d5eda:	a829      	add	r0, sp, #164	; 0xa4
   d5edc:	f7ff f8a6 	bl	d502c <_Z3log6Stringi>
   d5ee0:	a829      	add	r0, sp, #164	; 0xa4
   d5ee2:	f006 fb1f 	bl	dc524 <_ZN6StringD1Ev>
  root = SD.open("LOGS/");
   d5ee6:	2301      	movs	r3, #1
   d5ee8:	4a5a      	ldr	r2, [pc, #360]	; (d6054 <_Z7cleanSD6String+0x41c>)
   d5eea:	495b      	ldr	r1, [pc, #364]	; (d6058 <_Z7cleanSD6String+0x420>)
   d5eec:	a829      	add	r0, sp, #164	; 0xa4
   d5eee:	f005 faf9 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
   d5ef2:	a929      	add	r1, sp, #164	; 0xa4
   d5ef4:	a805      	add	r0, sp, #20
   d5ef6:	f7ff f883 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  entry = root.openNextFile();
   d5efa:	a905      	add	r1, sp, #20
   d5efc:	a829      	add	r0, sp, #164	; 0xa4
   d5efe:	2201      	movs	r2, #1
   d5f00:	f005 fb6c 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d5f04:	a929      	add	r1, sp, #164	; 0xa4
   d5f06:	a80e      	add	r0, sp, #56	; 0x38
   d5f08:	f7ff f87a 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  while (entry) {
   d5f0c:	a80e      	add	r0, sp, #56	; 0x38
   d5f0e:	f004 fc07 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d5f12:	4605      	mov	r5, r0
   d5f14:	2800      	cmp	r0, #0
   d5f16:	f000 80a5 	beq.w	d6064 <_Z7cleanSD6String+0x42c>
    String entryname = entry.name();
   d5f1a:	a80e      	add	r0, sp, #56	; 0x38
   d5f1c:	f004 fbc6 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5f20:	4601      	mov	r1, r0
   d5f22:	a817      	add	r0, sp, #92	; 0x5c
   d5f24:	f006 fb45 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    if(entryname.endsWith(String(nowyear-2))){
   d5f28:	220a      	movs	r2, #10
   d5f2a:	1eb9      	subs	r1, r7, #2
   d5f2c:	a829      	add	r0, sp, #164	; 0xa4
   d5f2e:	f006 fb90 	bl	dc652 <_ZN6StringC1Eih>
   d5f32:	a929      	add	r1, sp, #164	; 0xa4
   d5f34:	a817      	add	r0, sp, #92	; 0x5c
   d5f36:	f006 fc47 	bl	dc7c8 <_ZNK6String8endsWithERKS_>
   d5f3a:	4605      	mov	r5, r0
   d5f3c:	a829      	add	r0, sp, #164	; 0xa4
   d5f3e:	f006 faf1 	bl	dc524 <_ZN6StringD1Ev>
   d5f42:	b30d      	cbz	r5, d5f88 <_Z7cleanSD6String+0x350>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d5f44:	4943      	ldr	r1, [pc, #268]	; (d6054 <_Z7cleanSD6String+0x41c>)
   d5f46:	a829      	add	r0, sp, #164	; 0xa4
   d5f48:	f006 fb33 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
        if(!SD.remove("LOGS/" + String(entry.name()))){
   d5f4c:	a80e      	add	r0, sp, #56	; 0x38
   d5f4e:	f004 fbad 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5f52:	4601      	mov	r1, r0
   d5f54:	a820      	add	r0, sp, #128	; 0x80
   d5f56:	f006 fb2c 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d5f5a:	a920      	add	r1, sp, #128	; 0x80
   d5f5c:	a829      	add	r0, sp, #164	; 0xa4
   d5f5e:	f006 fc03 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
      }

      // Delete the file.
      bool remove(const char *filepath);
      bool remove(const String &filepath) {
        return remove(filepath.c_str());
   d5f62:	6801      	ldr	r1, [r0, #0]
   d5f64:	483c      	ldr	r0, [pc, #240]	; (d6058 <_Z7cleanSD6String+0x420>)
   d5f66:	f005 fb2b 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>
   d5f6a:	4605      	mov	r5, r0
   d5f6c:	a820      	add	r0, sp, #128	; 0x80
   d5f6e:	f006 fad9 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d5f72:	a829      	add	r0, sp, #164	; 0xa4
   d5f74:	f006 fad6 	bl	dc524 <_ZN6StringD1Ev>
   d5f78:	b92d      	cbnz	r5, d5f86 <_Z7cleanSD6String+0x34e>
          Serial.println("failed");
   d5f7a:	f007 ff91 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5f7e:	4937      	ldr	r1, [pc, #220]	; (d605c <_Z7cleanSD6String+0x424>)
   d5f80:	f006 ff73 	bl	dce6a <_ZN5Print7printlnEPKc>
   d5f84:	e000      	b.n	d5f88 <_Z7cleanSD6String+0x350>
        } else {
          FileRmvd++;
   d5f86:	3401      	adds	r4, #1
          }
        }
    entry.close();
   d5f88:	a80e      	add	r0, sp, #56	; 0x38
   d5f8a:	f004 fbbd 	bl	da708 <_ZN5SDLib4File5closeEv>
    entry =  root.openNextFile();
   d5f8e:	2201      	movs	r2, #1
   d5f90:	a905      	add	r1, sp, #20
   d5f92:	a829      	add	r0, sp, #164	; 0xa4
   d5f94:	f005 fb22 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d5f98:	a929      	add	r1, sp, #164	; 0xa4
   d5f9a:	a80e      	add	r0, sp, #56	; 0x38
   d5f9c:	f7ff f830 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
  Particle.publish("status", "Cleaning old logs on SD...");
  log("clL", 4);
  root = SD.open("LOGS/");
  entry = root.openNextFile();
  while (entry) {
    String entryname = entry.name();
   d5fa0:	a817      	add	r0, sp, #92	; 0x5c
   d5fa2:	f006 fabf 	bl	dc524 <_ZN6StringD1Ev>
  FileRmvd = 0;
  Particle.publish("status", "Cleaning old logs on SD...");
  log("clL", 4);
  root = SD.open("LOGS/");
  entry = root.openNextFile();
  while (entry) {
   d5fa6:	e7b1      	b.n	d5f0c <_Z7cleanSD6String+0x2d4>
  while (entry) {
    String entryname = entry.name();
    Serial.println(String(entryname.toInt()));
    if (entry.isDirectory()) {
      if(entryname.toInt() != nowyear && entryname.toInt() != nowyear-1){
          File entry1 = entry.openNextFile();
   d5fa8:	a90e      	add	r1, sp, #56	; 0x38
   d5faa:	2201      	movs	r2, #1
   d5fac:	a817      	add	r0, sp, #92	; 0x5c
   d5fae:	f005 fb15 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
          Serial.println(entry1.name());
   d5fb2:	f007 ff75 	bl	ddea0 <_Z16_fetch_usbserialv>
   d5fb6:	4604      	mov	r4, r0
   d5fb8:	a817      	add	r0, sp, #92	; 0x5c
   d5fba:	f004 fb77 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5fbe:	4601      	mov	r1, r0
   d5fc0:	4620      	mov	r0, r4
   d5fc2:	f006 ff52 	bl	dce6a <_ZN5Print7printlnEPKc>
   d5fc6:	e6e4      	b.n	d5d92 <_Z7cleanSD6String+0x15a>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d5fc8:	a829      	add	r0, sp, #164	; 0xa4
   d5fca:	f006 fb14 	bl	dc5f6 <_ZN6StringC1ERKS_>
          while(entry1){
            if(entry1.isDirectory()){
              File entry2 = entry1.openNextFile();
              Serial.println(entry2.name());
              while(entry2) {
                if(!SD.remove(stationName + "/" + entry.name() + "/" + entry1.name() + "/" + entry2.name())){
   d5fce:	4924      	ldr	r1, [pc, #144]	; (d6060 <_Z7cleanSD6String+0x428>)
   d5fd0:	a829      	add	r0, sp, #164	; 0xa4
   d5fd2:	f006 fbd5 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5fd6:	4604      	mov	r4, r0
   d5fd8:	a80e      	add	r0, sp, #56	; 0x38
   d5fda:	f004 fb67 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5fde:	4601      	mov	r1, r0
   d5fe0:	4620      	mov	r0, r4
   d5fe2:	f006 fbcd 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5fe6:	491e      	ldr	r1, [pc, #120]	; (d6060 <_Z7cleanSD6String+0x428>)
   d5fe8:	f006 fbca 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5fec:	4604      	mov	r4, r0
   d5fee:	a817      	add	r0, sp, #92	; 0x5c
   d5ff0:	f004 fb5c 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d5ff4:	4601      	mov	r1, r0
   d5ff6:	4620      	mov	r0, r4
   d5ff8:	f006 fbc2 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d5ffc:	4918      	ldr	r1, [pc, #96]	; (d6060 <_Z7cleanSD6String+0x428>)
   d5ffe:	f006 fbbf 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d6002:	4604      	mov	r4, r0
   d6004:	a820      	add	r0, sp, #128	; 0x80
   d6006:	f004 fb51 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d600a:	4601      	mov	r1, r0
   d600c:	4620      	mov	r0, r4
   d600e:	f006 fbb7 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d6012:	6801      	ldr	r1, [r0, #0]
   d6014:	4810      	ldr	r0, [pc, #64]	; (d6058 <_Z7cleanSD6String+0x420>)
   d6016:	f005 fad3 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>
   d601a:	4604      	mov	r4, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d601c:	a829      	add	r0, sp, #164	; 0xa4
   d601e:	f006 fa81 	bl	dc524 <_ZN6StringD1Ev>
   d6022:	b104      	cbz	r4, d6026 <_Z7cleanSD6String+0x3ee>
                    //Serial.println("removal of " + stationName + "/" + entry.name() + "/" + entry1.name() + "/" + entry2.name() + " failed");
                  } else {
                    //Serial.println("removal of " + stationName + "/" + entry.name() + "/" + entry1.name() + "/" + entry2.name() + " Succeed");
                    FileRmvd++;
   d6024:	3601      	adds	r6, #1
                    }
                entry2.close();                  
   d6026:	a820      	add	r0, sp, #128	; 0x80
   d6028:	f004 fb6e 	bl	da708 <_ZN5SDLib4File5closeEv>
                entry2 = entry1.openNextFile();
   d602c:	a917      	add	r1, sp, #92	; 0x5c
   d602e:	a829      	add	r0, sp, #164	; 0xa4
   d6030:	2201      	movs	r2, #1
   d6032:	f005 fad3 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d6036:	a929      	add	r1, sp, #164	; 0xa4
   d6038:	a820      	add	r0, sp, #128	; 0x80
   d603a:	f7fe ffe1 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
          Serial.println(entry1.name());
          while(entry1){
            if(entry1.isDirectory()){
              File entry2 = entry1.openNextFile();
              Serial.println(entry2.name());
              while(entry2) {
   d603e:	e673      	b.n	d5d28 <_Z7cleanSD6String+0xf0>
   d6040:	000e1dd8 	.word	0x000e1dd8
   d6044:	000e1ddc 	.word	0x000e1ddc
   d6048:	000e1dcc 	.word	0x000e1dcc
   d604c:	000e1de1 	.word	0x000e1de1
   d6050:	000e1dfc 	.word	0x000e1dfc
   d6054:	000e1af9 	.word	0x000e1af9
   d6058:	2003e3d4 	.word	0x2003e3d4
   d605c:	000e1b21 	.word	0x000e1b21
   d6060:	000e1afd 	.word	0x000e1afd
          }
        }
    entry.close();
    entry =  root.openNextFile();
  }
  root.close();
   d6064:	a805      	add	r0, sp, #20
   d6066:	f004 fb4f 	bl	da708 <_ZN5SDLib4File5closeEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d606a:	492e      	ldr	r1, [pc, #184]	; (d6124 <_Z7cleanSD6String+0x4ec>)
   d606c:	a820      	add	r0, sp, #128	; 0x80
   d606e:	f006 faa0 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  Particle.publish("status", "Rd " + String(FolderRmvd) + ", Rf" + String(FileRmvd));  
   d6072:	220a      	movs	r2, #10
   d6074:	4629      	mov	r1, r5
   d6076:	a817      	add	r0, sp, #92	; 0x5c
   d6078:	f006 faeb 	bl	dc652 <_ZN6StringC1Eih>
   d607c:	a917      	add	r1, sp, #92	; 0x5c
   d607e:	a820      	add	r0, sp, #128	; 0x80
   d6080:	f006 fb72 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d6084:	4928      	ldr	r1, [pc, #160]	; (d6128 <_Z7cleanSD6String+0x4f0>)
   d6086:	f006 fb7b 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d608a:	220a      	movs	r2, #10
   d608c:	4606      	mov	r6, r0
   d608e:	4621      	mov	r1, r4
   d6090:	a829      	add	r0, sp, #164	; 0xa4
   d6092:	f006 fade 	bl	dc652 <_ZN6StringC1Eih>
   d6096:	a929      	add	r1, sp, #164	; 0xa4
   d6098:	4630      	mov	r0, r6
   d609a:	f006 fb65 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d609e:	4923      	ldr	r1, [pc, #140]	; (d612c <_Z7cleanSD6String+0x4f4>)
   d60a0:	6802      	ldr	r2, [r0, #0]
   d60a2:	a801      	add	r0, sp, #4
   d60a4:	f7fe fde8 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d60a8:	a802      	add	r0, sp, #8
   d60aa:	f7ff fdaf 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d60ae:	a829      	add	r0, sp, #164	; 0xa4
   d60b0:	f006 fa38 	bl	dc524 <_ZN6StringD1Ev>
   d60b4:	a817      	add	r0, sp, #92	; 0x5c
   d60b6:	f006 fa35 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d60ba:	a820      	add	r0, sp, #128	; 0x80
   d60bc:	f006 fa32 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d60c0:	4918      	ldr	r1, [pc, #96]	; (d6124 <_Z7cleanSD6String+0x4ec>)
   d60c2:	a817      	add	r0, sp, #92	; 0x5c
   d60c4:	f006 fa75 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  log("Rd " + String(FolderRmvd) + ", Rf" + String(FileRmvd), 4);
   d60c8:	220a      	movs	r2, #10
   d60ca:	4629      	mov	r1, r5
   d60cc:	a801      	add	r0, sp, #4
   d60ce:	f006 fac0 	bl	dc652 <_ZN6StringC1Eih>
   d60d2:	a901      	add	r1, sp, #4
   d60d4:	a817      	add	r0, sp, #92	; 0x5c
   d60d6:	f006 fb47 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d60da:	4913      	ldr	r1, [pc, #76]	; (d6128 <_Z7cleanSD6String+0x4f0>)
   d60dc:	f006 fb50 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d60e0:	220a      	movs	r2, #10
   d60e2:	4605      	mov	r5, r0
   d60e4:	4621      	mov	r1, r4
   d60e6:	a820      	add	r0, sp, #128	; 0x80
   d60e8:	f006 fab3 	bl	dc652 <_ZN6StringC1Eih>
   d60ec:	a920      	add	r1, sp, #128	; 0x80
   d60ee:	4628      	mov	r0, r5
   d60f0:	f006 fb3a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d60f4:	4601      	mov	r1, r0
   d60f6:	a829      	add	r0, sp, #164	; 0xa4
   d60f8:	f006 fa7d 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d60fc:	2104      	movs	r1, #4
   d60fe:	a829      	add	r0, sp, #164	; 0xa4
   d6100:	f7fe ff94 	bl	d502c <_Z3log6Stringi>
   d6104:	a829      	add	r0, sp, #164	; 0xa4
   d6106:	f006 fa0d 	bl	dc524 <_ZN6StringD1Ev>
   d610a:	a820      	add	r0, sp, #128	; 0x80
   d610c:	f006 fa0a 	bl	dc524 <_ZN6StringD1Ev>
   d6110:	a801      	add	r0, sp, #4
   d6112:	f006 fa07 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d6116:	a817      	add	r0, sp, #92	; 0x5c
   d6118:	f006 fa04 	bl	dc524 <_ZN6StringD1Ev>
  return 1;
}
   d611c:	2001      	movs	r0, #1
   d611e:	b032      	add	sp, #200	; 0xc8
   d6120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d6124:	000e1dd8 	.word	0x000e1dd8
   d6128:	000e1ddc 	.word	0x000e1ddc
   d612c:	000e1dcc 	.word	0x000e1dcc

000d6130 <_Z7grabPic6String>:
* /!\ LE NOM NE PEUT FAIRE PLUS QUE 8 CARACTRES!! /!\
*
* V1.1 2019-12-18 : EXIF injection from template
* V1.2 2020-02-07 : Temp folder for offline takes
*/
int grabPic(String Short_filename) {
   d6130:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   d6134:	4606      	mov	r6, r0
   d6136:	b0a5      	sub	sp, #148	; 0x94

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   d6138:	4c59      	ldr	r4, [pc, #356]	; (d62a0 <_Z7grabPic6String+0x170>)
   d613a:	6823      	ldr	r3, [r4, #0]
   d613c:	07db      	lsls	r3, r3, #31
   d613e:	d40a      	bmi.n	d6156 <_Z7grabPic6String+0x26>
   d6140:	4620      	mov	r0, r4
   d6142:	f7fd ffbb 	bl	d40bc <__cxa_guard_acquire>
   d6146:	b130      	cbz	r0, d6156 <_Z7grabPic6String+0x26>
   d6148:	2101      	movs	r1, #1
   d614a:	4856      	ldr	r0, [pc, #344]	; (d62a4 <_Z7grabPic6String+0x174>)
   d614c:	f005 ff62 	bl	dc014 <_ZN8SPIClassC1E17HAL_SPI_Interface>
   d6150:	4620      	mov	r0, r4
   d6152:	f7fd ffb8 	bl	d40c6 <__cxa_guard_release>
    }
    void begin(uint16_t ss_pin) {
        instance().begin(ss_pin);
    }
    void begin(SPI_Mode mode, uint16_t ss_pin = SPI_DEFAULT_SS) {
        instance().begin(mode, ss_pin);
   d6156:	f64f 72ff 	movw	r2, #65535	; 0xffff
   d615a:	2100      	movs	r1, #0
   d615c:	4851      	ldr	r0, [pc, #324]	; (d62a4 <_Z7grabPic6String+0x174>)
   d615e:	f005 ff74 	bl	dc04a <_ZN8SPIClass5beginE8SPI_Modet>
    //SPI1.begin(SPI_CS);
    SPI1.begin(SPI_MODE_MASTER);
    //SPI.begin(SPI_MODE_SLAVE, SPI_CS);  
    // La camra est alimente par un "latching relay", attention, elle consomme beaucoup.

    digitalWrite(Cam_on, HIGH);
   d6162:	2101      	movs	r1, #1
   d6164:	2013      	movs	r0, #19
   d6166:	f008 fcf4 	bl	deb52 <digitalWrite>
    //delay(2000);
    delay(100);
   d616a:	2064      	movs	r0, #100	; 0x64
   d616c:	f006 ffe6 	bl	dd13c <delay>
    myCAM.CS_LOW();
   d6170:	484d      	ldr	r0, [pc, #308]	; (d62a8 <_Z7grabPic6String+0x178>)
   d6172:	f7fe fa65 	bl	d4640 <_ZN7ArduCAM6CS_LOWEv>
    //On vrifie si la camra rpond sur le bus SPI1
    myCAM.write_reg(ARDUCHIP_TEST1, 0x55);
   d6176:	2255      	movs	r2, #85	; 0x55
   d6178:	2100      	movs	r1, #0
   d617a:	484b      	ldr	r0, [pc, #300]	; (d62a8 <_Z7grabPic6String+0x178>)
   d617c:	f7fe fd1c 	bl	d4bb8 <_ZN7ArduCAM9write_regEhh>
    temp = myCAM.read_reg(ARDUCHIP_TEST1); //ce registre est ddi pour a
   d6180:	2100      	movs	r1, #0
   d6182:	4849      	ldr	r0, [pc, #292]	; (d62a8 <_Z7grabPic6String+0x178>)
   d6184:	f7fe fcb7 	bl	d4af6 <_ZN7ArduCAM8read_regEh>
    if(temp != 0x55)
   d6188:	2855      	cmp	r0, #85	; 0x55
    //delay(2000);
    delay(100);
    myCAM.CS_LOW();
    //On vrifie si la camra rpond sur le bus SPI1
    myCAM.write_reg(ARDUCHIP_TEST1, 0x55);
    temp = myCAM.read_reg(ARDUCHIP_TEST1); //ce registre est ddi pour a
   d618a:	4604      	mov	r4, r0
    if(temp != 0x55)
   d618c:	d06d      	beq.n	d626a <_Z7grabPic6String+0x13a>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d618e:	4947      	ldr	r1, [pc, #284]	; (d62ac <_Z7grabPic6String+0x17c>)
   d6190:	a811      	add	r0, sp, #68	; 0x44
   d6192:	f006 fa0e 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    {
      log("SPI interface Error! resetting in 15 seconds, myCam.read_reg said " + String(temp), 1);
   d6196:	220a      	movs	r2, #10
   d6198:	4621      	mov	r1, r4
   d619a:	a80d      	add	r0, sp, #52	; 0x34
   d619c:	f006 fa47 	bl	dc62e <_ZN6StringC1Ehh>
   d61a0:	a90d      	add	r1, sp, #52	; 0x34
   d61a2:	a811      	add	r0, sp, #68	; 0x44
   d61a4:	f006 fae0 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d61a8:	4601      	mov	r1, r0
   d61aa:	a81a      	add	r0, sp, #104	; 0x68
   d61ac:	f006 fa23 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d61b0:	2101      	movs	r1, #1
   d61b2:	a81a      	add	r0, sp, #104	; 0x68
   d61b4:	f7fe ff3a 	bl	d502c <_Z3log6Stringi>
   d61b8:	a81a      	add	r0, sp, #104	; 0x68
   d61ba:	f006 f9b3 	bl	dc524 <_ZN6StringD1Ev>
   d61be:	a80d      	add	r0, sp, #52	; 0x34
   d61c0:	f006 f9b0 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d61c4:	a811      	add	r0, sp, #68	; 0x44
   d61c6:	f006 f9ad 	bl	dc524 <_ZN6StringD1Ev>
      Particle.publish("status", "SPI Error");
   d61ca:	4a39      	ldr	r2, [pc, #228]	; (d62b0 <_Z7grabPic6String+0x180>)
   d61cc:	4939      	ldr	r1, [pc, #228]	; (d62b4 <_Z7grabPic6String+0x184>)
   d61ce:	a81a      	add	r0, sp, #104	; 0x68
   d61d0:	f7fe fd52 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d61d4:	a81b      	add	r0, sp, #108	; 0x6c
   d61d6:	f7ff fd19 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      delay(15000);
   d61da:	f643 2098 	movw	r0, #15000	; 0x3a98
   d61de:	f006 ffad 	bl	dd13c <delay>
   d61e2:	4b35      	ldr	r3, [pc, #212]	; (d62b8 <_Z7grabPic6String+0x188>)
   d61e4:	681b      	ldr	r3, [r3, #0]
      System.sleep(SS_Button, FALLING, 1500);
   d61e6:	9300      	str	r3, [sp, #0]
   d61e8:	2202      	movs	r2, #2
   d61ea:	f240 53dc 	movw	r3, #1500	; 0x5dc
   d61ee:	2106      	movs	r1, #6
   d61f0:	a81a      	add	r0, sp, #104	; 0x68
   d61f2:	f7fe fda5 	bl	d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>
      delay(1000);
   d61f6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d61fa:	f006 ff9f 	bl	dd13c <delay>
      System.reset();
   d61fe:	f006 f80e 	bl	dc21e <_ZN11SystemClass5resetEv>
    }
    else {
      break; //on sort du while(1) si il n'y a pas de problme.
    }
    Particle.process(); //On donne signe de vie au cloud
   d6202:	f7fe fe51 	bl	d4ea8 <_ZN10CloudClass7processEv>
  uint8_t temp;
  uint8_t temp_last;
  
  //Vrification de la comm avec la camra, le while(1) (provient de l'exemple de la librairie
  //  modifier ventuellement 
  while(1) {
   d6206:	e797      	b.n	d6138 <_Z7grabPic6String+0x8>
    myCAM.wrSensorReg8_8(0xff, 0x01);
    myCAM.rdSensorReg8_8(OV2640_CHIPID_HIGH, &vid);
    myCAM.rdSensorReg8_8(OV2640_CHIPID_LOW, &pid);

    //Ce registre devrait indiquer 2640
    if ((vid != 0x26 ) && ( pid != 0x41 ) || ( pid != 0x42 )){
   d6208:	2b42      	cmp	r3, #66	; 0x42
   d620a:	d05b      	beq.n	d62c4 <_Z7grabPic6String+0x194>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d620c:	492b      	ldr	r1, [pc, #172]	; (d62bc <_Z7grabPic6String+0x18c>)
   d620e:	a811      	add	r0, sp, #68	; 0x44
   d6210:	f006 f9cf 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      log("Can't find OV2640 module! camera says " + String::format("%d:%d", vid, pid), 1);
   d6214:	f89d 300b 	ldrb.w	r3, [sp, #11]
   d6218:	f89d 200a 	ldrb.w	r2, [sp, #10]
   d621c:	4928      	ldr	r1, [pc, #160]	; (d62c0 <_Z7grabPic6String+0x190>)
   d621e:	a80d      	add	r0, sp, #52	; 0x34
   d6220:	f006 faec 	bl	dc7fc <_ZN6String6formatEPKcz>
   d6224:	a90d      	add	r1, sp, #52	; 0x34
   d6226:	a811      	add	r0, sp, #68	; 0x44
   d6228:	f006 fa9e 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d622c:	4601      	mov	r1, r0
   d622e:	a81a      	add	r0, sp, #104	; 0x68
   d6230:	f006 f9e1 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d6234:	2101      	movs	r1, #1
   d6236:	a81a      	add	r0, sp, #104	; 0x68
   d6238:	f7fe fef8 	bl	d502c <_Z3log6Stringi>
   d623c:	a81a      	add	r0, sp, #104	; 0x68
   d623e:	f006 f971 	bl	dc524 <_ZN6StringD1Ev>
   d6242:	a80d      	add	r0, sp, #52	; 0x34
   d6244:	f006 f96e 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d6248:	a811      	add	r0, sp, #68	; 0x44
   d624a:	f006 f96b 	bl	dc524 <_ZN6StringD1Ev>
      delay(5000);
   d624e:	f241 3088 	movw	r0, #5000	; 0x1388
   d6252:	f006 ff73 	bl	dd13c <delay>
   d6256:	4b18      	ldr	r3, [pc, #96]	; (d62b8 <_Z7grabPic6String+0x188>)
   d6258:	681b      	ldr	r3, [r3, #0]
      System.sleep(SS_Button, FALLING, 1500);
   d625a:	9300      	str	r3, [sp, #0]
   d625c:	2202      	movs	r2, #2
   d625e:	f240 53dc 	movw	r3, #1500	; 0x5dc
   d6262:	2106      	movs	r1, #6
   d6264:	a81a      	add	r0, sp, #104	; 0x68
   d6266:	f7fe fd6b 	bl	d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>

  }

  // Vrifier le modle de la camra. Encore un while(1)...
  while(1){
    Particle.process();
   d626a:	f7fe fe1d 	bl	d4ea8 <_ZN10CloudClass7processEv>
    //Check if the camera module type is OV5642
    // myCAM.rdSensorReg8_8(OV2640_CHIPID_HIGH, &vid);
    // myCAM.rdSensorReg8_8(OV2640_CHIPID_LOW, &pid);

    myCAM.wrSensorReg8_8(0xff, 0x01);
   d626e:	2201      	movs	r2, #1
   d6270:	21ff      	movs	r1, #255	; 0xff
   d6272:	480d      	ldr	r0, [pc, #52]	; (d62a8 <_Z7grabPic6String+0x178>)
   d6274:	f7fe f9f8 	bl	d4668 <_ZN7ArduCAM14wrSensorReg8_8Eii>
    myCAM.rdSensorReg8_8(OV2640_CHIPID_HIGH, &vid);
   d6278:	f10d 020a 	add.w	r2, sp, #10
   d627c:	210a      	movs	r1, #10
   d627e:	480a      	ldr	r0, [pc, #40]	; (d62a8 <_Z7grabPic6String+0x178>)
   d6280:	f7fe fbaa 	bl	d49d8 <_ZN7ArduCAM14rdSensorReg8_8EhPh>
    myCAM.rdSensorReg8_8(OV2640_CHIPID_LOW, &pid);
   d6284:	f10d 020b 	add.w	r2, sp, #11
   d6288:	210b      	movs	r1, #11
   d628a:	4807      	ldr	r0, [pc, #28]	; (d62a8 <_Z7grabPic6String+0x178>)
   d628c:	f7fe fba4 	bl	d49d8 <_ZN7ArduCAM14rdSensorReg8_8EhPh>

    //Ce registre devrait indiquer 2640
    if ((vid != 0x26 ) && ( pid != 0x41 ) || ( pid != 0x42 )){
   d6290:	f89d 300a 	ldrb.w	r3, [sp, #10]
   d6294:	2b26      	cmp	r3, #38	; 0x26
   d6296:	f89d 300b 	ldrb.w	r3, [sp, #11]
   d629a:	d1b7      	bne.n	d620c <_Z7grabPic6String+0xdc>
   d629c:	e7b4      	b.n	d6208 <_Z7grabPic6String+0xd8>
   d629e:	bf00      	nop
   d62a0:	2003dd08 	.word	0x2003dd08
   d62a4:	2003dd0c 	.word	0x2003dd0c
   d62a8:	2003df08 	.word	0x2003df08
   d62ac:	000e1e00 	.word	0x000e1e00
   d62b0:	000e1e43 	.word	0x000e1e43
   d62b4:	000e1dcc 	.word	0x000e1dcc
   d62b8:	2003e2a8 	.word	0x2003e2a8
   d62bc:	000e1e4d 	.word	0x000e1e4d
   d62c0:	000e1e74 	.word	0x000e1e74
    }
  }

  //myCAM.write_reg(ARDUCHIP_MODE, 0x01);		 	//Viens de la librairie, usage inconnu
  // On utilise la compression JPEG
  myCAM.set_format(JPEG);
   d62c4:	2101      	movs	r1, #1
   d62c6:	489c      	ldr	r0, [pc, #624]	; (d6538 <_Z7grabPic6String+0x408>)
   d62c8:	f7fe f9c8 	bl	d465c <_ZN7ArduCAM10set_formatEh>
  delay(10);
   d62cc:	200a      	movs	r0, #10
   d62ce:	f006 ff35 	bl	dd13c <delay>
  // On initalise la camra
  myCAM.InitCAM();
   d62d2:	4899      	ldr	r0, [pc, #612]	; (d6538 <_Z7grabPic6String+0x408>)
   d62d4:	f7fe fb42 	bl	d495c <_ZN7ArduCAM7InitCAMEv>
  delay(10);
   d62d8:	200a      	movs	r0, #10
   d62da:	f006 ff2f 	bl	dd13c <delay>
  //myCAM.OV5642_set_JPEG_size(OV5642_320x240);   //works
  //myCAM.OV5642_set_JPEG_size(OV5642_640x480);   // works
  //myCAM.OV5642_set_JPEG_size(OV5642_1600x1200); // works
  //myCAM.OV5642_set_JPEG_size(OV5642_1280x960);  // works
  //myCAM.OV2640_set_JPEG_size(OV2640_1600x1200); //works
  myCAM.OV2640_set_JPEG_size(OV2640_1280x1024);
   d62de:	2107      	movs	r1, #7
   d62e0:	4895      	ldr	r0, [pc, #596]	; (d6538 <_Z7grabPic6String+0x408>)
   d62e2:	f7fe fb0d 	bl	d4900 <_ZN7ArduCAM20OV2640_set_JPEG_sizeEh>
  delay(10);
   d62e6:	200a      	movs	r0, #10
   d62e8:	f006 ff28 	bl	dd13c <delay>
  myCAM.set_Special_effects(Normal);
   d62ec:	2107      	movs	r1, #7
   d62ee:	4892      	ldr	r0, [pc, #584]	; (d6538 <_Z7grabPic6String+0x408>)
   d62f0:	f7fe fa3f 	bl	d4772 <_ZN7ArduCAM19set_Special_effectsEh>
  delay(10);
   d62f4:	200a      	movs	r0, #10
   d62f6:	f006 ff21 	bl	dd13c <delay>
  myCAM.set_Light_Mode(Auto);
   d62fa:	2100      	movs	r1, #0
   d62fc:	488e      	ldr	r0, [pc, #568]	; (d6538 <_Z7grabPic6String+0x408>)
   d62fe:	f7fe f9d3 	bl	d46a8 <_ZN7ArduCAM14set_Light_ModeEh>
  delay(10);
   d6302:	200a      	movs	r0, #10
   d6304:	f006 ff1a 	bl	dd13c <delay>

  // On flush toute info associe  une photo antrieure avant de prendre une photo
  myCAM.flush_fifo();
   d6308:	488b      	ldr	r0, [pc, #556]	; (d6538 <_Z7grabPic6String+0x408>)
   d630a:	f7fe fc61 	bl	d4bd0 <_ZN7ArduCAM10flush_fifoEv>
  delay(10);
   d630e:	200a      	movs	r0, #10
   d6310:	f006 ff14 	bl	dd13c <delay>
  myCAM.clear_fifo_flag();
   d6314:	4888      	ldr	r0, [pc, #544]	; (d6538 <_Z7grabPic6String+0x408>)
   d6316:	f7fe fc57 	bl	d4bc8 <_ZN7ArduCAM15clear_fifo_flagEv>
  delay(5000);
   d631a:	f241 3088 	movw	r0, #5000	; 0x1388
   d631e:	f006 ff0d 	bl	dd13c <delay>
  myCAM.start_capture();
   d6322:	4885      	ldr	r0, [pc, #532]	; (d6538 <_Z7grabPic6String+0x408>)
   d6324:	f7fe fc4c 	bl	d4bc0 <_ZN7ArduCAM13start_captureEv>
  delay(10);
   d6328:	200a      	movs	r0, #10
   d632a:	f006 ff07 	bl	dd13c <delay>
   d632e:	f005 fa51 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
   d6332:	4604      	mov	r4, r0
   d6334:	f005 fa4e 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>

  unsigned long start_time = millis(),
  last_publish = millis();

  // On attends que la photo soit prise
  while(!myCAM.get_bit(ARDUCHIP_TRIG , CAP_DONE_MASK)) {
   d6338:	2208      	movs	r2, #8
   d633a:	2141      	movs	r1, #65	; 0x41
   d633c:	487e      	ldr	r0, [pc, #504]	; (d6538 <_Z7grabPic6String+0x408>)
   d633e:	f7fe fbde 	bl	d4afe <_ZN7ArduCAM7get_bitEhh>
   d6342:	b9b0      	cbnz	r0, d6372 <_Z7grabPic6String+0x242>
      Particle.process(); // on oublie pas le cloud
   d6344:	f7fe fdb0 	bl	d4ea8 <_ZN10CloudClass7processEv>
      delay(10);
   d6348:	200a      	movs	r0, #10
   d634a:	f006 fef7 	bl	dd13c <delay>
   d634e:	f005 fa41 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
      unsigned long now = millis();
      if ((now - last_publish) > 1000) {
          last_publish = now;
      }
      // SI jamais c'est trop long, il y a un problme
      if ((now-start_time) > 30000) {
   d6352:	f247 5330 	movw	r3, #30000	; 0x7530
   d6356:	1b00      	subs	r0, r0, r4
   d6358:	4298      	cmp	r0, r3
   d635a:	d9ed      	bls.n	d6338 <_Z7grabPic6String+0x208>
          log("Photo timeout", 1);
   d635c:	4977      	ldr	r1, [pc, #476]	; (d653c <_Z7grabPic6String+0x40c>)
   d635e:	a81a      	add	r0, sp, #104	; 0x68
   d6360:	f006 f927 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d6364:	a81a      	add	r0, sp, #104	; 0x68
   d6366:	2101      	movs	r1, #1
   d6368:	f7fe fe60 	bl	d502c <_Z3log6Stringi>
   d636c:	a81a      	add	r0, sp, #104	; 0x68
   d636e:	f006 f8d9 	bl	dc524 <_ZN6StringD1Ev>
          break;
      }
  }
  delay(10);
   d6372:	200a      	movs	r0, #10
   d6374:	f006 fee2 	bl	dd13c <delay>
  // Lecture de la taille de l'image, inscription dans le log
  int length = myCAM.read_fifo_length();
   d6378:	486f      	ldr	r0, [pc, #444]	; (d6538 <_Z7grabPic6String+0x408>)
   d637a:	f7fe fbc6 	bl	d4b0a <_ZN7ArduCAM16read_fifo_lengthEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d637e:	4970      	ldr	r1, [pc, #448]	; (d6540 <_Z7grabPic6String+0x410>)
   d6380:	4604      	mov	r4, r0
   d6382:	a811      	add	r0, sp, #68	; 0x44
   d6384:	f006 f915 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  log("Is " + String(length), 4);
   d6388:	220a      	movs	r2, #10
   d638a:	4621      	mov	r1, r4
   d638c:	a80d      	add	r0, sp, #52	; 0x34
   d638e:	f006 f960 	bl	dc652 <_ZN6StringC1Eih>
   d6392:	a90d      	add	r1, sp, #52	; 0x34
   d6394:	a811      	add	r0, sp, #68	; 0x44
   d6396:	f006 f9e7 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d639a:	4601      	mov	r1, r0
   d639c:	a81a      	add	r0, sp, #104	; 0x68
   d639e:	f006 f92a 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d63a2:	2104      	movs	r1, #4
   d63a4:	a81a      	add	r0, sp, #104	; 0x68
   d63a6:	f7fe fe41 	bl	d502c <_Z3log6Stringi>
   d63aa:	a81a      	add	r0, sp, #104	; 0x68
   d63ac:	f006 f8ba 	bl	dc524 <_ZN6StringD1Ev>
   d63b0:	a80d      	add	r0, sp, #52	; 0x34
   d63b2:	f006 f8b7 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d63b6:	a811      	add	r0, sp, #68	; 0x44
   d63b8:	f006 f8b4 	bl	dc524 <_ZN6StringD1Ev>

  //Variables temporaires
  temp = 0xff, temp_last = 0;
  int bytesRead = 0;
  String Pic = "";
   d63bc:	4961      	ldr	r1, [pc, #388]	; (d6544 <_Z7grabPic6String+0x414>)
   d63be:	a805      	add	r0, sp, #20
   d63c0:	f006 f8f7 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>

  // Si l'image est prte, on la prlve 
  if(myCAM.get_bit(ARDUCHIP_TRIG, CAP_DONE_MASK))
   d63c4:	2208      	movs	r2, #8
   d63c6:	2141      	movs	r1, #65	; 0x41
   d63c8:	485b      	ldr	r0, [pc, #364]	; (d6538 <_Z7grabPic6String+0x408>)
   d63ca:	f7fe fb98 	bl	d4afe <_ZN7ArduCAM7get_bitEhh>
   d63ce:	2800      	cmp	r0, #0
   d63d0:	f000 82aa 	beq.w	d6928 <_Z7grabPic6String+0x7f8>
  {
    //d'autres variables temporaires
    byte buf[256];
    //uint8_t temp, temp_last;
    File file;
   d63d4:	a811      	add	r0, sp, #68	; 0x44
   d63d6:	f004 f95d 	bl	da694 <_ZN5SDLib4FileC1Ev>
    String dir;
   d63da:	495a      	ldr	r1, [pc, #360]	; (d6544 <_Z7grabPic6String+0x414>)
   d63dc:	4d5a      	ldr	r5, [pc, #360]	; (d6548 <_Z7grabPic6String+0x418>)
   d63de:	a809      	add	r0, sp, #36	; 0x24
   d63e0:	f006 f8e7 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    //myCAM.CS_HIGH(); //On s'assure de taire la camra sur le Bus SPI
    delay(10);
   d63e4:	200a      	movs	r0, #10
   d63e6:	f006 fea9 	bl	dd13c <delay>
     
    dir = String(config.stationName) + "/";
   d63ea:	4958      	ldr	r1, [pc, #352]	; (d654c <_Z7grabPic6String+0x41c>)
   d63ec:	a80d      	add	r0, sp, #52	; 0x34
   d63ee:	f006 f8e0 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d63f2:	a90d      	add	r1, sp, #52	; 0x34
   d63f4:	a81a      	add	r0, sp, #104	; 0x68
   d63f6:	f006 f8fe 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d63fa:	4955      	ldr	r1, [pc, #340]	; (d6550 <_Z7grabPic6String+0x420>)
   d63fc:	a81a      	add	r0, sp, #104	; 0x68
   d63fe:	f006 f9bf 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d6402:	4601      	mov	r1, r0
   d6404:	a809      	add	r0, sp, #36	; 0x24
   d6406:	f006 f8e7 	bl	dc5d8 <_ZN6StringaSERKS_>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d640a:	a81a      	add	r0, sp, #104	; 0x68
   d640c:	f006 f88a 	bl	dc524 <_ZN6StringD1Ev>
   d6410:	a80d      	add	r0, sp, #52	; 0x34
   d6412:	f006 f887 	bl	dc524 <_ZN6StringD1Ev>
    dir += String(now.year()) + "/";
   d6416:	7829      	ldrb	r1, [r5, #0]
   d6418:	220a      	movs	r2, #10
   d641a:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d641e:	a80d      	add	r0, sp, #52	; 0x34
   d6420:	f006 f917 	bl	dc652 <_ZN6StringC1Eih>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d6424:	a90d      	add	r1, sp, #52	; 0x34
   d6426:	a81a      	add	r0, sp, #104	; 0x68
   d6428:	f006 f8e5 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d642c:	4948      	ldr	r1, [pc, #288]	; (d6550 <_Z7grabPic6String+0x420>)
   d642e:	a81a      	add	r0, sp, #104	; 0x68
   d6430:	f006 f9a6 	bl	dc780 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
   d6434:	4601      	mov	r1, r0
   d6436:	a809      	add	r0, sp, #36	; 0x24
   d6438:	f006 f976 	bl	dc728 <_ZN6String6concatERKS_>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d643c:	a81a      	add	r0, sp, #104	; 0x68
   d643e:	f006 f871 	bl	dc524 <_ZN6StringD1Ev>
   d6442:	a80d      	add	r0, sp, #52	; 0x34
   d6444:	f006 f86e 	bl	dc524 <_ZN6StringD1Ev>
    dir += String(now.month()) + "/";     
   d6448:	220a      	movs	r2, #10
   d644a:	7869      	ldrb	r1, [r5, #1]
   d644c:	a80d      	add	r0, sp, #52	; 0x34
   d644e:	f006 f8ee 	bl	dc62e <_ZN6StringC1Ehh>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d6452:	a90d      	add	r1, sp, #52	; 0x34
   d6454:	a81a      	add	r0, sp, #104	; 0x68
   d6456:	f006 f8ce 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d645a:	493d      	ldr	r1, [pc, #244]	; (d6550 <_Z7grabPic6String+0x420>)
   d645c:	a81a      	add	r0, sp, #104	; 0x68
   d645e:	f006 f98f 	bl	dc780 <_ZplRK15StringSumHelperPKc>
	unsigned char concat(float num);
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
   d6462:	4601      	mov	r1, r0
   d6464:	a809      	add	r0, sp, #36	; 0x24
   d6466:	f006 f95f 	bl	dc728 <_ZN6String6concatERKS_>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d646a:	a81a      	add	r0, sp, #104	; 0x68
   d646c:	f006 f85a 	bl	dc524 <_ZN6StringD1Ev>
   d6470:	a80d      	add	r0, sp, #52	; 0x34
   d6472:	f006 f857 	bl	dc524 <_ZN6StringD1Ev>
    if(offlineMode) {
   d6476:	4b37      	ldr	r3, [pc, #220]	; (d6554 <_Z7grabPic6String+0x424>)
   d6478:	781b      	ldrb	r3, [r3, #0]
   d647a:	b11b      	cbz	r3, d6484 <_Z7grabPic6String+0x354>
	unsigned char concat(double num);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
   d647c:	4936      	ldr	r1, [pc, #216]	; (d6558 <_Z7grabPic6String+0x428>)
   d647e:	a809      	add	r0, sp, #36	; 0x24
   d6480:	f006 f956 	bl	dc730 <_ZN6String6concatEPKc>
      dir += "TEMP";
    } 
    // On cre le dossier s'il n'existe pas
    Serial.println("dir:" + dir);
   d6484:	f007 fd0c 	bl	ddea0 <_Z16_fetch_usbserialv>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d6488:	4934      	ldr	r1, [pc, #208]	; (d655c <_Z7grabPic6String+0x42c>)
   d648a:	4604      	mov	r4, r0
   d648c:	a81a      	add	r0, sp, #104	; 0x68
   d648e:	f006 f890 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d6492:	a909      	add	r1, sp, #36	; 0x24
   d6494:	a81a      	add	r0, sp, #104	; 0x68
   d6496:	f006 f967 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d649a:	6801      	ldr	r1, [r0, #0]
   d649c:	4620      	mov	r0, r4
   d649e:	f006 fce4 	bl	dce6a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d64a2:	a81a      	add	r0, sp, #104	; 0x68
   d64a4:	f006 f83e 	bl	dc524 <_ZN6StringD1Ev>
      }

      // Methods to determine if the requested file path exists.
      bool exists(const char *filepath);
      bool exists(const String &filepath) {
        return exists(filepath.c_str());
   d64a8:	9909      	ldr	r1, [sp, #36]	; 0x24
   d64aa:	482d      	ldr	r0, [pc, #180]	; (d6560 <_Z7grabPic6String+0x430>)
   d64ac:	f005 f85e 	bl	db56c <_ZN5SDLib7SDClass6existsEPKc>
    if(!SD.exists(dir)){
   d64b0:	2800      	cmp	r0, #0
   d64b2:	d038      	beq.n	d6526 <_Z7grabPic6String+0x3f6>
       return false;
      } 
    } 

    // On gnre le nom de l'arborescence + le nom du fichier pour le crer au bon endroit
    String namePlusDir = "";
   d64b4:	4923      	ldr	r1, [pc, #140]	; (d6544 <_Z7grabPic6String+0x414>)
   d64b6:	a80d      	add	r0, sp, #52	; 0x34
   d64b8:	f006 f87b 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d64bc:	a909      	add	r1, sp, #36	; 0x24
   d64be:	a81a      	add	r0, sp, #104	; 0x68
   d64c0:	f006 f899 	bl	dc5f6 <_ZN6StringC1ERKS_>
    namePlusDir = dir + "/" + Short_filename;
   d64c4:	4922      	ldr	r1, [pc, #136]	; (d6550 <_Z7grabPic6String+0x420>)
   d64c6:	a81a      	add	r0, sp, #104	; 0x68
   d64c8:	f006 f95a 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d64cc:	4631      	mov	r1, r6
   d64ce:	f006 f94b 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d64d2:	4601      	mov	r1, r0
   d64d4:	a80d      	add	r0, sp, #52	; 0x34
   d64d6:	f006 f87f 	bl	dc5d8 <_ZN6StringaSERKS_>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d64da:	a81a      	add	r0, sp, #104	; 0x68
   d64dc:	f006 f822 	bl	dc524 <_ZN6StringD1Ev>
      // Open the specified file/directory with the supplied mode (e.g. read or
      // write, etc). Returns a File object for interacting with the file.
      // Note that currently only one file can be open at a time.
      File open(const char *filename, uint8_t mode = FILE_READ);
      File open(const String &filename, uint8_t mode = FILE_READ) {
        return open(filename.c_str(), mode);
   d64e0:	2352      	movs	r3, #82	; 0x52
   d64e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   d64e4:	491e      	ldr	r1, [pc, #120]	; (d6560 <_Z7grabPic6String+0x430>)
   d64e6:	a81a      	add	r0, sp, #104	; 0x68
   d64e8:	f004 fffc 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
    file = SD.open(namePlusDir, O_WRITE | O_CREAT | O_TRUNC);
   d64ec:	a91a      	add	r1, sp, #104	; 0x68
   d64ee:	a811      	add	r0, sp, #68	; 0x44
   d64f0:	f7fe fd86 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
    delay(10);
   d64f4:	200a      	movs	r0, #10
   d64f6:	f006 fe21 	bl	dd13c <delay>

    // Si on a pas russi  le crer, on dtruit l'image dans le buffer de la camra et on retourne en erreur
    if(!file){
   d64fa:	a811      	add	r0, sp, #68	; 0x44
   d64fc:	f004 f910 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d6500:	4604      	mov	r4, r0
   d6502:	bb78      	cbnz	r0, d6564 <_Z7grabPic6String+0x434>
      //log("open file failed: " + namePlusDir, 1,1);
      file.close();
   d6504:	a811      	add	r0, sp, #68	; 0x44
   d6506:	f004 f8ff 	bl	da708 <_ZN5SDLib4File5closeEv>
      //printNclearSDlogBuffer();
      myCAM.flush_fifo();
   d650a:	480b      	ldr	r0, [pc, #44]	; (d6538 <_Z7grabPic6String+0x408>)
   d650c:	f7fe fb60 	bl	d4bd0 <_ZN7ArduCAM10flush_fifoEv>
      delay(100);
   d6510:	2064      	movs	r0, #100	; 0x64
   d6512:	f006 fe13 	bl	dd13c <delay>
      myCAM.clear_fifo_flag();
   d6516:	4808      	ldr	r0, [pc, #32]	; (d6538 <_Z7grabPic6String+0x408>)
   d6518:	f7fe fb56 	bl	d4bc8 <_ZN7ArduCAM15clear_fifo_flagEv>
      delay(5000);
   d651c:	f241 3088 	movw	r0, #5000	; 0x1388
   d6520:	f006 fe0c 	bl	dd13c <delay>
      return false;
   d6524:	e1f5      	b.n	d6912 <_Z7grabPic6String+0x7e2>

      // Create the requested directory heirarchy--if intermediate directories
      // do not exist they will be created.
      bool mkdir(const char *filepath);
      bool mkdir(const String &filepath) {
        return mkdir(filepath.c_str());
   d6526:	9909      	ldr	r1, [sp, #36]	; 0x24
   d6528:	480d      	ldr	r0, [pc, #52]	; (d6560 <_Z7grabPic6String+0x430>)
   d652a:	f005 f82d 	bl	db588 <_ZN5SDLib7SDClass5mkdirEPKc>
    } 
    // On cre le dossier s'il n'existe pas
    Serial.println("dir:" + dir);
    if(!SD.exists(dir)){
       //log("Directory" + dir + "does not exist, trying to create it...", 3,1);
      if(!SD.mkdir(dir)){
   d652e:	2800      	cmp	r0, #0
   d6530:	d1c0      	bne.n	d64b4 <_Z7grabPic6String+0x384>
       //log("SD mkdir failed", 2,1);
       return false;
   d6532:	4604      	mov	r4, r0
   d6534:	e1f0      	b.n	d6918 <_Z7grabPic6String+0x7e8>
   d6536:	bf00      	nop
   d6538:	2003df08 	.word	0x2003df08
   d653c:	000e1e7a 	.word	0x000e1e7a
   d6540:	000e1e88 	.word	0x000e1e88
   d6544:	000e1eea 	.word	0x000e1eea
   d6548:	2003debc 	.word	0x2003debc
   d654c:	2003d6c4 	.word	0x2003d6c4
   d6550:	000e1afd 	.word	0x000e1afd
   d6554:	2003de98 	.word	0x2003de98
   d6558:	000e1e8c 	.word	0x000e1e8c
   d655c:	000e1e91 	.word	0x000e1e91
   d6560:	2003e3d4 	.word	0x2003e3d4
    }

    // Le fichier d'image doit commencer par 0xFF, trangement ce n'est pas dans le buffer de la camra
    //file.write(0xFF);

    CellularSignal sig = Cellular.RSSI();
   d6564:	49bc      	ldr	r1, [pc, #752]	; (d6858 <_Z7grabPic6String+0x728>)
    //Serial.write(Heurestr);
    //Serial.write(BDH);  
    //Serial.write(stationName);

    //file.write(buffer, tx_buffer_index);
    tx_buffer_index = 0;
   d6566:	4cbd      	ldr	r4, [pc, #756]	; (d685c <_Z7grabPic6String+0x72c>)
    Particle.process();     

    file.write(exif1,86);
    for (size_t i = 0; i <= 2054; i++) {
        file.write(n);
   d6568:	4ebd      	ldr	r6, [pc, #756]	; (d6860 <_Z7grabPic6String+0x730>)
    }

    // Le fichier d'image doit commencer par 0xFF, trangement ce n'est pas dans le buffer de la camra
    //file.write(0xFF);

    CellularSignal sig = Cellular.RSSI();
   d656a:	a81a      	add	r0, sp, #104	; 0x68
   d656c:	f007 fce2 	bl	ddf34 <_ZN5spark13CellularClass4RSSIEv>

    //Serial.println("Creating EXIF header");
    sprintf(Vbatstr, "%1.2f", fuel.getVCell());
   d6570:	48bc      	ldr	r0, [pc, #752]	; (d6864 <_Z7grabPic6String+0x734>)
   d6572:	f006 ff81 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d6576:	ee10 0a10 	vmov	r0, s0
   d657a:	f008 feab 	bl	df2d4 <__aeabi_f2d>
   d657e:	460b      	mov	r3, r1
   d6580:	4602      	mov	r2, r0
   d6582:	49b9      	ldr	r1, [pc, #740]	; (d6868 <_Z7grabPic6String+0x738>)
   d6584:	48b9      	ldr	r0, [pc, #740]	; (d686c <_Z7grabPic6String+0x73c>)
   d6586:	f005 fc2f 	bl	dbde8 <sprintf>
    //Serial.write(Vbatstr);
    sprintf(RSSIstr, "%2d", sig.rssi);
   d658a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   d658c:	49b8      	ldr	r1, [pc, #736]	; (d6870 <_Z7grabPic6String+0x740>)
   d658e:	48b9      	ldr	r0, [pc, #740]	; (d6874 <_Z7grabPic6String+0x744>)
   d6590:	f005 fc2a 	bl	dbde8 <sprintf>
    //Serial.write(RSSIstr);
    sprintf(Datestr, "%04d%02d%02d", now.year(),now.month(),now.day());
   d6594:	782a      	ldrb	r2, [r5, #0]
   d6596:	78a9      	ldrb	r1, [r5, #2]
   d6598:	786b      	ldrb	r3, [r5, #1]
   d659a:	48b7      	ldr	r0, [pc, #732]	; (d6878 <_Z7grabPic6String+0x748>)
   d659c:	9100      	str	r1, [sp, #0]
   d659e:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
   d65a2:	49b6      	ldr	r1, [pc, #728]	; (d687c <_Z7grabPic6String+0x74c>)
   d65a4:	f005 fc20 	bl	dbde8 <sprintf>
   // Serial.write(Datestr);
    sprintf(Heurestr, "%02d%02d%02d", now.hour(),now.minute(),now.second());
   d65a8:	7969      	ldrb	r1, [r5, #5]
   d65aa:	78ea      	ldrb	r2, [r5, #3]
   d65ac:	792b      	ldrb	r3, [r5, #4]
   d65ae:	48b4      	ldr	r0, [pc, #720]	; (d6880 <_Z7grabPic6String+0x750>)
   d65b0:	9100      	str	r1, [sp, #0]
   d65b2:	49b4      	ldr	r1, [pc, #720]	; (d6884 <_Z7grabPic6String+0x754>)
   d65b4:	f005 fc18 	bl	dbde8 <sprintf>
    //Serial.write(Heurestr);
    //Serial.write(BDH);  
    //Serial.write(stationName);

    //file.write(buffer, tx_buffer_index);
    tx_buffer_index = 0;
   d65b8:	2300      	movs	r3, #0
   d65ba:	6023      	str	r3, [r4, #0]
    Particle.process();     
   d65bc:	f7fe fc74 	bl	d4ea8 <_ZN10CloudClass7processEv>

    file.write(exif1,86);
   d65c0:	2256      	movs	r2, #86	; 0x56
   d65c2:	49b1      	ldr	r1, [pc, #708]	; (d6888 <_Z7grabPic6String+0x758>)
   d65c4:	a811      	add	r0, sp, #68	; 0x44
   d65c6:	f003 fff8 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
   d65ca:	f640 0707 	movw	r7, #2055	; 0x807
    for (size_t i = 0; i <= 2054; i++) {
        file.write(n);
   d65ce:	7831      	ldrb	r1, [r6, #0]
   d65d0:	4da3      	ldr	r5, [pc, #652]	; (d6860 <_Z7grabPic6String+0x730>)
   d65d2:	a811      	add	r0, sp, #68	; 0x44
   d65d4:	f003 ffe6 	bl	da5a4 <_ZN5SDLib4File5writeEh>
    //file.write(buffer, tx_buffer_index);
    tx_buffer_index = 0;
    Particle.process();     

    file.write(exif1,86);
    for (size_t i = 0; i <= 2054; i++) {
   d65d8:	3f01      	subs	r7, #1
   d65da:	d1f8      	bne.n	d65ce <_Z7grabPic6String+0x49e>
        file.write(n);
      }
    file.write(exif2,23);
   d65dc:	2217      	movs	r2, #23
   d65de:	49ab      	ldr	r1, [pc, #684]	; (d688c <_Z7grabPic6String+0x75c>)
   d65e0:	4eab      	ldr	r6, [pc, #684]	; (d6890 <_Z7grabPic6String+0x760>)
   d65e2:	a811      	add	r0, sp, #68	; 0x44
   d65e4:	f003 ffe9 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
   d65e8:	48aa      	ldr	r0, [pc, #680]	; (d6894 <_Z7grabPic6String+0x764>)

    int i = 0;
   for (indexer = Vbatindex1; indexer <= 6+Vbatindex1 ; indexer++) {
        exifInfo3[indexer] = Vbatstr[i];
   d65ea:	49ab      	ldr	r1, [pc, #684]	; (d6898 <_Z7grabPic6String+0x768>)
        file.write(n);
      }
    file.write(exif2,23);

    int i = 0;
   for (indexer = Vbatindex1; indexer <= 6+Vbatindex1 ; indexer++) {
   d65ec:	220a      	movs	r2, #10
        exifInfo3[indexer] = Vbatstr[i];
   d65ee:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   d65f2:	5453      	strb	r3, [r2, r1]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d65f4:	188b      	adds	r3, r1, r2
        file.write(n);
      }
    file.write(exif2,23);

    int i = 0;
   for (indexer = Vbatindex1; indexer <= 6+Vbatindex1 ; indexer++) {
   d65f6:	3202      	adds	r2, #2
   d65f8:	2a10      	cmp	r2, #16
        exifInfo3[indexer] = Vbatstr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d65fa:	705f      	strb	r7, [r3, #1]
   d65fc:	4ba6      	ldr	r3, [pc, #664]	; (d6898 <_Z7grabPic6String+0x768>)
        file.write(n);
      }
    file.write(exif2,23);

    int i = 0;
   for (indexer = Vbatindex1; indexer <= 6+Vbatindex1 ; indexer++) {
   d65fe:	ddf6      	ble.n	d65ee <_Z7grabPic6String+0x4be>
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = Vbatindex2; indexer <= 3+Vbatindex2 ; indexer++) {
        exifInfo5[indexer] = Vbatstr[i];
   d6600:	f8df c268 	ldr.w	ip, [pc, #616]	; d686c <_Z7grabPic6String+0x73c>
   d6604:	f8df e298 	ldr.w	lr, [pc, #664]	; d68a0 <_Z7grabPic6String+0x770>
        exifInfo7[indexer] = Vbatstr[i];
   d6608:	4fa4      	ldr	r7, [pc, #656]	; (d689c <_Z7grabPic6String+0x76c>)
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = Vbatindex2; indexer <= 3+Vbatindex2 ; indexer++) {
   d660a:	2215      	movs	r2, #21
        exifInfo5[indexer] = Vbatstr[i];
   d660c:	eb0c 0102 	add.w	r1, ip, r2
   d6610:	48a3      	ldr	r0, [pc, #652]	; (d68a0 <_Z7grabPic6String+0x770>)
   d6612:	f811 1c15 	ldrb.w	r1, [r1, #-21]
   d6616:	f802 100e 	strb.w	r1, [r2, lr]
        exifInfo7[indexer] = Vbatstr[i];
   d661a:	55d1      	strb	r1, [r2, r7]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = Vbatindex2; indexer <= 3+Vbatindex2 ; indexer++) {
   d661c:	3201      	adds	r2, #1
   d661e:	2a19      	cmp	r2, #25
   d6620:	499e      	ldr	r1, [pc, #632]	; (d689c <_Z7grabPic6String+0x76c>)
   d6622:	d1f3      	bne.n	d660c <_Z7grabPic6String+0x4dc>
   d6624:	4f9f      	ldr	r7, [pc, #636]	; (d68a4 <_Z7grabPic6String+0x774>)
        exifInfo7[indexer] = Vbatstr[i];
        i++;
      }
    
    i = 0;
    for (indexer = RSSIindex1; indexer <= 4+RSSIindex1 ; indexer++) {
   d6626:	221e      	movs	r2, #30
        exifInfo3[indexer] = RSSIstr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d6628:	f04f 0c00 	mov.w	ip, #0
        i++;
      }
    
    i = 0;
    for (indexer = RSSIindex1; indexer <= 4+RSSIindex1 ; indexer++) {
        exifInfo3[indexer] = RSSIstr[i];
   d662c:	f817 ef01 	ldrb.w	lr, [r7, #1]!
   d6630:	f803 e002 	strb.w	lr, [r3, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d6634:	eb03 0e02 	add.w	lr, r3, r2
        exifInfo7[indexer] = Vbatstr[i];
        i++;
      }
    
    i = 0;
    for (indexer = RSSIindex1; indexer <= 4+RSSIindex1 ; indexer++) {
   d6638:	3202      	adds	r2, #2
   d663a:	2a22      	cmp	r2, #34	; 0x22
        exifInfo3[indexer] = RSSIstr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d663c:	f88e c001 	strb.w	ip, [lr, #1]
        exifInfo7[indexer] = Vbatstr[i];
        i++;
      }
    
    i = 0;
    for (indexer = RSSIindex1; indexer <= 4+RSSIindex1 ; indexer++) {
   d6640:	ddf4      	ble.n	d662c <_Z7grabPic6String+0x4fc>
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = RSSIindex2; indexer <= 2+RSSIindex2 ; indexer++) {
        exifInfo5[indexer] = RSSIstr[i];
   d6642:	f8df e230 	ldr.w	lr, [pc, #560]	; d6874 <_Z7grabPic6String+0x744>
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = RSSIindex2; indexer <= 2+RSSIindex2 ; indexer++) {
   d6646:	223f      	movs	r2, #63	; 0x3f
        exifInfo5[indexer] = RSSIstr[i];
   d6648:	eb0e 0702 	add.w	r7, lr, r2
   d664c:	f817 7c3f 	ldrb.w	r7, [r7, #-63]
   d6650:	5487      	strb	r7, [r0, r2]
        exifInfo7[indexer] = RSSIstr[i];
   d6652:	548f      	strb	r7, [r1, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = RSSIindex2; indexer <= 2+RSSIindex2 ; indexer++) {
   d6654:	3201      	adds	r2, #1
   d6656:	2a42      	cmp	r2, #66	; 0x42
   d6658:	d1f6      	bne.n	d6648 <_Z7grabPic6String+0x518>
   d665a:	4f93      	ldr	r7, [pc, #588]	; (d68a8 <_Z7grabPic6String+0x778>)
        exifInfo7[indexer] = RSSIstr[i];
        i++;
      }      

    i = 0;
    for (indexer = DateIndex1; indexer <= 14+DateIndex1 ; indexer++) {
   d665c:	2230      	movs	r2, #48	; 0x30
        exifInfo3[indexer] = Datestr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d665e:	f04f 0c00 	mov.w	ip, #0
        i++;
      }      

    i = 0;
    for (indexer = DateIndex1; indexer <= 14+DateIndex1 ; indexer++) {
        exifInfo3[indexer] = Datestr[i];
   d6662:	f817 ef01 	ldrb.w	lr, [r7, #1]!
   d6666:	f803 e002 	strb.w	lr, [r3, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d666a:	eb03 0e02 	add.w	lr, r3, r2
        exifInfo7[indexer] = RSSIstr[i];
        i++;
      }      

    i = 0;
    for (indexer = DateIndex1; indexer <= 14+DateIndex1 ; indexer++) {
   d666e:	3202      	adds	r2, #2
   d6670:	2a3e      	cmp	r2, #62	; 0x3e
        exifInfo3[indexer] = Datestr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d6672:	f88e c001 	strb.w	ip, [lr, #1]
        exifInfo7[indexer] = RSSIstr[i];
        i++;
      }      

    i = 0;
    for (indexer = DateIndex1; indexer <= 14+DateIndex1 ; indexer++) {
   d6676:	ddf4      	ble.n	d6662 <_Z7grabPic6String+0x532>
        exifInfo3[indexer] = 0x00;
        i++;
      }   
    i = 0;
    for (indexer = DateIndex2; indexer <= 7+DateIndex2 ; indexer++) {
        exifInfo5[indexer] = Datestr[i];
   d6678:	f8df e1fc 	ldr.w	lr, [pc, #508]	; d6878 <_Z7grabPic6String+0x748>
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }   
    i = 0;
    for (indexer = DateIndex2; indexer <= 7+DateIndex2 ; indexer++) {
   d667c:	2268      	movs	r2, #104	; 0x68
        exifInfo5[indexer] = Datestr[i];
   d667e:	eb0e 0702 	add.w	r7, lr, r2
   d6682:	f817 7c68 	ldrb.w	r7, [r7, #-104]
   d6686:	5487      	strb	r7, [r0, r2]
        exifInfo7[indexer] = Datestr[i];
   d6688:	548f      	strb	r7, [r1, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }   
    i = 0;
    for (indexer = DateIndex2; indexer <= 7+DateIndex2 ; indexer++) {
   d668a:	3201      	adds	r2, #1
   d668c:	2a70      	cmp	r2, #112	; 0x70
   d668e:	d1f6      	bne.n	d667e <_Z7grabPic6String+0x54e>
   d6690:	4f86      	ldr	r7, [pc, #536]	; (d68ac <_Z7grabPic6String+0x77c>)
        exifInfo7[indexer] = Datestr[i];
        i++;
      }         

    i = 0;
    for (indexer = HeureIndex1; indexer <= 10+HeureIndex1 ; indexer++) {
   d6692:	224e      	movs	r2, #78	; 0x4e
        exifInfo3[indexer] = Heurestr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d6694:	f04f 0c00 	mov.w	ip, #0
        i++;
      }         

    i = 0;
    for (indexer = HeureIndex1; indexer <= 10+HeureIndex1 ; indexer++) {
        exifInfo3[indexer] = Heurestr[i];
   d6698:	f817 ef01 	ldrb.w	lr, [r7, #1]!
   d669c:	f803 e002 	strb.w	lr, [r3, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d66a0:	eb03 0e02 	add.w	lr, r3, r2
        exifInfo7[indexer] = Datestr[i];
        i++;
      }         

    i = 0;
    for (indexer = HeureIndex1; indexer <= 10+HeureIndex1 ; indexer++) {
   d66a4:	3202      	adds	r2, #2
   d66a6:	2a58      	cmp	r2, #88	; 0x58
        exifInfo3[indexer] = Heurestr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d66a8:	f88e c001 	strb.w	ip, [lr, #1]
        exifInfo7[indexer] = Datestr[i];
        i++;
      }         

    i = 0;
    for (indexer = HeureIndex1; indexer <= 10+HeureIndex1 ; indexer++) {
   d66ac:	ddf4      	ble.n	d6698 <_Z7grabPic6String+0x568>
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = HeureIndex2; indexer <= 5+HeureIndex2 ; indexer++) {
        exifInfo5[indexer] = Heurestr[i];
   d66ae:	f8df e1d0 	ldr.w	lr, [pc, #464]	; d6880 <_Z7grabPic6String+0x750>
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = HeureIndex2; indexer <= 5+HeureIndex2 ; indexer++) {
   d66b2:	2297      	movs	r2, #151	; 0x97
        exifInfo5[indexer] = Heurestr[i];
   d66b4:	eb0e 0702 	add.w	r7, lr, r2
   d66b8:	f817 7c97 	ldrb.w	r7, [r7, #-151]
   d66bc:	5487      	strb	r7, [r0, r2]
        exifInfo7[indexer] = Heurestr[i];
   d66be:	548f      	strb	r7, [r1, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      }
    i = 0;
    for (indexer = HeureIndex2; indexer <= 5+HeureIndex2 ; indexer++) {
   d66c0:	3201      	adds	r2, #1
   d66c2:	2a9d      	cmp	r2, #157	; 0x9d
   d66c4:	d1f6      	bne.n	d66b4 <_Z7grabPic6String+0x584>
        exifInfo7[indexer] = Heurestr[i];
        i++;
      }      

    i = 0;
    for (indexer = BDHIndex1; indexer <= 10+BDHIndex1 ; indexer++) {
   d66c6:	2264      	movs	r2, #100	; 0x64
   d66c8:	6032      	str	r2, [r6, #0]
   d66ca:	4a79      	ldr	r2, [pc, #484]	; (d68b0 <_Z7grabPic6String+0x780>)
   d66cc:	f8df 81c0 	ldr.w	r8, [pc, #448]	; d6890 <_Z7grabPic6String+0x760>
   d66d0:	6812      	ldr	r2, [r2, #0]
   d66d2:	f102 3eff 	add.w	lr, r2, #4294967295
   d66d6:	46f4      	mov	ip, lr
        exifInfo3[indexer] = BDH.c_str()[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d66d8:	f04f 0900 	mov.w	r9, #0
        exifInfo7[indexer] = Heurestr[i];
        i++;
      }      

    i = 0;
    for (indexer = BDHIndex1; indexer <= 10+BDHIndex1 ; indexer++) {
   d66dc:	6832      	ldr	r2, [r6, #0]
   d66de:	4f6c      	ldr	r7, [pc, #432]	; (d6890 <_Z7grabPic6String+0x760>)
   d66e0:	2a6e      	cmp	r2, #110	; 0x6e
   d66e2:	dc09      	bgt.n	d66f8 <_Z7grabPic6String+0x5c8>
        exifInfo3[indexer] = BDH.c_str()[i];
   d66e4:	f81c 7f01 	ldrb.w	r7, [ip, #1]!
   d66e8:	549f      	strb	r7, [r3, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d66ea:	189f      	adds	r7, r3, r2
        exifInfo7[indexer] = Heurestr[i];
        i++;
      }      

    i = 0;
    for (indexer = BDHIndex1; indexer <= 10+BDHIndex1 ; indexer++) {
   d66ec:	3202      	adds	r2, #2
        exifInfo3[indexer] = BDH.c_str()[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d66ee:	f887 9001 	strb.w	r9, [r7, #1]
        exifInfo7[indexer] = Heurestr[i];
        i++;
      }      

    i = 0;
    for (indexer = BDHIndex1; indexer <= 10+BDHIndex1 ; indexer++) {
   d66f2:	f8c8 2000 	str.w	r2, [r8]
   d66f6:	e7f1      	b.n	d66dc <_Z7grabPic6String+0x5ac>
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      } 
    i = 0;
     for (indexer = BDHIndex2; indexer <= 5+BDHIndex2 ; indexer++) {
   d66f8:	22c2      	movs	r2, #194	; 0xc2
   d66fa:	603a      	str	r2, [r7, #0]
   d66fc:	6832      	ldr	r2, [r6, #0]
   d66fe:	2ac7      	cmp	r2, #199	; 0xc7
   d6700:	dc09      	bgt.n	d6716 <_Z7grabPic6String+0x5e6>
        exifInfo5[indexer] = BDH.c_str()[i];
   d6702:	f81e cf01 	ldrb.w	ip, [lr, #1]!
   d6706:	f800 c002 	strb.w	ip, [r0, r2]
        exifInfo7[indexer] = BDH.c_str()[i];
   d670a:	f89e c000 	ldrb.w	ip, [lr]
   d670e:	f801 c002 	strb.w	ip, [r1, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      } 
    i = 0;
     for (indexer = BDHIndex2; indexer <= 5+BDHIndex2 ; indexer++) {
   d6712:	3201      	adds	r2, #1
   d6714:	e7f1      	b.n	d66fa <_Z7grabPic6String+0x5ca>
   d6716:	4f67      	ldr	r7, [pc, #412]	; (d68b4 <_Z7grabPic6String+0x784>)
        exifInfo7[indexer] = BDH.c_str()[i];
        i++;
      }      

    i = 0;     
   for (indexer = StationIndex1; indexer <= 8+StationIndex1 ; indexer++) {
   d6718:	2280      	movs	r2, #128	; 0x80
        exifInfo3[indexer] = Stationstr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d671a:	f04f 0c00 	mov.w	ip, #0
        i++;
      }      

    i = 0;     
   for (indexer = StationIndex1; indexer <= 8+StationIndex1 ; indexer++) {
        exifInfo3[indexer] = Stationstr[i];
   d671e:	f817 ef01 	ldrb.w	lr, [r7, #1]!
   d6722:	f803 e002 	strb.w	lr, [r3, r2]
        indexer++;
        exifInfo3[indexer] = 0x00;
   d6726:	eb03 0e02 	add.w	lr, r3, r2
        exifInfo7[indexer] = BDH.c_str()[i];
        i++;
      }      

    i = 0;     
   for (indexer = StationIndex1; indexer <= 8+StationIndex1 ; indexer++) {
   d672a:	3202      	adds	r2, #2
   d672c:	2a88      	cmp	r2, #136	; 0x88
        exifInfo3[indexer] = Stationstr[i];
        indexer++;
        exifInfo3[indexer] = 0x00;
   d672e:	f88e c001 	strb.w	ip, [lr, #1]
        exifInfo7[indexer] = BDH.c_str()[i];
        i++;
      }      

    i = 0;     
   for (indexer = StationIndex1; indexer <= 8+StationIndex1 ; indexer++) {
   d6732:	ddf4      	ble.n	d671e <_Z7grabPic6String+0x5ee>
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      } 
    i = 0;
    for (indexer = StationIndex2; indexer <= 5+StationIndex2 ; indexer++) {
   d6734:	23f0      	movs	r3, #240	; 0xf0
   d6736:	6033      	str	r3, [r6, #0]
   d6738:	4b5f      	ldr	r3, [pc, #380]	; (d68b8 <_Z7grabPic6String+0x788>)
   d673a:	4f55      	ldr	r7, [pc, #340]	; (d6890 <_Z7grabPic6String+0x760>)
   d673c:	681a      	ldr	r2, [r3, #0]
   d673e:	3a01      	subs	r2, #1
   d6740:	6833      	ldr	r3, [r6, #0]
   d6742:	2bf5      	cmp	r3, #245	; 0xf5
   d6744:	dc0a      	bgt.n	d675c <_Z7grabPic6String+0x62c>
        exifInfo5[indexer] = stationName.c_str()[i];
   d6746:	f812 ef01 	ldrb.w	lr, [r2, #1]!
   d674a:	f800 e003 	strb.w	lr, [r0, r3]
        exifInfo7[indexer] = stationName.c_str()[i];
   d674e:	f892 e000 	ldrb.w	lr, [r2]
   d6752:	f801 e003 	strb.w	lr, [r1, r3]
        indexer++;
        exifInfo3[indexer] = 0x00;
        i++;
      } 
    i = 0;
    for (indexer = StationIndex2; indexer <= 5+StationIndex2 ; indexer++) {
   d6756:	3301      	adds	r3, #1
   d6758:	603b      	str	r3, [r7, #0]
   d675a:	e7f1      	b.n	d6740 <_Z7grabPic6String+0x610>
        exifInfo5[indexer] = stationName.c_str()[i];
        exifInfo7[indexer] = stationName.c_str()[i];
        i++;
      }
    indexer = 0;
   d675c:	4b4c      	ldr	r3, [pc, #304]	; (d6890 <_Z7grabPic6String+0x760>)
   d675e:	2200      	movs	r2, #0
   d6760:	601a      	str	r2, [r3, #0]
   d6762:	f640 0608 	movw	r6, #2056	; 0x808

    for (size_t j = 0; j <= 2055; j++) {
      file.write(n);
   d6766:	7829      	ldrb	r1, [r5, #0]
   d6768:	a811      	add	r0, sp, #68	; 0x44
   d676a:	f003 ff1b 	bl	da5a4 <_ZN5SDLib4File5writeEh>
        exifInfo7[indexer] = stationName.c_str()[i];
        i++;
      }
    indexer = 0;

    for (size_t j = 0; j <= 2055; j++) {
   d676e:	3e01      	subs	r6, #1
   d6770:	d1f9      	bne.n	d6766 <_Z7grabPic6String+0x636>
      file.write(n);
    }   
    file.write(exifInfo3,138);
   d6772:	228a      	movs	r2, #138	; 0x8a
   d6774:	4948      	ldr	r1, [pc, #288]	; (d6898 <_Z7grabPic6String+0x768>)
    file.write(exifInfo5,245);
    file.write(exif6,288);
    file.write(exifInfo7,245);
    file.write(exif8,98);
    for (size_t i = 0; i <= 2047; i++) {
      file.write(n2);
   d6776:	4e51      	ldr	r6, [pc, #324]	; (d68bc <_Z7grabPic6String+0x78c>)
    indexer = 0;

    for (size_t j = 0; j <= 2055; j++) {
      file.write(n);
    }   
    file.write(exifInfo3,138);
   d6778:	a811      	add	r0, sp, #68	; 0x44
   d677a:	f003 ff1e 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    file.write(exif4,637);                              
   d677e:	f240 227d 	movw	r2, #637	; 0x27d
   d6782:	494f      	ldr	r1, [pc, #316]	; (d68c0 <_Z7grabPic6String+0x790>)
   d6784:	a811      	add	r0, sp, #68	; 0x44
   d6786:	f003 ff18 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    file.write(exifInfo5,245);
   d678a:	22f5      	movs	r2, #245	; 0xf5
   d678c:	4944      	ldr	r1, [pc, #272]	; (d68a0 <_Z7grabPic6String+0x770>)
   d678e:	a811      	add	r0, sp, #68	; 0x44
   d6790:	f003 ff13 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    file.write(exif6,288);
   d6794:	f44f 7290 	mov.w	r2, #288	; 0x120
   d6798:	494a      	ldr	r1, [pc, #296]	; (d68c4 <_Z7grabPic6String+0x794>)
   d679a:	a811      	add	r0, sp, #68	; 0x44
   d679c:	f003 ff0d 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    file.write(exifInfo7,245);
   d67a0:	22f5      	movs	r2, #245	; 0xf5
   d67a2:	493e      	ldr	r1, [pc, #248]	; (d689c <_Z7grabPic6String+0x76c>)
   d67a4:	a811      	add	r0, sp, #68	; 0x44
   d67a6:	f003 ff08 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    file.write(exif8,98);
   d67aa:	2262      	movs	r2, #98	; 0x62
   d67ac:	4946      	ldr	r1, [pc, #280]	; (d68c8 <_Z7grabPic6String+0x798>)
   d67ae:	a811      	add	r0, sp, #68	; 0x44
   d67b0:	f003 ff03 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
   d67b4:	f44f 6500 	mov.w	r5, #2048	; 0x800
    for (size_t i = 0; i <= 2047; i++) {
      file.write(n2);
   d67b8:	7831      	ldrb	r1, [r6, #0]
   d67ba:	a811      	add	r0, sp, #68	; 0x44
   d67bc:	f003 fef2 	bl	da5a4 <_ZN5SDLib4File5writeEh>
    file.write(exif4,637);                              
    file.write(exifInfo5,245);
    file.write(exif6,288);
    file.write(exifInfo7,245);
    file.write(exif8,98);
    for (size_t i = 0; i <= 2047; i++) {
   d67c0:	3d01      	subs	r5, #1
   d67c2:	d1f9      	bne.n	d67b8 <_Z7grabPic6String+0x688>
      file.write(n2);
    }          
    file.write(exif9,20);
   d67c4:	2214      	movs	r2, #20
   d67c6:	4941      	ldr	r1, [pc, #260]	; (d68cc <_Z7grabPic6String+0x79c>)
   d67c8:	a811      	add	r0, sp, #68	; 0x44
   d67ca:	f003 fef6 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    
    Serial.println(" Exif injection done");    
   d67ce:	f007 fb67 	bl	ddea0 <_Z16_fetch_usbserialv>
   d67d2:	493f      	ldr	r1, [pc, #252]	; (d68d0 <_Z7grabPic6String+0x7a0>)
   d67d4:	f006 fb49 	bl	dce6a <_ZN5Print7printlnEPKc>

    //On s'adresse maintenant  la camra
    myCAM.CS_LOW();
   d67d8:	483e      	ldr	r0, [pc, #248]	; (d68d4 <_Z7grabPic6String+0x7a4>)
   d67da:	f7fd ff31 	bl	d4640 <_ZN7ArduCAM6CS_LOWEv>
    delay(10);
   d67de:	200a      	movs	r0, #10
   d67e0:	f006 fcac 	bl	dd13c <delay>
    //log("Capture Done.", 4);
    Particle.publish("status", "Capture done");
   d67e4:	4a3c      	ldr	r2, [pc, #240]	; (d68d8 <_Z7grabPic6String+0x7a8>)
   d67e6:	493d      	ldr	r1, [pc, #244]	; (d68dc <_Z7grabPic6String+0x7ac>)
   d67e8:	a803      	add	r0, sp, #12
   d67ea:	f7fe fa45 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d67ee:	a804      	add	r0, sp, #16
   d67f0:	f7ff fa0c 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    // On veut lire l'image dans le buffer bit par bit
    myCAM.set_fifo_burst();
   d67f4:	4837      	ldr	r0, [pc, #220]	; (d68d4 <_Z7grabPic6String+0x7a4>)
   d67f6:	f7fe f93a 	bl	d4a6e <_ZN7ArduCAM14set_fifo_burstEv>
    delay(10);
   d67fa:	200a      	movs	r0, #10
   d67fc:	f006 fc9e 	bl	dd13c <delay>

    tx_buffer_index = 0;
   d6800:	6025      	str	r5, [r4, #0]
   d6802:	2514      	movs	r5, #20
//    temp = 0;
      for (size_t i = 0; i < 20; i++)
    {
      temp = myCAM.read_fifo();
   d6804:	4833      	ldr	r0, [pc, #204]	; (d68d4 <_Z7grabPic6String+0x7a4>)
   d6806:	f7fe f973 	bl	d4af0 <_ZN7ArduCAM9read_fifoEv>
    myCAM.set_fifo_burst();
    delay(10);

    tx_buffer_index = 0;
//    temp = 0;
      for (size_t i = 0; i < 20; i++)
   d680a:	3d01      	subs	r5, #1
    {
      temp = myCAM.read_fifo();
   d680c:	4606      	mov	r6, r0
    myCAM.set_fifo_burst();
    delay(10);

    tx_buffer_index = 0;
//    temp = 0;
      for (size_t i = 0; i < 20; i++)
   d680e:	d1f9      	bne.n	d6804 <_Z7grabPic6String+0x6d4>
   d6810:	4c33      	ldr	r4, [pc, #204]	; (d68e0 <_Z7grabPic6String+0x7b0>)
   d6812:	4f12      	ldr	r7, [pc, #72]	; (d685c <_Z7grabPic6String+0x72c>)
    {
      
      temp_last = temp;
      temp = myCAM.read_fifo(); // Le fifo est la stack de mmoire du buffer de la camra, first in first out
      bytesRead++;
      buffer[tx_buffer_index++] = temp; // on crit octets par octets
   d6814:	f8df 90cc 	ldr.w	r9, [pc, #204]	; d68e4 <_Z7grabPic6String+0x7b4>
    }   

    //delay(10);
    // Tant que les deux derniers octets ne sont pas 0xFF et 0xD9, nous ne sommes pas  la fin du fichier
    // 0xFF et 0xD9 sont les marqueurs standards de la fin d'un JPG
    while( (temp != 0xD9) || (temp_last != 0xFF) )
   d6818:	2ed9      	cmp	r6, #217	; 0xd9
   d681a:	d101      	bne.n	d6820 <_Z7grabPic6String+0x6f0>
   d681c:	2dff      	cmp	r5, #255	; 0xff
   d681e:	d063      	beq.n	d68e8 <_Z7grabPic6String+0x7b8>
    //while(bytesRead< length-20)
    {
      
      temp_last = temp;
      temp = myCAM.read_fifo(); // Le fifo est la stack de mmoire du buffer de la camra, first in first out
   d6820:	482c      	ldr	r0, [pc, #176]	; (d68d4 <_Z7grabPic6String+0x7a4>)
   d6822:	f7fe f965 	bl	d4af0 <_ZN7ArduCAM9read_fifoEv>
      bytesRead++;
      buffer[tx_buffer_index++] = temp; // on crit octets par octets
   d6826:	683b      	ldr	r3, [r7, #0]
   d6828:	1c5a      	adds	r2, r3, #1

      // Si on a rempli le buffer, on le vide dans le fichier de la carte SD
      if (tx_buffer_index >= TX_BUFFER_MAX) {
   d682a:	2aff      	cmp	r2, #255	; 0xff
    while( (temp != 0xD9) || (temp_last != 0xFF) )
    //while(bytesRead< length-20)
    {
      
      temp_last = temp;
      temp = myCAM.read_fifo(); // Le fifo est la stack de mmoire du buffer de la camra, first in first out
   d682c:	4680      	mov	r8, r0
      bytesRead++;
      buffer[tx_buffer_index++] = temp; // on crit octets par octets
   d682e:	603a      	str	r2, [r7, #0]
   d6830:	f809 0003 	strb.w	r0, [r9, r3]

      // Si on a rempli le buffer, on le vide dans le fichier de la carte SD
      if (tx_buffer_index >= TX_BUFFER_MAX) {
   d6834:	dd07      	ble.n	d6846 <_Z7grabPic6String+0x716>
          file.write(buffer, tx_buffer_index);
   d6836:	492b      	ldr	r1, [pc, #172]	; (d68e4 <_Z7grabPic6String+0x7b4>)
   d6838:	a811      	add	r0, sp, #68	; 0x44
   d683a:	f003 febe 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
          tx_buffer_index = 0;
   d683e:	2300      	movs	r3, #0
   d6840:	603b      	str	r3, [r7, #0]
          Particle.process();
   d6842:	f7fe fb31 	bl	d4ea8 <_ZN10CloudClass7processEv>
      }
      // Aprs un certain nombre d'octets, il y a un problme
      if (bytesRead > 600000) {
   d6846:	3c01      	subs	r4, #1
   d6848:	4635      	mov	r5, r6
   d684a:	d001      	beq.n	d6850 <_Z7grabPic6String+0x720>
    while( (temp != 0xD9) || (temp_last != 0xFF) )
    //while(bytesRead< length-20)
    {
      
      temp_last = temp;
      temp = myCAM.read_fifo(); // Le fifo est la stack de mmoire du buffer de la camra, first in first out
   d684c:	4646      	mov	r6, r8
   d684e:	e7e3      	b.n	d6818 <_Z7grabPic6String+0x6e8>
          Particle.process();
      }
      // Aprs un certain nombre d'octets, il y a un problme
      if (bytesRead > 600000) {
          // failsafe
          file.close();
   d6850:	a811      	add	r0, sp, #68	; 0x44
   d6852:	f003 ff59 	bl	da708 <_ZN5SDLib4File5closeEv>
          return 0;
   d6856:	e05c      	b.n	d6912 <_Z7grabPic6String+0x7e2>
   d6858:	2003e4c0 	.word	0x2003e4c0
   d685c:	2003de9c 	.word	0x2003de9c
   d6860:	2003dea2 	.word	0x2003dea2
   d6864:	2003deb4 	.word	0x2003deb4
   d6868:	000e1e96 	.word	0x000e1e96
   d686c:	2003df00 	.word	0x2003df00
   d6870:	000e1e9c 	.word	0x000e1e9c
   d6874:	2003deed 	.word	0x2003deed
   d6878:	2003df14 	.word	0x2003df14
   d687c:	000e1ea0 	.word	0x000e1ea0
   d6880:	2003dd40 	.word	0x2003dd40
   d6884:	000e1ead 	.word	0x000e1ead
   d6888:	000e1651 	.word	0x000e1651
   d688c:	000e163a 	.word	0x000e163a
   d6890:	2003df3c 	.word	0x2003df3c
   d6894:	2003deff 	.word	0x2003deff
   d6898:	2003d8b7 	.word	0x2003d8b7
   d689c:	2003d943 	.word	0x2003d943
   d68a0:	2003d7c1 	.word	0x2003d7c1
   d68a4:	2003deec 	.word	0x2003deec
   d68a8:	2003df13 	.word	0x2003df13
   d68ac:	2003dd3f 	.word	0x2003dd3f
   d68b0:	2003df78 	.word	0x2003df78
   d68b4:	2003df63 	.word	0x2003df63
   d68b8:	2003dea4 	.word	0x2003dea4
   d68bc:	2003d7c0 	.word	0x2003d7c0
   d68c0:	000e16a7 	.word	0x000e16a7
   d68c4:	000e1924 	.word	0x000e1924
   d68c8:	000e1a58 	.word	0x000e1a58
   d68cc:	000e1a44 	.word	0x000e1a44
   d68d0:	000e1eba 	.word	0x000e1eba
   d68d4:	2003df08 	.word	0x2003df08
   d68d8:	000e1ecf 	.word	0x000e1ecf
   d68dc:	000e1dcc 	.word	0x000e1dcc
   d68e0:	000927c1 	.word	0x000927c1
   d68e4:	2003e2ac 	.word	0x2003e2ac
      }
    }

    // Il reste des octets dans le buffer, on vide le tout dans le fichier
    if (tx_buffer_index != 0) {
   d68e8:	4b12      	ldr	r3, [pc, #72]	; (d6934 <_Z7grabPic6String+0x804>)
   d68ea:	681a      	ldr	r2, [r3, #0]
   d68ec:	b11a      	cbz	r2, d68f6 <_Z7grabPic6String+0x7c6>
        file.write(buffer, tx_buffer_index);
   d68ee:	4912      	ldr	r1, [pc, #72]	; (d6938 <_Z7grabPic6String+0x808>)
   d68f0:	a811      	add	r0, sp, #68	; 0x44
   d68f2:	f003 fe62 	bl	da5ba <_ZN5SDLib4File5writeEPKhj>
    }          
    // On a finit avec le fifo, on le libre
    myCAM.clear_fifo_flag();
   d68f6:	4811      	ldr	r0, [pc, #68]	; (d693c <_Z7grabPic6String+0x80c>)
   d68f8:	f7fe f966 	bl	d4bc8 <_ZN7ArduCAM15clear_fifo_flagEv>
    myCAM.CS_HIGH();
   d68fc:	480f      	ldr	r0, [pc, #60]	; (d693c <_Z7grabPic6String+0x80c>)
   d68fe:	f7fd fe91 	bl	d4624 <_ZN7ArduCAM7CS_HIGHEv>

    // On ferme le fichier 
    file.close();
   d6902:	a811      	add	r0, sp, #68	; 0x44
   d6904:	f003 ff00 	bl	da708 <_ZN5SDLib4File5closeEv>

    //printNclearSDlogBuffer();

    //On teint la camra pour conomiser le plus d'nergie possible
    digitalWrite(Cam_on, LOW);
   d6908:	2100      	movs	r1, #0
   d690a:	2013      	movs	r0, #19
   d690c:	f008 f921 	bl	deb52 <digitalWrite>

    return 1;
   d6910:	2401      	movs	r4, #1
       return false;
      } 
    } 

    // On gnre le nom de l'arborescence + le nom du fichier pour le crer au bon endroit
    String namePlusDir = "";
   d6912:	a80d      	add	r0, sp, #52	; 0x34
   d6914:	f005 fe06 	bl	dc524 <_ZN6StringD1Ev>
  {
    //d'autres variables temporaires
    byte buf[256];
    //uint8_t temp, temp_last;
    File file;
    String dir;
   d6918:	a809      	add	r0, sp, #36	; 0x24
   d691a:	f005 fe03 	bl	dc524 <_ZN6StringD1Ev>
   d691e:	a805      	add	r0, sp, #20
   d6920:	f005 fe00 	bl	dc524 <_ZN6StringD1Ev>
   d6924:	4620      	mov	r0, r4
   d6926:	e002      	b.n	d692e <_Z7grabPic6String+0x7fe>
  log("Is " + String(length), 4);

  //Variables temporaires
  temp = 0xff, temp_last = 0;
  int bytesRead = 0;
  String Pic = "";
   d6928:	a805      	add	r0, sp, #20
   d692a:	f005 fdfb 	bl	dc524 <_ZN6StringD1Ev>
    //On teint la camra pour conomiser le plus d'nergie possible
    digitalWrite(Cam_on, LOW);

    return 1;
  }
}
   d692e:	b025      	add	sp, #148	; 0x94
   d6930:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d6934:	2003de9c 	.word	0x2003de9c
   d6938:	2003e2ac 	.word	0x2003e2ac
   d693c:	2003df08 	.word	0x2003df08

000d6940 <_ZN17particleftpclient17ParticleFtpClientD1Ev>:
#include <time.h>
//#define PARTICLE_FTP_DEBUG
#define RESPONSE_BUFFER_SIZE 270

namespace particleftpclient {
  class ParticleFtpClient {
   d6940:	b538      	push	{r3, r4, r5, lr}
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
   d6942:	4d06      	ldr	r5, [pc, #24]	; (d695c <_ZN17particleftpclient17ParticleFtpClientD1Ev+0x1c>)
   d6944:	61c5      	str	r5, [r0, #28]
   d6946:	4604      	mov	r4, r0
   d6948:	3034      	adds	r0, #52	; 0x34
   d694a:	f7ff f95f 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d694e:	4620      	mov	r0, r4
   d6950:	f840 5b18 	str.w	r5, [r0], #24
   d6954:	f7ff f95a 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d6958:	4620      	mov	r0, r4
   d695a:	bd38      	pop	{r3, r4, r5, pc}
   d695c:	000e288c 	.word	0x000e288c

000d6960 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_>:
  }
  return 0;
}

template <typename TAdaptedString>
inline VariantData* CollectionData::get(TAdaptedString key) const {
   d6960:	b538      	push	{r3, r4, r5, lr}
   d6962:	6804      	ldr	r4, [r0, #0]
   d6964:	460d      	mov	r5, r1
}

template <typename TAdaptedString>
inline VariantSlot* CollectionData::getSlot(TAdaptedString key) const {
  VariantSlot* slot = _head;
  while (slot) {
   d6966:	b17c      	cbz	r4, d6988 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x28>
   d6968:	68e1      	ldr	r1, [r4, #12]
#include <ArduinoJson/Namespace.hpp>

namespace ARDUINOJSON_NAMESPACE {

inline int8_t safe_strcmp(const char* a, const char* b) {
  if (a == b) return 0;
   d696a:	42a9      	cmp	r1, r5
   d696c:	d00c      	beq.n	d6988 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x28>
  if (!a) return -1;
   d696e:	b135      	cbz	r5, d697e <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x1e>
  if (!b) return 1;
   d6970:	b129      	cbz	r1, d697e <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x1e>
  return static_cast<int8_t>(strcmp(a, b));
   d6972:	4628      	mov	r0, r5
   d6974:	f009 fb36 	bl	dffe4 <strcmp>
    if (key.equals(slot->key())) break;
   d6978:	f010 0fff 	tst.w	r0, #255	; 0xff
   d697c:	d004      	beq.n	d6988 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x28>
    slot = slot->next();
   d697e:	4620      	mov	r0, r4
   d6980:	f7fe fa99 	bl	d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>
   d6984:	4604      	mov	r4, r0
   d6986:	e7ee      	b.n	d6966 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_+0x6>

template <typename TAdaptedString>
inline VariantData* CollectionData::get(TAdaptedString key) const {
  VariantSlot* slot = getSlot(key);
  return slot ? slot->data() : 0;
}
   d6988:	4620      	mov	r0, r4
   d698a:	bd38      	pop	{r3, r4, r5, pc}

000d698c <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev>:
class StaticJsonDocument : public JsonDocument {
  static const size_t _capacity =
      AddPadding<Max<1, desiredCapacity>::value>::value;

 public:
  StaticJsonDocument() : JsonDocument(_buffer, _capacity) {}
   d698c:	b508      	push	{r3, lr}
   d698e:	f100 031c 	add.w	r3, r0, #28
   d6992:	4602      	mov	r2, r0
 public:
  MemoryPool(char* buf, size_t capa)
      : _begin(buf),
        _left(buf),
        _right(buf ? buf + capa : 0),
        _end(buf ? buf + capa : 0) {
   d6994:	6003      	str	r3, [r0, #0]
   d6996:	6043      	str	r3, [r0, #4]
   d6998:	b113      	cbz	r3, d69a0 <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev+0x14>
   d699a:	f500 7107 	add.w	r1, r0, #540	; 0x21c
   d699e:	e000      	b.n	d69a2 <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev+0x16>
   d69a0:	4619      	mov	r1, r3
   d69a2:	6091      	str	r1, [r2, #8]
   d69a4:	b10b      	cbz	r3, d69aa <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev+0x1e>
   d69a6:	f502 7307 	add.w	r3, r2, #540	; 0x21c
      setType(VALUE_IS_NULL);
    }
  }

  void setNull() {
    setType(VALUE_IS_NULL);
   d69aa:	f102 0018 	add.w	r0, r2, #24
   d69ae:	60d3      	str	r3, [r2, #12]
   d69b0:	2100      	movs	r1, #0
   d69b2:	f7fe f95b 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
   d69b6:	4610      	mov	r0, r2
   d69b8:	bd08      	pop	{r3, pc}

000d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>:
  var->setOwnedString(value);
  return true;
}

template <typename T>
inline bool variantSetOwnedString(VariantData *var, T value, MemoryPool *pool) {
   d69ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return var != 0 && var->setOwnedString(value, pool);
   d69bc:	4604      	mov	r4, r0
   d69be:	b1c0      	cbz	r0, d69f2 <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE+0x38>
class ArduinoStringAdapter {
 public:
  ArduinoStringAdapter(const ::String& str) : _str(&str) {}

  char* save(MemoryPool* pool) const {
    if (isNull()) return NULL;
   d69c0:	680b      	ldr	r3, [r1, #0]
   d69c2:	f100 0608 	add.w	r6, r0, #8
   d69c6:	b1ab      	cbz	r3, d69f4 <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE+0x3a>
    size_t n = _str->length() + 1;
   d69c8:	688b      	ldr	r3, [r1, #8]
    _left = _begin;
    _right = _end;
  }

  bool canAlloc(size_t bytes) const {
    return _left + bytes <= _right;
   d69ca:	6855      	ldr	r5, [r2, #4]
  VariantSlot* allocVariant() {
    return allocRight<VariantSlot>();
  }

  char* allocFrozenString(size_t n) {
    if (!canAlloc(n)) return 0;
   d69cc:	6897      	ldr	r7, [r2, #8]
   d69ce:	3301      	adds	r3, #1
    _left = _begin;
    _right = _end;
  }

  bool canAlloc(size_t bytes) const {
    return _left + bytes <= _right;
   d69d0:	18e8      	adds	r0, r5, r3
  VariantSlot* allocVariant() {
    return allocRight<VariantSlot>();
  }

  char* allocFrozenString(size_t n) {
    if (!canAlloc(n)) return 0;
   d69d2:	42b8      	cmp	r0, r7
   d69d4:	d80e      	bhi.n	d69f4 <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE+0x3a>
    char* s = _left;
    _left += n;
   d69d6:	6050      	str	r0, [r2, #4]
    char* dup = pool->allocFrozenString(n);
    if (dup) memcpy(dup, _str->c_str(), n);
   d69d8:	b165      	cbz	r5, d69f4 <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE+0x3a>
   d69da:	461a      	mov	r2, r3
   d69dc:	6809      	ldr	r1, [r1, #0]
   d69de:	4628      	mov	r0, r5
   d69e0:	f009 fab7 	bl	dff52 <memcpy>
  }

  void setOwnedString(not_null<const char *> s) {
    setType(VALUE_IS_OWNED_STRING);
   d69e4:	4630      	mov	r0, r6
   d69e6:	2105      	movs	r1, #5
   d69e8:	f7fe f940 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asString = s.get();
   d69ec:	6025      	str	r5, [r4, #0]
   d69ee:	2001      	movs	r0, #1
   d69f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d69f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  bool setOwnedString(const char *s) {
    if (s) {
      setOwnedString(make_not_null(s));
      return true;
    } else {
      setType(VALUE_IS_NULL);
   d69f4:	4630      	mov	r0, r6
   d69f6:	2100      	movs	r1, #0
   d69f8:	f7fe f938 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
   d69fc:	2000      	movs	r0, #0
}
   d69fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000d6a00 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_>:
                               MemoryPool *pool) {
  return var != 0 && var->setOwnedRaw(value, pool);
}

template <typename T>
inline bool variantSetSignedInteger(VariantData *var, T value) {
   d6a00:	b510      	push	{r4, lr}
  if (!var) return false;
   d6a02:	4602      	mov	r2, r0
                               MemoryPool *pool) {
  return var != 0 && var->setOwnedRaw(value, pool);
}

template <typename T>
inline bool variantSetSignedInteger(VariantData *var, T value) {
   d6a04:	460c      	mov	r4, r1
  if (!var) return false;
   d6a06:	b170      	cbz	r0, d6a26 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_+0x26>
    setSignedInteger(value);
  }

  template <typename T>
  void setSignedInteger(T value) {
    if (value >= 0) {
   d6a08:	2900      	cmp	r1, #0
   d6a0a:	f100 0008 	add.w	r0, r0, #8
   d6a0e:	db03      	blt.n	d6a18 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_+0x18>
      setNegativeInteger(~static_cast<UInt>(value) + 1);
    }
  }

  void setPositiveInteger(UInt value) {
    setType(VALUE_IS_POSITIVE_INTEGER);
   d6a10:	2108      	movs	r1, #8
   d6a12:	f7fe f92b 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
   d6a16:	e003      	b.n	d6a20 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_+0x20>
    _content.asInteger = value;
  }

  void setNegativeInteger(UInt value) {
    setType(VALUE_IS_NEGATIVE_INTEGER);
   d6a18:	210a      	movs	r1, #10
   d6a1a:	f7fe f927 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asInteger = value;
   d6a1e:	4264      	negs	r4, r4
   d6a20:	6014      	str	r4, [r2, #0]
  var->setSignedInteger(value);
  return true;
   d6a22:	2001      	movs	r0, #1
   d6a24:	bd10      	pop	{r4, pc}
}
   d6a26:	bd10      	pop	{r4, pc}

000d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>:
  VariantData *getMember(TAdaptedString key) const {
    return isObject() ? _content.asCollection.get(key) : 0;
  }

  template <typename TAdaptedString>
  VariantData *getOrAddMember(TAdaptedString key, MemoryPool *pool) {
   d6a28:	b570      	push	{r4, r5, r6, lr}
   d6a2a:	4616      	mov	r6, r2
    if (isNull()) toObject();
   d6a2c:	7a02      	ldrb	r2, [r0, #8]
   d6a2e:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
  VariantData *getMember(TAdaptedString key) const {
    return isObject() ? _content.asCollection.get(key) : 0;
  }

  template <typename TAdaptedString>
  VariantData *getOrAddMember(TAdaptedString key, MemoryPool *pool) {
   d6a32:	4604      	mov	r4, r0
   d6a34:	460d      	mov	r5, r1
    if (isNull()) toObject();
   d6a36:	d105      	bne.n	d6a44 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE+0x1c>
    _content.asCollection.clear();
    return _content.asCollection;
  }

  CollectionData &toObject() {
    setType(VALUE_IS_OBJECT);
   d6a38:	2120      	movs	r1, #32
   d6a3a:	3008      	adds	r0, #8
   d6a3c:	f7fe f916 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
  if (!slotSetKey(slot, key, pool)) return 0;
  return slot->data();
}

inline void CollectionData::clear() {
  _head = 0;
   d6a40:	6022      	str	r2, [r4, #0]
  _tail = 0;
   d6a42:	6062      	str	r2, [r4, #4]
  }

  template <typename TAdaptedString>
  VariantData *getOrAddMember(TAdaptedString key, MemoryPool *pool) {
    if (isNull()) toObject();
    if (!isObject()) return 0;
   d6a44:	7a23      	ldrb	r3, [r4, #8]
   d6a46:	f003 0320 	and.w	r3, r3, #32
   d6a4a:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   d6a4e:	b173      	cbz	r3, d6a6e <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE+0x46>
    VariantData *var = _content.asCollection.get(key);
   d6a50:	4629      	mov	r1, r5
   d6a52:	4620      	mov	r0, r4
   d6a54:	f7ff ff84 	bl	d6960 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_>
    if (var) return var;
   d6a58:	b948      	cbnz	r0, d6a6e <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE+0x46>
  return slotData(addSlot(pool));
}

template <typename TAdaptedString>
inline VariantData* CollectionData::add(TAdaptedString key, MemoryPool* pool) {
  VariantSlot* slot = addSlot(pool);
   d6a5a:	4631      	mov	r1, r6
   d6a5c:	4620      	mov	r0, r4
   d6a5e:	f7fe fa32 	bl	d4ec6 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE>

namespace ARDUINOJSON_NAMESPACE {

template <typename TAdaptedString>
inline bool slotSetKey(VariantSlot* var, TAdaptedString key, MemoryPool* pool) {
  if (!var) return false;
   d6a62:	b120      	cbz	r0, d6a6e <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE+0x46>
    _flags |= KEY_IS_OWNED;
    _key = k.get();
  }

  void setLinkedKey(not_null<const char*> k) {
    _flags &= VALUE_MASK;
   d6a64:	7a03      	ldrb	r3, [r0, #8]
    _key = k.get();
   d6a66:	60c5      	str	r5, [r0, #12]
    _flags |= KEY_IS_OWNED;
    _key = k.get();
  }

  void setLinkedKey(not_null<const char*> k) {
    _flags &= VALUE_MASK;
   d6a68:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d6a6c:	7203      	strb	r3, [r0, #8]
    return _content.asCollection.add(key, pool);
  }
   d6a6e:	bd70      	pop	{r4, r5, r6, pc}

000d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>:
  }

 private:
  JsonDeserializer &operator=(const JsonDeserializer &);  // non-copiable

  char current() {
   d6a70:	b513      	push	{r0, r1, r4, lr}
    if (!_loaded) {
   d6a72:	7b83      	ldrb	r3, [r0, #14]
  }

 private:
  JsonDeserializer &operator=(const JsonDeserializer &);  // non-copiable

  char current() {
   d6a74:	4604      	mov	r4, r0
    if (!_loaded) {
   d6a76:	b983      	cbnz	r3, d6a9a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv+0x2a>
  explicit Reader(Stream& stream) : _stream(&stream) {}

  int read() {
    // don't use _stream.read() as it ignores the timeout
    char c;
    return _stream->readBytes(&c, 1) ? static_cast<unsigned char>(c) : -1;
   d6a78:	2201      	movs	r2, #1
   d6a7a:	f10d 0107 	add.w	r1, sp, #7
   d6a7e:	6840      	ldr	r0, [r0, #4]
   d6a80:	f006 fa6c 	bl	dcf5c <_ZN6Stream9readBytesEPcj>
   d6a84:	b110      	cbz	r0, d6a8c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv+0x1c>
   d6a86:	f89d 3007 	ldrb.w	r3, [sp, #7]
   d6a8a:	e001      	b.n	d6a90 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv+0x20>
   d6a8c:	f04f 33ff 	mov.w	r3, #4294967295
      int c = _reader.read();
      _current = static_cast<char>(c > 0 ? c : 0);
   d6a90:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   d6a94:	7363      	strb	r3, [r4, #13]
      _loaded = true;
   d6a96:	2301      	movs	r3, #1
   d6a98:	73a3      	strb	r3, [r4, #14]
    }
    return _current;
  }
   d6a9a:	7b60      	ldrb	r0, [r4, #13]
   d6a9c:	b002      	add	sp, #8
   d6a9e:	bd10      	pop	{r4, pc}

000d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>:
    if (c < 'A') return uint8_t(c - '0');
    c = char(c & ~0x20);  // uppercase
    return uint8_t(c - 'A' + 10);
  }

  DeserializationError skipSpacesAndComments() {
   d6aa0:	b570      	push	{r4, r5, r6, lr}
   d6aa2:	4604      	mov	r4, r0
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6aa4:	2500      	movs	r5, #0
    return uint8_t(c - 'A' + 10);
  }

  DeserializationError skipSpacesAndComments() {
    for (;;) {
      switch (current()) {
   d6aa6:	4620      	mov	r0, r4
   d6aa8:	f7ff ffe2 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6aac:	280a      	cmp	r0, #10
   d6aae:	d803      	bhi.n	d6ab8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x18>
   d6ab0:	2809      	cmp	r0, #9
   d6ab2:	d21d      	bcs.n	d6af0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x50>
   d6ab4:	b1b0      	cbz	r0, d6ae4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x44>
   d6ab6:	e02f      	b.n	d6b18 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x78>
   d6ab8:	2820      	cmp	r0, #32
   d6aba:	d019      	beq.n	d6af0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x50>
   d6abc:	282f      	cmp	r0, #47	; 0x2f
   d6abe:	d002      	beq.n	d6ac6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x26>
   d6ac0:	280d      	cmp	r0, #13
   d6ac2:	d129      	bne.n	d6b18 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x78>
   d6ac4:	e014      	b.n	d6af0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x50>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6ac6:	73a5      	strb	r5, [r4, #14]
          continue;

        // comments
        case '/':
          move();  // skip '/'
          switch (current()) {
   d6ac8:	4620      	mov	r0, r4
   d6aca:	f7ff ffd1 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6ace:	282a      	cmp	r0, #42	; 0x2a
   d6ad0:	d002      	beq.n	d6ad8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x38>
   d6ad2:	282f      	cmp	r0, #47	; 0x2f
   d6ad4:	d016      	beq.n	d6b04 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x64>
   d6ad6:	e01c      	b.n	d6b12 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x72>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6ad8:	73a5      	strb	r5, [r4, #14]
          move();  // skip '/'
          switch (current()) {
            // block comment
            case '*': {
              move();  // skip '*'
              bool wasStar = false;
   d6ada:	2600      	movs	r6, #0
              for (;;) {
                char c = current();
   d6adc:	4620      	mov	r0, r4
   d6ade:	f7ff ffc7 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
                if (c == '\0') return DeserializationError::IncompleteInput;
   d6ae2:	b910      	cbnz	r0, d6aea <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x4a>
   d6ae4:	f04f 0001 	mov.w	r0, #1
   d6ae8:	bd70      	pop	{r4, r5, r6, pc}
                if (c == '/' && wasStar) {
   d6aea:	282f      	cmp	r0, #47	; 0x2f
   d6aec:	d102      	bne.n	d6af4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x54>
   d6aee:	b10e      	cbz	r6, d6af4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x54>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6af0:	73a5      	strb	r5, [r4, #14]
   d6af2:	e7d8      	b.n	d6aa6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x6>
                if (c == '\0') return DeserializationError::IncompleteInput;
                if (c == '/' && wasStar) {
                  move();
                  break;
                }
                wasStar = c == '*';
   d6af4:	f1a0 032a 	sub.w	r3, r0, #42	; 0x2a
   d6af8:	425e      	negs	r6, r3
   d6afa:	415e      	adcs	r6, r3
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6afc:	73a5      	strb	r5, [r4, #14]
   d6afe:	e7ed      	b.n	d6adc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x3c>
              // no need to skip "//"
              for (;;) {
                move();
                char c = current();
                if (c == '\0') return DeserializationError::IncompleteInput;
                if (c == '\n') break;
   d6b00:	280a      	cmp	r0, #10
   d6b02:	d0d0      	beq.n	d6aa6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x6>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6b04:	73a5      	strb	r5, [r4, #14]
            // trailing comment
            case '/':
              // no need to skip "//"
              for (;;) {
                move();
                char c = current();
   d6b06:	4620      	mov	r0, r4
   d6b08:	f7ff ffb2 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
                if (c == '\0') return DeserializationError::IncompleteInput;
   d6b0c:	2800      	cmp	r0, #0
   d6b0e:	d1f7      	bne.n	d6b00 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x60>
   d6b10:	e7e8      	b.n	d6ae4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv+0x44>
              }
              break;

            // not a comment, just a '/'
            default:
              return DeserializationError::InvalidInput;
   d6b12:	f04f 0002 	mov.w	r0, #2
   d6b16:	bd70      	pop	{r4, r5, r6, pc}
          }
          break;

        default:
          return DeserializationError::Ok;
   d6b18:	f04f 0000 	mov.w	r0, #0
      }
    }
  }
   d6b1c:	bd70      	pop	{r4, r5, r6, pc}

000d6b1e <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_>:
  VariantData *getElement(size_t index) const {
    return isArray() ? _content.asCollection.get(index) : 0;
  }

  template <typename TAdaptedString>
  VariantData *getMember(TAdaptedString key) const {
   d6b1e:	b508      	push	{r3, lr}
    return isObject() ? _content.asCollection.get(key) : 0;
   d6b20:	7a02      	ldrb	r2, [r0, #8]
   d6b22:	f002 0220 	and.w	r2, r2, #32
   d6b26:	f002 03ff 	and.w	r3, r2, #255	; 0xff
   d6b2a:	b112      	cbz	r2, d6b32 <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_+0x14>
   d6b2c:	f7ff ff18 	bl	d6960 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_>
   d6b30:	bd08      	pop	{r3, pc}
   d6b32:	4618      	mov	r0, r3
  }
   d6b34:	bd08      	pop	{r3, pc}
	...

000d6b38 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc>:
    if (err) return err;
    variant.setOwnedString(make_not_null(value));
    return DeserializationError::Ok;
  }

  DeserializationError parseQuotedString(const char *&result) {
   d6b38:	b5f0      	push	{r4, r5, r6, r7, lr}
   d6b3a:	b085      	sub	sp, #20
  typedef ARDUINOJSON_NAMESPACE::StringBuilder StringBuilder;

  StringCopier(MemoryPool* pool) : _pool(pool) {}

  StringBuilder startString() {
    return StringBuilder(_pool);
   d6b3c:	6882      	ldr	r2, [r0, #8]

namespace ARDUINOJSON_NAMESPACE {

class StringBuilder {
 public:
  explicit StringBuilder(MemoryPool* parent) : _parent(parent), _size(0) {
   d6b3e:	9200      	str	r2, [sp, #0]
   d6b40:	2500      	movs	r5, #0
   d6b42:	9501      	str	r5, [sp, #4]
  }

  StringSlot allocExpandableString() {
    StringSlot s;
    s.value = _left;
    s.size = size_t(_right - _left);
   d6b44:	6893      	ldr	r3, [r2, #8]
   d6b46:	460e      	mov	r6, r1
    return s;
  }

  StringSlot allocExpandableString() {
    StringSlot s;
    s.value = _left;
   d6b48:	6851      	ldr	r1, [r2, #4]
    s.size = size_t(_right - _left);
    _left = _right;
   d6b4a:	6053      	str	r3, [r2, #4]
    _slot = _parent->allocExpandableString();
   d6b4c:	1a5b      	subs	r3, r3, r1
   d6b4e:	4604      	mov	r4, r0
   d6b50:	9102      	str	r1, [sp, #8]
   d6b52:	9303      	str	r3, [sp, #12]
    StringBuilder builder = _stringStorage.startString();
    const char stopChar = current();
   d6b54:	f7ff ff8c 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6b58:	73a5      	strb	r5, [r4, #14]
    return DeserializationError::Ok;
  }

  DeserializationError parseQuotedString(const char *&result) {
    StringBuilder builder = _stringStorage.startString();
    const char stopChar = current();
   d6b5a:	4607      	mov	r7, r0

    move();
    for (;;) {
      char c = current();
   d6b5c:	4620      	mov	r0, r4
   d6b5e:	f7ff ff87 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
      move();
      if (c == stopChar) break;
   d6b62:	4287      	cmp	r7, r0
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6b64:	73a5      	strb	r5, [r4, #14]

    move();
    for (;;) {
      char c = current();
      move();
      if (c == stopChar) break;
   d6b66:	d023      	beq.n	d6bb0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x78>

      if (c == '\0') return DeserializationError::IncompleteInput;
   d6b68:	b910      	cbnz	r0, d6b70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x38>
   d6b6a:	f04f 0001 	mov.w	r0, #1
   d6b6e:	e029      	b.n	d6bc4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x8c>

      if (c == '\\') {
   d6b70:	285c      	cmp	r0, #92	; 0x5c
   d6b72:	d118      	bne.n	d6ba6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x6e>
        c = current();
   d6b74:	4620      	mov	r0, r4
   d6b76:	f7ff ff7b 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
        if (c == '\0') return DeserializationError::IncompleteInput;
   d6b7a:	2800      	cmp	r0, #0
   d6b7c:	d0f5      	beq.n	d6b6a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x32>
        if (c == 'u') {
   d6b7e:	2875      	cmp	r0, #117	; 0x75
   d6b80:	d001      	beq.n	d6b86 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x4e>
   d6b82:	4b11      	ldr	r3, [pc, #68]	; (d6bc8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x90>)
   d6b84:	e005      	b.n	d6b92 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x5a>
          DeserializationError err = parseCodepoint(codepoint);
          if (err) return err;
          Utf8::encodeCodepoint(codepoint, builder);
          continue;
#else
          return DeserializationError::NotSupported;
   d6b86:	f04f 0004 	mov.w	r0, #4
   d6b8a:	e01b      	b.n	d6bc4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x8c>
  // Optimized for code size on a 8-bit AVR
  static char unescapeChar(char c) {
    const char *p = escapeTable(true);
    for (;;) {
      if (p[0] == '\0') return c;
      if (p[0] == c) return p[1];
   d6b8c:	4290      	cmp	r0, r2
   d6b8e:	d004      	beq.n	d6b9a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x62>
      p += 2;
   d6b90:	3302      	adds	r3, #2

  // Optimized for code size on a 8-bit AVR
  static char unescapeChar(char c) {
    const char *p = escapeTable(true);
    for (;;) {
      if (p[0] == '\0') return c;
   d6b92:	781a      	ldrb	r2, [r3, #0]
   d6b94:	2a00      	cmp	r2, #0
   d6b96:	d1f9      	bne.n	d6b8c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x54>
   d6b98:	e004      	b.n	d6ba4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x6c>
      if (p[0] == c) return p[1];
   d6b9a:	7858      	ldrb	r0, [r3, #1]
#endif
        }
        // replace char
        c = EscapeSequence::unescapeChar(c);
        if (c == '\0') return DeserializationError::InvalidInput;
   d6b9c:	b910      	cbnz	r0, d6ba4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x6c>
   d6b9e:	f04f 0002 	mov.w	r0, #2
   d6ba2:	e00f      	b.n	d6bc4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x8c>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6ba4:	73a5      	strb	r5, [r4, #14]
        c = EscapeSequence::unescapeChar(c);
        if (c == '\0') return DeserializationError::InvalidInput;
        move();
      }

      builder.append(c);
   d6ba6:	4601      	mov	r1, r0
   d6ba8:	4668      	mov	r0, sp
   d6baa:	f7fe f9b7 	bl	d4f1c <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc>
  DeserializationError parseQuotedString(const char *&result) {
    StringBuilder builder = _stringStorage.startString();
    const char stopChar = current();

    move();
    for (;;) {
   d6bae:	e7d5      	b.n	d6b5c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x24>
      }

      builder.append(c);
    }

    result = builder.complete();
   d6bb0:	4668      	mov	r0, sp
   d6bb2:	f7fe f9c1 	bl	d4f38 <_ZN22ArduinoJson6130_00000113StringBuilder8completeEv>
   d6bb6:	6030      	str	r0, [r6, #0]
    if (!result) return DeserializationError::NoMemory;
   d6bb8:	b910      	cbnz	r0, d6bc0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x88>
   d6bba:	f04f 0003 	mov.w	r0, #3
   d6bbe:	e001      	b.n	d6bc4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc+0x8c>
    return DeserializationError::Ok;
   d6bc0:	f04f 0000 	mov.w	r0, #0
  }
   d6bc4:	b005      	add	sp, #20
   d6bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d6bc8:	000e1ee0 	.word	0x000e1ee0

000d6bcc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc>:
    }
    return DeserializationError::Ok;
  }

  static inline bool isBetween(char c, char min, char max) {
    return min <= c && c <= max;
   d6bcc:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
   d6bd0:	2b1b      	cmp	r3, #27
   d6bd2:	d913      	bls.n	d6bfc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc+0x30>
   d6bd4:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   d6bd8:	2b19      	cmp	r3, #25
   d6bda:	d90f      	bls.n	d6bfc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc+0x30>
  }

  static inline bool canBeInNonQuotedString(char c) {
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
   d6bdc:	f1a0 032b 	sub.w	r3, r0, #43	; 0x2b
   d6be0:	b2db      	uxtb	r3, r3
   d6be2:	2b0e      	cmp	r3, #14
   d6be4:	d904      	bls.n	d6bf0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc+0x24>
   d6be6:	f1a0 022e 	sub.w	r2, r0, #46	; 0x2e
   d6bea:	4250      	negs	r0, r2
   d6bec:	4150      	adcs	r0, r2
   d6bee:	4770      	bx	lr
   d6bf0:	f647 72e5 	movw	r2, #32741	; 0x7fe5
   d6bf4:	fa22 f303 	lsr.w	r3, r2, r3
   d6bf8:	07db      	lsls	r3, r3, #31
   d6bfa:	d5f4      	bpl.n	d6be6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc+0x1a>
   d6bfc:	2001      	movs	r0, #1
  }
   d6bfe:	4770      	bx	lr

000d6c00 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc>:
      err = skipSpacesAndComments();
      if (err) return err;
    }
  }

  DeserializationError parseKey(const char *&key) {
   d6c00:	b5f0      	push	{r4, r5, r6, r7, lr}
   d6c02:	b085      	sub	sp, #20
   d6c04:	4604      	mov	r4, r0
   d6c06:	460e      	mov	r6, r1
    if (isQuote(current())) {
   d6c08:	f7ff ff32 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
  }

  static inline bool isQuote(char c) {
    return c == '\'' || c == '\"';
   d6c0c:	2827      	cmp	r0, #39	; 0x27
   d6c0e:	d02d      	beq.n	d6c6c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x6c>
   d6c10:	2822      	cmp	r0, #34	; 0x22
   d6c12:	d02b      	beq.n	d6c6c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x6c>
   d6c14:	68a2      	ldr	r2, [r4, #8]

namespace ARDUINOJSON_NAMESPACE {

class StringBuilder {
 public:
  explicit StringBuilder(MemoryPool* parent) : _parent(parent), _size(0) {
   d6c16:	9200      	str	r2, [sp, #0]
   d6c18:	2500      	movs	r5, #0
   d6c1a:	9501      	str	r5, [sp, #4]
    return s;
  }

  StringSlot allocExpandableString() {
    StringSlot s;
    s.value = _left;
   d6c1c:	6851      	ldr	r1, [r2, #4]
    s.size = size_t(_right - _left);
   d6c1e:	6893      	ldr	r3, [r2, #8]
    _left = _right;
   d6c20:	6053      	str	r3, [r2, #4]
  }

  DeserializationError parseNonQuotedString(const char *&result) {
    StringBuilder builder = _stringStorage.startString();

    char c = current();
   d6c22:	4620      	mov	r0, r4
    _slot = _parent->allocExpandableString();
   d6c24:	1a5b      	subs	r3, r3, r1
   d6c26:	9102      	str	r1, [sp, #8]
   d6c28:	9303      	str	r3, [sp, #12]
   d6c2a:	f7ff ff21 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
    if (c == '\0') return DeserializationError::IncompleteInput;
   d6c2e:	4607      	mov	r7, r0
   d6c30:	b1d0      	cbz	r0, d6c68 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x68>

    if (canBeInNonQuotedString(c)) {  // no quotes
   d6c32:	f7ff ffcb 	bl	d6bcc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc>
   d6c36:	b1a8      	cbz	r0, d6c64 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x64>
      do {
        move();
        builder.append(c);
   d6c38:	4639      	mov	r1, r7
   d6c3a:	4668      	mov	r0, sp
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6c3c:	73a5      	strb	r5, [r4, #14]
    if (c == '\0') return DeserializationError::IncompleteInput;

    if (canBeInNonQuotedString(c)) {  // no quotes
      do {
        move();
        builder.append(c);
   d6c3e:	f7fe f96d 	bl	d4f1c <_ZN22ArduinoJson6130_00000113StringBuilder6appendEc>
        c = current();
   d6c42:	4620      	mov	r0, r4
   d6c44:	f7ff ff14 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6c48:	4607      	mov	r7, r0

    char c = current();
    if (c == '\0') return DeserializationError::IncompleteInput;

    if (canBeInNonQuotedString(c)) {  // no quotes
      do {
   d6c4a:	f7ff ffbf 	bl	d6bcc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc>
   d6c4e:	2800      	cmp	r0, #0
   d6c50:	d1f2      	bne.n	d6c38 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x38>
      } while (canBeInNonQuotedString(c));
    } else {
      return DeserializationError::InvalidInput;
    }

    result = builder.complete();
   d6c52:	4668      	mov	r0, sp
   d6c54:	f7fe f970 	bl	d4f38 <_ZN22ArduinoJson6130_00000113StringBuilder8completeEv>
    if (!result) return DeserializationError::NoMemory;
    return DeserializationError::Ok;
   d6c58:	2800      	cmp	r0, #0
      } while (canBeInNonQuotedString(c));
    } else {
      return DeserializationError::InvalidInput;
    }

    result = builder.complete();
   d6c5a:	6030      	str	r0, [r6, #0]
    if (!result) return DeserializationError::NoMemory;
    return DeserializationError::Ok;
   d6c5c:	bf0c      	ite	eq
   d6c5e:	2003      	moveq	r0, #3
   d6c60:	2000      	movne	r0, #0
   d6c62:	e007      	b.n	d6c74 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x74>
        move();
        builder.append(c);
        c = current();
      } while (canBeInNonQuotedString(c));
    } else {
      return DeserializationError::InvalidInput;
   d6c64:	2002      	movs	r0, #2
   d6c66:	e005      	b.n	d6c74 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x74>

  DeserializationError parseNonQuotedString(const char *&result) {
    StringBuilder builder = _stringStorage.startString();

    char c = current();
    if (c == '\0') return DeserializationError::IncompleteInput;
   d6c68:	2001      	movs	r0, #1
   d6c6a:	e003      	b.n	d6c74 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc+0x74>
    }
  }

  DeserializationError parseKey(const char *&key) {
    if (isQuote(current())) {
      return parseQuotedString(key);
   d6c6c:	4631      	mov	r1, r6
   d6c6e:	4620      	mov	r0, r4
   d6c70:	f7ff ff62 	bl	d6b38 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc>
    } else {
      return parseNonQuotedString(key);
    }
  }
   d6c74:	b005      	add	sp, #20
   d6c76:	bdf0      	pop	{r4, r5, r6, r7, pc}

000d6c78 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_>:
  typedef int8_t exponent_type;
  static const exponent_type exponent_max = 38;

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
   d6c78:	2800      	cmp	r0, #0
   d6c7a:	dd0f      	ble.n	d6c9c <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x24>
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
   d6c7c:	4911      	ldr	r1, [pc, #68]	; (d6cc4 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x4c>)
   d6c7e:	2300      	movs	r3, #0

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
   d6c80:	07c2      	lsls	r2, r0, #31
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
   d6c82:	bf41      	itttt	mi
   d6c84:	b2da      	uxtbmi	r2, r3
   d6c86:	eb01 0282 	addmi.w	r2, r1, r2, lsl #2

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
   d6c8a:	edd2 7a00 	vldrmi	s15, [r2]
   d6c8e:	ee20 0a27 	vmulmi.f32	s0, s0, s15
  static const exponent_type exponent_max = 38;

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
   d6c92:	1040      	asrs	r0, r0, #1
   d6c94:	f103 0301 	add.w	r3, r3, #1
   d6c98:	d1f2      	bne.n	d6c80 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x8>
   d6c9a:	4770      	bx	lr
    return factors[index];
  }

  static T negativeBinaryPowerOfTen(int index) {
    static T factors[] = {1e-1f, 1e-2f, 1e-4f, 1e-8f, 1e-16f, 1e-32f};
    return factors[index];
   d6c9c:	490a      	ldr	r1, [pc, #40]	; (d6cc8 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x50>)
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
        e >>= 1;
      }
    } else {
      e = -e;
   d6c9e:	4240      	negs	r0, r0
   d6ca0:	2300      	movs	r3, #0
      for (uint8_t index = 0; e != 0; index++) {
   d6ca2:	b168      	cbz	r0, d6cc0 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x48>
        if (e & 1) m *= negativeBinaryPowerOfTen(index);
   d6ca4:	07c2      	lsls	r2, r0, #31
    return factors[index];
  }

  static T negativeBinaryPowerOfTen(int index) {
    static T factors[] = {1e-1f, 1e-2f, 1e-4f, 1e-8f, 1e-16f, 1e-32f};
    return factors[index];
   d6ca6:	bf42      	ittt	mi
   d6ca8:	b2da      	uxtbmi	r2, r3
   d6caa:	eb01 0282 	addmi.w	r2, r1, r2, lsl #2
        e >>= 1;
      }
    } else {
      e = -e;
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= negativeBinaryPowerOfTen(index);
   d6cae:	edd2 7a00 	vldrmi	s15, [r2]
        e >>= 1;
   d6cb2:	ea4f 0060 	mov.w	r0, r0, asr #1
        e >>= 1;
      }
    } else {
      e = -e;
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= negativeBinaryPowerOfTen(index);
   d6cb6:	bf48      	it	mi
   d6cb8:	ee20 0a27 	vmulmi.f32	s0, s0, s15
   d6cbc:	3301      	adds	r3, #1
   d6cbe:	e7f0      	b.n	d6ca2 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_+0x2a>
        e >>= 1;
      }
    }
    return m;
  }
   d6cc0:	4770      	bx	lr
   d6cc2:	bf00      	nop
   d6cc4:	2003d6a0 	.word	0x2003d6a0
   d6cc8:	2003d688 	.word	0x2003d688

000d6ccc <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc>:

template <typename A, typename B>
struct choose_largest : conditional<(sizeof(A) > sizeof(B)), A, B> {};

template <typename TFloat, typename TUInt>
inline ParsedNumber<TFloat, TUInt> parseNumber(const char *s) {
   d6ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
   d6cd0:	780b      	ldrb	r3, [r1, #0]
   d6cd2:	2b2b      	cmp	r3, #43	; 0x2b

template <typename A, typename B>
struct choose_largest : conditional<(sizeof(A) > sizeof(B)), A, B> {};

template <typename TFloat, typename TUInt>
inline ParsedNumber<TFloat, TUInt> parseNumber(const char *s) {
   d6cd4:	4604      	mov	r4, r0
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
   d6cd6:	d004      	beq.n	d6ce2 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x16>
   d6cd8:	2b2d      	cmp	r3, #45	; 0x2d
   d6cda:	d103      	bne.n	d6ce4 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x18>
    case '-':
      is_negative = true;
      s++;
   d6cdc:	3101      	adds	r1, #1
  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
    case '-':
      is_negative = true;
   d6cde:	2601      	movs	r6, #1
      s++;
      break;
   d6ce0:	e001      	b.n	d6ce6 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x1a>
    case '+':
      s++;
   d6ce2:	3101      	adds	r1, #1
  typedef typename traits::exponent_type exponent_t;
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
   d6ce4:	2600      	movs	r6, #0
#if ARDUINOJSON_ENABLE_INFINITY
  if (*s == 'i' || *s == 'I')
    return is_negative ? -traits::inf() : traits::inf();
#endif

  if (!isdigit(*s) && *s != '.') return return_type();
   d6ce6:	780b      	ldrb	r3, [r1, #0]
   d6ce8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   d6cec:	2a09      	cmp	r2, #9
   d6cee:	d902      	bls.n	d6cf6 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x2a>
   d6cf0:	2b2e      	cmp	r3, #46	; 0x2e
   d6cf2:	f040 8089 	bne.w	d6e08 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x13c>
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
   d6cf6:	4f4f      	ldr	r7, [pc, #316]	; (d6e34 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x168>)
  typedef typename traits::exponent_type exponent_t;
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
   d6cf8:	2300      	movs	r3, #0
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
    mantissa *= 10;
   d6cfa:	f04f 0e0a 	mov.w	lr, #10

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
   d6cfe:	4608      	mov	r0, r1
   d6d00:	f810 5b01 	ldrb.w	r5, [r0], #1
#include <ArduinoJson/Namespace.hpp>

namespace ARDUINOJSON_NAMESPACE {

inline bool isdigit(char c) {
  return '0' <= c && c <= '9';
   d6d04:	f1a5 0230 	sub.w	r2, r5, #48	; 0x30
   d6d08:	b2d2      	uxtb	r2, r2
   d6d0a:	2a09      	cmp	r2, #9
   d6d0c:	d809      	bhi.n	d6d22 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x56>
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
   d6d0e:	42bb      	cmp	r3, r7
   d6d10:	d808      	bhi.n	d6d24 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x58>
    mantissa *= 10;
   d6d12:	fb0e f303 	mul.w	r3, lr, r3
    if (mantissa > maxUint - digit) break;
   d6d16:	43d5      	mvns	r5, r2
   d6d18:	42ab      	cmp	r3, r5
   d6d1a:	d803      	bhi.n	d6d24 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x58>
    mantissa += digit;
   d6d1c:	4413      	add	r3, r2

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
   d6d1e:	4601      	mov	r1, r0
   d6d20:	e7ed      	b.n	d6cfe <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x32>
    if (mantissa > maxUint - digit) break;
    mantissa += digit;
    s++;
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);
   d6d22:	b11d      	cbz	r5, d6d2c <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x60>

  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
   d6d24:	2200      	movs	r2, #0
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d6d26:	4f44      	ldr	r7, [pc, #272]	; (d6e38 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x16c>)
    mantissa /= 10;
   d6d28:	250a      	movs	r5, #10
   d6d2a:	e00e      	b.n	d6d4a <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x7e>

  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
   d6d2c:	ee07 3a90 	vmov	s15, r3
   d6d30:	eef8 7a67 	vcvt.f32.u32	s15, s15
   d6d34:	2e00      	cmp	r6, #0
   d6d36:	6023      	str	r3, [r4, #0]
   d6d38:	edc4 7a01 	vstr	s15, [r4, #4]
   d6d3c:	bf0c      	ite	eq
   d6d3e:	2308      	moveq	r3, #8
   d6d40:	230a      	movne	r3, #10
   d6d42:	e073      	b.n	d6e2c <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x160>
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d6d44:	4602      	mov	r2, r0
    mantissa /= 10;
   d6d46:	fbb3 f3f5 	udiv	r3, r3, r5
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d6d4a:	42bb      	cmp	r3, r7
   d6d4c:	f102 0001 	add.w	r0, r2, #1
   d6d50:	d8f8      	bhi.n	d6d44 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x78>
   d6d52:	1a52      	subs	r2, r2, r1
   d6d54:	1850      	adds	r0, r2, r1
   d6d56:	460d      	mov	r5, r1
    mantissa /= 10;
    exponent_offset++;
  }

  // remaing digits can't fit in the mantissa
  while (isdigit(*s)) {
   d6d58:	f811 7b01 	ldrb.w	r7, [r1], #1
   d6d5c:	f1a7 0e30 	sub.w	lr, r7, #48	; 0x30
   d6d60:	f1be 0f09 	cmp.w	lr, #9
   d6d64:	b240      	sxtb	r0, r0
   d6d66:	d9f5      	bls.n	d6d54 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x88>
    exponent_offset++;
    s++;
  }

  if (*s == '.') {
   d6d68:	2f2e      	cmp	r7, #46	; 0x2e
   d6d6a:	d110      	bne.n	d6d8e <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xc2>
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
   d6d6c:	f8df e0dc 	ldr.w	lr, [pc, #220]	; d6e4c <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x180>
        mantissa = mantissa * 10 + uint8_t(*s - '0');
   d6d70:	270a      	movs	r7, #10
   d6d72:	460d      	mov	r5, r1
   d6d74:	3101      	adds	r1, #1
   d6d76:	782a      	ldrb	r2, [r5, #0]
   d6d78:	3a30      	subs	r2, #48	; 0x30
   d6d7a:	b2d2      	uxtb	r2, r2
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
   d6d7c:	2a09      	cmp	r2, #9
   d6d7e:	d806      	bhi.n	d6d8e <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xc2>
      if (mantissa < traits::mantissa_max / 10) {
   d6d80:	4573      	cmp	r3, lr
   d6d82:	d8f6      	bhi.n	d6d72 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xa6>
        mantissa = mantissa * 10 + uint8_t(*s - '0');
        exponent_offset--;
   d6d84:	3801      	subs	r0, #1

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
        mantissa = mantissa * 10 + uint8_t(*s - '0');
   d6d86:	fb07 2303 	mla	r3, r7, r3, r2
        exponent_offset--;
   d6d8a:	b240      	sxtb	r0, r0
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
   d6d8c:	e7f1      	b.n	d6d72 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xa6>
      s++;
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
   d6d8e:	782a      	ldrb	r2, [r5, #0]
   d6d90:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   d6d94:	2a45      	cmp	r2, #69	; 0x45
   d6d96:	d134      	bne.n	d6e02 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x136>
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
   d6d98:	786a      	ldrb	r2, [r5, #1]
   d6d9a:	2a2d      	cmp	r2, #45	; 0x2d
   d6d9c:	d102      	bne.n	d6da4 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xd8>
      negative_exponent = true;
      s++;
   d6d9e:	1ca9      	adds	r1, r5, #2
  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
   d6da0:	2701      	movs	r7, #1
   d6da2:	e004      	b.n	d6dae <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xe2>
      s++;
    } else if (*s == '+') {
   d6da4:	2a2b      	cmp	r2, #43	; 0x2b
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
   d6da6:	bf14      	ite	ne
   d6da8:	1c69      	addne	r1, r5, #1
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
      s++;
    } else if (*s == '+') {
      s++;
   d6daa:	1ca9      	addeq	r1, r5, #2
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
   d6dac:	2700      	movs	r7, #0
   d6dae:	2200      	movs	r2, #0
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
      exponent = exponent * 10 + (*s - '0');
   d6db0:	f04f 0c0a 	mov.w	ip, #10
   d6db4:	460d      	mov	r5, r1
      s++;
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
   d6db6:	f811 eb01 	ldrb.w	lr, [r1], #1
   d6dba:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
   d6dbe:	fa5f f88e 	uxtb.w	r8, lr
   d6dc2:	f1b8 0f09 	cmp.w	r8, #9
   d6dc6:	d819      	bhi.n	d6dfc <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x130>
      exponent = exponent * 10 + (*s - '0');
   d6dc8:	fb0c e202 	mla	r2, ip, r2, lr
      if (exponent + exponent_offset > traits::exponent_max) {
   d6dcc:	1885      	adds	r5, r0, r2
   d6dce:	2d26      	cmp	r5, #38	; 0x26
   d6dd0:	ddf0      	ble.n	d6db4 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0xe8>
        if (negative_exponent)
   d6dd2:	b147      	cbz	r7, d6de6 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x11a>
          return is_negative ? -0.0f : 0.0f;
   d6dd4:	ed9f 7a19 	vldr	s14, [pc, #100]	; d6e3c <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x170>
   d6dd8:	eddf 7a19 	vldr	s15, [pc, #100]	; d6e40 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x174>
   d6ddc:	2e00      	cmp	r6, #0
   d6dde:	bf18      	it	ne
   d6de0:	eef0 7a47 	vmovne.f32	s15, s14
   d6de4:	e007      	b.n	d6df6 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x12a>
        else
          return is_negative ? -traits::inf() : traits::inf();
   d6de6:	ed9f 7a17 	vldr	s14, [pc, #92]	; d6e44 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x178>
   d6dea:	eddf 7a17 	vldr	s15, [pc, #92]	; d6e48 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x17c>
   d6dee:	2e00      	cmp	r6, #0
   d6df0:	bf08      	it	eq
   d6df2:	eef0 7a47 	vmoveq.f32	s15, s14
  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
  ParsedNumber(TFloat value) : floatValue(value), _type(VALUE_IS_FLOAT) {}
   d6df6:	edc4 7a01 	vstr	s15, [r4, #4]
   d6dfa:	e016      	b.n	d6e2a <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x15e>
        else
          return is_negative ? -traits::inf() : traits::inf();
      }
      s++;
    }
    if (negative_exponent) exponent = -exponent;
   d6dfc:	b117      	cbz	r7, d6e04 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x138>
   d6dfe:	4252      	negs	r2, r2
   d6e00:	e000      	b.n	d6e04 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x138>
      }
      s++;
    }
  }

  int exponent = 0;
   d6e02:	2200      	movs	r2, #0
    if (negative_exponent) exponent = -exponent;
  }
  exponent += exponent_offset;

  // we should be at the end of the string, otherwise it's an error
  if (*s != '\0') return return_type();
   d6e04:	7829      	ldrb	r1, [r5, #0]
   d6e06:	b121      	cbz	r1, d6e12 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x146>

namespace ARDUINOJSON_NAMESPACE {

template <typename TFloat, typename TUInt>
struct ParsedNumber {
  ParsedNumber() : uintValue(0), floatValue(0), _type(VALUE_IS_NULL) {}
   d6e08:	2300      	movs	r3, #0
   d6e0a:	2200      	movs	r2, #0
   d6e0c:	6023      	str	r3, [r4, #0]
   d6e0e:	6062      	str	r2, [r4, #4]
   d6e10:	e00c      	b.n	d6e2c <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x160>
  exponent += exponent_offset;

  // we should be at the end of the string, otherwise it's an error
  if (*s != '\0') return return_type();

  TFloat result = traits::make_float(static_cast<TFloat>(mantissa), exponent);
   d6e12:	ee07 3a90 	vmov	s15, r3
   d6e16:	4410      	add	r0, r2
   d6e18:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   d6e1c:	f7ff ff2c 	bl	d6c78 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_>

  return is_negative ? -result : result;
   d6e20:	b10e      	cbz	r6, d6e26 <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc+0x15a>
   d6e22:	eeb1 0a40 	vneg.f32	s0, s0
  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
  ParsedNumber(TFloat value) : floatValue(value), _type(VALUE_IS_FLOAT) {}
   d6e26:	ed84 0a01 	vstr	s0, [r4, #4]
   d6e2a:	230c      	movs	r3, #12
   d6e2c:	7223      	strb	r3, [r4, #8]
  if (*s != '\0') return return_type();

  TFloat result = traits::make_float(static_cast<TFloat>(mantissa), exponent);

  return is_negative ? -result : result;
}
   d6e2e:	4620      	mov	r0, r4
   d6e30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d6e34:	19999999 	.word	0x19999999
   d6e38:	007fffff 	.word	0x007fffff
   d6e3c:	80000000 	.word	0x80000000
   d6e40:	00000000 	.word	0x00000000
   d6e44:	7f800000 	.word	0x7f800000
   d6e48:	ff800000 	.word	0xff800000
   d6e4c:	000ccccb 	.word	0x000ccccb

000d6e50 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE>:
    result = builder.complete();
    if (!result) return DeserializationError::NoMemory;
    return DeserializationError::Ok;
  }

  DeserializationError parseNumericValue(VariantData &result) {
   d6e50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   d6e54:	b095      	sub	sp, #84	; 0x54
   d6e56:	4680      	mov	r8, r0
   d6e58:	460d      	mov	r5, r1
    char buffer[64];
    uint8_t n = 0;

    char c = current();
   d6e5a:	f7ff fe09 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6e5e:	2400      	movs	r4, #0
   d6e60:	4607      	mov	r7, r0
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6e62:	46a1      	mov	r9, r4
  DeserializationError parseNumericValue(VariantData &result) {
    char buffer[64];
    uint8_t n = 0;

    char c = current();
    while (canBeInNonQuotedString(c) && n < 63) {
   d6e64:	4638      	mov	r0, r7
   d6e66:	b2e6      	uxtb	r6, r4
   d6e68:	f7ff feb0 	bl	d6bcc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE22canBeInNonQuotedStringEc>
   d6e6c:	b158      	cbz	r0, d6e86 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x36>
   d6e6e:	2c3f      	cmp	r4, #63	; 0x3f
   d6e70:	d009      	beq.n	d6e86 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x36>
      move();
      buffer[n++] = c;
   d6e72:	ab04      	add	r3, sp, #16
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d6e74:	f888 900e 	strb.w	r9, [r8, #14]
    uint8_t n = 0;

    char c = current();
    while (canBeInNonQuotedString(c) && n < 63) {
      move();
      buffer[n++] = c;
   d6e78:	54e7      	strb	r7, [r4, r3]
      c = current();
   d6e7a:	4640      	mov	r0, r8
   d6e7c:	f7ff fdf8 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6e80:	3401      	adds	r4, #1
   d6e82:	4607      	mov	r7, r0
  DeserializationError parseNumericValue(VariantData &result) {
    char buffer[64];
    uint8_t n = 0;

    char c = current();
    while (canBeInNonQuotedString(c) && n < 63) {
   d6e84:	e7ee      	b.n	d6e64 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x14>
      move();
      buffer[n++] = c;
      c = current();
    }
    buffer[n] = 0;
   d6e86:	ab14      	add	r3, sp, #80	; 0x50
   d6e88:	4433      	add	r3, r6
   d6e8a:	2400      	movs	r4, #0
   d6e8c:	f803 4c40 	strb.w	r4, [r3, #-64]

    c = buffer[0];
   d6e90:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if (c == 't') {  // true
   d6e94:	2b74      	cmp	r3, #116	; 0x74
   d6e96:	d107      	bne.n	d6ea8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x58>
  void remove(TAdaptedString key) {
    if (isObject()) _content.asCollection.remove(key);
  }

  void setBoolean(bool value) {
    setType(VALUE_IS_BOOLEAN);
   d6e98:	2106      	movs	r1, #6
   d6e9a:	f105 0008 	add.w	r0, r5, #8
   d6e9e:	f7fd fee5 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asInteger = static_cast<UInt>(value);
   d6ea2:	2301      	movs	r3, #1
   d6ea4:	602b      	str	r3, [r5, #0]
   d6ea6:	e00d      	b.n	d6ec4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x74>
      result.setBoolean(true);
      return n == 4 ? DeserializationError::Ok
                    : DeserializationError::IncompleteInput;
    }
    if (c == 'f') {  // false
   d6ea8:	2b66      	cmp	r3, #102	; 0x66
   d6eaa:	d109      	bne.n	d6ec0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x70>
  void remove(TAdaptedString key) {
    if (isObject()) _content.asCollection.remove(key);
  }

  void setBoolean(bool value) {
    setType(VALUE_IS_BOOLEAN);
   d6eac:	f105 0008 	add.w	r0, r5, #8
   d6eb0:	2106      	movs	r1, #6
   d6eb2:	f7fd fedb 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asInteger = static_cast<UInt>(value);
   d6eb6:	602c      	str	r4, [r5, #0]
      result.setBoolean(false);
      return n == 5 ? DeserializationError::Ok
                    : DeserializationError::IncompleteInput;
   d6eb8:	1f70      	subs	r0, r6, #5
   d6eba:	bf18      	it	ne
   d6ebc:	2001      	movne	r0, #1
   d6ebe:	e020      	b.n	d6f02 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0xb2>
    }
    if (c == 'n') {  // null
   d6ec0:	2b6e      	cmp	r3, #110	; 0x6e
   d6ec2:	d101      	bne.n	d6ec8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x78>
      // the variant is already null
      return n == 4 ? DeserializationError::Ok
                    : DeserializationError::IncompleteInput;
   d6ec4:	1f30      	subs	r0, r6, #4
   d6ec6:	e7f8      	b.n	d6eba <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x6a>
    }

    ParsedNumber<Float, UInt> num = parseNumber<Float, UInt>(buffer);
   d6ec8:	a904      	add	r1, sp, #16
   d6eca:	a801      	add	r0, sp, #4
   d6ecc:	f7ff fefe 	bl	d6ccc <_ZN22ArduinoJson6130_00000111parseNumberIfmEENS_12ParsedNumberIT_T0_EEPKc>

    switch (num.type()) {
   d6ed0:	f89d 100c 	ldrb.w	r1, [sp, #12]
      // the variant is already null
      return n == 4 ? DeserializationError::Ok
                    : DeserializationError::IncompleteInput;
    }

    ParsedNumber<Float, UInt> num = parseNumber<Float, UInt>(buffer);
   d6ed4:	9a01      	ldr	r2, [sp, #4]

    switch (num.type()) {
   d6ed6:	290a      	cmp	r1, #10
   d6ed8:	d003      	beq.n	d6ee2 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x92>
   d6eda:	290c      	cmp	r1, #12
   d6edc:	d007      	beq.n	d6eee <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0x9e>
   d6ede:	2908      	cmp	r1, #8
   d6ee0:	d10d      	bne.n	d6efe <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0xae>
      setNegativeInteger(~static_cast<UInt>(value) + 1);
    }
  }

  void setPositiveInteger(UInt value) {
    setType(VALUE_IS_POSITIVE_INTEGER);
   d6ee2:	f105 0008 	add.w	r0, r5, #8
   d6ee6:	f7fd fec1 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asInteger = value;
   d6eea:	602a      	str	r2, [r5, #0]
   d6eec:	e005      	b.n	d6efa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0xaa>
    setType(VALUE_IS_BOOLEAN);
    _content.asInteger = static_cast<UInt>(value);
  }

  void setFloat(Float value) {
    setType(VALUE_IS_FLOAT);
   d6eee:	f105 0008 	add.w	r0, r5, #8
      case VALUE_IS_POSITIVE_INTEGER:
        result.setPositiveInteger(num.uintValue);
        return DeserializationError::Ok;

      case VALUE_IS_FLOAT:
        result.setFloat(num.floatValue);
   d6ef2:	9a02      	ldr	r2, [sp, #8]
   d6ef4:	f7fd feba 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asFloat = value;
   d6ef8:	602a      	str	r2, [r5, #0]
        return DeserializationError::Ok;
   d6efa:	4620      	mov	r0, r4
   d6efc:	e001      	b.n	d6f02 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE+0xb2>
    }

    return DeserializationError::InvalidInput;
   d6efe:	f04f 0002 	mov.w	r0, #2
  }
   d6f02:	b015      	add	sp, #84	; 0x54
   d6f04:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000d6f08 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE>:
    if (current() != charToSkip) return false;
    move();
    return true;
  }

  DeserializationError parseVariant(VariantData &variant) {
   d6f08:	b570      	push	{r4, r5, r6, lr}
   d6f0a:	b088      	sub	sp, #32
   d6f0c:	460c      	mov	r4, r1
   d6f0e:	4606      	mov	r6, r0
    DeserializationError err = skipSpacesAndComments();
   d6f10:	f7ff fdc6 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
    if (err) return err;
   d6f14:	a901      	add	r1, sp, #4
    move();
    return true;
  }

  DeserializationError parseVariant(VariantData &variant) {
    DeserializationError err = skipSpacesAndComments();
   d6f16:	f88d 0004 	strb.w	r0, [sp, #4]
    if (err) return err;
   d6f1a:	a804      	add	r0, sp, #16
   d6f1c:	f7fd fff2 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d6f20:	9b04      	ldr	r3, [sp, #16]
   d6f22:	2b00      	cmp	r3, #0
   d6f24:	d13e      	bne.n	d6fa4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x9c>
   d6f26:	9d05      	ldr	r5, [sp, #20]
   d6f28:	f015 0501 	ands.w	r5, r5, #1
   d6f2c:	d13a      	bne.n	d6fa4 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x9c>

    switch (current()) {
   d6f2e:	4630      	mov	r0, r6
   d6f30:	f7ff fd9e 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d6f34:	2827      	cmp	r0, #39	; 0x27
   d6f36:	d110      	bne.n	d6f5a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x52>
    }
  }

  DeserializationError parseStringValue(VariantData &variant) {
    const char *value;
    DeserializationError err = parseQuotedString(value);
   d6f38:	a903      	add	r1, sp, #12
   d6f3a:	4630      	mov	r0, r6
   d6f3c:	f7ff fdfc 	bl	d6b38 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseQuotedStringERPKc>
    if (err) return err;
   d6f40:	a902      	add	r1, sp, #8
    }
  }

  DeserializationError parseStringValue(VariantData &variant) {
    const char *value;
    DeserializationError err = parseQuotedString(value);
   d6f42:	f88d 0008 	strb.w	r0, [sp, #8]
    if (err) return err;
   d6f46:	a806      	add	r0, sp, #24
   d6f48:	f7fd ffdc 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d6f4c:	9b06      	ldr	r3, [sp, #24]
   d6f4e:	bb63      	cbnz	r3, d6faa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xa2>
   d6f50:	9807      	ldr	r0, [sp, #28]
   d6f52:	f010 0201 	ands.w	r2, r0, #1
   d6f56:	d128      	bne.n	d6faa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xa2>
   d6f58:	e02a      	b.n	d6fb0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xa8>

  DeserializationError parseVariant(VariantData &variant) {
    DeserializationError err = skipSpacesAndComments();
    if (err) return err;

    switch (current()) {
   d6f5a:	d807      	bhi.n	d6f6c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x64>
   d6f5c:	2822      	cmp	r0, #34	; 0x22
   d6f5e:	d0eb      	beq.n	d6f38 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x30>
      case '\"':
      case '\'':
        return parseStringValue(variant);

      default:
        return parseNumericValue(variant);
   d6f60:	4621      	mov	r1, r4
   d6f62:	4630      	mov	r0, r6
   d6f64:	f7ff ff74 	bl	d6e50 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE17parseNumericValueERNS_11VariantDataE>
   d6f68:	b2c0      	uxtb	r0, r0
   d6f6a:	e029      	b.n	d6fc0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xb8>

  DeserializationError parseVariant(VariantData &variant) {
    DeserializationError err = skipSpacesAndComments();
    if (err) return err;

    switch (current()) {
   d6f6c:	285b      	cmp	r0, #91	; 0x5b
   d6f6e:	d10b      	bne.n	d6f88 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x80>
    setType(VALUE_IS_POSITIVE_INTEGER);
    _content.asInteger = static_cast<UInt>(value);
  }

  CollectionData &toArray() {
    setType(VALUE_IS_ARRAY);
   d6f70:	f104 0008 	add.w	r0, r4, #8
   d6f74:	2140      	movs	r1, #64	; 0x40
   d6f76:	f7fd fe79 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
  if (!slotSetKey(slot, key, pool)) return 0;
  return slot->data();
}

inline void CollectionData::clear() {
  _head = 0;
   d6f7a:	6025      	str	r5, [r4, #0]
  _tail = 0;
   d6f7c:	6065      	str	r5, [r4, #4]
      case '[':
        return parseArray(variant.toArray());
   d6f7e:	4621      	mov	r1, r4
   d6f80:	4630      	mov	r0, r6
   d6f82:	f000 f856 	bl	d7032 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE>
   d6f86:	e7ef      	b.n	d6f68 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x60>

  DeserializationError parseVariant(VariantData &variant) {
    DeserializationError err = skipSpacesAndComments();
    if (err) return err;

    switch (current()) {
   d6f88:	287b      	cmp	r0, #123	; 0x7b
   d6f8a:	d1e9      	bne.n	d6f60 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x58>
    _content.asCollection.clear();
    return _content.asCollection;
  }

  CollectionData &toObject() {
    setType(VALUE_IS_OBJECT);
   d6f8c:	f104 0008 	add.w	r0, r4, #8
   d6f90:	2120      	movs	r1, #32
   d6f92:	f7fd fe6b 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
  if (!slotSetKey(slot, key, pool)) return 0;
  return slot->data();
}

inline void CollectionData::clear() {
  _head = 0;
   d6f96:	6025      	str	r5, [r4, #0]
  _tail = 0;
   d6f98:	6065      	str	r5, [r4, #4]
      case '[':
        return parseArray(variant.toArray());

      case '{':
        return parseObject(variant.toObject());
   d6f9a:	4621      	mov	r1, r4
   d6f9c:	4630      	mov	r0, r6
   d6f9e:	f000 f8ae 	bl	d70fe <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE>
   d6fa2:	e7e1      	b.n	d6f68 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0x60>
    return true;
  }

  DeserializationError parseVariant(VariantData &variant) {
    DeserializationError err = skipSpacesAndComments();
    if (err) return err;
   d6fa4:	f89d 0004 	ldrb.w	r0, [sp, #4]
   d6fa8:	e00a      	b.n	d6fc0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xb8>
  }

  DeserializationError parseStringValue(VariantData &variant) {
    const char *value;
    DeserializationError err = parseQuotedString(value);
    if (err) return err;
   d6faa:	f89d 0008 	ldrb.w	r0, [sp, #8]
   d6fae:	e007      	b.n	d6fc0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE+0xb8>
  void setNull() {
    setType(VALUE_IS_NULL);
  }

  void setOwnedString(not_null<const char *> s) {
    setType(VALUE_IS_OWNED_STRING);
   d6fb0:	f104 0008 	add.w	r0, r4, #8
   d6fb4:	2105      	movs	r1, #5
    variant.setOwnedString(make_not_null(value));
   d6fb6:	9d03      	ldr	r5, [sp, #12]
   d6fb8:	f7fd fe58 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
    _content.asString = s.get();
   d6fbc:	6025      	str	r5, [r4, #0]
    return DeserializationError::Ok;
   d6fbe:	4610      	mov	r0, r2
        return parseStringValue(variant);

      default:
        return parseNumericValue(variant);
    }
  }
   d6fc0:	b008      	add	sp, #32
   d6fc2:	bd70      	pop	{r4, r5, r6, pc}

000d6fc4 <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE>:
}
//
// deserialize(JsonDocument&, std::istream&);
// deserialize(JsonDocument&, Stream&);
template <template <typename, typename> class TDeserializer, typename TStream>
DeserializationError deserialize(JsonDocument &doc, TStream &input,
   d6fc4:	b530      	push	{r4, r5, lr}
    s.size = newSize;
    checkInvariants();
  }

  void clear() {
    _left = _begin;
   d6fc6:	6803      	ldr	r3, [r0, #0]
   d6fc8:	6043      	str	r3, [r0, #4]
    _right = _end;
   d6fca:	68c3      	ldr	r3, [r0, #12]
   d6fcc:	6083      	str	r3, [r0, #8]
   d6fce:	b089      	sub	sp, #36	; 0x24
   d6fd0:	4604      	mov	r4, r0
   d6fd2:	460d      	mov	r5, r1
      setType(VALUE_IS_NULL);
    }
  }

  void setNull() {
    setType(VALUE_IS_NULL);
   d6fd4:	3018      	adds	r0, #24
   d6fd6:	2100      	movs	r1, #0
   d6fd8:	f7fd fe48 	bl	d4c6c <_ZN22ArduinoJson6130_00000111VariantData7setTypeEh.isra.31>
                   TStringStorage stringStorage, uint8_t nestingLimit)
      : _pool(&pool),
        _reader(reader),
        _stringStorage(stringStorage),
        _nestingLimit(nestingLimit),
        _loaded(false) {}
   d6fdc:	2300      	movs	r3, #0
  DeserializationError parse(VariantData &variant) {
    DeserializationError err = parseVariant(variant);
   d6fde:	f104 0110 	add.w	r1, r4, #16
   d6fe2:	a804      	add	r0, sp, #16
                   TStringStorage stringStorage, uint8_t nestingLimit)
      : _pool(&pool),
        _reader(reader),
        _stringStorage(stringStorage),
        _nestingLimit(nestingLimit),
        _loaded(false) {}
   d6fe4:	f88d 301e 	strb.w	r3, [sp, #30]
   d6fe8:	f88d 201c 	strb.w	r2, [sp, #28]
   d6fec:	9404      	str	r4, [sp, #16]
   d6fee:	9505      	str	r5, [sp, #20]
   d6ff0:	9406      	str	r4, [sp, #24]
  DeserializationError parse(VariantData &variant) {
    DeserializationError err = parseVariant(variant);
   d6ff2:	f7ff ff89 	bl	d6f08 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE>

    if (!err && _current != 0 && !variant.isEnclosed()) {
   d6ff6:	a901      	add	r1, sp, #4
        _reader(reader),
        _stringStorage(stringStorage),
        _nestingLimit(nestingLimit),
        _loaded(false) {}
  DeserializationError parse(VariantData &variant) {
    DeserializationError err = parseVariant(variant);
   d6ff8:	f88d 0004 	strb.w	r0, [sp, #4]

    if (!err && _current != 0 && !variant.isEnclosed()) {
   d6ffc:	a802      	add	r0, sp, #8
   d6ffe:	f7fd ff81 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d7002:	9b02      	ldr	r3, [sp, #8]
   d7004:	b98b      	cbnz	r3, d702a <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE+0x66>
   d7006:	9b03      	ldr	r3, [sp, #12]
   d7008:	07db      	lsls	r3, r3, #31
   d700a:	d40e      	bmi.n	d702a <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE+0x66>
   d700c:	f89d 301d 	ldrb.w	r3, [sp, #29]
   d7010:	b15b      	cbz	r3, d702a <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE+0x66>
   d7012:	7e23      	ldrb	r3, [r4, #24]
  bool isNull() const {
    return type() == VALUE_IS_NULL;
  }

  bool isEnclosed() const {
    return isCollection() || isString();
   d7014:	f013 0f60 	tst.w	r3, #96	; 0x60
   d7018:	d107      	bne.n	d702a <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE+0x66>
    return type() == VALUE_IS_FLOAT || type() == VALUE_IS_POSITIVE_INTEGER ||
           type() == VALUE_IS_NEGATIVE_INTEGER;
  }

  bool isString() const {
    return type() == VALUE_IS_LINKED_STRING || type() == VALUE_IS_OWNED_STRING;
   d701a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d701e:	3b04      	subs	r3, #4
   d7020:	2b01      	cmp	r3, #1
      // We don't detect trailing characters earlier, so we need to check now
      err = DeserializationError::InvalidInput;
   d7022:	bf84      	itt	hi
   d7024:	2302      	movhi	r3, #2
   d7026:	f88d 3004 	strbhi.w	r3, [sp, #4]
  doc.clear();
  return makeDeserializer<TDeserializer>(
             doc.memoryPool(), reader,
             makeStringStorage(doc.memoryPool(), input), nestingLimit.value)
      .parse(doc.data());
}
   d702a:	f89d 0004 	ldrb.w	r0, [sp, #4]
   d702e:	b009      	add	sp, #36	; 0x24
   d7030:	bd30      	pop	{r4, r5, pc}

000d7032 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE>:
      default:
        return parseNumericValue(variant);
    }
  }

  DeserializationError parseArray(CollectionData &array) {
   d7032:	b570      	push	{r4, r5, r6, lr}
    if (_nestingLimit == 0) return DeserializationError::TooDeep;
   d7034:	7b03      	ldrb	r3, [r0, #12]
      default:
        return parseNumericValue(variant);
    }
  }

  DeserializationError parseArray(CollectionData &array) {
   d7036:	b088      	sub	sp, #32
   d7038:	4604      	mov	r4, r0
   d703a:	460e      	mov	r6, r1
    if (_nestingLimit == 0) return DeserializationError::TooDeep;
   d703c:	b913      	cbnz	r3, d7044 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x12>
   d703e:	f04f 0005 	mov.w	r0, #5
   d7042:	e05a      	b.n	d70fa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0xc8>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d7044:	f7ff fd14 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d7048:	285b      	cmp	r0, #91	; 0x5b
   d704a:	d110      	bne.n	d706e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x3c>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d704c:	2300      	movs	r3, #0
   d704e:	73a3      	strb	r3, [r4, #14]

    // Check opening braket
    if (!eat('[')) return DeserializationError::InvalidInput;

    // Skip spaces
    DeserializationError err = skipSpacesAndComments();
   d7050:	4620      	mov	r0, r4
   d7052:	f7ff fd25 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
    if (err) return err;
   d7056:	a901      	add	r1, sp, #4

    // Check opening braket
    if (!eat('[')) return DeserializationError::InvalidInput;

    // Skip spaces
    DeserializationError err = skipSpacesAndComments();
   d7058:	f88d 0004 	strb.w	r0, [sp, #4]
    if (err) return err;
   d705c:	a802      	add	r0, sp, #8
   d705e:	f7fd ff51 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d7062:	9b02      	ldr	r3, [sp, #8]
   d7064:	b9bb      	cbnz	r3, d7096 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x64>
   d7066:	9b03      	ldr	r3, [sp, #12]
   d7068:	07da      	lsls	r2, r3, #31
   d706a:	d414      	bmi.n	d7096 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x64>
   d706c:	e016      	b.n	d709c <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x6a>

  DeserializationError parseArray(CollectionData &array) {
    if (_nestingLimit == 0) return DeserializationError::TooDeep;

    // Check opening braket
    if (!eat('[')) return DeserializationError::InvalidInput;
   d706e:	f04f 0002 	mov.w	r0, #2
   d7072:	e042      	b.n	d70fa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0xc8>
      // Allocate slot in array
      VariantData *value = array.add(_pool);
      if (!value) return DeserializationError::NoMemory;

      // 1 - Parse value
      _nestingLimit--;
   d7074:	7b23      	ldrb	r3, [r4, #12]
   d7076:	3b01      	subs	r3, #1
   d7078:	7323      	strb	r3, [r4, #12]
      err = parseVariant(*value);
   d707a:	4620      	mov	r0, r4
   d707c:	f7ff ff44 	bl	d6f08 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE>
      _nestingLimit++;
   d7080:	7b23      	ldrb	r3, [r4, #12]
      VariantData *value = array.add(_pool);
      if (!value) return DeserializationError::NoMemory;

      // 1 - Parse value
      _nestingLimit--;
      err = parseVariant(*value);
   d7082:	f88d 0004 	strb.w	r0, [sp, #4]
      _nestingLimit++;
   d7086:	3301      	adds	r3, #1
   d7088:	7323      	strb	r3, [r4, #12]
      if (err) return err;
   d708a:	a901      	add	r1, sp, #4
   d708c:	a804      	add	r0, sp, #16
   d708e:	f7fd ff39 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d7092:	9b04      	ldr	r3, [sp, #16]
   d7094:	b153      	cbz	r3, d70ac <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x7a>
    // Check opening braket
    if (!eat('[')) return DeserializationError::InvalidInput;

    // Skip spaces
    DeserializationError err = skipSpacesAndComments();
    if (err) return err;
   d7096:	f89d 0004 	ldrb.w	r0, [sp, #4]
   d709a:	e02e      	b.n	d70fa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0xc8>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d709c:	4620      	mov	r0, r4
   d709e:	f7ff fce7 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d70a2:	285d      	cmp	r0, #93	; 0x5d
   d70a4:	d120      	bne.n	d70e8 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0xb6>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d70a6:	2000      	movs	r0, #0
   d70a8:	73a0      	strb	r0, [r4, #14]
   d70aa:	e026      	b.n	d70fa <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0xc8>

      // 1 - Parse value
      _nestingLimit--;
      err = parseVariant(*value);
      _nestingLimit++;
      if (err) return err;
   d70ac:	9b05      	ldr	r3, [sp, #20]
   d70ae:	07db      	lsls	r3, r3, #31
   d70b0:	d4f1      	bmi.n	d7096 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x64>

      // 2 - Skip spaces
      err = skipSpacesAndComments();
   d70b2:	4620      	mov	r0, r4
   d70b4:	f7ff fcf4 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
      if (err) return err;
   d70b8:	a901      	add	r1, sp, #4
      err = parseVariant(*value);
      _nestingLimit++;
      if (err) return err;

      // 2 - Skip spaces
      err = skipSpacesAndComments();
   d70ba:	f88d 0004 	strb.w	r0, [sp, #4]
      if (err) return err;
   d70be:	a806      	add	r0, sp, #24
   d70c0:	f7fd ff20 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d70c4:	9b06      	ldr	r3, [sp, #24]
   d70c6:	2b00      	cmp	r3, #0
   d70c8:	d1e5      	bne.n	d7096 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x64>
   d70ca:	9b07      	ldr	r3, [sp, #28]
   d70cc:	f013 0501 	ands.w	r5, r3, #1
   d70d0:	d1e1      	bne.n	d7096 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x64>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d70d2:	4620      	mov	r0, r4
   d70d4:	f7ff fccc 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d70d8:	285d      	cmp	r0, #93	; 0x5d
   d70da:	d0e4      	beq.n	d70a6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x74>
   d70dc:	4620      	mov	r0, r4
   d70de:	f7ff fcc7 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d70e2:	282c      	cmp	r0, #44	; 0x2c
   d70e4:	d1c3      	bne.n	d706e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x3c>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d70e6:	73a5      	strb	r5, [r4, #14]
  slot->clear();
  return slot;
}

inline VariantData* CollectionData::add(MemoryPool* pool) {
  return slotData(addSlot(pool));
   d70e8:	6821      	ldr	r1, [r4, #0]
   d70ea:	4630      	mov	r0, r6
   d70ec:	f7fd feeb 	bl	d4ec6 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE>

    // Read each value
    for (;;) {
      // Allocate slot in array
      VariantData *value = array.add(_pool);
      if (!value) return DeserializationError::NoMemory;
   d70f0:	4601      	mov	r1, r0
   d70f2:	2800      	cmp	r0, #0
   d70f4:	d1be      	bne.n	d7074 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE10parseArrayERNS_14CollectionDataE+0x42>
   d70f6:	f04f 0003 	mov.w	r0, #3

      // 3 - More values?
      if (eat(']')) return DeserializationError::Ok;
      if (!eat(',')) return DeserializationError::InvalidInput;
    }
  }
   d70fa:	b008      	add	sp, #32
   d70fc:	bd70      	pop	{r4, r5, r6, pc}

000d70fe <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE>:

  DeserializationError parseObject(CollectionData &object) {
   d70fe:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (_nestingLimit == 0) return DeserializationError::TooDeep;
   d7100:	7b03      	ldrb	r3, [r0, #12]
      if (eat(']')) return DeserializationError::Ok;
      if (!eat(',')) return DeserializationError::InvalidInput;
    }
  }

  DeserializationError parseObject(CollectionData &object) {
   d7102:	b08f      	sub	sp, #60	; 0x3c
   d7104:	4605      	mov	r5, r0
   d7106:	460e      	mov	r6, r1
    if (_nestingLimit == 0) return DeserializationError::TooDeep;
   d7108:	b913      	cbnz	r3, d7110 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x12>
   d710a:	f04f 0005 	mov.w	r0, #5
   d710e:	e0a1      	b.n	d7254 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x156>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d7110:	f7ff fcae 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d7114:	287b      	cmp	r0, #123	; 0x7b
   d7116:	f040 8095 	bne.w	d7244 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x146>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d711a:	2300      	movs	r3, #0
   d711c:	73ab      	strb	r3, [r5, #14]

    // Check opening brace
    if (!eat('{')) return DeserializationError::InvalidInput;

    // Skip spaces
    DeserializationError err = skipSpacesAndComments();
   d711e:	4628      	mov	r0, r5
   d7120:	f7ff fcbe 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
    if (err) return err;
   d7124:	4669      	mov	r1, sp

    // Check opening brace
    if (!eat('{')) return DeserializationError::InvalidInput;

    // Skip spaces
    DeserializationError err = skipSpacesAndComments();
   d7126:	f88d 0000 	strb.w	r0, [sp]
    if (err) return err;
   d712a:	a802      	add	r0, sp, #8
   d712c:	f7fd feea 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d7130:	9b02      	ldr	r3, [sp, #8]
   d7132:	2b00      	cmp	r3, #0
   d7134:	d173      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
   d7136:	9803      	ldr	r0, [sp, #12]
   d7138:	f010 0401 	ands.w	r4, r0, #1
   d713c:	d16f      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d713e:	4628      	mov	r0, r5
   d7140:	f7ff fc96 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d7144:	287d      	cmp	r0, #125	; 0x7d
   d7146:	d056      	beq.n	d71f6 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0xf8>

    // Read each key value pair
    for (;;) {
      // Parse key
      const char *key;
      err = parseKey(key);
   d7148:	a901      	add	r1, sp, #4
   d714a:	4628      	mov	r0, r5
   d714c:	f7ff fd58 	bl	d6c00 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE8parseKeyERPKc>
      if (err) return err;
   d7150:	4669      	mov	r1, sp

    // Read each key value pair
    for (;;) {
      // Parse key
      const char *key;
      err = parseKey(key);
   d7152:	f88d 0000 	strb.w	r0, [sp]
      if (err) return err;
   d7156:	a804      	add	r0, sp, #16
   d7158:	f7fd fed4 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d715c:	9b04      	ldr	r3, [sp, #16]
   d715e:	2b00      	cmp	r3, #0
   d7160:	d15d      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
   d7162:	9b05      	ldr	r3, [sp, #20]
   d7164:	07d9      	lsls	r1, r3, #31
   d7166:	d55d      	bpl.n	d7224 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x126>
   d7168:	e059      	b.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
    ARDUINOJSON_ASSERT(slot != 0);
    _next = VariantSlotDiff(slot - this);
  }

  void setOwnedKey(not_null<const char*> k) {
    _flags |= KEY_IS_OWNED;
   d716a:	7a03      	ldrb	r3, [r0, #8]
   d716c:	f063 037f 	orn	r3, r3, #127	; 0x7f
   d7170:	7203      	strb	r3, [r0, #8]
    _key = k.get();
   d7172:	9b01      	ldr	r3, [sp, #4]
   d7174:	60c3      	str	r3, [r0, #12]
  // - no destructor
  // - no virtual
  // - no inheritance

  VariantData* data() {
    return reinterpret_cast<VariantData*>(&_content);
   d7176:	4604      	mov	r4, r0

        variant = slot->data();
      }

      // Skip spaces
      err = skipSpacesAndComments();
   d7178:	4628      	mov	r0, r5
   d717a:	f7ff fc91 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
      if (err) return err;  // Colon
   d717e:	4669      	mov	r1, sp

        variant = slot->data();
      }

      // Skip spaces
      err = skipSpacesAndComments();
   d7180:	f88d 0000 	strb.w	r0, [sp]
      if (err) return err;  // Colon
   d7184:	a806      	add	r0, sp, #24
   d7186:	f7fd febd 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d718a:	9b06      	ldr	r3, [sp, #24]
   d718c:	2b00      	cmp	r3, #0
   d718e:	d146      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
   d7190:	9b07      	ldr	r3, [sp, #28]
   d7192:	f013 0701 	ands.w	r7, r3, #1
   d7196:	d142      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d7198:	4628      	mov	r0, r5
   d719a:	f7ff fc69 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d719e:	283a      	cmp	r0, #58	; 0x3a
   d71a0:	d150      	bne.n	d7244 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x146>
      err = skipSpacesAndComments();
      if (err) return err;  // Colon
      if (!eat(':')) return DeserializationError::InvalidInput;

      // Parse value
      _nestingLimit--;
   d71a2:	7b2b      	ldrb	r3, [r5, #12]
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d71a4:	73af      	strb	r7, [r5, #14]
      err = skipSpacesAndComments();
      if (err) return err;  // Colon
      if (!eat(':')) return DeserializationError::InvalidInput;

      // Parse value
      _nestingLimit--;
   d71a6:	3b01      	subs	r3, #1
   d71a8:	732b      	strb	r3, [r5, #12]
      err = parseVariant(*variant);
   d71aa:	4621      	mov	r1, r4
   d71ac:	4628      	mov	r0, r5
   d71ae:	f7ff feab 	bl	d6f08 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE12parseVariantERNS_11VariantDataE>
      _nestingLimit++;
   d71b2:	7b2b      	ldrb	r3, [r5, #12]
      if (err) return err;  // Colon
      if (!eat(':')) return DeserializationError::InvalidInput;

      // Parse value
      _nestingLimit--;
      err = parseVariant(*variant);
   d71b4:	f88d 0000 	strb.w	r0, [sp]
      _nestingLimit++;
   d71b8:	3301      	adds	r3, #1
   d71ba:	732b      	strb	r3, [r5, #12]
      if (err) return err;
   d71bc:	4669      	mov	r1, sp
   d71be:	a808      	add	r0, sp, #32
   d71c0:	f7fd fea0 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d71c4:	9b08      	ldr	r3, [sp, #32]
   d71c6:	bb53      	cbnz	r3, d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
   d71c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   d71ca:	07da      	lsls	r2, r3, #31
   d71cc:	d427      	bmi.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>

      // Skip spaces
      err = skipSpacesAndComments();
   d71ce:	4628      	mov	r0, r5
   d71d0:	f7ff fc66 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
      if (err) return err;
   d71d4:	4669      	mov	r1, sp
      err = parseVariant(*variant);
      _nestingLimit++;
      if (err) return err;

      // Skip spaces
      err = skipSpacesAndComments();
   d71d6:	f88d 0000 	strb.w	r0, [sp]
      if (err) return err;
   d71da:	a80a      	add	r0, sp, #40	; 0x28
   d71dc:	f7fd fe92 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d71e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   d71e2:	b9e3      	cbnz	r3, d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
   d71e4:	980b      	ldr	r0, [sp, #44]	; 0x2c
   d71e6:	f010 0401 	ands.w	r4, r0, #1
   d71ea:	d118      	bne.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d71ec:	4628      	mov	r0, r5
   d71ee:	f7ff fc3f 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d71f2:	287d      	cmp	r0, #125	; 0x7d
   d71f4:	d102      	bne.n	d71fc <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0xfe>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d71f6:	73ac      	strb	r4, [r5, #14]
      // Skip spaces
      err = skipSpacesAndComments();
      if (err) return err;

      // More keys/values?
      if (eat('}')) return DeserializationError::Ok;
   d71f8:	4620      	mov	r0, r4
   d71fa:	e02b      	b.n	d7254 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x156>
  void move() {
    _loaded = false;
  }

  FORCE_INLINE bool eat(char charToSkip) {
    if (current() != charToSkip) return false;
   d71fc:	4628      	mov	r0, r5
   d71fe:	f7ff fc37 	bl	d6a70 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE7currentEv>
   d7202:	282c      	cmp	r0, #44	; 0x2c
   d7204:	d11e      	bne.n	d7244 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x146>
    }
    return _current;
  }

  void move() {
    _loaded = false;
   d7206:	73ac      	strb	r4, [r5, #14]
      // More keys/values?
      if (eat('}')) return DeserializationError::Ok;
      if (!eat(',')) return DeserializationError::InvalidInput;

      // Skip spaces
      err = skipSpacesAndComments();
   d7208:	4628      	mov	r0, r5
   d720a:	f7ff fc49 	bl	d6aa0 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE21skipSpacesAndCommentsEv>
      if (err) return err;
   d720e:	4669      	mov	r1, sp
      // More keys/values?
      if (eat('}')) return DeserializationError::Ok;
      if (!eat(',')) return DeserializationError::InvalidInput;

      // Skip spaces
      err = skipSpacesAndComments();
   d7210:	f88d 0000 	strb.w	r0, [sp]
      if (err) return err;
   d7214:	a80c      	add	r0, sp, #48	; 0x30
   d7216:	f7fd fe75 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d721a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   d721c:	b1ab      	cbz	r3, d724a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x14c>
    // Read each key value pair
    for (;;) {
      // Parse key
      const char *key;
      err = parseKey(key);
      if (err) return err;
   d721e:	f89d 0000 	ldrb.w	r0, [sp]
   d7222:	e017      	b.n	d7254 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x156>

      VariantData *variant = object.get(adaptString(key));
   d7224:	9901      	ldr	r1, [sp, #4]
   d7226:	4630      	mov	r0, r6
   d7228:	f7ff fb9a 	bl	d6960 <_ZNK22ArduinoJson6130_00000114CollectionData3getINS_21ConstRamStringAdapterEEEPNS_11VariantDataET_>
      if (!variant) {
   d722c:	4604      	mov	r4, r0
   d722e:	2800      	cmp	r0, #0
   d7230:	d1a2      	bne.n	d7178 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x7a>
        // Allocate slot in object
        VariantSlot *slot = object.addSlot(_pool);
   d7232:	6829      	ldr	r1, [r5, #0]
   d7234:	4630      	mov	r0, r6
   d7236:	f7fd fe46 	bl	d4ec6 <_ZN22ArduinoJson6130_00000114CollectionData7addSlotEPNS_10MemoryPoolE>
        if (!slot) return DeserializationError::NoMemory;
   d723a:	2800      	cmp	r0, #0
   d723c:	d195      	bne.n	d716a <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x6c>
   d723e:	f04f 0003 	mov.w	r0, #3
   d7242:	e007      	b.n	d7254 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x156>
      }

      // Skip spaces
      err = skipSpacesAndComments();
      if (err) return err;  // Colon
      if (!eat(':')) return DeserializationError::InvalidInput;
   d7244:	f04f 0002 	mov.w	r0, #2
   d7248:	e004      	b.n	d7254 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x156>
      if (eat('}')) return DeserializationError::Ok;
      if (!eat(',')) return DeserializationError::InvalidInput;

      // Skip spaces
      err = skipSpacesAndComments();
      if (err) return err;
   d724a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   d724c:	07db      	lsls	r3, r3, #31
   d724e:	f57f af7b 	bpl.w	d7148 <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x4a>
   d7252:	e7e4      	b.n	d721e <_ZN22ArduinoJson6130_00000116JsonDeserializerINS_6ReaderIN5SDLib4FileEvEENS_12StringCopierEE11parseObjectERNS_14CollectionDataE+0x120>
    }
  }
   d7254:	b00f      	add	sp, #60	; 0x3c
   d7256:	bdf0      	pop	{r4, r5, r6, r7, pc}

000d7258 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc>:

template <typename A, typename B>
struct choose_largest : conditional<(sizeof(A) > sizeof(B)), A, B> {};

template <typename TFloat, typename TUInt>
inline ParsedNumber<TFloat, TUInt> parseNumber(const char *s) {
   d7258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
   d725c:	780b      	ldrb	r3, [r1, #0]
   d725e:	2b2b      	cmp	r3, #43	; 0x2b

template <typename A, typename B>
struct choose_largest : conditional<(sizeof(A) > sizeof(B)), A, B> {};

template <typename TFloat, typename TUInt>
inline ParsedNumber<TFloat, TUInt> parseNumber(const char *s) {
   d7260:	4604      	mov	r4, r0
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
   d7262:	d004      	beq.n	d726e <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x16>
   d7264:	2b2d      	cmp	r3, #45	; 0x2d
   d7266:	d103      	bne.n	d7270 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x18>
    case '-':
      is_negative = true;
      s++;
   d7268:	3101      	adds	r1, #1
  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
  switch (*s) {
    case '-':
      is_negative = true;
   d726a:	2601      	movs	r6, #1
      s++;
      break;
   d726c:	e001      	b.n	d7272 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x1a>
    case '+':
      s++;
   d726e:	3101      	adds	r1, #1
  typedef typename traits::exponent_type exponent_t;
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
   d7270:	2600      	movs	r6, #0
#if ARDUINOJSON_ENABLE_INFINITY
  if (*s == 'i' || *s == 'I')
    return is_negative ? -traits::inf() : traits::inf();
#endif

  if (!isdigit(*s) && *s != '.') return return_type();
   d7272:	780b      	ldrb	r3, [r1, #0]
   d7274:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   d7278:	2a09      	cmp	r2, #9
   d727a:	d902      	bls.n	d7282 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x2a>
   d727c:	2b2e      	cmp	r3, #46	; 0x2e
   d727e:	f040 8089 	bne.w	d7394 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x13c>
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
   d7282:	4f4f      	ldr	r7, [pc, #316]	; (d73c0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x168>)
  typedef typename traits::exponent_type exponent_t;
  typedef ParsedNumber<TFloat, TUInt> return_type;

  ARDUINOJSON_ASSERT(s != 0);

  bool is_negative = false;
   d7284:	2300      	movs	r3, #0
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
    mantissa *= 10;
   d7286:	f04f 0e0a 	mov.w	lr, #10

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
   d728a:	4608      	mov	r0, r1
   d728c:	f810 5b01 	ldrb.w	r5, [r0], #1
   d7290:	f1a5 0230 	sub.w	r2, r5, #48	; 0x30
   d7294:	b2d2      	uxtb	r2, r2
   d7296:	2a09      	cmp	r2, #9
   d7298:	d809      	bhi.n	d72ae <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x56>
    uint8_t digit = uint8_t(*s - '0');
    if (mantissa > maxUint / 10) break;
   d729a:	42bb      	cmp	r3, r7
   d729c:	d808      	bhi.n	d72b0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x58>
    mantissa *= 10;
   d729e:	fb0e f303 	mul.w	r3, lr, r3
    if (mantissa > maxUint - digit) break;
   d72a2:	43d5      	mvns	r5, r2
   d72a4:	42ab      	cmp	r3, r5
   d72a6:	d803      	bhi.n	d72b0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x58>
    mantissa += digit;
   d72a8:	4413      	add	r3, r2

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;
  const mantissa_t maxUint = TUInt(-1);

  while (isdigit(*s)) {
   d72aa:	4601      	mov	r1, r0
   d72ac:	e7ed      	b.n	d728a <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x32>
    if (mantissa > maxUint - digit) break;
    mantissa += digit;
    s++;
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);
   d72ae:	b11d      	cbz	r5, d72b8 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x60>

  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
   d72b0:	2200      	movs	r2, #0
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d72b2:	4f44      	ldr	r7, [pc, #272]	; (d73c4 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x16c>)
    mantissa /= 10;
   d72b4:	250a      	movs	r5, #10
   d72b6:	e00e      	b.n	d72d6 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x7e>

  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
   d72b8:	ee07 3a90 	vmov	s15, r3
   d72bc:	eef8 7a67 	vcvt.f32.u32	s15, s15
   d72c0:	2e00      	cmp	r6, #0
   d72c2:	6023      	str	r3, [r4, #0]
   d72c4:	edc4 7a01 	vstr	s15, [r4, #4]
   d72c8:	bf0c      	ite	eq
   d72ca:	2308      	moveq	r3, #8
   d72cc:	230a      	movne	r3, #10
   d72ce:	e073      	b.n	d73b8 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x160>
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d72d0:	4602      	mov	r2, r0
    mantissa /= 10;
   d72d2:	fbb3 f3f5 	udiv	r3, r3, r5
  }

  if (*s == '\0') return return_type(TUInt(mantissa), is_negative);

  // avoid mantissa overflow
  while (mantissa > traits::mantissa_max) {
   d72d6:	42bb      	cmp	r3, r7
   d72d8:	f102 0001 	add.w	r0, r2, #1
   d72dc:	d8f8      	bhi.n	d72d0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x78>
   d72de:	1a52      	subs	r2, r2, r1
   d72e0:	1850      	adds	r0, r2, r1
   d72e2:	460d      	mov	r5, r1
    mantissa /= 10;
    exponent_offset++;
  }

  // remaing digits can't fit in the mantissa
  while (isdigit(*s)) {
   d72e4:	f811 7b01 	ldrb.w	r7, [r1], #1
   d72e8:	f1a7 0e30 	sub.w	lr, r7, #48	; 0x30
   d72ec:	f1be 0f09 	cmp.w	lr, #9
   d72f0:	b240      	sxtb	r0, r0
   d72f2:	d9f5      	bls.n	d72e0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x88>
    exponent_offset++;
    s++;
  }

  if (*s == '.') {
   d72f4:	2f2e      	cmp	r7, #46	; 0x2e
   d72f6:	d110      	bne.n	d731a <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xc2>
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
   d72f8:	f8df e0dc 	ldr.w	lr, [pc, #220]	; d73d8 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x180>
        mantissa = mantissa * 10 + uint8_t(*s - '0');
   d72fc:	270a      	movs	r7, #10
   d72fe:	460d      	mov	r5, r1
   d7300:	3101      	adds	r1, #1
   d7302:	782a      	ldrb	r2, [r5, #0]
   d7304:	3a30      	subs	r2, #48	; 0x30
   d7306:	b2d2      	uxtb	r2, r2
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
   d7308:	2a09      	cmp	r2, #9
   d730a:	d806      	bhi.n	d731a <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xc2>
      if (mantissa < traits::mantissa_max / 10) {
   d730c:	4573      	cmp	r3, lr
   d730e:	d8f6      	bhi.n	d72fe <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xa6>
        mantissa = mantissa * 10 + uint8_t(*s - '0');
        exponent_offset--;
   d7310:	3801      	subs	r0, #1

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
        mantissa = mantissa * 10 + uint8_t(*s - '0');
   d7312:	fb07 2303 	mla	r3, r7, r3, r2
        exponent_offset--;
   d7316:	b240      	sxtb	r0, r0
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
   d7318:	e7f1      	b.n	d72fe <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xa6>
      s++;
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
   d731a:	782a      	ldrb	r2, [r5, #0]
   d731c:	f002 02df 	and.w	r2, r2, #223	; 0xdf
   d7320:	2a45      	cmp	r2, #69	; 0x45
   d7322:	d134      	bne.n	d738e <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x136>
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
   d7324:	786a      	ldrb	r2, [r5, #1]
   d7326:	2a2d      	cmp	r2, #45	; 0x2d
   d7328:	d102      	bne.n	d7330 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xd8>
      negative_exponent = true;
      s++;
   d732a:	1ca9      	adds	r1, r5, #2
  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
   d732c:	2701      	movs	r7, #1
   d732e:	e004      	b.n	d733a <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xe2>
      s++;
    } else if (*s == '+') {
   d7330:	2a2b      	cmp	r2, #43	; 0x2b
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
   d7332:	bf14      	ite	ne
   d7334:	1c69      	addne	r1, r5, #1
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
      s++;
    } else if (*s == '+') {
      s++;
   d7336:	1ca9      	addeq	r1, r5, #2
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
   d7338:	2700      	movs	r7, #0
   d733a:	2200      	movs	r2, #0
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
      exponent = exponent * 10 + (*s - '0');
   d733c:	f04f 0c0a 	mov.w	ip, #10
   d7340:	460d      	mov	r5, r1
      s++;
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
   d7342:	f811 eb01 	ldrb.w	lr, [r1], #1
   d7346:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
   d734a:	fa5f f88e 	uxtb.w	r8, lr
   d734e:	f1b8 0f09 	cmp.w	r8, #9
   d7352:	d819      	bhi.n	d7388 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x130>
      exponent = exponent * 10 + (*s - '0');
   d7354:	fb0c e202 	mla	r2, ip, r2, lr
      if (exponent + exponent_offset > traits::exponent_max) {
   d7358:	1885      	adds	r5, r0, r2
   d735a:	2d26      	cmp	r5, #38	; 0x26
   d735c:	ddf0      	ble.n	d7340 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0xe8>
        if (negative_exponent)
   d735e:	b147      	cbz	r7, d7372 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x11a>
          return is_negative ? -0.0f : 0.0f;
   d7360:	ed9f 7a19 	vldr	s14, [pc, #100]	; d73c8 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x170>
   d7364:	eddf 7a19 	vldr	s15, [pc, #100]	; d73cc <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x174>
   d7368:	2e00      	cmp	r6, #0
   d736a:	bf18      	it	ne
   d736c:	eef0 7a47 	vmovne.f32	s15, s14
   d7370:	e007      	b.n	d7382 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x12a>
        else
          return is_negative ? -traits::inf() : traits::inf();
   d7372:	ed9f 7a17 	vldr	s14, [pc, #92]	; d73d0 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x178>
   d7376:	eddf 7a17 	vldr	s15, [pc, #92]	; d73d4 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x17c>
   d737a:	2e00      	cmp	r6, #0
   d737c:	bf08      	it	eq
   d737e:	eef0 7a47 	vmoveq.f32	s15, s14
  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
  ParsedNumber(TFloat value) : floatValue(value), _type(VALUE_IS_FLOAT) {}
   d7382:	edc4 7a01 	vstr	s15, [r4, #4]
   d7386:	e016      	b.n	d73b6 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x15e>
        else
          return is_negative ? -traits::inf() : traits::inf();
      }
      s++;
    }
    if (negative_exponent) exponent = -exponent;
   d7388:	b117      	cbz	r7, d7390 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x138>
   d738a:	4252      	negs	r2, r2
   d738c:	e000      	b.n	d7390 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x138>
      }
      s++;
    }
  }

  int exponent = 0;
   d738e:	2200      	movs	r2, #0
    if (negative_exponent) exponent = -exponent;
  }
  exponent += exponent_offset;

  // we should be at the end of the string, otherwise it's an error
  if (*s != '\0') return return_type();
   d7390:	7829      	ldrb	r1, [r5, #0]
   d7392:	b121      	cbz	r1, d739e <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x146>

namespace ARDUINOJSON_NAMESPACE {

template <typename TFloat, typename TUInt>
struct ParsedNumber {
  ParsedNumber() : uintValue(0), floatValue(0), _type(VALUE_IS_NULL) {}
   d7394:	2300      	movs	r3, #0
   d7396:	2200      	movs	r2, #0
   d7398:	6023      	str	r3, [r4, #0]
   d739a:	6062      	str	r2, [r4, #4]
   d739c:	e00c      	b.n	d73b8 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x160>
  exponent += exponent_offset;

  // we should be at the end of the string, otherwise it's an error
  if (*s != '\0') return return_type();

  TFloat result = traits::make_float(static_cast<TFloat>(mantissa), exponent);
   d739e:	ee07 3a90 	vmov	s15, r3
   d73a2:	4410      	add	r0, r2
   d73a4:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   d73a8:	f7ff fc66 	bl	d6c78 <_ZN22ArduinoJson6130_00000111FloatTraitsIfLj4EE10make_floatIiEEffT_>

  return is_negative ? -result : result;
   d73ac:	b10e      	cbz	r6, d73b2 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc+0x15a>
   d73ae:	eeb1 0a40 	vneg.f32	s0, s0
  ParsedNumber(TUInt value, bool is_negative)
      : uintValue(value),
        floatValue(TFloat(value)),
        _type(uint8_t(is_negative ? VALUE_IS_NEGATIVE_INTEGER
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
  ParsedNumber(TFloat value) : floatValue(value), _type(VALUE_IS_FLOAT) {}
   d73b2:	ed84 0a01 	vstr	s0, [r4, #4]
   d73b6:	230c      	movs	r3, #12
   d73b8:	7223      	strb	r3, [r4, #8]
  if (*s != '\0') return return_type();

  TFloat result = traits::make_float(static_cast<TFloat>(mantissa), exponent);

  return is_negative ? -result : result;
}
   d73ba:	4620      	mov	r0, r4
   d73bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d73c0:	19999999 	.word	0x19999999
   d73c4:	007fffff 	.word	0x007fffff
   d73c8:	80000000 	.word	0x80000000
   d73cc:	00000000 	.word	0x00000000
   d73d0:	7f800000 	.word	0x7f800000
   d73d4:	ff800000 	.word	0xff800000
   d73d8:	000ccccb 	.word	0x000ccccb

000d73dc <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_>:
template <typename TImpl>
class VariantOr {
 public:
  // Returns the default value if the VariantRef is undefined of incompatible
  template <typename T>
  T operator|(const T &defaultValue) const {
   d73dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  // JsonVariant getMember(char*)
  // JsonVariant getMember(const char*)
  // JsonVariant getMember(const __FlashStringHelper*)
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar* key) {
    return VariantRef(&_pool, _data.getMember(adaptString(key)));
   d73de:	e890 0030 	ldmia.w	r0, {r4, r5}
   d73e2:	3410      	adds	r4, #16
   d73e4:	460e      	mov	r6, r1
   d73e6:	4620      	mov	r0, r4
   d73e8:	4629      	mov	r1, r5
   d73ea:	f7ff fb98 	bl	d6b1e <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_>
  return var && var->isBoolean();
}

template <typename T>
inline bool variantIsInteger(const VariantData *var) {
  return var && var->isInteger<T>();
   d73ee:	2800      	cmp	r0, #0
   d73f0:	d059      	beq.n	d74a6 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xca>
    return (_flags & COLLECTION_MASK) != 0;
  }

  template <typename T>
  bool isInteger() const {
    switch (type()) {
   d73f2:	7a03      	ldrb	r3, [r0, #8]
   d73f4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d73f8:	2b08      	cmp	r3, #8
   d73fa:	d008      	beq.n	d740e <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x32>
   d73fc:	2b0a      	cmp	r3, #10
   d73fe:	d152      	bne.n	d74a6 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xca>
template <typename TOut, typename TIn>
typename enable_if<is_integral<TOut>::value && is_signed<TOut>::value &&
                       sizeof(TOut) <= sizeof(TIn),
                   bool>::type
canStoreNegativeInteger(TIn value) {
  return value <= TIn(numeric_limits<TOut>::highest()) + 1;
   d7400:	6803      	ldr	r3, [r0, #0]
   d7402:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   d7406:	bf8c      	ite	hi
   d7408:	2300      	movhi	r3, #0
   d740a:	2301      	movls	r3, #1
   d740c:	e002      	b.n	d7414 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x38>

template <typename TOut, typename TIn>
typename enable_if<is_integral<TOut>::value && sizeof(TOut) <= sizeof(TIn),
                   bool>::type
canStorePositiveInteger(TIn value) {
  return value <= TIn(numeric_limits<TOut>::highest());
   d740e:	6803      	ldr	r3, [r0, #0]
   d7410:	43db      	mvns	r3, r3
   d7412:	0fdb      	lsrs	r3, r3, #31
   d7414:	2b00      	cmp	r3, #0
   d7416:	d046      	beq.n	d74a6 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xca>
   d7418:	4629      	mov	r1, r5
   d741a:	4620      	mov	r0, r4
   d741c:	f7ff fb7f 	bl	d6b1e <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_>
// ---

template <typename T>
inline typename enable_if<is_integral<T>::value, T>::type variantAs(
    const VariantData* _data) {
  return _data != 0 ? _data->asIntegral<T>() : T(0);
   d7420:	2800      	cmp	r0, #0
   d7422:	d043      	beq.n	d74ac <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd0>

namespace ARDUINOJSON_NAMESPACE {

template <typename T>
inline T VariantData::asIntegral() const {
  switch (type()) {
   d7424:	7a03      	ldrb	r3, [r0, #8]
   d7426:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d742a:	3b04      	subs	r3, #4
   d742c:	2b08      	cmp	r3, #8
   d742e:	d83c      	bhi.n	d74aa <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xce>
   d7430:	e8df f003 	tbb	[pc, r3]
   d7434:	3b050909 	.word	0x3b050909
   d7438:	3b073b05 	.word	0x3b073b05
   d743c:	24          	.byte	0x24
   d743d:	00          	.byte	0x00
    case VALUE_IS_POSITIVE_INTEGER:
    case VALUE_IS_BOOLEAN:
      return convertPositiveInteger<T>(_content.asInteger);
   d743e:	6800      	ldr	r0, [r0, #0]
   d7440:	e014      	b.n	d746c <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x90>
    case VALUE_IS_NEGATIVE_INTEGER:
      return convertNegativeInteger<T>(_content.asInteger);
   d7442:	6800      	ldr	r0, [r0, #0]
   d7444:	e00d      	b.n	d7462 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x86>
template <typename T>
T parseInteger(const char *s) {
  // try to reuse the same parameters as JsonDeserializer
  typedef typename choose_largest<UInt, typename make_unsigned<T>::type>::type
      TUInt;
  return parseNumber<Float, TUInt>(s).template as<T>();
   d7446:	6801      	ldr	r1, [r0, #0]
   d7448:	a801      	add	r0, sp, #4
   d744a:	f7ff ff05 	bl	d7258 <_ZN22ArduinoJson6130_00000111parseNumberIfjEENS_12ParsedNumberIT_T0_EEPKc>
                                  : VALUE_IS_POSITIVE_INTEGER)) {}
  ParsedNumber(TFloat value) : floatValue(value), _type(VALUE_IS_FLOAT) {}

  template <typename T>
  T as() const {
    switch (_type) {
   d744e:	f89d 300c 	ldrb.w	r3, [sp, #12]
   d7452:	9801      	ldr	r0, [sp, #4]
   d7454:	2b0a      	cmp	r3, #10
   d7456:	d004      	beq.n	d7462 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x86>
   d7458:	2b0c      	cmp	r3, #12
   d745a:	d00c      	beq.n	d7476 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x9a>
   d745c:	2b08      	cmp	r3, #8
   d745e:	d124      	bne.n	d74aa <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xce>
   d7460:	e004      	b.n	d746c <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0x90>
  return canStorePositiveInteger<TOut>(value) ? TOut(value) : 0;
}

template <typename TOut, typename TIn>
TOut convertNegativeInteger(TIn value) {
  return canStoreNegativeInteger<TOut>(value) ? TOut(~value + 1) : 0;
   d7462:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
   d7466:	d820      	bhi.n	d74aa <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xce>
   d7468:	4240      	negs	r0, r0
   d746a:	e01f      	b.n	d74ac <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd0>
  return false;
}

template <typename TOut, typename TIn>
TOut convertPositiveInteger(TIn value) {
  return canStorePositiveInteger<TOut>(value) ? TOut(value) : 0;
   d746c:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
   d7470:	bf28      	it	cs
   d7472:	2000      	movcs	r0, #0
   d7474:	e01a      	b.n	d74ac <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd0>
      case VALUE_IS_NEGATIVE_INTEGER:
        return convertNegativeInteger<T>(uintValue);
      case VALUE_IS_POSITIVE_INTEGER:
        return convertPositiveInteger<T>(uintValue);
      case VALUE_IS_FLOAT:
        return convertFloat<T>(floatValue);
   d7476:	eddd 7a02 	vldr	s15, [sp, #8]
   d747a:	e001      	b.n	d7480 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xa4>
    case VALUE_IS_LINKED_STRING:
    case VALUE_IS_OWNED_STRING:
      return parseInteger<T>(_content.asString);
    case VALUE_IS_FLOAT:
      return convertFloat<T>(_content.asFloat);
   d747c:	edd0 7a00 	vldr	s15, [r0]
typename enable_if<!is_floating_point<TOut>::value, TOut>::type convertFloat(
    TIn value) {
  return value >= numeric_limits<TOut>::lowest() &&
                 value <= numeric_limits<TOut>::highest()
             ? TOut(value)
             : 0;
   d7480:	ed9f 7a0b 	vldr	s14, [pc, #44]	; d74b0 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd4>
   d7484:	eef4 7ac7 	vcmpe.f32	s15, s14
   d7488:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d748c:	db0d      	blt.n	d74aa <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xce>
   d748e:	ed9f 7a09 	vldr	s14, [pc, #36]	; d74b4 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd8>
   d7492:	eef4 7ac7 	vcmpe.f32	s15, s14
   d7496:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d749a:	d806      	bhi.n	d74aa <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xce>
   d749c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   d74a0:	ee17 0a90 	vmov	r0, s15
   d74a4:	e002      	b.n	d74ac <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd0>
    if (impl()->template is<T>())
      return impl()->template as<T>();
    else
      return defaultValue;
   d74a6:	6830      	ldr	r0, [r6, #0]
   d74a8:	e000      	b.n	d74ac <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_+0xd0>
   d74aa:	2000      	movs	r0, #0
  }
   d74ac:	b004      	add	sp, #16
   d74ae:	bd70      	pop	{r4, r5, r6, pc}
   d74b0:	cf000000 	.word	0xcf000000
   d74b4:	4f000000 	.word	0x4f000000

000d74b8 <_ZN22ArduinoJson6130_0000016WriterIN5SDLib4FileEvE5writeEPKhj>:
  size_t write(uint8_t c) {
    return _print->write(c);
  }

  size_t write(const uint8_t* s, size_t n) {
    return _print->write(s, n);
   d74b8:	6800      	ldr	r0, [r0, #0]
   d74ba:	6803      	ldr	r3, [r0, #0]
   d74bc:	68db      	ldr	r3, [r3, #12]
   d74be:	4718      	bx	r3

000d74c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKc>:

    // and dump it in the right order
    writeRaw(begin, end);
  }

  void writeRaw(const char *s) {
   d74c0:	b538      	push	{r3, r4, r5, lr}
   d74c2:	4604      	mov	r4, r0
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
   d74c4:	4608      	mov	r0, r1

    // and dump it in the right order
    writeRaw(begin, end);
  }

  void writeRaw(const char *s) {
   d74c6:	460d      	mov	r5, r1
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
   d74c8:	f008 fdce 	bl	e0068 <strlen>
   d74cc:	4629      	mov	r1, r5
   d74ce:	4602      	mov	r2, r0
   d74d0:	4620      	mov	r0, r4
   d74d2:	f7ff fff1 	bl	d74b8 <_ZN22ArduinoJson6130_0000016WriterIN5SDLib4FileEvE5writeEPKhj>
   d74d6:	6863      	ldr	r3, [r4, #4]
   d74d8:	4418      	add	r0, r3
   d74da:	6060      	str	r0, [r4, #4]
   d74dc:	bd38      	pop	{r3, r4, r5, pc}

000d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>:

  template <size_t N>
  void writeRaw(const char (&s)[N]) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), N - 1);
  }
  void writeRaw(char c) {
   d74de:	b510      	push	{r4, lr}
   d74e0:	4604      	mov	r4, r0
    typename enable_if<is_base_of< ::Print, TDestination>::value>::type> {
 public:
  explicit Writer(::Print& print) : _print(&print) {}

  size_t write(uint8_t c) {
    return _print->write(c);
   d74e2:	6800      	ldr	r0, [r0, #0]
   d74e4:	6803      	ldr	r3, [r0, #0]
   d74e6:	689b      	ldr	r3, [r3, #8]
   d74e8:	4798      	blx	r3
    _length += _writer.write(static_cast<uint8_t>(c));
   d74ea:	6863      	ldr	r3, [r4, #4]
   d74ec:	4418      	add	r0, r3
   d74ee:	6060      	str	r0, [r4, #4]
   d74f0:	bd10      	pop	{r4, pc}
	...

000d74f4 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc>:
      writeRaw("true");
    else
      writeRaw("false");
  }

  void writeString(const char *value) {
   d74f4:	b570      	push	{r4, r5, r6, lr}
   d74f6:	4605      	mov	r5, r0
    if (!value) {
   d74f8:	460c      	mov	r4, r1
   d74fa:	b919      	cbnz	r1, d7504 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x10>
      writeRaw("null");
   d74fc:	4911      	ldr	r1, [pc, #68]	; (d7544 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x50>)
   d74fe:	f7ff ffdf 	bl	d74c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKc>
   d7502:	bd70      	pop	{r4, r5, r6, pc}
    } else {
      writeRaw('\"');
   d7504:	2122      	movs	r1, #34	; 0x22
   d7506:	f7ff ffea 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d750a:	3c01      	subs	r4, #1
      while (*value) writeChar(*value++);
   d750c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   d7510:	b171      	cbz	r1, d7530 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x3c>
   d7512:	4b0d      	ldr	r3, [pc, #52]	; (d7548 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x54>)
class EscapeSequence {
 public:
  // Optimized for code size on a 8-bit AVR
  static char escapeChar(char c) {
    const char *p = escapeTable(false);
    while (p[0] && p[1] != c) {
   d7514:	f813 6c02 	ldrb.w	r6, [r3, #-2]
   d7518:	b17e      	cbz	r6, d753a <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x46>
   d751a:	3302      	adds	r3, #2
   d751c:	f813 2c03 	ldrb.w	r2, [r3, #-3]
   d7520:	428a      	cmp	r2, r1
   d7522:	d1f7      	bne.n	d7514 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x20>
  }

  void writeChar(char c) {
    char specialChar = EscapeSequence::escapeChar(c);
    if (specialChar) {
      writeRaw('\\');
   d7524:	215c      	movs	r1, #92	; 0x5c
   d7526:	4628      	mov	r0, r5
   d7528:	f7ff ffd9 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
      writeRaw(specialChar);
   d752c:	4631      	mov	r1, r6
   d752e:	e004      	b.n	d753a <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x46>
    if (!value) {
      writeRaw("null");
    } else {
      writeRaw('\"');
      while (*value) writeChar(*value++);
      writeRaw('\"');
   d7530:	2122      	movs	r1, #34	; 0x22
   d7532:	4628      	mov	r0, r5
   d7534:	f7ff ffd3 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
    }
  }
   d7538:	bd70      	pop	{r4, r5, r6, pc}
    char specialChar = EscapeSequence::escapeChar(c);
    if (specialChar) {
      writeRaw('\\');
      writeRaw(specialChar);
    } else {
      writeRaw(c);
   d753a:	4628      	mov	r0, r5
   d753c:	f7ff ffcf 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d7540:	e7e4      	b.n	d750c <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc+0x18>
   d7542:	bf00      	nop
   d7544:	000e1eeb 	.word	0x000e1eeb
   d7548:	000e1ede 	.word	0x000e1ede
   d754c:	00000000 	.word	0x00000000

000d7550 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef>:
  uint32_t integral;
  uint32_t decimal;
  int16_t exponent;
  int8_t decimalPlaces;

  FloatParts(TFloat value) {
   d7550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int16_t powersOf10 = 0;

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
   d7552:	eddf 7a55 	vldr	s15, [pc, #340]	; d76a8 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x158>
   d7556:	eeb4 0ae7 	vcmpe.f32	s0, s15
  int16_t exponent;
  int8_t decimalPlaces;

  FloatParts(TFloat value) {
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;
   d755a:	2306      	movs	r3, #6
    int16_t powersOf10 = 0;

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
   d755c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  uint32_t integral;
  uint32_t decimal;
  int16_t exponent;
  int8_t decimalPlaces;

  FloatParts(TFloat value) {
   d7560:	ed2d 8b02 	vpush	{d8}
   d7564:	4604      	mov	r4, r0
   d7566:	eeb0 8a40 	vmov.f32	s16, s0
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;
   d756a:	7283      	strb	r3, [r0, #10]
    int16_t powersOf10 = 0;

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
   d756c:	db1c      	blt.n	d75a8 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x58>
   d756e:	4b4f      	ldr	r3, [pc, #316]	; (d76ac <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x15c>)
   d7570:	4a4f      	ldr	r2, [pc, #316]	; (d76b0 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x160>)
   d7572:	f1a3 0118 	sub.w	r1, r3, #24
   d7576:	2500      	movs	r5, #0
   d7578:	2720      	movs	r7, #32
      for (; index >= 0; index--) {
        if (value >= traits::positiveBinaryPowerOfTen(index)) {
   d757a:	ed72 7a01 	vldmdb	r2!, {s15}
   d757e:	eef4 7ac8 	vcmpe.f32	s15, s16
   d7582:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
          value *= traits::negativeBinaryPowerOfTen(index);
   d7586:	bf9c      	itt	ls
   d7588:	edd3 7a05 	vldrls	s15, [r3, #20]
          powersOf10 = int16_t(powersOf10 + bit);
   d758c:	19ed      	addls	r5, r5, r7
   d758e:	f1a3 0304 	sub.w	r3, r3, #4
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
        if (value >= traits::positiveBinaryPowerOfTen(index)) {
          value *= traits::negativeBinaryPowerOfTen(index);
   d7592:	bf9c      	itt	ls
   d7594:	ee28 8a27 	vmulls.f32	s16, s16, s15
          powersOf10 = int16_t(powersOf10 + bit);
   d7598:	b22d      	sxthls	r5, r5

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
   d759a:	4299      	cmp	r1, r3
        if (value >= traits::positiveBinaryPowerOfTen(index)) {
          value *= traits::negativeBinaryPowerOfTen(index);
          powersOf10 = int16_t(powersOf10 + bit);
        }
        bit >>= 1;
   d759c:	ea4f 0767 	mov.w	r7, r7, asr #1

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;

    if (value >= ARDUINOJSON_POSITIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
   d75a0:	d1eb      	bne.n	d757a <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x2a>
   d75a2:	f04f 36ff 	mov.w	r6, #4294967295
   d75a6:	e002      	b.n	d75ae <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x5e>
  static int16_t normalize(TFloat& value) {
    typedef FloatTraits<TFloat> traits;
    int16_t powersOf10 = 0;

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
    int bit = 1 << index;
   d75a8:	2720      	movs	r7, #32

  static int16_t normalize(TFloat& value) {
    typedef FloatTraits<TFloat> traits;
    int16_t powersOf10 = 0;

    int8_t index = sizeof(TFloat) == 8 ? 8 : 5;
   d75aa:	2605      	movs	r6, #5
    }
  }

  static int16_t normalize(TFloat& value) {
    typedef FloatTraits<TFloat> traits;
    int16_t powersOf10 = 0;
   d75ac:	2500      	movs	r5, #0
        }
        bit >>= 1;
      }
    }

    if (value > 0 && value <= ARDUINOJSON_NEGATIVE_EXPONENTIATION_THRESHOLD) {
   d75ae:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   d75b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d75b6:	dd21      	ble.n	d75fc <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xac>
   d75b8:	ee18 0a10 	vmov	r0, s16
   d75bc:	f007 fe8a 	bl	df2d4 <__aeabi_f2d>
   d75c0:	a337      	add	r3, pc, #220	; (adr r3, d76a0 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x150>)
   d75c2:	e9d3 2300 	ldrd	r2, r3, [r3]
   d75c6:	f008 f955 	bl	df874 <__aeabi_dcmple>
   d75ca:	b1b8      	cbz	r0, d75fc <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xac>
    return factors[index];
  }

  static T negativeBinaryPowerOfTenPlusOne(int index) {
    static T factors[] = {1e0f, 1e-1f, 1e-3f, 1e-7f, 1e-15f, 1e-31f};
    return factors[index];
   d75cc:	4a39      	ldr	r2, [pc, #228]	; (d76b4 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x164>)
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
   d75ce:	493a      	ldr	r1, [pc, #232]	; (d76b8 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x168>)
      for (; index >= 0; index--) {
   d75d0:	1c73      	adds	r3, r6, #1
   d75d2:	d013      	beq.n	d75fc <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xac>
    return factors[index];
  }

  static T negativeBinaryPowerOfTenPlusOne(int index) {
    static T factors[] = {1e0f, 1e-1f, 1e-3f, 1e-7f, 1e-15f, 1e-31f};
    return factors[index];
   d75d4:	00b3      	lsls	r3, r6, #2
   d75d6:	18d0      	adds	r0, r2, r3
        if (value < traits::negativeBinaryPowerOfTenPlusOne(index)) {
   d75d8:	edd0 7a00 	vldr	s15, [r0]
   d75dc:	eef4 7ac8 	vcmpe.f32	s15, s16
   d75e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d75e4:	dd06      	ble.n	d75f4 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xa4>
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
   d75e6:	440b      	add	r3, r1
          value *= traits::positiveBinaryPowerOfTen(index);
   d75e8:	edd3 7a00 	vldr	s15, [r3]
          powersOf10 = int16_t(powersOf10 - bit);
   d75ec:	1bed      	subs	r5, r5, r7
    }

    if (value > 0 && value <= ARDUINOJSON_NEGATIVE_EXPONENTIATION_THRESHOLD) {
      for (; index >= 0; index--) {
        if (value < traits::negativeBinaryPowerOfTenPlusOne(index)) {
          value *= traits::positiveBinaryPowerOfTen(index);
   d75ee:	ee28 8a27 	vmul.f32	s16, s16, s15
          powersOf10 = int16_t(powersOf10 - bit);
   d75f2:	b22d      	sxth	r5, r5
   d75f4:	3e01      	subs	r6, #1
        }
        bit >>= 1;
   d75f6:	107f      	asrs	r7, r7, #1
   d75f8:	b276      	sxtb	r6, r6
   d75fa:	e7e9      	b.n	d75d0 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x80>
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;

    exponent = normalize(value);

    integral = uint32_t(value);
   d75fc:	eefc 7ac8 	vcvt.u32.f32	s15, s16
  uint32_t decimal;
  int16_t exponent;
  int8_t decimalPlaces;

  FloatParts(TFloat value) {
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
   d7600:	492e      	ldr	r1, [pc, #184]	; (d76bc <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x16c>)
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;

    exponent = normalize(value);
   d7602:	8125      	strh	r5, [r4, #8]

    integral = uint32_t(value);
   d7604:	ee17 3a90 	vmov	r3, s15
    // reduce number of decimal places by the number of integral places
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
   d7608:	ee17 2a90 	vmov	r2, s15
    uint32_t maxDecimalPart = sizeof(TFloat) >= 8 ? 1000000000 : 1000000;
    decimalPlaces = sizeof(TFloat) >= 8 ? 9 : 6;

    exponent = normalize(value);

    integral = uint32_t(value);
   d760c:	edc4 7a00 	vstr	s15, [r4]
    // reduce number of decimal places by the number of integral places
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
      maxDecimalPart /= 10;
   d7610:	260a      	movs	r6, #10

    exponent = normalize(value);

    integral = uint32_t(value);
    // reduce number of decimal places by the number of integral places
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
   d7612:	2a09      	cmp	r2, #9
   d7614:	d907      	bls.n	d7626 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xd6>
      maxDecimalPart /= 10;
   d7616:	fbb1 f1f6 	udiv	r1, r1, r6

    exponent = normalize(value);

    integral = uint32_t(value);
    // reduce number of decimal places by the number of integral places
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
   d761a:	fbb2 f2f6 	udiv	r2, r2, r6
      maxDecimalPart /= 10;
      decimalPlaces--;
   d761e:	7aa0      	ldrb	r0, [r4, #10]
   d7620:	3801      	subs	r0, #1
   d7622:	72a0      	strb	r0, [r4, #10]

    exponent = normalize(value);

    integral = uint32_t(value);
    // reduce number of decimal places by the number of integral places
    for (uint32_t tmp = integral; tmp >= 10; tmp /= 10) {
   d7624:	e7f5      	b.n	d7612 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0xc2>
      maxDecimalPart /= 10;
      decimalPlaces--;
    }

    TFloat remainder = (value - TFloat(integral)) * TFloat(maxDecimalPart);
   d7626:	ee07 3a90 	vmov	s15, r3
   d762a:	eeb8 0a67 	vcvt.f32.u32	s0, s15
   d762e:	ee07 1a90 	vmov	s15, r1
   d7632:	ee38 8a40 	vsub.f32	s16, s16, s0
   d7636:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   d763a:	ee28 8a00 	vmul.f32	s16, s16, s0

    decimal = uint32_t(remainder);
   d763e:	eefc 7ac8 	vcvt.u32.f32	s15, s16
    remainder = remainder - TFloat(decimal);

    // rounding:
    // increment by 1 if remainder >= 0.5
    decimal += uint32_t(remainder * 2);
   d7642:	eeb8 0a67 	vcvt.f32.u32	s0, s15
   d7646:	ee17 0a90 	vmov	r0, s15
   d764a:	ee38 8a40 	vsub.f32	s16, s16, s0
   d764e:	ee38 8a08 	vadd.f32	s16, s16, s16
   d7652:	eebc 8ac8 	vcvt.u32.f32	s16, s16
   d7656:	ee18 2a10 	vmov	r2, s16
   d765a:	4402      	add	r2, r0
    if (decimal >= maxDecimalPart) {
   d765c:	4291      	cmp	r1, r2
   d765e:	d901      	bls.n	d7664 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x114>
    decimal = uint32_t(remainder);
    remainder = remainder - TFloat(decimal);

    // rounding:
    // increment by 1 if remainder >= 0.5
    decimal += uint32_t(remainder * 2);
   d7660:	6062      	str	r2, [r4, #4]
   d7662:	e00a      	b.n	d767a <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x12a>
    if (decimal >= maxDecimalPart) {
      decimal = 0;
   d7664:	2200      	movs	r2, #0
      integral++;
   d7666:	3301      	adds	r3, #1

    // rounding:
    // increment by 1 if remainder >= 0.5
    decimal += uint32_t(remainder * 2);
    if (decimal >= maxDecimalPart) {
      decimal = 0;
   d7668:	6062      	str	r2, [r4, #4]
      integral++;
   d766a:	6023      	str	r3, [r4, #0]
      if (exponent && integral >= 10) {
   d766c:	b12d      	cbz	r5, d767a <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x12a>
   d766e:	2b09      	cmp	r3, #9
        exponent++;
   d7670:	bf81      	itttt	hi
   d7672:	3501      	addhi	r5, #1
        integral = 1;
   d7674:	2301      	movhi	r3, #1
    decimal += uint32_t(remainder * 2);
    if (decimal >= maxDecimalPart) {
      decimal = 0;
      integral++;
      if (exponent && integral >= 10) {
        exponent++;
   d7676:	8125      	strhhi	r5, [r4, #8]
        integral = 1;
   d7678:	6023      	strhi	r3, [r4, #0]
      }
    }

    // remove trailing zeros
    while (decimal % 10 == 0 && decimalPlaces > 0) {
   d767a:	210a      	movs	r1, #10
   d767c:	6863      	ldr	r3, [r4, #4]
   d767e:	fbb3 f2f1 	udiv	r2, r3, r1
   d7682:	fb01 3312 	mls	r3, r1, r2, r3
   d7686:	b93b      	cbnz	r3, d7698 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x148>
   d7688:	f994 300a 	ldrsb.w	r3, [r4, #10]
   d768c:	2b00      	cmp	r3, #0
   d768e:	dd03      	ble.n	d7698 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x148>
      decimal /= 10;
      decimalPlaces--;
   d7690:	3b01      	subs	r3, #1
      }
    }

    // remove trailing zeros
    while (decimal % 10 == 0 && decimalPlaces > 0) {
      decimal /= 10;
   d7692:	6062      	str	r2, [r4, #4]
      decimalPlaces--;
   d7694:	72a3      	strb	r3, [r4, #10]
        integral = 1;
      }
    }

    // remove trailing zeros
    while (decimal % 10 == 0 && decimalPlaces > 0) {
   d7696:	e7f1      	b.n	d767c <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef+0x12c>
      decimal /= 10;
      decimalPlaces--;
    }
  }
   d7698:	ecbd 8b02 	vpop	{d8}
   d769c:	4620      	mov	r0, r4
   d769e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   d76a0:	88e368f1 	.word	0x88e368f1
   d76a4:	3ee4f8b5 	.word	0x3ee4f8b5
   d76a8:	4b189680 	.word	0x4b189680
   d76ac:	2003d688 	.word	0x2003d688
   d76b0:	2003d6b8 	.word	0x2003d6b8
   d76b4:	2003d670 	.word	0x2003d670
   d76b8:	2003d6a0 	.word	0x2003d6a0
   d76bc:	000f4240 	.word	0x000f4240

000d76c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKcS7_>:

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
  }

  void writeRaw(const char *begin, const char *end) {
   d76c0:	b510      	push	{r4, lr}
    _length += _writer.write(reinterpret_cast<const uint8_t *>(begin),
   d76c2:	1a52      	subs	r2, r2, r1

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
  }

  void writeRaw(const char *begin, const char *end) {
   d76c4:	4604      	mov	r4, r0
    _length += _writer.write(reinterpret_cast<const uint8_t *>(begin),
   d76c6:	f7ff fef7 	bl	d74b8 <_ZN22ArduinoJson6130_0000016WriterIN5SDLib4FileEvE5writeEPKhj>
   d76ca:	6863      	ldr	r3, [r4, #4]
   d76cc:	4418      	add	r0, r3
   d76ce:	6060      	str	r0, [r4, #4]
   d76d0:	bd10      	pop	{r4, pc}

000d76d2 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE20writePositiveIntegerImEEvT_>:
    writeRaw('-');
    writePositiveInteger(value);
  }

  template <typename T>
  void writePositiveInteger(T value) {
   d76d2:	b530      	push	{r4, r5, lr}
   d76d4:	b087      	sub	sp, #28
   d76d6:	460b      	mov	r3, r1
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d76d8:	f10d 0116 	add.w	r1, sp, #22
   d76dc:	460a      	mov	r2, r1

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d76de:	250a      	movs	r5, #10
   d76e0:	fbb3 f4f5 	udiv	r4, r3, r5
   d76e4:	fb05 3314 	mls	r3, r5, r4, r3
   d76e8:	3330      	adds	r3, #48	; 0x30
   d76ea:	f801 3d01 	strb.w	r3, [r1, #-1]!
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d76ee:	4623      	mov	r3, r4
   d76f0:	2c00      	cmp	r4, #0
   d76f2:	d1f5      	bne.n	d76e0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE20writePositiveIntegerImEEvT_+0xe>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d76f4:	f7ff ffe4 	bl	d76c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKcS7_>
  }
   d76f8:	b007      	add	sp, #28
   d76fa:	bd30      	pop	{r4, r5, pc}

000d76fc <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_>:
      writeRaw(c);
    }
  }

  template <typename T>
  void writeFloat(T value) {
   d76fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   d76fe:	ed2d 8b02 	vpush	{d8}
    if (isnan(value)) return writeRaw(ARDUINOJSON_ENABLE_NAN ? "NaN" : "null");
   d7702:	eeb4 0a40 	vcmp.f32	s0, s0
   d7706:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      writeRaw(c);
    }
  }

  template <typename T>
  void writeFloat(T value) {
   d770a:	b08b      	sub	sp, #44	; 0x2c
   d770c:	4604      	mov	r4, r0
   d770e:	eeb0 8a40 	vmov.f32	s16, s0
    if (isnan(value)) return writeRaw(ARDUINOJSON_ENABLE_NAN ? "NaN" : "null");
   d7712:	d704      	bvc.n	d771e <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x22>
   d7714:	493c      	ldr	r1, [pc, #240]	; (d7808 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x10c>)
   d7716:	4620      	mov	r0, r4
   d7718:	f7ff fed2 	bl	d74c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKc>
   d771c:	e06f      	b.n	d77fe <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x102>
      value = -value;
    }

    if (isinf(value)) return writeRaw("Infinity");
#else
    if (isinf(value)) return writeRaw("null");
   d771e:	ed9f 7a3b 	vldr	s14, [pc, #236]	; d780c <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x110>
   d7722:	eef0 7ac0 	vabs.f32	s15, s0
   d7726:	eef4 7a47 	vcmp.f32	s15, s14
   d772a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d772e:	dcf1      	bgt.n	d7714 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x18>

    if (value < 0.0) {
   d7730:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   d7734:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d7738:	d504      	bpl.n	d7744 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x48>
      writeRaw('-');
   d773a:	212d      	movs	r1, #45	; 0x2d
   d773c:	f7ff fecf 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
      value = -value;
   d7740:	eeb1 8a48 	vneg.f32	s16, s16
    }
#endif

    FloatParts<T> parts(value);
   d7744:	eeb0 0a48 	vmov.f32	s0, s16
   d7748:	a801      	add	r0, sp, #4
   d774a:	f7ff ff01 	bl	d7550 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef>

    writePositiveInteger(parts.integral);
   d774e:	9901      	ldr	r1, [sp, #4]
   d7750:	4620      	mov	r0, r4
   d7752:	f7ff ffbe 	bl	d76d2 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE20writePositiveIntegerImEEvT_>
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);
   d7756:	f99d 100e 	ldrsb.w	r1, [sp, #14]
   d775a:	b1c9      	cbz	r1, d7790 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x94>

  void writeDecimals(uint32_t value, int8_t width) {
    // buffer should be big enough for all digits and the dot
    char buffer[16];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d775c:	ad08      	add	r5, sp, #32
#endif

    FloatParts<T> parts(value);

    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);
   d775e:	9b02      	ldr	r3, [sp, #8]
   d7760:	4608      	mov	r0, r1
   d7762:	462a      	mov	r2, r5
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    while (width--) {
      *--begin = char(value % 10 + '0');
   d7764:	270a      	movs	r7, #10
   d7766:	3801      	subs	r0, #1
   d7768:	b240      	sxtb	r0, r0
    char buffer[16];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    while (width--) {
   d776a:	1c46      	adds	r6, r0, #1
   d776c:	d008      	beq.n	d7780 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x84>
      *--begin = char(value % 10 + '0');
   d776e:	fbb3 f6f7 	udiv	r6, r3, r7
   d7772:	fb07 3316 	mls	r3, r7, r6, r3
   d7776:	3330      	adds	r3, #48	; 0x30
   d7778:	f805 3d01 	strb.w	r3, [r5, #-1]!
      value /= 10;
   d777c:	4633      	mov	r3, r6
   d777e:	e7f2      	b.n	d7766 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x6a>
   d7780:	b2c9      	uxtb	r1, r1
    }
    *--begin = '.';
   d7782:	1a51      	subs	r1, r2, r1
   d7784:	232e      	movs	r3, #46	; 0x2e
   d7786:	f801 3d01 	strb.w	r3, [r1, #-1]!

    // and dump it in the right order
    writeRaw(begin, end);
   d778a:	4620      	mov	r0, r4
   d778c:	f7ff ff98 	bl	d76c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKcS7_>
    FloatParts<T> parts(value);

    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);

    if (parts.exponent < 0) {
   d7790:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d7794:	2b00      	cmp	r3, #0
   d7796:	da17      	bge.n	d77c8 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0xcc>
      writeRaw("e-");
   d7798:	491d      	ldr	r1, [pc, #116]	; (d7810 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x114>)
   d779a:	4620      	mov	r0, r4
   d779c:	f7ff fe90 	bl	d74c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKc>
      writePositiveInteger(-parts.exponent);
   d77a0:	f9bd 300c 	ldrsh.w	r3, [sp, #12]

  template <typename T>
  void writePositiveInteger(T value) {
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d77a4:	f10d 0126 	add.w	r1, sp, #38	; 0x26
    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);

    if (parts.exponent < 0) {
      writeRaw("e-");
      writePositiveInteger(-parts.exponent);
   d77a8:	425b      	negs	r3, r3
   d77aa:	460a      	mov	r2, r1
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d77ac:	250a      	movs	r5, #10
   d77ae:	fb93 f0f5 	sdiv	r0, r3, r5
   d77b2:	fb05 3310 	mls	r3, r5, r0, r3
   d77b6:	3330      	adds	r3, #48	; 0x30
   d77b8:	f801 3d01 	strb.w	r3, [r1, #-1]!
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d77bc:	4603      	mov	r3, r0
   d77be:	2800      	cmp	r0, #0
   d77c0:	d1f5      	bne.n	d77ae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0xb2>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d77c2:	4620      	mov	r0, r4
   d77c4:	f7ff ff7c 	bl	d76c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKcS7_>
    if (parts.exponent < 0) {
      writeRaw("e-");
      writePositiveInteger(-parts.exponent);
    }

    if (parts.exponent > 0) {
   d77c8:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d77cc:	2b00      	cmp	r3, #0
   d77ce:	dd16      	ble.n	d77fe <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0x102>
      writeRaw('e');
   d77d0:	2165      	movs	r1, #101	; 0x65
   d77d2:	4620      	mov	r0, r4
   d77d4:	f7ff fe83 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>

  template <typename T>
  void writePositiveInteger(T value) {
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d77d8:	f10d 0126 	add.w	r1, sp, #38	; 0x26
      writePositiveInteger(-parts.exponent);
    }

    if (parts.exponent > 0) {
      writeRaw('e');
      writePositiveInteger(parts.exponent);
   d77dc:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d77e0:	460a      	mov	r2, r1
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d77e2:	250a      	movs	r5, #10
   d77e4:	fb93 f0f5 	sdiv	r0, r3, r5
   d77e8:	fb05 3310 	mls	r3, r5, r0, r3
   d77ec:	3330      	adds	r3, #48	; 0x30
   d77ee:	f801 3d01 	strb.w	r3, [r1, #-1]!
      value = T(value / 10);
   d77f2:	b203      	sxth	r3, r0
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d77f4:	2b00      	cmp	r3, #0
   d77f6:	d1f5      	bne.n	d77e4 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_+0xe8>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d77f8:	4620      	mov	r0, r4
   d77fa:	f7ff ff61 	bl	d76c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKcS7_>

    if (parts.exponent > 0) {
      writeRaw('e');
      writePositiveInteger(parts.exponent);
    }
  }
   d77fe:	b00b      	add	sp, #44	; 0x2c
   d7800:	ecbd 8b02 	vpop	{d8}
   d7804:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d7806:	bf00      	nop
   d7808:	000e1eeb 	.word	0x000e1eeb
   d780c:	7f7fffff 	.word	0x7f7fffff
   d7810:	000e1ef0 	.word	0x000e1ef0

000d7814 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_>:
  // - no destructor
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
   d7814:	b538      	push	{r3, r4, r5, lr}
    switch (type()) {
   d7816:	7a03      	ldrb	r3, [r0, #8]
   d7818:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d781c:	2b06      	cmp	r3, #6
  // - no destructor
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
   d781e:	4605      	mov	r5, r0
   d7820:	460c      	mov	r4, r1
    switch (type()) {
   d7822:	d067      	beq.n	d78f4 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xe0>
   d7824:	d808      	bhi.n	d7838 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x24>
   d7826:	2b02      	cmp	r3, #2
   d7828:	d36a      	bcc.n	d7900 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xec>
   d782a:	2b03      	cmp	r3, #3
   d782c:	d954      	bls.n	d78d8 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xc4>
  void visitFloat(Float value) {
    _formatter.writeFloat(value);
  }

  void visitString(const char *value) {
    _formatter.writeString(value);
   d782e:	6801      	ldr	r1, [r0, #0]
   d7830:	4620      	mov	r0, r4
   d7832:	f7ff fe5f 	bl	d74f4 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc>
   d7836:	bd38      	pop	{r3, r4, r5, pc}
   d7838:	2b0c      	cmp	r3, #12
   d783a:	d015      	beq.n	d7868 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x54>
   d783c:	d80a      	bhi.n	d7854 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x40>
   d783e:	2b08      	cmp	r3, #8
   d7840:	d053      	beq.n	d78ea <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xd6>
   d7842:	2b0a      	cmp	r3, #10
   d7844:	d15c      	bne.n	d7900 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xec>
      case VALUE_IS_OWNED_RAW:
      case VALUE_IS_LINKED_RAW:
        return visitor.visitRawJson(_content.asRaw.data, _content.asRaw.size);

      case VALUE_IS_NEGATIVE_INTEGER:
        return visitor.visitNegativeInteger(_content.asInteger);
   d7846:	6805      	ldr	r5, [r0, #0]

  void writeNegativeInteger(UInt value) {
    writeRaw('-');
   d7848:	212d      	movs	r1, #45	; 0x2d
   d784a:	4620      	mov	r0, r4
   d784c:	f7ff fe47 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
    writePositiveInteger(value);
   d7850:	4629      	mov	r1, r5
   d7852:	e04b      	b.n	d78ec <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xd8>
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
    switch (type()) {
   d7854:	2b20      	cmp	r3, #32
   d7856:	d01e      	beq.n	d7896 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x82>
   d7858:	2b40      	cmp	r3, #64	; 0x40
   d785a:	d151      	bne.n	d7900 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xec>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d785c:	215b      	movs	r1, #91	; 0x5b
   d785e:	4620      	mov	r0, r4
   d7860:	f7ff fe3d 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d7864:	682d      	ldr	r5, [r5, #0]
   d7866:	e012      	b.n	d788e <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x7a>

    write('}');
  }

  void visitFloat(Float value) {
    _formatter.writeFloat(value);
   d7868:	ed90 0a00 	vldr	s0, [r0]
   d786c:	4608      	mov	r0, r1
   d786e:	f7ff ff45 	bl	d76fc <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE10writeFloatIfEEvT_>
   d7872:	bd38      	pop	{r3, r4, r5, pc}
    write('[');

    VariantSlot *slot = array.head();

    while (slot != 0) {
      slot->data()->accept(*this);
   d7874:	4628      	mov	r0, r5
   d7876:	4621      	mov	r1, r4
   d7878:	f7ff ffcc 	bl	d7814 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_>

      slot = slot->next();
   d787c:	4628      	mov	r0, r5
   d787e:	f7fd fb1a 	bl	d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>
      if (slot == 0) break;
   d7882:	4605      	mov	r5, r0
   d7884:	b128      	cbz	r0, d7892 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x7e>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7886:	212c      	movs	r1, #44	; 0x2c
   d7888:	4620      	mov	r0, r4
   d788a:	f7ff fe28 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
  FORCE_INLINE void visitArray(const CollectionData &array) {
    write('[');

    VariantSlot *slot = array.head();

    while (slot != 0) {
   d788e:	2d00      	cmp	r5, #0
   d7890:	d1f0      	bne.n	d7874 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x60>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7892:	215d      	movs	r1, #93	; 0x5d
   d7894:	e01c      	b.n	d78d0 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xbc>
   d7896:	217b      	movs	r1, #123	; 0x7b
   d7898:	4620      	mov	r0, r4
   d789a:	f7ff fe20 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d789e:	682d      	ldr	r5, [r5, #0]
  void visitObject(const CollectionData &object) {
    write('{');

    VariantSlot *slot = object.head();

    while (slot != 0) {
   d78a0:	b1ad      	cbz	r5, d78ce <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xba>
      _formatter.writeString(slot->key());
   d78a2:	68e9      	ldr	r1, [r5, #12]
   d78a4:	4620      	mov	r0, r4
   d78a6:	f7ff fe25 	bl	d74f4 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE11writeStringEPKc>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d78aa:	213a      	movs	r1, #58	; 0x3a
   d78ac:	4620      	mov	r0, r4
   d78ae:	f7ff fe16 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
    VariantSlot *slot = object.head();

    while (slot != 0) {
      _formatter.writeString(slot->key());
      write(':');
      slot->data()->accept(*this);
   d78b2:	4628      	mov	r0, r5
   d78b4:	4621      	mov	r1, r4
   d78b6:	f7ff ffad 	bl	d7814 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_>

      slot = slot->next();
   d78ba:	4628      	mov	r0, r5
   d78bc:	f7fd fafb 	bl	d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>
      if (slot == 0) break;
   d78c0:	4605      	mov	r5, r0
   d78c2:	b120      	cbz	r0, d78ce <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xba>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d78c4:	212c      	movs	r1, #44	; 0x2c
   d78c6:	4620      	mov	r0, r4
   d78c8:	f7ff fe09 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d78cc:	e7e8      	b.n	d78a0 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x8c>
   d78ce:	217d      	movs	r1, #125	; 0x7d
   d78d0:	4620      	mov	r0, r4
   d78d2:	f7ff fe04 	bl	d74de <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEc>
   d78d6:	bd38      	pop	{r3, r4, r5, pc}
  void writeRaw(const char *s) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
  }

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
   d78d8:	e890 0006 	ldmia.w	r0, {r1, r2}
   d78dc:	4620      	mov	r0, r4
   d78de:	f7ff fdeb 	bl	d74b8 <_ZN22ArduinoJson6130_0000016WriterIN5SDLib4FileEvE5writeEPKhj>
   d78e2:	6863      	ldr	r3, [r4, #4]
   d78e4:	4418      	add	r0, r3
   d78e6:	6060      	str	r0, [r4, #4]
   d78e8:	bd38      	pop	{r3, r4, r5, pc}
  void visitNegativeInteger(UInt value) {
    _formatter.writeNegativeInteger(value);
  }

  void visitPositiveInteger(UInt value) {
    _formatter.writePositiveInteger(value);
   d78ea:	6801      	ldr	r1, [r0, #0]
   d78ec:	4620      	mov	r0, r4
   d78ee:	f7ff fef0 	bl	d76d2 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE20writePositiveIntegerImEEvT_>
   d78f2:	bd38      	pop	{r3, r4, r5, pc}
  size_t bytesWritten() const {
    return _length;
  }

  void writeBoolean(bool value) {
    if (value)
   d78f4:	6803      	ldr	r3, [r0, #0]
   d78f6:	b10b      	cbz	r3, d78fc <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xe8>
      writeRaw("true");
   d78f8:	4904      	ldr	r1, [pc, #16]	; (d790c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xf8>)
   d78fa:	e002      	b.n	d7902 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xee>
    else
      writeRaw("false");
   d78fc:	4904      	ldr	r1, [pc, #16]	; (d7910 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xfc>)
   d78fe:	e000      	b.n	d7902 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0xee>
  void visitBoolean(bool value) {
    _formatter.writeBoolean(value);
  }

  void visitNull() {
    _formatter.writeRaw("null");
   d7900:	4904      	ldr	r1, [pc, #16]	; (d7914 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_+0x100>)
   d7902:	4620      	mov	r0, r4
   d7904:	f7ff fddc 	bl	d74c0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterIN5SDLib4FileEvEEE8writeRawEPKc>
   d7908:	bd38      	pop	{r3, r4, r5, pc}
   d790a:	bf00      	nop
   d790c:	000e1ef3 	.word	0x000e1ef3
   d7910:	000e1ef8 	.word	0x000e1ef8
   d7914:	000e1eeb 	.word	0x000e1eeb

000d7918 <_Z17saveConfigurationPKcRK6Config>:

/*
* Fonction servant  Sauvegarder les variables du programme avec les paramtres spcifies
* dans le fichier. V1.0 2019-11-14
*/ 
void saveConfiguration(const char *filename, const Config &config) {
   d7918:	b530      	push	{r4, r5, lr}
   d791a:	f5ad 7d15 	sub.w	sp, sp, #596	; 0x254
  // On supprime le fichier de configuration original
  SD.remove(filename);
   d791e:	4601      	mov	r1, r0

/*
* Fonction servant  Sauvegarder les variables du programme avec les paramtres spcifies
* dans le fichier. V1.0 2019-11-14
*/ 
void saveConfiguration(const char *filename, const Config &config) {
   d7920:	4605      	mov	r5, r0
  // On supprime le fichier de configuration original
  SD.remove(filename);

  // On cre et ouvre un nouveau fichier de configuration vide avec le mme nom
  File file = SD.open(filename, FILE_WRITE);
   d7922:	ac04      	add	r4, sp, #16
* Fonction servant  Sauvegarder les variables du programme avec les paramtres spcifies
* dans le fichier. V1.0 2019-11-14
*/ 
void saveConfiguration(const char *filename, const Config &config) {
  // On supprime le fichier de configuration original
  SD.remove(filename);
   d7924:	4844      	ldr	r0, [pc, #272]	; (d7a38 <_Z17saveConfigurationPKcRK6Config+0x120>)
   d7926:	f003 fe4b 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>

  // On cre et ouvre un nouveau fichier de configuration vide avec le mme nom
  File file = SD.open(filename, FILE_WRITE);
   d792a:	4620      	mov	r0, r4
   d792c:	2317      	movs	r3, #23
   d792e:	462a      	mov	r2, r5
   d7930:	4941      	ldr	r1, [pc, #260]	; (d7a38 <_Z17saveConfigurationPKcRK6Config+0x120>)
   d7932:	f003 fdd7 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
  if (!file) {
   d7936:	4620      	mov	r0, r4
   d7938:	f002 fef2 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d793c:	b968      	cbnz	r0, d795a <_Z17saveConfigurationPKcRK6Config+0x42>
    Serial.println("Failed to create config file");
   d793e:	f006 faaf 	bl	ddea0 <_Z16_fetch_usbserialv>
   d7942:	493e      	ldr	r1, [pc, #248]	; (d7a3c <_Z17saveConfigurationPKcRK6Config+0x124>)
   d7944:	f005 fa91 	bl	dce6a <_ZN5Print7printlnEPKc>
    Particle.publish("Satus","Failed to create config file");
   d7948:	a80d      	add	r0, sp, #52	; 0x34
   d794a:	4a3c      	ldr	r2, [pc, #240]	; (d7a3c <_Z17saveConfigurationPKcRK6Config+0x124>)
   d794c:	493c      	ldr	r1, [pc, #240]	; (d7a40 <_Z17saveConfigurationPKcRK6Config+0x128>)
   d794e:	f7fd f993 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d7952:	a80e      	add	r0, sp, #56	; 0x38
   d7954:	f7fe f95a 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d7958:	e06a      	b.n	d7a30 <_Z17saveConfigurationPKcRK6Config+0x118>
    return;
  }

  // allocation de mmoire pour la srialisation JSON
  StaticJsonDocument<512> doc;
   d795a:	a80d      	add	r0, sp, #52	; 0x34
   d795c:	f7ff f816 	bl	d698c <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev>
  // getOrAddMember(char*)
  // getOrAddMember(const char*)
  // getOrAddMember(const __FlashStringHelper*)
  template <typename TChar>
  FORCE_INLINE VariantRef getOrAddMember(TChar* key) {
    return VariantRef(&_pool, _data.getOrAddMember(adaptString(key), &_pool));
   d7960:	aa0d      	add	r2, sp, #52	; 0x34
   d7962:	4938      	ldr	r1, [pc, #224]	; (d7a44 <_Z17saveConfigurationPKcRK6Config+0x12c>)
   d7964:	a811      	add	r0, sp, #68	; 0x44
   d7966:	f7ff f85f 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
  // set(const String&)
  template <typename T>
  FORCE_INLINE bool set(
      const T &value,
      typename enable_if<IsString<T>::value>::type * = 0) const {
    return variantSetOwnedString(_data, adaptString(value), _pool);
   d796a:	aa0d      	add	r2, sp, #52	; 0x34
   d796c:	4936      	ldr	r1, [pc, #216]	; (d7a48 <_Z17saveConfigurationPKcRK6Config+0x130>)
   d796e:	f7ff f824 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d7972:	aa0d      	add	r2, sp, #52	; 0x34
   d7974:	4935      	ldr	r1, [pc, #212]	; (d7a4c <_Z17saveConfigurationPKcRK6Config+0x134>)
   d7976:	a811      	add	r0, sp, #68	; 0x44
   d7978:	f7ff f856 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d797c:	aa0d      	add	r2, sp, #52	; 0x34
   d797e:	4934      	ldr	r1, [pc, #208]	; (d7a50 <_Z17saveConfigurationPKcRK6Config+0x138>)
   d7980:	f7ff f81b 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d7984:	aa0d      	add	r2, sp, #52	; 0x34
   d7986:	4933      	ldr	r1, [pc, #204]	; (d7a54 <_Z17saveConfigurationPKcRK6Config+0x13c>)
   d7988:	a811      	add	r0, sp, #68	; 0x44
   d798a:	f7ff f84d 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d798e:	aa0d      	add	r2, sp, #52	; 0x34
   d7990:	4931      	ldr	r1, [pc, #196]	; (d7a58 <_Z17saveConfigurationPKcRK6Config+0x140>)
   d7992:	f7ff f812 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d7996:	aa0d      	add	r2, sp, #52	; 0x34
   d7998:	4930      	ldr	r1, [pc, #192]	; (d7a5c <_Z17saveConfigurationPKcRK6Config+0x144>)
   d799a:	a811      	add	r0, sp, #68	; 0x44
   d799c:	f7ff f844 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
  }

  template <typename TValue>
  FORCE_INLINE typename enable_if<!is_array<TValue>::value, this_type &>::type
  operator=(const TValue &src) {
    getOrAddUpstreamMember().set(src);
   d79a0:	4b2f      	ldr	r3, [pc, #188]	; (d7a60 <_Z17saveConfigurationPKcRK6Config+0x148>)
  template <typename T>
  FORCE_INLINE bool set(
      T value,
      typename enable_if<is_integral<T>::value && is_signed<T>::value>::type * =
          0) const {
    return variantSetSignedInteger(_data, value);
   d79a2:	6819      	ldr	r1, [r3, #0]
   d79a4:	f7ff f82c 	bl	d6a00 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_>
   d79a8:	aa0d      	add	r2, sp, #52	; 0x34
   d79aa:	492e      	ldr	r1, [pc, #184]	; (d7a64 <_Z17saveConfigurationPKcRK6Config+0x14c>)
   d79ac:	a811      	add	r0, sp, #68	; 0x44
   d79ae:	f7ff f83b 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d79b2:	4b2d      	ldr	r3, [pc, #180]	; (d7a68 <_Z17saveConfigurationPKcRK6Config+0x150>)
   d79b4:	6819      	ldr	r1, [r3, #0]
   d79b6:	f7ff f823 	bl	d6a00 <_ZN22ArduinoJson6130_00000123variantSetSignedIntegerIiEEbPNS_11VariantDataET_>
   d79ba:	aa0d      	add	r2, sp, #52	; 0x34
   d79bc:	492b      	ldr	r1, [pc, #172]	; (d7a6c <_Z17saveConfigurationPKcRK6Config+0x154>)
   d79be:	a811      	add	r0, sp, #68	; 0x44
   d79c0:	f7ff f832 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
  // set(const String&)
  template <typename T>
  FORCE_INLINE bool set(
      const T &value,
      typename enable_if<IsString<T>::value>::type * = 0) const {
    return variantSetOwnedString(_data, adaptString(value), _pool);
   d79c4:	aa0d      	add	r2, sp, #52	; 0x34
   d79c6:	492a      	ldr	r1, [pc, #168]	; (d7a70 <_Z17saveConfigurationPKcRK6Config+0x158>)
   d79c8:	f7fe fff7 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d79cc:	aa0d      	add	r2, sp, #52	; 0x34
   d79ce:	4929      	ldr	r1, [pc, #164]	; (d7a74 <_Z17saveConfigurationPKcRK6Config+0x15c>)
   d79d0:	a811      	add	r0, sp, #68	; 0x44
   d79d2:	f7ff f829 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d79d6:	aa0d      	add	r2, sp, #52	; 0x34
   d79d8:	4927      	ldr	r1, [pc, #156]	; (d7a78 <_Z17saveConfigurationPKcRK6Config+0x160>)
   d79da:	f7fe ffee 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d79de:	aa0d      	add	r2, sp, #52	; 0x34
   d79e0:	4926      	ldr	r1, [pc, #152]	; (d7a7c <_Z17saveConfigurationPKcRK6Config+0x164>)
   d79e2:	a811      	add	r0, sp, #68	; 0x44
   d79e4:	f7ff f820 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d79e8:	aa0d      	add	r2, sp, #52	; 0x34
   d79ea:	4925      	ldr	r1, [pc, #148]	; (d7a80 <_Z17saveConfigurationPKcRK6Config+0x168>)
   d79ec:	f7fe ffe5 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
   d79f0:	aa0d      	add	r2, sp, #52	; 0x34
   d79f2:	4924      	ldr	r1, [pc, #144]	; (d7a84 <_Z17saveConfigurationPKcRK6Config+0x16c>)
   d79f4:	a811      	add	r0, sp, #68	; 0x44
   d79f6:	f7ff f817 	bl	d6a28 <_ZN22ArduinoJson6130_00000111VariantData14getOrAddMemberINS_21ConstRamStringAdapterEEEPS0_T_PNS_10MemoryPoolE>
   d79fa:	aa0d      	add	r2, sp, #52	; 0x34
   d79fc:	4922      	ldr	r1, [pc, #136]	; (d7a88 <_Z17saveConfigurationPKcRK6Config+0x170>)
   d79fe:	f7fe ffdc 	bl	d69ba <_ZN22ArduinoJson6130_00000121variantSetOwnedStringINS_20ArduinoStringAdapterEEEbPNS_11VariantDataET_PNS_10MemoryPoolE>
namespace ARDUINOJSON_NAMESPACE {

template <typename TWriter>
class TextFormatter {
 public:
  explicit TextFormatter(TWriter writer) : _writer(writer), _length(0) {}
   d7a02:	2300      	movs	r3, #0
namespace ARDUINOJSON_NAMESPACE {

template <typename Visitor>
inline void variantAccept(const VariantData *var, Visitor &visitor) {
  if (var != 0)
    var->accept(visitor);
   d7a04:	4669      	mov	r1, sp
   d7a06:	a811      	add	r0, sp, #68	; 0x44
   d7a08:	9301      	str	r3, [sp, #4]
   d7a0a:	9400      	str	r4, [sp, #0]
   d7a0c:	f7ff ff02 	bl	d7814 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterIN5SDLib4FileEvEEEEEEvRT_>
   d7a10:	9b01      	ldr	r3, [sp, #4]
  doc["ftp_username"] = username;
  doc["ftp_password"] = password;
  doc["ftp_dir"] = ftp_dir;

  // Srialisation
  if (serializeJson(doc, file) == 0) {
   d7a12:	b953      	cbnz	r3, d7a2a <_Z17saveConfigurationPKcRK6Config+0x112>
    log("Failed to write to file", 2);
   d7a14:	491d      	ldr	r1, [pc, #116]	; (d7a8c <_Z17saveConfigurationPKcRK6Config+0x174>)
   d7a16:	4668      	mov	r0, sp
   d7a18:	f004 fdcb 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d7a1c:	4668      	mov	r0, sp
   d7a1e:	2102      	movs	r1, #2
   d7a20:	f7fd fb04 	bl	d502c <_Z3log6Stringi>
   d7a24:	4668      	mov	r0, sp
   d7a26:	f004 fd7d 	bl	dc524 <_ZN6StringD1Ev>
  }

  // On ferme le fichier sans quoi les donnes ne seront pas enregistres
  file.close();
   d7a2a:	4620      	mov	r0, r4
   d7a2c:	f002 fe6c 	bl	da708 <_ZN5SDLib4File5closeEv>
}
   d7a30:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
   d7a34:	bd30      	pop	{r4, r5, pc}
   d7a36:	bf00      	nop
   d7a38:	2003e3d4 	.word	0x2003e3d4
   d7a3c:	000e1efe 	.word	0x000e1efe
   d7a40:	000e1f1b 	.word	0x000e1f1b
   d7a44:	000e1f21 	.word	0x000e1f21
   d7a48:	2003df78 	.word	0x2003df78
   d7a4c:	000e1f25 	.word	0x000e1f25
   d7a50:	2003dea4 	.word	0x2003dea4
   d7a54:	000e1f31 	.word	0x000e1f31
   d7a58:	2003df68 	.word	0x2003df68
   d7a5c:	000e1f3a 	.word	0x000e1f3a
   d7a60:	2003de94 	.word	0x2003de94
   d7a64:	000e1f47 	.word	0x000e1f47
   d7a68:	2003d6b8 	.word	0x2003d6b8
   d7a6c:	000e1f53 	.word	0x000e1f53
   d7a70:	2003df1c 	.word	0x2003df1c
   d7a74:	000e1f60 	.word	0x000e1f60
   d7a78:	2003df40 	.word	0x2003df40
   d7a7c:	000e1f6d 	.word	0x000e1f6d
   d7a80:	2003df54 	.word	0x2003df54
   d7a84:	000e1f7a 	.word	0x000e1f7a
   d7a88:	2003dec4 	.word	0x2003dec4
   d7a8c:	000e1f82 	.word	0x000e1f82

000d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>:

    // and dump it in the right order
    writeRaw(begin, end);
  }

  void writeRaw(const char *s) {
   d7a90:	b538      	push	{r3, r4, r5, lr}
   d7a92:	4604      	mov	r4, r0
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
   d7a94:	4608      	mov	r0, r1

    // and dump it in the right order
    writeRaw(begin, end);
  }

  void writeRaw(const char *s) {
   d7a96:	460d      	mov	r5, r1
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
   d7a98:	f008 fae6 	bl	e0068 <strlen>
   d7a9c:	4629      	mov	r1, r5
   d7a9e:	4602      	mov	r2, r0
   d7aa0:	4620      	mov	r0, r4
   d7aa2:	f7fd fa5a 	bl	d4f5a <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj>
   d7aa6:	6863      	ldr	r3, [r4, #4]
   d7aa8:	4418      	add	r0, r3
   d7aaa:	6060      	str	r0, [r4, #4]
   d7aac:	bd38      	pop	{r3, r4, r5, pc}

000d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>:

  template <size_t N>
  void writeRaw(const char (&s)[N]) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), N - 1);
  }
  void writeRaw(char c) {
   d7aae:	b510      	push	{r4, lr}
   d7ab0:	4604      	mov	r4, r0

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
   d7ab2:	6800      	ldr	r0, [r0, #0]
   d7ab4:	f004 fe4b 	bl	dc74e <_ZN6String6concatEc>
    _length += _writer.write(static_cast<uint8_t>(c));
   d7ab8:	6863      	ldr	r3, [r4, #4]
   d7aba:	3301      	adds	r3, #1
   d7abc:	6063      	str	r3, [r4, #4]
   d7abe:	bd10      	pop	{r4, pc}

000d7ac0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc>:
      writeRaw("true");
    else
      writeRaw("false");
  }

  void writeString(const char *value) {
   d7ac0:	b570      	push	{r4, r5, r6, lr}
   d7ac2:	4605      	mov	r5, r0
    if (!value) {
   d7ac4:	460c      	mov	r4, r1
   d7ac6:	b919      	cbnz	r1, d7ad0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x10>
      writeRaw("null");
   d7ac8:	4911      	ldr	r1, [pc, #68]	; (d7b10 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x50>)
   d7aca:	f7ff ffe1 	bl	d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>
   d7ace:	bd70      	pop	{r4, r5, r6, pc}
    } else {
      writeRaw('\"');
   d7ad0:	2122      	movs	r1, #34	; 0x22
   d7ad2:	f7ff ffec 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7ad6:	3c01      	subs	r4, #1
      while (*value) writeChar(*value++);
   d7ad8:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   d7adc:	b171      	cbz	r1, d7afc <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x3c>
   d7ade:	4b0d      	ldr	r3, [pc, #52]	; (d7b14 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x54>)
   d7ae0:	f813 6c02 	ldrb.w	r6, [r3, #-2]
   d7ae4:	b17e      	cbz	r6, d7b06 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x46>
   d7ae6:	3302      	adds	r3, #2
   d7ae8:	f813 2c03 	ldrb.w	r2, [r3, #-3]
   d7aec:	428a      	cmp	r2, r1
   d7aee:	d1f7      	bne.n	d7ae0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x20>
  }

  void writeChar(char c) {
    char specialChar = EscapeSequence::escapeChar(c);
    if (specialChar) {
      writeRaw('\\');
   d7af0:	215c      	movs	r1, #92	; 0x5c
   d7af2:	4628      	mov	r0, r5
   d7af4:	f7ff ffdb 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
      writeRaw(specialChar);
   d7af8:	4631      	mov	r1, r6
   d7afa:	e004      	b.n	d7b06 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x46>
    if (!value) {
      writeRaw("null");
    } else {
      writeRaw('\"');
      while (*value) writeChar(*value++);
      writeRaw('\"');
   d7afc:	2122      	movs	r1, #34	; 0x22
   d7afe:	4628      	mov	r0, r5
   d7b00:	f7ff ffd5 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
    }
  }
   d7b04:	bd70      	pop	{r4, r5, r6, pc}
    char specialChar = EscapeSequence::escapeChar(c);
    if (specialChar) {
      writeRaw('\\');
      writeRaw(specialChar);
    } else {
      writeRaw(c);
   d7b06:	4628      	mov	r0, r5
   d7b08:	f7ff ffd1 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7b0c:	e7e4      	b.n	d7ad8 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc+0x18>
   d7b0e:	bf00      	nop
   d7b10:	000e1eeb 	.word	0x000e1eeb
   d7b14:	000e1ede 	.word	0x000e1ede

000d7b18 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKcS6_>:

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
  }

  void writeRaw(const char *begin, const char *end) {
   d7b18:	b510      	push	{r4, lr}
    _length += _writer.write(reinterpret_cast<const uint8_t *>(begin),
   d7b1a:	1a52      	subs	r2, r2, r1

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
  }

  void writeRaw(const char *begin, const char *end) {
   d7b1c:	4604      	mov	r4, r0
    _length += _writer.write(reinterpret_cast<const uint8_t *>(begin),
   d7b1e:	f7fd fa1c 	bl	d4f5a <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj>
   d7b22:	6863      	ldr	r3, [r4, #4]
   d7b24:	4418      	add	r0, r3
   d7b26:	6060      	str	r0, [r4, #4]
   d7b28:	bd10      	pop	{r4, pc}

000d7b2a <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE20writePositiveIntegerImEEvT_>:
    writeRaw('-');
    writePositiveInteger(value);
  }

  template <typename T>
  void writePositiveInteger(T value) {
   d7b2a:	b530      	push	{r4, r5, lr}
   d7b2c:	b087      	sub	sp, #28
   d7b2e:	460b      	mov	r3, r1
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d7b30:	f10d 0116 	add.w	r1, sp, #22
   d7b34:	460a      	mov	r2, r1

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d7b36:	250a      	movs	r5, #10
   d7b38:	fbb3 f4f5 	udiv	r4, r3, r5
   d7b3c:	fb05 3314 	mls	r3, r5, r4, r3
   d7b40:	3330      	adds	r3, #48	; 0x30
   d7b42:	f801 3d01 	strb.w	r3, [r1, #-1]!
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d7b46:	4623      	mov	r3, r4
   d7b48:	2c00      	cmp	r4, #0
   d7b4a:	d1f5      	bne.n	d7b38 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE20writePositiveIntegerImEEvT_+0xe>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d7b4c:	f7ff ffe4 	bl	d7b18 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKcS6_>
  }
   d7b50:	b007      	add	sp, #28
   d7b52:	bd30      	pop	{r4, r5, pc}

000d7b54 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_>:
      writeRaw(c);
    }
  }

  template <typename T>
  void writeFloat(T value) {
   d7b54:	b5f0      	push	{r4, r5, r6, r7, lr}
   d7b56:	ed2d 8b02 	vpush	{d8}
    if (isnan(value)) return writeRaw(ARDUINOJSON_ENABLE_NAN ? "NaN" : "null");
   d7b5a:	eeb4 0a40 	vcmp.f32	s0, s0
   d7b5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      writeRaw(c);
    }
  }

  template <typename T>
  void writeFloat(T value) {
   d7b62:	b08b      	sub	sp, #44	; 0x2c
   d7b64:	4604      	mov	r4, r0
   d7b66:	eeb0 8a40 	vmov.f32	s16, s0
    if (isnan(value)) return writeRaw(ARDUINOJSON_ENABLE_NAN ? "NaN" : "null");
   d7b6a:	d704      	bvc.n	d7b76 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x22>
   d7b6c:	493c      	ldr	r1, [pc, #240]	; (d7c60 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x10c>)
   d7b6e:	4620      	mov	r0, r4
   d7b70:	f7ff ff8e 	bl	d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>
   d7b74:	e06f      	b.n	d7c56 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x102>
      value = -value;
    }

    if (isinf(value)) return writeRaw("Infinity");
#else
    if (isinf(value)) return writeRaw("null");
   d7b76:	ed9f 7a3b 	vldr	s14, [pc, #236]	; d7c64 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x110>
   d7b7a:	eef0 7ac0 	vabs.f32	s15, s0
   d7b7e:	eef4 7a47 	vcmp.f32	s15, s14
   d7b82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d7b86:	dcf1      	bgt.n	d7b6c <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x18>

    if (value < 0.0) {
   d7b88:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   d7b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d7b90:	d504      	bpl.n	d7b9c <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x48>
      writeRaw('-');
   d7b92:	212d      	movs	r1, #45	; 0x2d
   d7b94:	f7ff ff8b 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
      value = -value;
   d7b98:	eeb1 8a48 	vneg.f32	s16, s16
    }
#endif

    FloatParts<T> parts(value);
   d7b9c:	eeb0 0a48 	vmov.f32	s0, s16
   d7ba0:	a801      	add	r0, sp, #4
   d7ba2:	f7ff fcd5 	bl	d7550 <_ZN22ArduinoJson6130_00000110FloatPartsIfEC1Ef>

    writePositiveInteger(parts.integral);
   d7ba6:	9901      	ldr	r1, [sp, #4]
   d7ba8:	4620      	mov	r0, r4
   d7baa:	f7ff ffbe 	bl	d7b2a <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE20writePositiveIntegerImEEvT_>
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);
   d7bae:	f99d 100e 	ldrsb.w	r1, [sp, #14]
   d7bb2:	b1c9      	cbz	r1, d7be8 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x94>

  void writeDecimals(uint32_t value, int8_t width) {
    // buffer should be big enough for all digits and the dot
    char buffer[16];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d7bb4:	ad08      	add	r5, sp, #32
#endif

    FloatParts<T> parts(value);

    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);
   d7bb6:	9b02      	ldr	r3, [sp, #8]
   d7bb8:	4608      	mov	r0, r1
   d7bba:	462a      	mov	r2, r5
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    while (width--) {
      *--begin = char(value % 10 + '0');
   d7bbc:	270a      	movs	r7, #10
   d7bbe:	3801      	subs	r0, #1
   d7bc0:	b240      	sxtb	r0, r0
    char buffer[16];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    while (width--) {
   d7bc2:	1c46      	adds	r6, r0, #1
   d7bc4:	d008      	beq.n	d7bd8 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x84>
      *--begin = char(value % 10 + '0');
   d7bc6:	fbb3 f6f7 	udiv	r6, r3, r7
   d7bca:	fb07 3316 	mls	r3, r7, r6, r3
   d7bce:	3330      	adds	r3, #48	; 0x30
   d7bd0:	f805 3d01 	strb.w	r3, [r5, #-1]!
      value /= 10;
   d7bd4:	4633      	mov	r3, r6
   d7bd6:	e7f2      	b.n	d7bbe <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x6a>
   d7bd8:	b2c9      	uxtb	r1, r1
    }
    *--begin = '.';
   d7bda:	1a51      	subs	r1, r2, r1
   d7bdc:	232e      	movs	r3, #46	; 0x2e
   d7bde:	f801 3d01 	strb.w	r3, [r1, #-1]!

    // and dump it in the right order
    writeRaw(begin, end);
   d7be2:	4620      	mov	r0, r4
   d7be4:	f7ff ff98 	bl	d7b18 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKcS6_>
    FloatParts<T> parts(value);

    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);

    if (parts.exponent < 0) {
   d7be8:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d7bec:	2b00      	cmp	r3, #0
   d7bee:	da17      	bge.n	d7c20 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0xcc>
      writeRaw("e-");
   d7bf0:	491d      	ldr	r1, [pc, #116]	; (d7c68 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x114>)
   d7bf2:	4620      	mov	r0, r4
   d7bf4:	f7ff ff4c 	bl	d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>
      writePositiveInteger(-parts.exponent);
   d7bf8:	f9bd 300c 	ldrsh.w	r3, [sp, #12]

  template <typename T>
  void writePositiveInteger(T value) {
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d7bfc:	f10d 0126 	add.w	r1, sp, #38	; 0x26
    writePositiveInteger(parts.integral);
    if (parts.decimalPlaces) writeDecimals(parts.decimal, parts.decimalPlaces);

    if (parts.exponent < 0) {
      writeRaw("e-");
      writePositiveInteger(-parts.exponent);
   d7c00:	425b      	negs	r3, r3
   d7c02:	460a      	mov	r2, r1
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d7c04:	250a      	movs	r5, #10
   d7c06:	fb93 f0f5 	sdiv	r0, r3, r5
   d7c0a:	fb05 3310 	mls	r3, r5, r0, r3
   d7c0e:	3330      	adds	r3, #48	; 0x30
   d7c10:	f801 3d01 	strb.w	r3, [r1, #-1]!
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d7c14:	4603      	mov	r3, r0
   d7c16:	2800      	cmp	r0, #0
   d7c18:	d1f5      	bne.n	d7c06 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0xb2>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d7c1a:	4620      	mov	r0, r4
   d7c1c:	f7ff ff7c 	bl	d7b18 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKcS6_>
    if (parts.exponent < 0) {
      writeRaw("e-");
      writePositiveInteger(-parts.exponent);
    }

    if (parts.exponent > 0) {
   d7c20:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d7c24:	2b00      	cmp	r3, #0
   d7c26:	dd16      	ble.n	d7c56 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0x102>
      writeRaw('e');
   d7c28:	2165      	movs	r1, #101	; 0x65
   d7c2a:	4620      	mov	r0, r4
   d7c2c:	f7ff ff3f 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>

  template <typename T>
  void writePositiveInteger(T value) {
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;
   d7c30:	f10d 0126 	add.w	r1, sp, #38	; 0x26
      writePositiveInteger(-parts.exponent);
    }

    if (parts.exponent > 0) {
      writeRaw('e');
      writePositiveInteger(parts.exponent);
   d7c34:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   d7c38:	460a      	mov	r2, r1
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
      *--begin = char(value % 10 + '0');
   d7c3a:	250a      	movs	r5, #10
   d7c3c:	fb93 f0f5 	sdiv	r0, r3, r5
   d7c40:	fb05 3310 	mls	r3, r5, r0, r3
   d7c44:	3330      	adds	r3, #48	; 0x30
   d7c46:	f801 3d01 	strb.w	r3, [r1, #-1]!
      value = T(value / 10);
   d7c4a:	b203      	sxth	r3, r0
    char buffer[22];
    char *end = buffer + sizeof(buffer);
    char *begin = end;

    // write the string in reverse order
    do {
   d7c4c:	2b00      	cmp	r3, #0
   d7c4e:	d1f5      	bne.n	d7c3c <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_+0xe8>
      *--begin = char(value % 10 + '0');
      value = T(value / 10);
    } while (value);

    // and dump it in the right order
    writeRaw(begin, end);
   d7c50:	4620      	mov	r0, r4
   d7c52:	f7ff ff61 	bl	d7b18 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKcS6_>

    if (parts.exponent > 0) {
      writeRaw('e');
      writePositiveInteger(parts.exponent);
    }
  }
   d7c56:	b00b      	add	sp, #44	; 0x2c
   d7c58:	ecbd 8b02 	vpop	{d8}
   d7c5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d7c5e:	bf00      	nop
   d7c60:	000e1eeb 	.word	0x000e1eeb
   d7c64:	7f7fffff 	.word	0x7f7fffff
   d7c68:	000e1ef0 	.word	0x000e1ef0

000d7c6c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_>:
  // - no destructor
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
   d7c6c:	b538      	push	{r3, r4, r5, lr}
    switch (type()) {
   d7c6e:	7a03      	ldrb	r3, [r0, #8]
   d7c70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d7c74:	2b06      	cmp	r3, #6
  // - no destructor
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
   d7c76:	4605      	mov	r5, r0
   d7c78:	460c      	mov	r4, r1
    switch (type()) {
   d7c7a:	d067      	beq.n	d7d4c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xe0>
   d7c7c:	d808      	bhi.n	d7c90 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x24>
   d7c7e:	2b02      	cmp	r3, #2
   d7c80:	d36a      	bcc.n	d7d58 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xec>
   d7c82:	2b03      	cmp	r3, #3
   d7c84:	d954      	bls.n	d7d30 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xc4>
  void visitFloat(Float value) {
    _formatter.writeFloat(value);
  }

  void visitString(const char *value) {
    _formatter.writeString(value);
   d7c86:	6801      	ldr	r1, [r0, #0]
   d7c88:	4620      	mov	r0, r4
   d7c8a:	f7ff ff19 	bl	d7ac0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc>
   d7c8e:	bd38      	pop	{r3, r4, r5, pc}
   d7c90:	2b0c      	cmp	r3, #12
   d7c92:	d015      	beq.n	d7cc0 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x54>
   d7c94:	d80a      	bhi.n	d7cac <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x40>
   d7c96:	2b08      	cmp	r3, #8
   d7c98:	d053      	beq.n	d7d42 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xd6>
   d7c9a:	2b0a      	cmp	r3, #10
   d7c9c:	d15c      	bne.n	d7d58 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xec>
      case VALUE_IS_OWNED_RAW:
      case VALUE_IS_LINKED_RAW:
        return visitor.visitRawJson(_content.asRaw.data, _content.asRaw.size);

      case VALUE_IS_NEGATIVE_INTEGER:
        return visitor.visitNegativeInteger(_content.asInteger);
   d7c9e:	6805      	ldr	r5, [r0, #0]

  void writeNegativeInteger(UInt value) {
    writeRaw('-');
   d7ca0:	212d      	movs	r1, #45	; 0x2d
   d7ca2:	4620      	mov	r0, r4
   d7ca4:	f7ff ff03 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
    writePositiveInteger(value);
   d7ca8:	4629      	mov	r1, r5
   d7caa:	e04b      	b.n	d7d44 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xd8>
  // - no virtual
  // - no inheritance

  template <typename Visitor>
  void accept(Visitor &visitor) const {
    switch (type()) {
   d7cac:	2b20      	cmp	r3, #32
   d7cae:	d01e      	beq.n	d7cee <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x82>
   d7cb0:	2b40      	cmp	r3, #64	; 0x40
   d7cb2:	d151      	bne.n	d7d58 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xec>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7cb4:	215b      	movs	r1, #91	; 0x5b
   d7cb6:	4620      	mov	r0, r4
   d7cb8:	f7ff fef9 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7cbc:	682d      	ldr	r5, [r5, #0]
   d7cbe:	e012      	b.n	d7ce6 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x7a>

    write('}');
  }

  void visitFloat(Float value) {
    _formatter.writeFloat(value);
   d7cc0:	ed90 0a00 	vldr	s0, [r0]
   d7cc4:	4608      	mov	r0, r1
   d7cc6:	f7ff ff45 	bl	d7b54 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE10writeFloatIfEEvT_>
   d7cca:	bd38      	pop	{r3, r4, r5, pc}
    write('[');

    VariantSlot *slot = array.head();

    while (slot != 0) {
      slot->data()->accept(*this);
   d7ccc:	4628      	mov	r0, r5
   d7cce:	4621      	mov	r1, r4
   d7cd0:	f7ff ffcc 	bl	d7c6c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_>

      slot = slot->next();
   d7cd4:	4628      	mov	r0, r5
   d7cd6:	f7fd f8ee 	bl	d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>
      if (slot == 0) break;
   d7cda:	4605      	mov	r5, r0
   d7cdc:	b128      	cbz	r0, d7cea <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x7e>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7cde:	212c      	movs	r1, #44	; 0x2c
   d7ce0:	4620      	mov	r0, r4
   d7ce2:	f7ff fee4 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
  FORCE_INLINE void visitArray(const CollectionData &array) {
    write('[');

    VariantSlot *slot = array.head();

    while (slot != 0) {
   d7ce6:	2d00      	cmp	r5, #0
   d7ce8:	d1f0      	bne.n	d7ccc <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x60>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7cea:	215d      	movs	r1, #93	; 0x5d
   d7cec:	e01c      	b.n	d7d28 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xbc>
   d7cee:	217b      	movs	r1, #123	; 0x7b
   d7cf0:	4620      	mov	r0, r4
   d7cf2:	f7ff fedc 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7cf6:	682d      	ldr	r5, [r5, #0]
  void visitObject(const CollectionData &object) {
    write('{');

    VariantSlot *slot = object.head();

    while (slot != 0) {
   d7cf8:	b1ad      	cbz	r5, d7d26 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xba>
      _formatter.writeString(slot->key());
   d7cfa:	68e9      	ldr	r1, [r5, #12]
   d7cfc:	4620      	mov	r0, r4
   d7cfe:	f7ff fedf 	bl	d7ac0 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE11writeStringEPKc>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7d02:	213a      	movs	r1, #58	; 0x3a
   d7d04:	4620      	mov	r0, r4
   d7d06:	f7ff fed2 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
    VariantSlot *slot = object.head();

    while (slot != 0) {
      _formatter.writeString(slot->key());
      write(':');
      slot->data()->accept(*this);
   d7d0a:	4628      	mov	r0, r5
   d7d0c:	4621      	mov	r1, r4
   d7d0e:	f7ff ffad 	bl	d7c6c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_>

      slot = slot->next();
   d7d12:	4628      	mov	r0, r5
   d7d14:	f7fd f8cf 	bl	d4eb6 <_ZN22ArduinoJson6130_00000111VariantSlot4nextEv>
      if (slot == 0) break;
   d7d18:	4605      	mov	r5, r0
   d7d1a:	b120      	cbz	r0, d7d26 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xba>
    return _formatter.bytesWritten();
  }

 protected:
  void write(char c) {
    _formatter.writeRaw(c);
   d7d1c:	212c      	movs	r1, #44	; 0x2c
   d7d1e:	4620      	mov	r0, r4
   d7d20:	f7ff fec5 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7d24:	e7e8      	b.n	d7cf8 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x8c>
   d7d26:	217d      	movs	r1, #125	; 0x7d
   d7d28:	4620      	mov	r0, r4
   d7d2a:	f7ff fec0 	bl	d7aae <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEc>
   d7d2e:	bd38      	pop	{r3, r4, r5, pc}
  void writeRaw(const char *s) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), strlen(s));
  }

  void writeRaw(const char *s, size_t n) {
    _length += _writer.write(reinterpret_cast<const uint8_t *>(s), n);
   d7d30:	e890 0006 	ldmia.w	r0, {r1, r2}
   d7d34:	4620      	mov	r0, r4
   d7d36:	f7fd f910 	bl	d4f5a <_ZN22ArduinoJson6130_0000016WriterI6StringvE5writeEPKhj>
   d7d3a:	6863      	ldr	r3, [r4, #4]
   d7d3c:	4418      	add	r0, r3
   d7d3e:	6060      	str	r0, [r4, #4]
   d7d40:	bd38      	pop	{r3, r4, r5, pc}
  void visitNegativeInteger(UInt value) {
    _formatter.writeNegativeInteger(value);
  }

  void visitPositiveInteger(UInt value) {
    _formatter.writePositiveInteger(value);
   d7d42:	6801      	ldr	r1, [r0, #0]
   d7d44:	4620      	mov	r0, r4
   d7d46:	f7ff fef0 	bl	d7b2a <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE20writePositiveIntegerImEEvT_>
   d7d4a:	bd38      	pop	{r3, r4, r5, pc}
  size_t bytesWritten() const {
    return _length;
  }

  void writeBoolean(bool value) {
    if (value)
   d7d4c:	6803      	ldr	r3, [r0, #0]
   d7d4e:	b10b      	cbz	r3, d7d54 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xe8>
      writeRaw("true");
   d7d50:	4904      	ldr	r1, [pc, #16]	; (d7d64 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xf8>)
   d7d52:	e002      	b.n	d7d5a <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xee>
    else
      writeRaw("false");
   d7d54:	4904      	ldr	r1, [pc, #16]	; (d7d68 <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xfc>)
   d7d56:	e000      	b.n	d7d5a <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0xee>
  void visitBoolean(bool value) {
    _formatter.writeBoolean(value);
  }

  void visitNull() {
    _formatter.writeRaw("null");
   d7d58:	4904      	ldr	r1, [pc, #16]	; (d7d6c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_+0x100>)
   d7d5a:	4620      	mov	r0, r4
   d7d5c:	f7ff fe98 	bl	d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>
   d7d60:	bd38      	pop	{r3, r4, r5, pc}
   d7d62:	bf00      	nop
   d7d64:	000e1ef3 	.word	0x000e1ef3
   d7d68:	000e1ef8 	.word	0x000e1ef8
   d7d6c:	000e1eeb 	.word	0x000e1eeb

000d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>:
template <typename TImpl>
class VariantOr {
 public:
  // Returns the default value if the VariantRef is undefined of incompatible
  template <typename T>
  T operator|(const T &defaultValue) const {
   d7d70:	b5f0      	push	{r4, r5, r6, r7, lr}
  // JsonVariant getMember(char*)
  // JsonVariant getMember(const char*)
  // JsonVariant getMember(const __FlashStringHelper*)
  template <typename TChar>
  FORCE_INLINE VariantRef getMember(TChar* key) {
    return VariantRef(&_pool, _data.getMember(adaptString(key)));
   d7d72:	e891 0050 	ldmia.w	r1, {r4, r6}
   d7d76:	3410      	adds	r4, #16
   d7d78:	b087      	sub	sp, #28
   d7d7a:	4605      	mov	r5, r0
   d7d7c:	4631      	mov	r1, r6
   d7d7e:	4620      	mov	r0, r4
   d7d80:	4617      	mov	r7, r2
   d7d82:	f7fe fecc 	bl	d6b1e <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_>
inline bool variantIsFloat(const VariantData *var) {
  return var && var->isFloat();
}

inline bool variantIsString(const VariantData *var) {
  return var && var->isString();
   d7d86:	b388      	cbz	r0, d7dec <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x7c>
    return type() == VALUE_IS_FLOAT || type() == VALUE_IS_POSITIVE_INTEGER ||
           type() == VALUE_IS_NEGATIVE_INTEGER;
  }

  bool isString() const {
    return type() == VALUE_IS_LINKED_STRING || type() == VALUE_IS_OWNED_STRING;
   d7d88:	7a03      	ldrb	r3, [r0, #8]
   d7d8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d7d8e:	3b04      	subs	r3, #4
   d7d90:	2b01      	cmp	r3, #1
   d7d92:	d82b      	bhi.n	d7dec <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x7c>
   d7d94:	4620      	mov	r0, r4
   d7d96:	4631      	mov	r1, r6
   d7d98:	f7fe fec1 	bl	d6b1e <_ZNK22ArduinoJson6130_00000111VariantData9getMemberINS_21ConstRamStringAdapterEEEPS0_T_>
}

template <typename T>
inline typename enable_if<IsWriteableString<T>::value, T>::type variantAs(
    const VariantData* _data) {
  const char* cstr = _data != 0 ? _data->asString() : 0;
   d7d9c:	4604      	mov	r4, r0
   d7d9e:	b158      	cbz	r0, d7db8 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x48>
      return 0;
  }
}

inline const char *VariantData::asString() const {
  switch (type()) {
   d7da0:	7a03      	ldrb	r3, [r0, #8]
   d7da2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d7da6:	3b04      	subs	r3, #4
   d7da8:	2b01      	cmp	r3, #1
   d7daa:	d805      	bhi.n	d7db8 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x48>
    case VALUE_IS_LINKED_STRING:
    case VALUE_IS_OWNED_STRING:
      return _content.asString;
   d7dac:	6801      	ldr	r1, [r0, #0]
  if (cstr) return T(cstr);
   d7dae:	b119      	cbz	r1, d7db8 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x48>
   d7db0:	4628      	mov	r0, r5
   d7db2:	f004 fbfe 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d7db6:	e01d      	b.n	d7df4 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x84>
  T s;
   d7db8:	ae02      	add	r6, sp, #8
   d7dba:	4910      	ldr	r1, [pc, #64]	; (d7dfc <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x8c>)
   d7dbc:	4630      	mov	r0, r6
   d7dbe:	f004 fbf8 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
namespace ARDUINOJSON_NAMESPACE {

template <typename TWriter>
class TextFormatter {
 public:
  explicit TextFormatter(TWriter writer) : _writer(writer), _length(0) {}
   d7dc2:	2300      	movs	r3, #0
   d7dc4:	9600      	str	r6, [sp, #0]
   d7dc6:	9301      	str	r3, [sp, #4]

namespace ARDUINOJSON_NAMESPACE {

template <typename Visitor>
inline void variantAccept(const VariantData *var, Visitor &visitor) {
  if (var != 0)
   d7dc8:	b124      	cbz	r4, d7dd4 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x64>
    var->accept(visitor);
   d7dca:	4669      	mov	r1, sp
   d7dcc:	4620      	mov	r0, r4
   d7dce:	f7ff ff4d 	bl	d7c6c <_ZNK22ArduinoJson6130_00000111VariantData6acceptINS_14JsonSerializerINS_6WriterI6StringvEEEEEEvRT_>
   d7dd2:	e003      	b.n	d7ddc <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x6c>
   d7dd4:	490a      	ldr	r1, [pc, #40]	; (d7e00 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x90>)
   d7dd6:	4668      	mov	r0, sp
   d7dd8:	f7ff fe5a 	bl	d7a90 <_ZN22ArduinoJson6130_00000113TextFormatterINS_6WriterI6StringvEEE8writeRawEPKc>
  serializeJson(VariantConstRef(_data), s);
  return s;
   d7ddc:	4631      	mov	r1, r6
   d7dde:	4628      	mov	r0, r5
   d7de0:	f004 fb90 	bl	dc504 <_ZN6StringC1EOS_>
template <typename T>
inline typename enable_if<IsWriteableString<T>::value, T>::type variantAs(
    const VariantData* _data) {
  const char* cstr = _data != 0 ? _data->asString() : 0;
  if (cstr) return T(cstr);
  T s;
   d7de4:	4630      	mov	r0, r6
   d7de6:	f004 fb9d 	bl	dc524 <_ZN6StringD1Ev>
   d7dea:	e003      	b.n	d7df4 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_+0x84>
    if (impl()->template is<T>())
      return impl()->template as<T>();
    else
      return defaultValue;
   d7dec:	4639      	mov	r1, r7
   d7dee:	4628      	mov	r0, r5
   d7df0:	f004 fc01 	bl	dc5f6 <_ZN6StringC1ERKS_>
  }
   d7df4:	4628      	mov	r0, r5
   d7df6:	b007      	add	sp, #28
   d7df8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d7dfa:	bf00      	nop
   d7dfc:	000e1eea 	.word	0x000e1eea
   d7e00:	000e1eeb 	.word	0x000e1eeb

000d7e04 <_Z17loadConfigurationPKcR6Config>:

/*
* Fonction servant  mettre  jour les variables du programme avec les paramtres spcifies
* dans le fichier. V1.0 2019-11-14
*/
void loadConfiguration(const char *filename, Config &config) {
   d7e04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   d7e08:	f5ad 7d1b 	sub.w	sp, sp, #620	; 0x26c
   d7e0c:	460c      	mov	r4, r1
  File file = SD.open(filename); //Ouvrir le fichier 
   d7e0e:	4602      	mov	r2, r0
   d7e10:	2301      	movs	r3, #1
   d7e12:	4979      	ldr	r1, [pc, #484]	; (d7ff8 <_Z17loadConfigurationPKcR6Config+0x1f4>)
   d7e14:	a80a      	add	r0, sp, #40	; 0x28
   d7e16:	f003 fb65 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
  if (file) {
   d7e1a:	a80a      	add	r0, sp, #40	; 0x28
   d7e1c:	f002 fc80 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d7e20:	ad13      	add	r5, sp, #76	; 0x4c
   d7e22:	f104 0608 	add.w	r6, r4, #8
   d7e26:	f104 071c 	add.w	r7, r4, #28
   d7e2a:	f104 0838 	add.w	r8, r4, #56	; 0x38
   d7e2e:	f104 096a 	add.w	r9, r4, #106	; 0x6a
   d7e32:	f104 0a7e 	add.w	sl, r4, #126	; 0x7e
   d7e36:	f104 0b92 	add.w	fp, r4, #146	; 0x92
   d7e3a:	2800      	cmp	r0, #0
   d7e3c:	f000 809b 	beq.w	d7f76 <_Z17loadConfigurationPKcR6Config+0x172>
    StaticJsonDocument<512> doc; //Allocation de mmoire pour la dsrialisation JSON des paramtres
   d7e40:	4628      	mov	r0, r5
   d7e42:	f7fe fda3 	bl	d698c <_ZN22ArduinoJson6130_00000118StaticJsonDocumentILj512EEC1Ev>

template <typename TInput>
DeserializationError deserializeJson(
    JsonDocument &doc, TInput &input,
    NestingLimit nestingLimit = NestingLimit()) {
  return deserialize<JsonDeserializer>(doc, input, nestingLimit);
   d7e46:	f04f 020a 	mov.w	r2, #10
   d7e4a:	a90a      	add	r1, sp, #40	; 0x28
   d7e4c:	4628      	mov	r0, r5
   d7e4e:	f7ff f8b9 	bl	d6fc4 <_ZN22ArduinoJson6130_00000111deserializeINS_16JsonDeserializerEN5SDLib4FileEEENS_20DeserializationErrorERNS_12JsonDocumentERT0_NS_12NestingLimitE>
    DeserializationError error = deserializeJson(doc, file); // Dsrialisation
    if (!error) {
   d7e52:	a901      	add	r1, sp, #4
*/
void loadConfiguration(const char *filename, Config &config) {
  File file = SD.open(filename); //Ouvrir le fichier 
  if (file) {
    StaticJsonDocument<512> doc; //Allocation de mmoire pour la dsrialisation JSON des paramtres
    DeserializationError error = deserializeJson(doc, file); // Dsrialisation
   d7e54:	f88d 0004 	strb.w	r0, [sp, #4]
    if (!error) {
   d7e58:	a804      	add	r0, sp, #16
   d7e5a:	f7fd f853 	bl	d4f04 <_ZNK22ArduinoJson6130_00000120DeserializationErrorcvMS0_KFvvEEv>
   d7e5e:	9b04      	ldr	r3, [sp, #16]
   d7e60:	2b00      	cmp	r3, #0
   d7e62:	f040 80bb 	bne.w	d7fdc <_Z17loadConfigurationPKcR6Config+0x1d8>
   d7e66:	9b05      	ldr	r3, [sp, #20]
   d7e68:	07db      	lsls	r3, r3, #31
   d7e6a:	f100 80b7 	bmi.w	d7fdc <_Z17loadConfigurationPKcR6Config+0x1d8>
                    public Visitable {
  typedef MemberProxy<TObject, TStringRef> this_type;

 public:
  FORCE_INLINE MemberProxy(TObject variant, TStringRef key)
      : _object(variant), _key(key) {}
   d7e6e:	4b63      	ldr	r3, [pc, #396]	; (d7ffc <_Z17loadConfigurationPKcR6Config+0x1f8>)
      // Copie des valeurs issues du fichier vers les champs associs du Struct config
      strlcpy(config.BDH,                  // <- destination
        doc["BDH"] | BDH,  // <- source
   d7e70:	4a63      	ldr	r2, [pc, #396]	; (d8000 <_Z17loadConfigurationPKcR6Config+0x1fc>)
   d7e72:	9303      	str	r3, [sp, #12]
   d7e74:	a902      	add	r1, sp, #8
   d7e76:	a806      	add	r0, sp, #24
   d7e78:	9502      	str	r5, [sp, #8]
   d7e7a:	f7ff ff79 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
        sizeof(config.BDH));         // <- destination's capacity
   d7e7e:	2208      	movs	r2, #8
   d7e80:	9906      	ldr	r1, [sp, #24]
   d7e82:	4620      	mov	r0, r4
   d7e84:	f008 f8db 	bl	e003e <strlcpy>
    StaticJsonDocument<512> doc; //Allocation de mmoire pour la dsrialisation JSON des paramtres
    DeserializationError error = deserializeJson(doc, file); // Dsrialisation
    if (!error) {
      // Copie des valeurs issues du fichier vers les champs associs du Struct config
      strlcpy(config.BDH,                  // <- destination
        doc["BDH"] | BDH,  // <- source
   d7e88:	a806      	add	r0, sp, #24
   d7e8a:	f004 fb4b 	bl	dc524 <_ZN6StringD1Ev>
   d7e8e:	4b5d      	ldr	r3, [pc, #372]	; (d8004 <_Z17loadConfigurationPKcR6Config+0x200>)
        sizeof(config.BDH));         // <- destination's capacity
      strlcpy(config.stationName,  doc["stationName"] |  stationName, sizeof(config.stationName));        
   d7e90:	4a5d      	ldr	r2, [pc, #372]	; (d8008 <_Z17loadConfigurationPKcR6Config+0x204>)
   d7e92:	9303      	str	r3, [sp, #12]
   d7e94:	a902      	add	r1, sp, #8
   d7e96:	a806      	add	r0, sp, #24
   d7e98:	9502      	str	r5, [sp, #8]
   d7e9a:	f7ff ff69 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7e9e:	2214      	movs	r2, #20
   d7ea0:	9906      	ldr	r1, [sp, #24]
   d7ea2:	4630      	mov	r0, r6
   d7ea4:	f008 f8cb 	bl	e003e <strlcpy>
   d7ea8:	a806      	add	r0, sp, #24
   d7eaa:	f004 fb3b 	bl	dc524 <_ZN6StringD1Ev>
   d7eae:	4b57      	ldr	r3, [pc, #348]	; (d800c <_Z17loadConfigurationPKcR6Config+0x208>)
      strlcpy(config.PublicIP,     doc["PublicIP"] |     PublicIP,    sizeof(config.PublicIP));
   d7eb0:	4a57      	ldr	r2, [pc, #348]	; (d8010 <_Z17loadConfigurationPKcR6Config+0x20c>)
   d7eb2:	9303      	str	r3, [sp, #12]
   d7eb4:	a902      	add	r1, sp, #8
   d7eb6:	a806      	add	r0, sp, #24
   d7eb8:	9502      	str	r5, [sp, #8]
   d7eba:	f7ff ff59 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7ebe:	2214      	movs	r2, #20
   d7ec0:	9906      	ldr	r1, [sp, #24]
   d7ec2:	4638      	mov	r0, r7
   d7ec4:	f008 f8bb 	bl	e003e <strlcpy>
   d7ec8:	a806      	add	r0, sp, #24
   d7eca:	f004 fb2b 	bl	dc524 <_ZN6StringD1Ev>
   d7ece:	4b51      	ldr	r3, [pc, #324]	; (d8014 <_Z17loadConfigurationPKcR6Config+0x210>)
      config.captureMode =         doc["Capture_Mode"] | captureMode; //mthode diffrente car type Int au lieu de String
   d7ed0:	4951      	ldr	r1, [pc, #324]	; (d8018 <_Z17loadConfigurationPKcR6Config+0x214>)
   d7ed2:	9307      	str	r3, [sp, #28]
   d7ed4:	a806      	add	r0, sp, #24
   d7ed6:	9506      	str	r5, [sp, #24]
   d7ed8:	f7ff fa80 	bl	d73dc <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_>
   d7edc:	4b4f      	ldr	r3, [pc, #316]	; (d801c <_Z17loadConfigurationPKcR6Config+0x218>)
   d7ede:	6320      	str	r0, [r4, #48]	; 0x30
      config.Batt_low_SP =         doc["Batt_low_SP"] |  Batt_low_SP;
   d7ee0:	494f      	ldr	r1, [pc, #316]	; (d8020 <_Z17loadConfigurationPKcR6Config+0x21c>)
   d7ee2:	9307      	str	r3, [sp, #28]
   d7ee4:	a806      	add	r0, sp, #24
   d7ee6:	9506      	str	r5, [sp, #24]
   d7ee8:	f7ff fa78 	bl	d73dc <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorIiEET_RKS9_>
   d7eec:	4b4d      	ldr	r3, [pc, #308]	; (d8024 <_Z17loadConfigurationPKcR6Config+0x220>)
   d7eee:	6360      	str	r0, [r4, #52]	; 0x34
      strlcpy(config.ftp_hostname, doc["ftp_hostname"] | hostname,    sizeof(config.ftp_hostname));  
   d7ef0:	4a4d      	ldr	r2, [pc, #308]	; (d8028 <_Z17loadConfigurationPKcR6Config+0x224>)
   d7ef2:	9303      	str	r3, [sp, #12]
   d7ef4:	a902      	add	r1, sp, #8
   d7ef6:	a806      	add	r0, sp, #24
   d7ef8:	9502      	str	r5, [sp, #8]
   d7efa:	f7ff ff39 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7efe:	2232      	movs	r2, #50	; 0x32
   d7f00:	9906      	ldr	r1, [sp, #24]
   d7f02:	4640      	mov	r0, r8
   d7f04:	f008 f89b 	bl	e003e <strlcpy>
   d7f08:	a806      	add	r0, sp, #24
   d7f0a:	f004 fb0b 	bl	dc524 <_ZN6StringD1Ev>
   d7f0e:	4b47      	ldr	r3, [pc, #284]	; (d802c <_Z17loadConfigurationPKcR6Config+0x228>)
      strlcpy(config.ftp_username, doc["ftp_username"] | username,    sizeof(config.ftp_username)); 
   d7f10:	4a47      	ldr	r2, [pc, #284]	; (d8030 <_Z17loadConfigurationPKcR6Config+0x22c>)
   d7f12:	9303      	str	r3, [sp, #12]
   d7f14:	a902      	add	r1, sp, #8
   d7f16:	a806      	add	r0, sp, #24
   d7f18:	9502      	str	r5, [sp, #8]
   d7f1a:	f7ff ff29 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7f1e:	2214      	movs	r2, #20
   d7f20:	9906      	ldr	r1, [sp, #24]
   d7f22:	4648      	mov	r0, r9
   d7f24:	f008 f88b 	bl	e003e <strlcpy>
   d7f28:	a806      	add	r0, sp, #24
   d7f2a:	f004 fafb 	bl	dc524 <_ZN6StringD1Ev>
   d7f2e:	4b41      	ldr	r3, [pc, #260]	; (d8034 <_Z17loadConfigurationPKcR6Config+0x230>)
      strlcpy(config.ftp_password, doc["ftp_password"] | password,    sizeof(config.ftp_password)); 
   d7f30:	4a41      	ldr	r2, [pc, #260]	; (d8038 <_Z17loadConfigurationPKcR6Config+0x234>)
   d7f32:	9303      	str	r3, [sp, #12]
   d7f34:	a902      	add	r1, sp, #8
   d7f36:	a806      	add	r0, sp, #24
   d7f38:	9502      	str	r5, [sp, #8]
   d7f3a:	f7ff ff19 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7f3e:	2214      	movs	r2, #20
   d7f40:	9906      	ldr	r1, [sp, #24]
   d7f42:	4650      	mov	r0, sl
   d7f44:	f008 f87b 	bl	e003e <strlcpy>
   d7f48:	a806      	add	r0, sp, #24
   d7f4a:	f004 faeb 	bl	dc524 <_ZN6StringD1Ev>
   d7f4e:	4b3b      	ldr	r3, [pc, #236]	; (d803c <_Z17loadConfigurationPKcR6Config+0x238>)
      strlcpy(config.ftp_dir,      doc["ftp_dir"] |      ftp_dir,     sizeof(config.ftp_dir));   
   d7f50:	4a3b      	ldr	r2, [pc, #236]	; (d8040 <_Z17loadConfigurationPKcR6Config+0x23c>)
   d7f52:	9303      	str	r3, [sp, #12]
   d7f54:	a902      	add	r1, sp, #8
   d7f56:	a806      	add	r0, sp, #24
   d7f58:	9502      	str	r5, [sp, #8]
   d7f5a:	f7ff ff09 	bl	d7d70 <_ZNK22ArduinoJson6130_0000019VariantOrINS_11MemberProxyIRNS_12JsonDocumentEPKcEEEorI6StringEET_RKSA_>
   d7f5e:	2232      	movs	r2, #50	; 0x32
   d7f60:	9906      	ldr	r1, [sp, #24]
   d7f62:	4658      	mov	r0, fp
   d7f64:	f008 f86b 	bl	e003e <strlcpy>
   d7f68:	a806      	add	r0, sp, #24
   d7f6a:	f004 fadb 	bl	dc524 <_ZN6StringD1Ev>
    } else {
        Serial.println("Failed to parse config file, using default");
        Particle.publish("Status","Failed to parse config file, using default");
      }
    // On ferme le fichier sans quoi une corruption peut avoir lieu
    file.close();
   d7f6e:	a80a      	add	r0, sp, #40	; 0x28
   d7f70:	f002 fbca 	bl	da708 <_ZN5SDLib4File5closeEv>
   d7f74:	e00c      	b.n	d7f90 <_Z17loadConfigurationPKcR6Config+0x18c>
    
  } else  {
      Serial.println("Failed to open config file on SD, using default");
   d7f76:	f005 ff93 	bl	ddea0 <_Z16_fetch_usbserialv>
   d7f7a:	4932      	ldr	r1, [pc, #200]	; (d8044 <_Z17loadConfigurationPKcR6Config+0x240>)
   d7f7c:	f004 ff75 	bl	dce6a <_ZN5Print7printlnEPKc>
      Particle.publish("Status","Failed to open config file on SD, using default");
   d7f80:	4628      	mov	r0, r5
   d7f82:	4a30      	ldr	r2, [pc, #192]	; (d8044 <_Z17loadConfigurationPKcR6Config+0x240>)
   d7f84:	4930      	ldr	r1, [pc, #192]	; (d8048 <_Z17loadConfigurationPKcR6Config+0x244>)
   d7f86:	f7fc fe77 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d7f8a:	a814      	add	r0, sp, #80	; 0x50
   d7f8c:	f7fd fe3e 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    }
    //Copie des paramtres mis  jour vers leurs variables fonctionnelles
    BDH = config.BDH;
   d7f90:	4621      	mov	r1, r4
   d7f92:	481b      	ldr	r0, [pc, #108]	; (d8000 <_Z17loadConfigurationPKcR6Config+0x1fc>)
   d7f94:	f004 fb3a 	bl	dc60c <_ZN6StringaSEPKc>
    stationName = config.stationName;
   d7f98:	4631      	mov	r1, r6
   d7f9a:	481b      	ldr	r0, [pc, #108]	; (d8008 <_Z17loadConfigurationPKcR6Config+0x204>)
   d7f9c:	f004 fb36 	bl	dc60c <_ZN6StringaSEPKc>
    PublicIP = config.PublicIP;
   d7fa0:	4639      	mov	r1, r7
   d7fa2:	481b      	ldr	r0, [pc, #108]	; (d8010 <_Z17loadConfigurationPKcR6Config+0x20c>)
   d7fa4:	f004 fb32 	bl	dc60c <_ZN6StringaSEPKc>
    captureMode = config.captureMode;
   d7fa8:	4b1b      	ldr	r3, [pc, #108]	; (d8018 <_Z17loadConfigurationPKcR6Config+0x214>)
   d7faa:	6b22      	ldr	r2, [r4, #48]	; 0x30
   d7fac:	601a      	str	r2, [r3, #0]
    Batt_low_SP = config.Batt_low_SP;
   d7fae:	4b1c      	ldr	r3, [pc, #112]	; (d8020 <_Z17loadConfigurationPKcR6Config+0x21c>)
   d7fb0:	6b62      	ldr	r2, [r4, #52]	; 0x34
    hostname = config.ftp_hostname;
   d7fb2:	481d      	ldr	r0, [pc, #116]	; (d8028 <_Z17loadConfigurationPKcR6Config+0x224>)
    //Copie des paramtres mis  jour vers leurs variables fonctionnelles
    BDH = config.BDH;
    stationName = config.stationName;
    PublicIP = config.PublicIP;
    captureMode = config.captureMode;
    Batt_low_SP = config.Batt_low_SP;
   d7fb4:	601a      	str	r2, [r3, #0]
    hostname = config.ftp_hostname;
   d7fb6:	4641      	mov	r1, r8
   d7fb8:	f004 fb28 	bl	dc60c <_ZN6StringaSEPKc>
    username = config.ftp_username;
   d7fbc:	4649      	mov	r1, r9
   d7fbe:	481c      	ldr	r0, [pc, #112]	; (d8030 <_Z17loadConfigurationPKcR6Config+0x22c>)
   d7fc0:	f004 fb24 	bl	dc60c <_ZN6StringaSEPKc>
    password = config.ftp_password;
   d7fc4:	4651      	mov	r1, sl
   d7fc6:	481c      	ldr	r0, [pc, #112]	; (d8038 <_Z17loadConfigurationPKcR6Config+0x234>)
   d7fc8:	f004 fb20 	bl	dc60c <_ZN6StringaSEPKc>
    ftp_dir = config.ftp_dir;
   d7fcc:	4659      	mov	r1, fp
   d7fce:	481c      	ldr	r0, [pc, #112]	; (d8040 <_Z17loadConfigurationPKcR6Config+0x23c>)
   d7fd0:	f004 fb1c 	bl	dc60c <_ZN6StringaSEPKc>

}
   d7fd4:	f50d 7d1b 	add.w	sp, sp, #620	; 0x26c
   d7fd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      strlcpy(config.ftp_hostname, doc["ftp_hostname"] | hostname,    sizeof(config.ftp_hostname));  
      strlcpy(config.ftp_username, doc["ftp_username"] | username,    sizeof(config.ftp_username)); 
      strlcpy(config.ftp_password, doc["ftp_password"] | password,    sizeof(config.ftp_password)); 
      strlcpy(config.ftp_dir,      doc["ftp_dir"] |      ftp_dir,     sizeof(config.ftp_dir));   
    } else {
        Serial.println("Failed to parse config file, using default");
   d7fdc:	f005 ff60 	bl	ddea0 <_Z16_fetch_usbserialv>
   d7fe0:	491a      	ldr	r1, [pc, #104]	; (d804c <_Z17loadConfigurationPKcR6Config+0x248>)
   d7fe2:	f004 ff42 	bl	dce6a <_ZN5Print7printlnEPKc>
        Particle.publish("Status","Failed to parse config file, using default");
   d7fe6:	a806      	add	r0, sp, #24
   d7fe8:	4a18      	ldr	r2, [pc, #96]	; (d804c <_Z17loadConfigurationPKcR6Config+0x248>)
   d7fea:	4917      	ldr	r1, [pc, #92]	; (d8048 <_Z17loadConfigurationPKcR6Config+0x244>)
   d7fec:	f7fc fe44 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d7ff0:	a807      	add	r0, sp, #28
   d7ff2:	f7fd fe0b 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d7ff6:	e7ba      	b.n	d7f6e <_Z17loadConfigurationPKcR6Config+0x16a>
   d7ff8:	2003e3d4 	.word	0x2003e3d4
   d7ffc:	000e1f21 	.word	0x000e1f21
   d8000:	2003df78 	.word	0x2003df78
   d8004:	000e1f25 	.word	0x000e1f25
   d8008:	2003dea4 	.word	0x2003dea4
   d800c:	000e1f31 	.word	0x000e1f31
   d8010:	2003df68 	.word	0x2003df68
   d8014:	000e1f3a 	.word	0x000e1f3a
   d8018:	2003de94 	.word	0x2003de94
   d801c:	000e1f47 	.word	0x000e1f47
   d8020:	2003d6b8 	.word	0x2003d6b8
   d8024:	000e1f53 	.word	0x000e1f53
   d8028:	2003df1c 	.word	0x2003df1c
   d802c:	000e1f60 	.word	0x000e1f60
   d8030:	2003df40 	.word	0x2003df40
   d8034:	000e1f6d 	.word	0x000e1f6d
   d8038:	2003df54 	.word	0x2003df54
   d803c:	000e1f7a 	.word	0x000e1f7a
   d8040:	2003dec4 	.word	0x2003dec4
   d8044:	000e1f9a 	.word	0x000e1f9a
   d8048:	000e1fca 	.word	0x000e1fca
   d804c:	000e1fd1 	.word	0x000e1fd1

000d8050 <_Z9getConfig6String>:
}
/* 
* Fonction qui rcupre le fichier de configuration sur le site ftp et se met  jour
* V1.0 2019-11-14 
*/
bool getConfig(String dir) {
   d8050:	b530      	push	{r4, r5, lr}
   d8052:	b08f      	sub	sp, #60	; 0x3c
  // Connction au site ftp au les identifiants fournis
  log("up", 4);
   d8054:	4984      	ldr	r1, [pc, #528]	; (d8268 <_Z9getConfig6String+0x218>)
}
/* 
* Fonction qui rcupre le fichier de configuration sur le site ftp et se met  jour
* V1.0 2019-11-14 
*/
bool getConfig(String dir) {
   d8056:	4604      	mov	r4, r0
  // Connction au site ftp au les identifiants fournis
  log("up", 4);
   d8058:	a805      	add	r0, sp, #20
   d805a:	f004 faaa 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d805e:	2104      	movs	r1, #4
   d8060:	a805      	add	r0, sp, #20
   d8062:	f7fc ffe3 	bl	d502c <_Z3log6Stringi>
   d8066:	a805      	add	r0, sp, #20
   d8068:	f004 fa5c 	bl	dc524 <_ZN6StringD1Ev>
  
  if (!ftp.open(hostname, port, timeout)) {
   d806c:	497f      	ldr	r1, [pc, #508]	; (d826c <_Z9getConfig6String+0x21c>)
   d806e:	a805      	add	r0, sp, #20
   d8070:	f004 fac1 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8074:	4b7e      	ldr	r3, [pc, #504]	; (d8270 <_Z9getConfig6String+0x220>)
   d8076:	4a7f      	ldr	r2, [pc, #508]	; (d8274 <_Z9getConfig6String+0x224>)
   d8078:	681b      	ldr	r3, [r3, #0]
   d807a:	8812      	ldrh	r2, [r2, #0]
   d807c:	487e      	ldr	r0, [pc, #504]	; (d8278 <_Z9getConfig6String+0x228>)
   d807e:	a905      	add	r1, sp, #20
   d8080:	f002 fba0 	bl	da7c4 <_ZN17particleftpclient17ParticleFtpClient4openE6Stringti>
   d8084:	4605      	mov	r5, r0
   d8086:	a805      	add	r0, sp, #20
   d8088:	f004 fa4c 	bl	dc524 <_ZN6StringD1Ev>
   d808c:	b90d      	cbnz	r5, d8092 <_Z9getConfig6String+0x42>
    log("Couldn't connect to ftp host",2);
   d808e:	497b      	ldr	r1, [pc, #492]	; (d827c <_Z9getConfig6String+0x22c>)
   d8090:	e00d      	b.n	d80ae <_Z9getConfig6String+0x5e>
    return 0;
  }
  if (!ftp.user(username)) {
   d8092:	497b      	ldr	r1, [pc, #492]	; (d8280 <_Z9getConfig6String+0x230>)
   d8094:	a805      	add	r0, sp, #20
   d8096:	f004 faae 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d809a:	a905      	add	r1, sp, #20
   d809c:	4876      	ldr	r0, [pc, #472]	; (d8278 <_Z9getConfig6String+0x228>)
   d809e:	f002 fbf3 	bl	da888 <_ZN17particleftpclient17ParticleFtpClient4userE6String>
   d80a2:	4605      	mov	r5, r0
   d80a4:	a805      	add	r0, sp, #20
   d80a6:	f004 fa3d 	bl	dc524 <_ZN6StringD1Ev>
   d80aa:	b95d      	cbnz	r5, d80c4 <_Z9getConfig6String+0x74>
    log("Bad username", 2);
   d80ac:	4975      	ldr	r1, [pc, #468]	; (d8284 <_Z9getConfig6String+0x234>)
   d80ae:	a805      	add	r0, sp, #20
   d80b0:	f004 fa7f 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d80b4:	a805      	add	r0, sp, #20
   d80b6:	2102      	movs	r1, #2
   d80b8:	f7fc ffb8 	bl	d502c <_Z3log6Stringi>
   d80bc:	a805      	add	r0, sp, #20
   d80be:	f004 fa31 	bl	dc524 <_ZN6StringD1Ev>
    return 0;
   d80c2:	e0ce      	b.n	d8262 <_Z9getConfig6String+0x212>
  }
  if (!ftp.pass(password)) {
   d80c4:	4970      	ldr	r1, [pc, #448]	; (d8288 <_Z9getConfig6String+0x238>)
   d80c6:	a805      	add	r0, sp, #20
   d80c8:	f004 fa95 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d80cc:	a905      	add	r1, sp, #20
   d80ce:	486a      	ldr	r0, [pc, #424]	; (d8278 <_Z9getConfig6String+0x228>)
   d80d0:	f002 fbfc 	bl	da8cc <_ZN17particleftpclient17ParticleFtpClient4passE6String>
   d80d4:	4605      	mov	r5, r0
   d80d6:	a805      	add	r0, sp, #20
   d80d8:	f004 fa24 	bl	dc524 <_ZN6StringD1Ev>
   d80dc:	b90d      	cbnz	r5, d80e2 <_Z9getConfig6String+0x92>
    log("Bad password", 2);
   d80de:	496b      	ldr	r1, [pc, #428]	; (d828c <_Z9getConfig6String+0x23c>)
   d80e0:	e7e5      	b.n	d80ae <_Z9getConfig6String+0x5e>
    return 0;
  }  

  // On "navigue" vers le chemin de dossier pass en paramtre (dir)
  if (!ftp.cwd(dir)){
   d80e2:	4621      	mov	r1, r4
   d80e4:	a805      	add	r0, sp, #20
   d80e6:	f004 fa86 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d80ea:	a905      	add	r1, sp, #20
   d80ec:	4862      	ldr	r0, [pc, #392]	; (d8278 <_Z9getConfig6String+0x228>)
   d80ee:	f002 fc0f 	bl	da910 <_ZN17particleftpclient17ParticleFtpClient3cwdE6String>
   d80f2:	4605      	mov	r5, r0
   d80f4:	a805      	add	r0, sp, #20
   d80f6:	f004 fa15 	bl	dc524 <_ZN6StringD1Ev>
   d80fa:	2d00      	cmp	r5, #0
   d80fc:	d144      	bne.n	d8188 <_Z9getConfig6String+0x138>
    log("could not set directory", 3);
   d80fe:	4964      	ldr	r1, [pc, #400]	; (d8290 <_Z9getConfig6String+0x240>)
   d8100:	a805      	add	r0, sp, #20
   d8102:	f004 fa56 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8106:	2103      	movs	r1, #3
   d8108:	a805      	add	r0, sp, #20
   d810a:	f7fc ff8f 	bl	d502c <_Z3log6Stringi>
   d810e:	a805      	add	r0, sp, #20
   d8110:	f004 fa08 	bl	dc524 <_ZN6StringD1Ev>
    if(!ftp.mkd(dir)){ // S'il n'existe pas, on le cre
   d8114:	4621      	mov	r1, r4
   d8116:	a805      	add	r0, sp, #20
   d8118:	f004 fa6d 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d811c:	a905      	add	r1, sp, #20
   d811e:	4856      	ldr	r0, [pc, #344]	; (d8278 <_Z9getConfig6String+0x228>)
   d8120:	f002 fc18 	bl	da954 <_ZN17particleftpclient17ParticleFtpClient3mkdE6String>
   d8124:	4605      	mov	r5, r0
   d8126:	a805      	add	r0, sp, #20
   d8128:	f004 f9fc 	bl	dc524 <_ZN6StringD1Ev>
   d812c:	b9b5      	cbnz	r5, d815c <_Z9getConfig6String+0x10c>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d812e:	4959      	ldr	r1, [pc, #356]	; (d8294 <_Z9getConfig6String+0x244>)
   d8130:	a801      	add	r0, sp, #4
   d8132:	f004 fa3e 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      log("ftp mkdir failed: " + dir, 2);
   d8136:	4621      	mov	r1, r4
   d8138:	a801      	add	r0, sp, #4
   d813a:	f004 fb15 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d813e:	4601      	mov	r1, r0
   d8140:	a805      	add	r0, sp, #20
   d8142:	f004 fa58 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8146:	2102      	movs	r1, #2
   d8148:	a805      	add	r0, sp, #20
   d814a:	f7fc ff6f 	bl	d502c <_Z3log6Stringi>
   d814e:	a805      	add	r0, sp, #20
   d8150:	f004 f9e8 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8154:	a801      	add	r0, sp, #4
   d8156:	f004 f9e5 	bl	dc524 <_ZN6StringD1Ev>
      return 0;
   d815a:	e082      	b.n	d8262 <_Z9getConfig6String+0x212>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d815c:	494e      	ldr	r1, [pc, #312]	; (d8298 <_Z9getConfig6String+0x248>)
   d815e:	a801      	add	r0, sp, #4
   d8160:	f004 fa27 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    }
    log("ftp mkdir success: " + dir, 3);
   d8164:	4621      	mov	r1, r4
   d8166:	a801      	add	r0, sp, #4
   d8168:	f004 fafe 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d816c:	4601      	mov	r1, r0
   d816e:	a805      	add	r0, sp, #20
   d8170:	f004 fa41 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8174:	2103      	movs	r1, #3
   d8176:	a805      	add	r0, sp, #20
   d8178:	f7fc ff58 	bl	d502c <_Z3log6Stringi>
   d817c:	a805      	add	r0, sp, #20
   d817e:	f004 f9d1 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8182:	a801      	add	r0, sp, #4
   d8184:	f004 f9ce 	bl	dc524 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8188:	4944      	ldr	r1, [pc, #272]	; (d829c <_Z9getConfig6String+0x24c>)
   d818a:	a801      	add	r0, sp, #4
   d818c:	f004 fa11 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  }

  // Tentative de rcupration du fichier, aprs un retr russi, l'info se trouve dans le buffer TCP
  if (!ftp.retr("/AutoCamDEH/config/" + BDH + "/CONFIG.JSN")) {
   d8190:	4943      	ldr	r1, [pc, #268]	; (d82a0 <_Z9getConfig6String+0x250>)
   d8192:	a801      	add	r0, sp, #4
   d8194:	f004 fae8 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8198:	4942      	ldr	r1, [pc, #264]	; (d82a4 <_Z9getConfig6String+0x254>)
   d819a:	f004 faf1 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d819e:	4601      	mov	r1, r0
   d81a0:	a805      	add	r0, sp, #20
   d81a2:	f004 fa28 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d81a6:	a905      	add	r1, sp, #20
   d81a8:	4833      	ldr	r0, [pc, #204]	; (d8278 <_Z9getConfig6String+0x228>)
   d81aa:	f002 fd43 	bl	dac34 <_ZN17particleftpclient17ParticleFtpClient4retrE6String>
   d81ae:	4604      	mov	r4, r0
   d81b0:	a805      	add	r0, sp, #20
   d81b2:	f004 f9b7 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d81b6:	a801      	add	r0, sp, #4
   d81b8:	f004 f9b4 	bl	dc524 <_ZN6StringD1Ev>
   d81bc:	b90c      	cbnz	r4, d81c2 <_Z9getConfig6String+0x172>
    log("Couldn't retrieve CONFIG.JSN", 2);
   d81be:	493a      	ldr	r1, [pc, #232]	; (d82a8 <_Z9getConfig6String+0x258>)
   d81c0:	e775      	b.n	d80ae <_Z9getConfig6String+0x5e>
    return 0;
  } else { //l'opration a russi, nous pouvons supprimer le fichier de configuration pour le mettre  jour
    if(!SD.remove("CONFIG.JSN")) { //S'il existe...
   d81c2:	493a      	ldr	r1, [pc, #232]	; (d82ac <_Z9getConfig6String+0x25c>)
   d81c4:	483a      	ldr	r0, [pc, #232]	; (d82b0 <_Z9getConfig6String+0x260>)
   d81c6:	f003 f9fb 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>
   d81ca:	b920      	cbnz	r0, d81d6 <_Z9getConfig6String+0x186>
      Serial.println("file config.jsn doesn't exist");
   d81cc:	f005 fe68 	bl	ddea0 <_Z16_fetch_usbserialv>
   d81d0:	4938      	ldr	r1, [pc, #224]	; (d82b4 <_Z9getConfig6String+0x264>)
   d81d2:	f004 fe4a 	bl	dce6a <_ZN5Print7printlnEPKc>
    }

    //On cre un nouveau fichier de configuration et on vide le contenu du buffer TCP dans ce fichier.
    File file = SD.open("CONFIG.JSN",  FILE_WRITE); 
   d81d6:	a805      	add	r0, sp, #20
   d81d8:	2317      	movs	r3, #23
   d81da:	4a34      	ldr	r2, [pc, #208]	; (d82ac <_Z9getConfig6String+0x25c>)
   d81dc:	4934      	ldr	r1, [pc, #208]	; (d82b0 <_Z9getConfig6String+0x260>)
   d81de:	f003 f981 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
    if(file) {
   d81e2:	a805      	add	r0, sp, #20
   d81e4:	f002 fa9c 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d81e8:	b180      	cbz	r0, d820c <_Z9getConfig6String+0x1bc>
      while (ftp.data.connected()) {
   d81ea:	4823      	ldr	r0, [pc, #140]	; (d8278 <_Z9getConfig6String+0x228>)
   d81ec:	f006 f921 	bl	de432 <_ZN9TCPClient9connectedEv>
   d81f0:	b1b8      	cbz	r0, d8222 <_Z9getConfig6String+0x1d2>
        while (ftp.data.available()) {
   d81f2:	4821      	ldr	r0, [pc, #132]	; (d8278 <_Z9getConfig6String+0x228>)
   d81f4:	f006 fb08 	bl	de808 <_ZN9TCPClient9availableEv>
   d81f8:	2800      	cmp	r0, #0
   d81fa:	d0f6      	beq.n	d81ea <_Z9getConfig6String+0x19a>
        file.write(ftp.data.read());
   d81fc:	481e      	ldr	r0, [pc, #120]	; (d8278 <_Z9getConfig6String+0x228>)
   d81fe:	f006 f9ac 	bl	de55a <_ZN9TCPClient4readEv>
   d8202:	b2c1      	uxtb	r1, r0
   d8204:	a805      	add	r0, sp, #20
   d8206:	f002 f9cd 	bl	da5a4 <_ZN5SDLib4File5writeEh>

    //On cre un nouveau fichier de configuration et on vide le contenu du buffer TCP dans ce fichier.
    File file = SD.open("CONFIG.JSN",  FILE_WRITE); 
    if(file) {
      while (ftp.data.connected()) {
        while (ftp.data.available()) {
   d820a:	e7f2      	b.n	d81f2 <_Z9getConfig6String+0x1a2>
        file.write(ftp.data.read());
        }
      }
      } else {
        log("Failed to create new config",2);
   d820c:	492a      	ldr	r1, [pc, #168]	; (d82b8 <_Z9getConfig6String+0x268>)
   d820e:	a801      	add	r0, sp, #4
   d8210:	f004 f9cf 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8214:	a801      	add	r0, sp, #4
   d8216:	2102      	movs	r1, #2
   d8218:	f7fc ff08 	bl	d502c <_Z3log6Stringi>
   d821c:	a801      	add	r0, sp, #4
   d821e:	f004 f981 	bl	dc524 <_ZN6StringD1Ev>
    }
    // Fin du transfert, on ferme la connexion.
    file.close();
   d8222:	a805      	add	r0, sp, #20
   d8224:	f002 fa70 	bl	da708 <_ZN5SDLib4File5closeEv>
    delay(10);
   d8228:	200a      	movs	r0, #10
   d822a:	f004 ff87 	bl	dd13c <delay>
    ftp.finish();
   d822e:	4812      	ldr	r0, [pc, #72]	; (d8278 <_Z9getConfig6String+0x228>)
   d8230:	f002 fb0a 	bl	da848 <_ZN17particleftpclient17ParticleFtpClient6finishEv>
    ftp.quit();
   d8234:	4810      	ldr	r0, [pc, #64]	; (d8278 <_Z9getConfig6String+0x228>)
   d8236:	f002 fbf3 	bl	daa20 <_ZN17particleftpclient17ParticleFtpClient4quitEv>
    delay(10);
   d823a:	200a      	movs	r0, #10
   d823c:	f004 ff7e 	bl	dd13c <delay>

    log("up'ed", 4);
   d8240:	491e      	ldr	r1, [pc, #120]	; (d82bc <_Z9getConfig6String+0x26c>)
   d8242:	a801      	add	r0, sp, #4
   d8244:	f004 f9b5 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8248:	2104      	movs	r1, #4
   d824a:	eb0d 0001 	add.w	r0, sp, r1
   d824e:	f7fc feed 	bl	d502c <_Z3log6Stringi>
   d8252:	a801      	add	r0, sp, #4
   d8254:	f004 f966 	bl	dc524 <_ZN6StringD1Ev>

    // On met  jour la configuration de l'appareil avec les nouvelles donnes dans le fichier
    loadConfiguration("CONFIG.JSN", config);
   d8258:	4814      	ldr	r0, [pc, #80]	; (d82ac <_Z9getConfig6String+0x25c>)
   d825a:	4919      	ldr	r1, [pc, #100]	; (d82c0 <_Z9getConfig6String+0x270>)
   d825c:	f7ff fdd2 	bl	d7e04 <_Z17loadConfigurationPKcR6Config>

  }
}
   d8260:	e000      	b.n	d8264 <_Z9getConfig6String+0x214>
   d8262:	2000      	movs	r0, #0
   d8264:	b00f      	add	sp, #60	; 0x3c
   d8266:	bd30      	pop	{r4, r5, pc}
   d8268:	000e1ffc 	.word	0x000e1ffc
   d826c:	2003df1c 	.word	0x2003df1c
   d8270:	2003d7bc 	.word	0x2003d7bc
   d8274:	2003da3c 	.word	0x2003da3c
   d8278:	2003dd48 	.word	0x2003dd48
   d827c:	000e1fff 	.word	0x000e1fff
   d8280:	2003df40 	.word	0x2003df40
   d8284:	000e201c 	.word	0x000e201c
   d8288:	2003df54 	.word	0x2003df54
   d828c:	000e2029 	.word	0x000e2029
   d8290:	000e1c6f 	.word	0x000e1c6f
   d8294:	000e1c87 	.word	0x000e1c87
   d8298:	000e1c9a 	.word	0x000e1c9a
   d829c:	000e2036 	.word	0x000e2036
   d82a0:	2003df78 	.word	0x2003df78
   d82a4:	000e204a 	.word	0x000e204a
   d82a8:	000e2056 	.word	0x000e2056
   d82ac:	000e2068 	.word	0x000e2068
   d82b0:	2003e3d4 	.word	0x2003e3d4
   d82b4:	000e2073 	.word	0x000e2073
   d82b8:	000e2091 	.word	0x000e2091
   d82bc:	000e20ad 	.word	0x000e20ad
   d82c0:	2003d6bc 	.word	0x2003d6bc

000d82c4 <loop>:

/* 
* Le loop se rpte en boucle automatiquement
* V1.1 2019-12-17
*/
void loop() {
   d82c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // Variables temporaires propre  cette boucle
  loop:
  //Cellular.on();
  //Particle.connect();
  int secstoTimeout = timeout;
   d82c8:	4fbe      	ldr	r7, [pc, #760]	; (d85c4 <loop+0x300>)

/* 
* Le loop se rpte en boucle automatiquement
* V1.1 2019-12-17
*/
void loop() {
   d82ca:	b0c9      	sub	sp, #292	; 0x124
   d82cc:	463d      	mov	r5, r7
  loop:
  //Cellular.on();
  //Particle.connect();
  int secstoTimeout = timeout;
  int SSButton_longpress = 0;
  String Nametocard;
   d82ce:	49be      	ldr	r1, [pc, #760]	; (d85c8 <loop+0x304>)
void loop() {
  // Variables temporaires propre  cette boucle
  loop:
  //Cellular.on();
  //Particle.connect();
  int secstoTimeout = timeout;
   d82d0:	683c      	ldr	r4, [r7, #0]
  int SSButton_longpress = 0;
  String Nametocard;
   d82d2:	a806      	add	r0, sp, #24
   d82d4:	f004 f96d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  uint8_t buf[4];
  Particle.process(); // on oublie pas le cloud
   d82d8:	f7fc fde6 	bl	d4ea8 <_ZN10CloudClass7processEv>
  SleepResult result = System.sleepResult();
   d82dc:	a804      	add	r0, sp, #16
   d82de:	49bb      	ldr	r1, [pc, #748]	; (d85cc <loop+0x308>)
   d82e0:	f7fc fd44 	bl	d4d6c <_ZN11SystemClass11sleepResultEv>

  if(result.wokenUpByRtc()) {
   d82e4:	a804      	add	r0, sp, #16
   d82e6:	f003 ffed 	bl	dc2c4 <_ZNK11SleepResult12wokenUpByRtcEv>
   d82ea:	b180      	cbz	r0, d830e <loop+0x4a>
    log("Wu", 4);
   d82ec:	49b8      	ldr	r1, [pc, #736]	; (d85d0 <loop+0x30c>)
   d82ee:	a83e      	add	r0, sp, #248	; 0xf8
   d82f0:	f004 f95f 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d82f4:	2104      	movs	r1, #4
   d82f6:	a83e      	add	r0, sp, #248	; 0xf8
   d82f8:	f7fc fe98 	bl	d502c <_Z3log6Stringi>
   d82fc:	a83e      	add	r0, sp, #248	; 0xf8
   d82fe:	f004 f911 	bl	dc524 <_ZN6StringD1Ev>
    delay(1000);
   d8302:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8306:	f004 ff19 	bl	dd13c <delay>
    System.reset();
   d830a:	f003 ff88 	bl	dc21e <_ZN11SystemClass5resetEv>
  }    

  if(result.wokenUpByPin()) {
   d830e:	a804      	add	r0, sp, #16
   d8310:	f003 ffdf 	bl	dc2d2 <_ZNK11SleepResult12wokenUpByPinEv>
   d8314:	2800      	cmp	r0, #0
   d8316:	f000 8171 	beq.w	d85fc <loop+0x338>
  secstoTimeout = timeout;
  RGB.mirrorTo( NULL, statusLed, NULL);
   d831a:	2400      	movs	r4, #0
    delay(1000);
    System.reset();
  }    

  if(result.wokenUpByPin()) {
  secstoTimeout = timeout;
   d831c:	682e      	ldr	r6, [r5, #0]
  RGB.mirrorTo( NULL, statusLed, NULL);
   d831e:	9400      	str	r4, [sp, #0]
   d8320:	4623      	mov	r3, r4
   d8322:	4622      	mov	r2, r4
   d8324:	2107      	movs	r1, #7
   d8326:	4620      	mov	r0, r4
   d8328:	f004 ff3c 	bl	dd1a4 <_ZN8RGBClass8mirrorToEtttbb>
    }
    void off() {
        network_off(*this, 0, 0, NULL);
    }
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   d832c:	48a9      	ldr	r0, [pc, #676]	; (d85d4 <loop+0x310>)
   d832e:	4623      	mov	r3, r4
   d8330:	4622      	mov	r2, r4
   d8332:	4621      	mov	r1, r4
   d8334:	6840      	ldr	r0, [r0, #4]
   d8336:	f003 fc97 	bl	dbc68 <network_connect>
  Cellular.connect();
  log("Wu SS_Button", 4);
   d833a:	49a7      	ldr	r1, [pc, #668]	; (d85d8 <loop+0x314>)
   d833c:	a83e      	add	r0, sp, #248	; 0xf8
   d833e:	f004 f938 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8342:	a83e      	add	r0, sp, #248	; 0xf8
   d8344:	2104      	movs	r1, #4
   d8346:	f7fc fe71 	bl	d502c <_Z3log6Stringi>
   d834a:	a83e      	add	r0, sp, #248	; 0xf8
   d834c:	f004 f8ea 	bl	dc524 <_ZN6StringD1Ev>

  while(!Cellular.ready()) {
   d8350:	48a0      	ldr	r0, [pc, #640]	; (d85d4 <loop+0x310>)
   d8352:	f7fc fcb3 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d8356:	4604      	mov	r4, r0
   d8358:	bb28      	cbnz	r0, d83a6 <loop+0xe2>
    secstoTimeout--;
   d835a:	3e01      	subs	r6, #1
    delay(1000);
   d835c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8360:	f004 feec 	bl	dd13c <delay>
    if(secstoTimeout <= 140) {
   d8364:	2e8c      	cmp	r6, #140	; 0x8c
   d8366:	dcf3      	bgt.n	d8350 <loop+0x8c>
      RGB.mirrorDisable();
   d8368:	2001      	movs	r0, #1
   d836a:	f004 ff3b 	bl	dd1e4 <_ZN8RGBClass13mirrorDisableEb>
      pinMode(statusLed, OUTPUT);
   d836e:	2101      	movs	r1, #1
   d8370:	2007      	movs	r0, #7
   d8372:	f006 fbdd 	bl	deb30 <pinMode>
      delay(100);
   d8376:	2064      	movs	r0, #100	; 0x64
   d8378:	f004 fee0 	bl	dd13c <delay>
      log("could not connect", 4);
   d837c:	4997      	ldr	r1, [pc, #604]	; (d85dc <loop+0x318>)
   d837e:	a83e      	add	r0, sp, #248	; 0xf8
   d8380:	f004 f917 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8384:	2104      	movs	r1, #4
   d8386:	a83e      	add	r0, sp, #248	; 0xf8
   d8388:	f7fc fe50 	bl	d502c <_Z3log6Stringi>
   d838c:	a83e      	add	r0, sp, #248	; 0xf8
   d838e:	f004 f8c9 	bl	dc524 <_ZN6StringD1Ev>
      digitalWrite(statusLed, HIGH);
   d8392:	2101      	movs	r1, #1
   d8394:	2007      	movs	r0, #7
   d8396:	f006 fbdc 	bl	deb52 <digitalWrite>
      delay(5000);
   d839a:	f241 3088 	movw	r0, #5000	; 0x1388
   d839e:	f004 fecd 	bl	dd13c <delay>
      digitalWrite(statusLed, LOW);
   d83a2:	4621      	mov	r1, r4
   d83a4:	e0d1      	b.n	d854a <loop+0x286>
      goto loop;
    }
  }

  standby:
  secstoTimeout = timeout * 300;
   d83a6:	682e      	ldr	r6, [r5, #0]
   d83a8:	f44f 7396 	mov.w	r3, #300	; 0x12c
   d83ac:	435e      	muls	r6, r3
  SSButton_longpress = 0;
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
   d83ae:	2e00      	cmp	r6, #0
   d83b0:	f340 80f4 	ble.w	d859c <loop+0x2d8>
    SSButton_longpress = 0;
    if(digitalRead(SS_Button) == LOW) {
   d83b4:	2006      	movs	r0, #6
   d83b6:	f006 fbe5 	bl	deb84 <digitalRead>
   d83ba:	2800      	cmp	r0, #0
   d83bc:	d16f      	bne.n	d849e <loop+0x1da>
   d83be:	4604      	mov	r4, r0
      while (digitalRead(SS_Button) == LOW) {
   d83c0:	2006      	movs	r0, #6
   d83c2:	f006 fbdf 	bl	deb84 <digitalRead>
   d83c6:	b920      	cbnz	r0, d83d2 <loop+0x10e>
        SSButton_longpress += 100;
        delay(100);
   d83c8:	2064      	movs	r0, #100	; 0x64
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
    SSButton_longpress = 0;
    if(digitalRead(SS_Button) == LOW) {
      while (digitalRead(SS_Button) == LOW) {
        SSButton_longpress += 100;
   d83ca:	3464      	adds	r4, #100	; 0x64
        delay(100);
   d83cc:	f004 feb6 	bl	dd13c <delay>
  SSButton_longpress = 0;
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
    SSButton_longpress = 0;
    if(digitalRead(SS_Button) == LOW) {
      while (digitalRead(SS_Button) == LOW) {
   d83d0:	e7f6      	b.n	d83c0 <loop+0xfc>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d83d2:	4983      	ldr	r1, [pc, #524]	; (d85e0 <loop+0x31c>)
   d83d4:	a83e      	add	r0, sp, #248	; 0xf8
   d83d6:	f004 f8ec 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
        SSButton_longpress += 100;
        delay(100);
      }
      
      Particle.publish("status", "SSButton_longpress >= 10000, " + String(secstoTimeout));
   d83da:	220a      	movs	r2, #10
   d83dc:	4631      	mov	r1, r6
   d83de:	a834      	add	r0, sp, #208	; 0xd0
   d83e0:	f004 f937 	bl	dc652 <_ZN6StringC1Eih>
   d83e4:	a934      	add	r1, sp, #208	; 0xd0
   d83e6:	a83e      	add	r0, sp, #248	; 0xf8
   d83e8:	f004 f9be 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d83ec:	497d      	ldr	r1, [pc, #500]	; (d85e4 <loop+0x320>)
   d83ee:	6802      	ldr	r2, [r0, #0]
   d83f0:	a82b      	add	r0, sp, #172	; 0xac
   d83f2:	f7fc fc41 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d83f6:	a82c      	add	r0, sp, #176	; 0xb0
   d83f8:	f7fd fc08 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d83fc:	a834      	add	r0, sp, #208	; 0xd0
   d83fe:	f004 f891 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8402:	a83e      	add	r0, sp, #248	; 0xf8
   d8404:	f004 f88e 	bl	dc524 <_ZN6StringD1Ev>
      CellularSignal sig = Cellular.RSSI();
   d8408:	4972      	ldr	r1, [pc, #456]	; (d85d4 <loop+0x310>)
   d840a:	a83e      	add	r0, sp, #248	; 0xf8
   d840c:	f005 fd92 	bl	ddf34 <_ZN5spark13CellularClass4RSSIEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8410:	4975      	ldr	r1, [pc, #468]	; (d85e8 <loop+0x324>)
   d8412:	a82b      	add	r0, sp, #172	; 0xac
   d8414:	f004 f8cd 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      log("Signal Query: " + String(sig.rssi) + "dB" , 4);
   d8418:	220a      	movs	r2, #10
   d841a:	9940      	ldr	r1, [sp, #256]	; 0x100
   d841c:	a822      	add	r0, sp, #136	; 0x88
   d841e:	f004 f918 	bl	dc652 <_ZN6StringC1Eih>
   d8422:	a922      	add	r1, sp, #136	; 0x88
   d8424:	a82b      	add	r0, sp, #172	; 0xac
   d8426:	f004 f99f 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d842a:	4970      	ldr	r1, [pc, #448]	; (d85ec <loop+0x328>)
   d842c:	f004 f9a8 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8430:	4601      	mov	r1, r0
   d8432:	a834      	add	r0, sp, #208	; 0xd0
   d8434:	f004 f8df 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8438:	2104      	movs	r1, #4
   d843a:	a834      	add	r0, sp, #208	; 0xd0
   d843c:	f7fc fdf6 	bl	d502c <_Z3log6Stringi>
   d8440:	a834      	add	r0, sp, #208	; 0xd0
   d8442:	f004 f86f 	bl	dc524 <_ZN6StringD1Ev>
   d8446:	a822      	add	r0, sp, #136	; 0x88
   d8448:	f004 f86c 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d844c:	a82b      	add	r0, sp, #172	; 0xac
   d844e:	f004 f869 	bl	dc524 <_ZN6StringD1Ev>
      RGB.mirrorDisable();
   d8452:	2001      	movs	r0, #1
   d8454:	f004 fec6 	bl	dd1e4 <_ZN8RGBClass13mirrorDisableEb>
      pinMode(statusLed, OUTPUT);
   d8458:	2101      	movs	r1, #1
   d845a:	2007      	movs	r0, #7
   d845c:	f006 fb68 	bl	deb30 <pinMode>
      delay(100);     
   d8460:	2064      	movs	r0, #100	; 0x64
   d8462:	f004 fe6b 	bl	dd13c <delay>
      for (size_t i = 0; i <= -(sig.rssi/10) ; i++) {
   d8466:	2600      	movs	r6, #0
   d8468:	f06f 0809 	mvn.w	r8, #9
   d846c:	9b40      	ldr	r3, [sp, #256]	; 0x100
   d846e:	fb93 f3f8 	sdiv	r3, r3, r8
   d8472:	429e      	cmp	r6, r3
   d8474:	d811      	bhi.n	d849a <loop+0x1d6>
        digitalWrite(statusLed, LOW);
   d8476:	2100      	movs	r1, #0
   d8478:	2007      	movs	r0, #7
   d847a:	f006 fb6a 	bl	deb52 <digitalWrite>
        delay(500);
   d847e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   d8482:	f004 fe5b 	bl	dd13c <delay>
        digitalWrite(statusLed, HIGH);
   d8486:	2101      	movs	r1, #1
   d8488:	2007      	movs	r0, #7
   d848a:	f006 fb62 	bl	deb52 <digitalWrite>
        delay(500);
   d848e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   d8492:	f004 fe53 	bl	dd13c <delay>
      CellularSignal sig = Cellular.RSSI();
      log("Signal Query: " + String(sig.rssi) + "dB" , 4);
      RGB.mirrorDisable();
      pinMode(statusLed, OUTPUT);
      delay(100);     
      for (size_t i = 0; i <= -(sig.rssi/10) ; i++) {
   d8496:	3601      	adds	r6, #1
   d8498:	e7e8      	b.n	d846c <loop+0x1a8>
        digitalWrite(statusLed, LOW);
        delay(500);
        digitalWrite(statusLed, HIGH);
        delay(500);
      }
      secstoTimeout = timeout;
   d849a:	682e      	ldr	r6, [r5, #0]
   d849c:	e000      	b.n	d84a0 <loop+0x1dc>
  standby:
  secstoTimeout = timeout * 300;
  SSButton_longpress = 0;
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
    SSButton_longpress = 0;
   d849e:	2400      	movs	r4, #0
        delay(500);
      }
      secstoTimeout = timeout;
    }

    RGB.mirrorTo( statusLed, statusLed, statusLed);
   d84a0:	2207      	movs	r2, #7
   d84a2:	2300      	movs	r3, #0
   d84a4:	4610      	mov	r0, r2
   d84a6:	9300      	str	r3, [sp, #0]
   d84a8:	4611      	mov	r1, r2
   d84aa:	f004 fe7b 	bl	dd1a4 <_ZN8RGBClass8mirrorToEtttbb>
    Particle.process();
   d84ae:	f7fc fcfb 	bl	d4ea8 <_ZN10CloudClass7processEv>
    delay(100);
   d84b2:	2064      	movs	r0, #100	; 0x64
   d84b4:	f004 fe42 	bl	dd13c <delay>
    secstoTimeout -= 1;
    wd.checkin();
   d84b8:	f7fc fc98 	bl	d4dec <_ZN19ApplicationWatchdog7checkinEv>

  standby:
  secstoTimeout = timeout * 300;
  SSButton_longpress = 0;
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
   d84bc:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
    }

    RGB.mirrorTo( statusLed, statusLed, statusLed);
    Particle.process();
    delay(100);
    secstoTimeout -= 1;
   d84c0:	f106 36ff 	add.w	r6, r6, #4294967295

  standby:
  secstoTimeout = timeout * 300;
  SSButton_longpress = 0;
  
  while(SSButton_longpress <= 2000 && secstoTimeout > 0) {
   d84c4:	f77f af73 	ble.w	d83ae <loop+0xea>
    delay(100);
    secstoTimeout -= 1;
    wd.checkin();
  }

  if(SSButton_longpress >= 10000) {
   d84c8:	f242 730f 	movw	r3, #9999	; 0x270f
   d84cc:	429c      	cmp	r4, r3
   d84ce:	dd65      	ble.n	d859c <loop+0x2d8>
    RGB.mirrorDisable();
   d84d0:	2001      	movs	r0, #1
   d84d2:	f004 fe87 	bl	dd1e4 <_ZN8RGBClass13mirrorDisableEb>
    pinMode(statusLed, OUTPUT);
   d84d6:	2101      	movs	r1, #1
   d84d8:	2007      	movs	r0, #7
   d84da:	f006 fb29 	bl	deb30 <pinMode>
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
   d84de:	f003 fc23 	bl	dbd28 <spark_cloud_flag_connect>
    Particle.connect();
    secstoTimeout = timeout;
   d84e2:	682c      	ldr	r4, [r5, #0]
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   d84e4:	f003 fc30 	bl	dbd48 <spark_cloud_flag_connected>
    while(!Particle.connected()) {
   d84e8:	4606      	mov	r6, r0
   d84ea:	2800      	cmp	r0, #0
   d84ec:	d148      	bne.n	d8580 <loop+0x2bc>
      digitalWrite(statusLed, LOW);
   d84ee:	4601      	mov	r1, r0
   d84f0:	2007      	movs	r0, #7
   d84f2:	f006 fb2e 	bl	deb52 <digitalWrite>
      delay(250);
   d84f6:	20fa      	movs	r0, #250	; 0xfa
   d84f8:	f004 fe20 	bl	dd13c <delay>
      digitalWrite(statusLed, HIGH);
   d84fc:	2101      	movs	r1, #1
   d84fe:	2007      	movs	r0, #7
   d8500:	f006 fb27 	bl	deb52 <digitalWrite>
      delay(250);
   d8504:	20fa      	movs	r0, #250	; 0xfa
   d8506:	f004 fe19 	bl	dd13c <delay>
      if(secstoTimeout <= 140) {
   d850a:	2c8c      	cmp	r4, #140	; 0x8c
   d850c:	dc34      	bgt.n	d8578 <loop+0x2b4>
        RGB.mirrorDisable();
   d850e:	2001      	movs	r0, #1
   d8510:	f004 fe68 	bl	dd1e4 <_ZN8RGBClass13mirrorDisableEb>
        pinMode(statusLed, OUTPUT);
   d8514:	2101      	movs	r1, #1
   d8516:	2007      	movs	r0, #7
   d8518:	f006 fb0a 	bl	deb30 <pinMode>
        delay(100);
   d851c:	2064      	movs	r0, #100	; 0x64
   d851e:	f004 fe0d 	bl	dd13c <delay>
        log("could not connect to cloud", 4);
   d8522:	4933      	ldr	r1, [pc, #204]	; (d85f0 <loop+0x32c>)
   d8524:	a83e      	add	r0, sp, #248	; 0xf8
   d8526:	f004 f844 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d852a:	2104      	movs	r1, #4
   d852c:	a83e      	add	r0, sp, #248	; 0xf8
   d852e:	f7fc fd7d 	bl	d502c <_Z3log6Stringi>
   d8532:	a83e      	add	r0, sp, #248	; 0xf8
   d8534:	f003 fff6 	bl	dc524 <_ZN6StringD1Ev>
        digitalWrite(statusLed, HIGH);
   d8538:	2101      	movs	r1, #1
   d853a:	2007      	movs	r0, #7
   d853c:	f006 fb09 	bl	deb52 <digitalWrite>
        delay(5000);
   d8540:	f241 3088 	movw	r0, #5000	; 0x1388
   d8544:	f004 fdfa 	bl	dd13c <delay>
        digitalWrite(statusLed, LOW);
   d8548:	4631      	mov	r1, r6
   d854a:	2007      	movs	r0, #7
   d854c:	f006 fb01 	bl	deb52 <digitalWrite>
        delay(1000);
   d8550:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8554:	f004 fdf2 	bl	dd13c <delay>
   d8558:	4b26      	ldr	r3, [pc, #152]	; (d85f4 <loop+0x330>)
   d855a:	681b      	ldr	r3, [r3, #0]
        System.sleep(SS_Button, FALLING, 1500);
   d855c:	9300      	str	r3, [sp, #0]
   d855e:	2202      	movs	r2, #2
   d8560:	f240 53dc 	movw	r3, #1500	; 0x5dc
   d8564:	2106      	movs	r1, #6
   d8566:	a83e      	add	r0, sp, #248	; 0xf8
   d8568:	f7fc fbea 	bl	d4d40 <_ZN11SystemClass5sleepEt13InterruptModelN8particle5FlagsI19SleepOptionFlagTypemEE>
        delay(1000);
   d856c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8570:	f004 fde4 	bl	dd13c <delay>
        goto loop;
   d8574:	f000 bd6b 	b.w	d904e <loop+0xd8a>
      }  
      secstoTimeout--;  
   d8578:	3c01      	subs	r4, #1
      wd.checkin();  
   d857a:	f7fc fc37 	bl	d4dec <_ZN19ApplicationWatchdog7checkinEv>
  if(SSButton_longpress >= 10000) {
    RGB.mirrorDisable();
    pinMode(statusLed, OUTPUT);
    Particle.connect();
    secstoTimeout = timeout;
    while(!Particle.connected()) {
   d857e:	e7b1      	b.n	d84e4 <loop+0x220>
        goto loop;
      }  
      secstoTimeout--;  
      wd.checkin();  
    }
    Particle.publishVitals();
   d8580:	f04f 31ff 	mov.w	r1, #4294967295
   d8584:	481c      	ldr	r0, [pc, #112]	; (d85f8 <loop+0x334>)
   d8586:	f005 f914 	bl	dd7b2 <_ZN10CloudClass13publishVitalsEm>
    RGB.mirrorTo( statusLed, statusLed, statusLed);
   d858a:	2207      	movs	r2, #7
   d858c:	2300      	movs	r3, #0
   d858e:	9300      	str	r3, [sp, #0]
   d8590:	4611      	mov	r1, r2
   d8592:	4610      	mov	r0, r2
   d8594:	f004 fe06 	bl	dd1a4 <_ZN8RGBClass8mirrorToEtttbb>
    goto loop;
   d8598:	f000 bd59 	b.w	d904e <loop+0xd8a>
  }
  
  RGB.mirrorDisable();
   d859c:	2001      	movs	r0, #1
   d859e:	f004 fe21 	bl	dd1e4 <_ZN8RGBClass13mirrorDisableEb>
  pinMode(statusLed, OUTPUT);
   d85a2:	2101      	movs	r1, #1
   d85a4:	2007      	movs	r0, #7
   d85a6:	f006 fac3 	bl	deb30 <pinMode>
  digitalWrite(statusLed,LOW);
   d85aa:	2100      	movs	r1, #0
   d85ac:	2007      	movs	r0, #7
   d85ae:	f006 fad0 	bl	deb52 <digitalWrite>
  delay(10);
   d85b2:	200a      	movs	r0, #10
   d85b4:	f004 fdc2 	bl	dd13c <delay>
  goToSleep(600);
   d85b8:	f44f 7016 	mov.w	r0, #600	; 0x258
   d85bc:	f7fd faec 	bl	d5b98 <_Z9goToSleepl>
   d85c0:	e7d4      	b.n	d856c <loop+0x2a8>
   d85c2:	bf00      	nop
   d85c4:	2003d7bc 	.word	0x2003d7bc
   d85c8:	000e1eea 	.word	0x000e1eea
   d85cc:	2003e440 	.word	0x2003e440
   d85d0:	000e20b3 	.word	0x000e20b3
   d85d4:	2003e4c0 	.word	0x2003e4c0
   d85d8:	000e20b6 	.word	0x000e20b6
   d85dc:	000e20c3 	.word	0x000e20c3
   d85e0:	000e20d5 	.word	0x000e20d5
   d85e4:	000e1dcc 	.word	0x000e1dcc
   d85e8:	000e20f3 	.word	0x000e20f3
   d85ec:	000e2102 	.word	0x000e2102
   d85f0:	000e2105 	.word	0x000e2105
   d85f4:	2003e2a8 	.word	0x2003e2a8
   d85f8:	2003e6f0 	.word	0x2003e6f0
  goto loop;
  
}  
  
  // Avant de procder aux opration ncessitant du rseau, on attends d'tre connect
  log("WCC", 4); 
   d85fc:	499f      	ldr	r1, [pc, #636]	; (d887c <loop+0x5b8>)
   d85fe:	a83e      	add	r0, sp, #248	; 0xf8
   d8600:	f003 ffd7 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8604:	2104      	movs	r1, #4
   d8606:	a83e      	add	r0, sp, #248	; 0xf8
   d8608:	f7fc fd10 	bl	d502c <_Z3log6Stringi>
   d860c:	a83e      	add	r0, sp, #248	; 0xf8
   d860e:	f003 ff89 	bl	dc524 <_ZN6StringD1Ev>
   d8612:	f003 f8df 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
  unsigned long previousMillis = millis();
  unsigned long thatTook = 0;
  while(!Cellular.ready()){
   d8616:	489a      	ldr	r0, [pc, #616]	; (d8880 <loop+0x5bc>)
   d8618:	f7fc fb50 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d861c:	b9b0      	cbnz	r0, d864c <loop+0x388>
      delay(1000);
   d861e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
      Particle.process();
      secstoTimeout--;
   d8622:	3c01      	subs	r4, #1
  // Avant de procder aux opration ncessitant du rseau, on attends d'tre connect
  log("WCC", 4); 
  unsigned long previousMillis = millis();
  unsigned long thatTook = 0;
  while(!Cellular.ready()){
      delay(1000);
   d8624:	f004 fd8a 	bl	dd13c <delay>
      Particle.process();
   d8628:	f7fc fc3e 	bl	d4ea8 <_ZN10CloudClass7processEv>
      secstoTimeout--;
      if (secstoTimeout <= 0) { // Si c'est trop long, on passe en mode offline
   d862c:	2c00      	cmp	r4, #0
   d862e:	dcf2      	bgt.n	d8616 <loop+0x352>
        offlineMode = true;
   d8630:	4b94      	ldr	r3, [pc, #592]	; (d8884 <loop+0x5c0>)
        log("Timeout, OM", 3);
   d8632:	4995      	ldr	r1, [pc, #596]	; (d8888 <loop+0x5c4>)
  while(!Cellular.ready()){
      delay(1000);
      Particle.process();
      secstoTimeout--;
      if (secstoTimeout <= 0) { // Si c'est trop long, on passe en mode offline
        offlineMode = true;
   d8634:	2201      	movs	r2, #1
        log("Timeout, OM", 3);
   d8636:	a83e      	add	r0, sp, #248	; 0xf8
  while(!Cellular.ready()){
      delay(1000);
      Particle.process();
      secstoTimeout--;
      if (secstoTimeout <= 0) { // Si c'est trop long, on passe en mode offline
        offlineMode = true;
   d8638:	701a      	strb	r2, [r3, #0]
        log("Timeout, OM", 3);
   d863a:	f003 ffba 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d863e:	a83e      	add	r0, sp, #248	; 0xf8
   d8640:	2103      	movs	r1, #3
   d8642:	f7fc fcf3 	bl	d502c <_Z3log6Stringi>
   d8646:	a83e      	add	r0, sp, #248	; 0xf8
   d8648:	f003 ff6c 	bl	dc524 <_ZN6StringD1Ev>
        break;
      }
    }
  secstoTimeout = timeout;
   d864c:	682c      	ldr	r4, [r5, #0]
   d864e:	4e8d      	ldr	r6, [pc, #564]	; (d8884 <loop+0x5c0>)
   d8650:	f003 f8c0 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
   d8654:	4681      	mov	r9, r0
   d8656:	f003 fb77 	bl	dbd48 <spark_cloud_flag_connected>
   d865a:	f8df 8228 	ldr.w	r8, [pc, #552]	; d8884 <loop+0x5c0>

  previousMillis = millis();
  thatTook = 0;
  while(!Particle.connected() && !offlineMode){
   d865e:	b9d0      	cbnz	r0, d8696 <loop+0x3d2>
   d8660:	7833      	ldrb	r3, [r6, #0]
   d8662:	b9c3      	cbnz	r3, d8696 <loop+0x3d2>
    delay(1000);
   d8664:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    Particle.process();
    secstoTimeout--;
   d8668:	3c01      	subs	r4, #1
  secstoTimeout = timeout;

  previousMillis = millis();
  thatTook = 0;
  while(!Particle.connected() && !offlineMode){
    delay(1000);
   d866a:	f004 fd67 	bl	dd13c <delay>
    Particle.process();
   d866e:	f7fc fc1b 	bl	d4ea8 <_ZN10CloudClass7processEv>
    secstoTimeout--;
    if (secstoTimeout <= 170) { // Si c'est trop long, on passe en mode cloud outage
   d8672:	2caa      	cmp	r4, #170	; 0xaa
   d8674:	dcef      	bgt.n	d8656 <loop+0x392>
      cloudOutage = true;
   d8676:	4b85      	ldr	r3, [pc, #532]	; (d888c <loop+0x5c8>)
   d8678:	2201      	movs	r2, #1
   d867a:	701a      	strb	r2, [r3, #0]
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
   d867c:	f003 fb5c 	bl	dbd38 <spark_cloud_flag_disconnect>
      Particle.disconnect();
      log("Timeout, CO", 3);
   d8680:	4983      	ldr	r1, [pc, #524]	; (d8890 <loop+0x5cc>)
   d8682:	a83e      	add	r0, sp, #248	; 0xf8
   d8684:	f003 ff95 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8688:	a83e      	add	r0, sp, #248	; 0xf8
   d868a:	2103      	movs	r1, #3
   d868c:	f7fc fcce 	bl	d502c <_Z3log6Stringi>
   d8690:	a83e      	add	r0, sp, #248	; 0xf8
   d8692:	f003 ff47 	bl	dc524 <_ZN6StringD1Ev>
      break;
    }
  }
  
  secstoTimeout = timeout;
   d8696:	682e      	ldr	r6, [r5, #0]
   d8698:	f003 f89c 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d869c:	497d      	ldr	r1, [pc, #500]	; (d8894 <loop+0x5d0>)
   d869e:	4604      	mov	r4, r0
   d86a0:	a834      	add	r0, sp, #208	; 0xd0
   d86a2:	f003 ff86 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  // Dcompte du temps de connection en secondes
  thatTook =  (millis() - previousMillis)/1000;
  log("TT " + String(thatTook), 4);
   d86a6:	ebc9 0404 	rsb	r4, r9, r4
   d86aa:	220a      	movs	r2, #10
   d86ac:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   d86b0:	a82b      	add	r0, sp, #172	; 0xac
   d86b2:	fbb4 f1f1 	udiv	r1, r4, r1
   d86b6:	f003 fff2 	bl	dc69e <_ZN6StringC1Emh>
   d86ba:	a92b      	add	r1, sp, #172	; 0xac
   d86bc:	a834      	add	r0, sp, #208	; 0xd0
   d86be:	f004 f853 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d86c2:	4601      	mov	r1, r0
   d86c4:	a83e      	add	r0, sp, #248	; 0xf8
   d86c6:	f003 ff96 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d86ca:	2104      	movs	r1, #4
   d86cc:	a83e      	add	r0, sp, #248	; 0xf8
   d86ce:	f7fc fcad 	bl	d502c <_Z3log6Stringi>
   d86d2:	a83e      	add	r0, sp, #248	; 0xf8
   d86d4:	f003 ff26 	bl	dc524 <_ZN6StringD1Ev>
   d86d8:	a82b      	add	r0, sp, #172	; 0xac
   d86da:	f003 ff23 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d86de:	a834      	add	r0, sp, #208	; 0xd0
   d86e0:	f003 ff20 	bl	dc524 <_ZN6StringD1Ev>

  // On obtient le niveau de batterie et de signal cell pour le log
  String SOC = String(fuel.getSoC());
   d86e4:	486c      	ldr	r0, [pc, #432]	; (d8898 <loop+0x5d4>)
   d86e6:	f004 fedd 	bl	dd4a4 <_ZN9FuelGauge6getSoCEv>
   d86ea:	2106      	movs	r1, #6
   d86ec:	a80a      	add	r0, sp, #40	; 0x28
   d86ee:	f003 ffea 	bl	dc6c6 <_ZN6StringC1Efi>
  String VCell = String(fuel.getVCell());
   d86f2:	4869      	ldr	r0, [pc, #420]	; (d8898 <loop+0x5d4>)
   d86f4:	f004 fec0 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d86f8:	2106      	movs	r1, #6
   d86fa:	a80e      	add	r0, sp, #56	; 0x38
   d86fc:	f003 ffe3 	bl	dc6c6 <_ZN6StringC1Efi>
  CellularSignal sig = Cellular.RSSI();
   d8700:	495f      	ldr	r1, [pc, #380]	; (d8880 <loop+0x5bc>)
   d8702:	a834      	add	r0, sp, #208	; 0xd0
   d8704:	f005 fc16 	bl	ddf34 <_ZN5spark13CellularClass4RSSIEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8708:	4964      	ldr	r1, [pc, #400]	; (d889c <loop+0x5d8>)
   d870a:	a81e      	add	r0, sp, #120	; 0x78
   d870c:	f003 ff51 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  log("SOC; " + SOC + ";Vb;" + VCell + ";RSSI;" + String(sig.rssi) + ";Qual; " + String(sig.getQuality()) + ";", 4);  
   d8710:	a90a      	add	r1, sp, #40	; 0x28
   d8712:	a81e      	add	r0, sp, #120	; 0x78
   d8714:	f004 f828 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8718:	4961      	ldr	r1, [pc, #388]	; (d88a0 <loop+0x5dc>)
   d871a:	f004 f831 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d871e:	a90e      	add	r1, sp, #56	; 0x38
   d8720:	f004 f822 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8724:	495f      	ldr	r1, [pc, #380]	; (d88a4 <loop+0x5e0>)
   d8726:	f004 f82b 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d872a:	220a      	movs	r2, #10
   d872c:	4604      	mov	r4, r0
   d872e:	9936      	ldr	r1, [sp, #216]	; 0xd8
   d8730:	a822      	add	r0, sp, #136	; 0x88
   d8732:	f003 ff8e 	bl	dc652 <_ZN6StringC1Eih>
   d8736:	a922      	add	r1, sp, #136	; 0x88
   d8738:	4620      	mov	r0, r4
   d873a:	f004 f815 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d873e:	495a      	ldr	r1, [pc, #360]	; (d88a8 <loop+0x5e4>)
   d8740:	f004 f81e 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8744:	4604      	mov	r4, r0
   d8746:	a834      	add	r0, sp, #208	; 0xd0
   d8748:	f004 fdb6 	bl	dd2b8 <_ZNK14CellularSignal10getQualityEv>
   d874c:	2106      	movs	r1, #6
   d874e:	a82b      	add	r0, sp, #172	; 0xac
   d8750:	f003 ffb9 	bl	dc6c6 <_ZN6StringC1Efi>
   d8754:	a92b      	add	r1, sp, #172	; 0xac
   d8756:	4620      	mov	r0, r4
   d8758:	f004 f806 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d875c:	4953      	ldr	r1, [pc, #332]	; (d88ac <loop+0x5e8>)
   d875e:	f004 f80f 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8762:	4601      	mov	r1, r0
   d8764:	a83e      	add	r0, sp, #248	; 0xf8
   d8766:	f003 ff46 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d876a:	2104      	movs	r1, #4
   d876c:	a83e      	add	r0, sp, #248	; 0xf8
   d876e:	f7fc fc5d 	bl	d502c <_Z3log6Stringi>
   d8772:	a83e      	add	r0, sp, #248	; 0xf8
   d8774:	f003 fed6 	bl	dc524 <_ZN6StringD1Ev>
   d8778:	a82b      	add	r0, sp, #172	; 0xac
   d877a:	f003 fed3 	bl	dc524 <_ZN6StringD1Ev>
   d877e:	a822      	add	r0, sp, #136	; 0x88
   d8780:	f003 fed0 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8784:	a81e      	add	r0, sp, #120	; 0x78
   d8786:	f003 fecd 	bl	dc524 <_ZN6StringD1Ev>
  if (sig.getQuality() < 25) offlineMode = true ; // Si la qualit du signal est sous 25, on considre que nous sommes hors ligne
   d878a:	a834      	add	r0, sp, #208	; 0xd0
   d878c:	f004 fd94 	bl	dd2b8 <_ZNK14CellularSignal10getQualityEv>
   d8790:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
   d8794:	eeb4 0ae7 	vcmpe.f32	s0, s15
   d8798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d879c:	bf44      	itt	mi
   d879e:	2301      	movmi	r3, #1
   d87a0:	f888 3000 	strbmi.w	r3, [r8]

  // Oprations  faire seulement si nous avons une connection rseau confirme
  if(!offlineMode) {
   d87a4:	f898 3000 	ldrb.w	r3, [r8]
   d87a8:	2b00      	cmp	r3, #0
   d87aa:	f040 8097 	bne.w	d88dc <loop+0x618>
    if(!cloudOutage) {
   d87ae:	4b37      	ldr	r3, [pc, #220]	; (d888c <loop+0x5c8>)
   d87b0:	781c      	ldrb	r4, [r3, #0]
   d87b2:	b1ec      	cbz	r4, d87f0 <loop+0x52c>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d87b4:	493e      	ldr	r1, [pc, #248]	; (d88b0 <loop+0x5ec>)
   d87b6:	a82b      	add	r0, sp, #172	; 0xac
   d87b8:	f003 fefb 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
        secstoTimeout--;
      }
      secstoTimeout = timeout;
    }

    getConfig("/AutoCamDEH/config/" + BDH + "/");
   d87bc:	493d      	ldr	r1, [pc, #244]	; (d88b4 <loop+0x5f0>)
   d87be:	a82b      	add	r0, sp, #172	; 0xac
   d87c0:	f003 ffd2 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d87c4:	493c      	ldr	r1, [pc, #240]	; (d88b8 <loop+0x5f4>)
   d87c6:	f003 ffdb 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d87ca:	4601      	mov	r1, r0
   d87cc:	a83e      	add	r0, sp, #248	; 0xf8
   d87ce:	f003 ff12 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d87d2:	a83e      	add	r0, sp, #248	; 0xf8
   d87d4:	f7ff fc3c 	bl	d8050 <_Z9getConfig6String>
   d87d8:	a83e      	add	r0, sp, #248	; 0xf8
   d87da:	f003 fea3 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d87de:	a82b      	add	r0, sp, #172	; 0xac
   d87e0:	f003 fea0 	bl	dc524 <_ZN6StringD1Ev>

    // On sauvegarde la nouvelle configuration
    saveConfiguration(configFileName,config);
   d87e4:	4b35      	ldr	r3, [pc, #212]	; (d88bc <loop+0x5f8>)
   d87e6:	4936      	ldr	r1, [pc, #216]	; (d88c0 <loop+0x5fc>)
   d87e8:	6818      	ldr	r0, [r3, #0]
   d87ea:	f7ff f895 	bl	d7918 <_Z17saveConfigurationPKcRK6Config>
   d87ee:	e075      	b.n	d88dc <loop+0x618>
   d87f0:	4b34      	ldr	r3, [pc, #208]	; (d88c4 <loop+0x600>)
        return publish(eventName, eventData, DEFAULT_CLOUD_EVENT_TTL, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
   d87f2:	4935      	ldr	r1, [pc, #212]	; (d88c8 <loop+0x604>)
   d87f4:	781b      	ldrb	r3, [r3, #0]
   d87f6:	f88d 3000 	strb.w	r3, [sp]
   d87fa:	4622      	mov	r2, r4
   d87fc:	233c      	movs	r3, #60	; 0x3c
   d87fe:	a83e      	add	r0, sp, #248	; 0xf8
   d8800:	f005 f8d4 	bl	dd9ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
   d8804:	a83f      	add	r0, sp, #252	; 0xfc
   d8806:	f7fd fa01 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d880a:	4b30      	ldr	r3, [pc, #192]	; (d88cc <loop+0x608>)
   d880c:	4930      	ldr	r1, [pc, #192]	; (d88d0 <loop+0x60c>)
   d880e:	781b      	ldrb	r3, [r3, #0]
   d8810:	f88d 3000 	strb.w	r3, [sp]
   d8814:	4622      	mov	r2, r4
   d8816:	233c      	movs	r3, #60	; 0x3c
   d8818:	a83e      	add	r0, sp, #248	; 0xf8
   d881a:	f005 f8c7 	bl	dd9ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
   d881e:	a83f      	add	r0, sp, #252	; 0xfc
   d8820:	f7fd f9f4 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
  // Oprations  faire seulement si nous avons une connection rseau confirme
  if(!offlineMode) {
    if(!cloudOutage) {
      Particle.publish("particle/device/ip", PRIVATE);
      Particle.publish("particle/device/name");
      Particle.publish("Batt_SOC",SOC);
   d8824:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   d8826:	492b      	ldr	r1, [pc, #172]	; (d88d4 <loop+0x610>)
   d8828:	a83e      	add	r0, sp, #248	; 0xf8
   d882a:	f7fc fa25 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d882e:	a83f      	add	r0, sp, #252	; 0xfc
   d8830:	f7fd f9ec 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      Particle.publish("RSSI",String(sig.rssi));
   d8834:	220a      	movs	r2, #10
   d8836:	9936      	ldr	r1, [sp, #216]	; 0xd8
   d8838:	a83e      	add	r0, sp, #248	; 0xf8
   d883a:	f003 ff0a 	bl	dc652 <_ZN6StringC1Eih>
   d883e:	9a3e      	ldr	r2, [sp, #248]	; 0xf8
   d8840:	4925      	ldr	r1, [pc, #148]	; (d88d8 <loop+0x614>)
   d8842:	a82b      	add	r0, sp, #172	; 0xac
   d8844:	f7fc fa18 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d8848:	a82c      	add	r0, sp, #176	; 0xb0
   d884a:	f7fd f9df 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   d884e:	a83e      	add	r0, sp, #248	; 0xf8
   d8850:	f003 fe68 	bl	dc524 <_ZN6StringD1Ev>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   d8854:	f003 fa78 	bl	dbd48 <spark_cloud_flag_connected>
        spark_unsubscribe(NULL);
    }

    bool syncTime(void)
    {
        if (!connected()) {
   d8858:	b110      	cbz	r0, d8860 <loop+0x59c>
            return false;
        }
        return spark_sync_time(NULL);
   d885a:	4620      	mov	r0, r4
   d885c:	f003 fa8c 	bl	dbd78 <spark_sync_time>

      // On force un synchronisation du temps de l'horloge interne avec le cloud
      Particle.syncTime();
      while(!Particle.syncTimeDone() && secstoTimeout >= 170) {
   d8860:	f7fc f9f7 	bl	d4c52 <_ZN10CloudClass12syncTimeDoneEv.isra.14>
   d8864:	2800      	cmp	r0, #0
   d8866:	f040 83f7 	bne.w	d9058 <loop+0xd94>
   d886a:	2ea9      	cmp	r6, #169	; 0xa9
   d886c:	f340 842d 	ble.w	d90ca <loop+0xe06>
        delay(500);
   d8870:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   d8874:	f004 fc62 	bl	dd13c <delay>
        secstoTimeout--;
   d8878:	3e01      	subs	r6, #1
      Particle.publish("Batt_SOC",SOC);
      Particle.publish("RSSI",String(sig.rssi));

      // On force un synchronisation du temps de l'horloge interne avec le cloud
      Particle.syncTime();
      while(!Particle.syncTimeDone() && secstoTimeout >= 170) {
   d887a:	e7f1      	b.n	d8860 <loop+0x59c>
   d887c:	000e2120 	.word	0x000e2120
   d8880:	2003e4c0 	.word	0x2003e4c0
   d8884:	2003de98 	.word	0x2003de98
   d8888:	000e2124 	.word	0x000e2124
   d888c:	2003deec 	.word	0x2003deec
   d8890:	000e2130 	.word	0x000e2130
   d8894:	000e1d9b 	.word	0x000e1d9b
   d8898:	2003deb4 	.word	0x2003deb4
   d889c:	000e213c 	.word	0x000e213c
   d88a0:	000e2142 	.word	0x000e2142
   d88a4:	000e2147 	.word	0x000e2147
   d88a8:	000e214e 	.word	0x000e214e
   d88ac:	000e1b6d 	.word	0x000e1b6d
   d88b0:	000e2036 	.word	0x000e2036
   d88b4:	2003df78 	.word	0x2003df78
   d88b8:	000e1afd 	.word	0x000e1afd
   d88bc:	2003def0 	.word	0x2003def0
   d88c0:	2003d6bc 	.word	0x2003d6bc
   d88c4:	2003dea1 	.word	0x2003dea1
   d88c8:	000e1bbf 	.word	0x000e1bbf
   d88cc:	2003df04 	.word	0x2003df04
   d88d0:	000e1baa 	.word	0x000e1baa
   d88d4:	000e2156 	.word	0x000e2156
   d88d8:	000e215f 	.word	0x000e215f
    // On sauvegarde la nouvelle configuration
    saveConfiguration(configFileName,config);
  }

  // On prlve l'heure actuelle et on l'affiche sur le port srie
  now = rtc.now();
   d88dc:	4cb7      	ldr	r4, [pc, #732]	; (d8bbc <loop+0x8f8>)
   d88de:	a83e      	add	r0, sp, #248	; 0xf8
   d88e0:	f002 fb9d 	bl	db01e <_ZN7PCF85233nowEv>
   d88e4:	f8bd 30fc 	ldrh.w	r3, [sp, #252]	; 0xfc
   d88e8:	983e      	ldr	r0, [sp, #248]	; 0xf8
   d88ea:	80a3      	strh	r3, [r4, #4]
   d88ec:	6020      	str	r0, [r4, #0]
  Serial.print(String(now.year()));
   d88ee:	f005 fad7 	bl	ddea0 <_Z16_fetch_usbserialv>
   d88f2:	7821      	ldrb	r1, [r4, #0]
   d88f4:	220a      	movs	r2, #10
   d88f6:	4606      	mov	r6, r0
   d88f8:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d88fc:	a83e      	add	r0, sp, #248	; 0xf8
   d88fe:	f003 fea8 	bl	dc652 <_ZN6StringC1Eih>
   d8902:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d8904:	4630      	mov	r0, r6
   d8906:	f004 fa9d 	bl	dce44 <_ZN5Print5printEPKc>
   d890a:	a83e      	add	r0, sp, #248	; 0xf8
   d890c:	f003 fe0a 	bl	dc524 <_ZN6StringD1Ev>
  Serial.print('/');
   d8910:	f005 fac6 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8914:	212f      	movs	r1, #47	; 0x2f
   d8916:	f004 fa99 	bl	dce4c <_ZN5Print5printEc>
  Serial.print(String(now.month()));
   d891a:	f005 fac1 	bl	ddea0 <_Z16_fetch_usbserialv>
   d891e:	220a      	movs	r2, #10
   d8920:	4606      	mov	r6, r0
   d8922:	7861      	ldrb	r1, [r4, #1]
   d8924:	a83e      	add	r0, sp, #248	; 0xf8
   d8926:	f003 fe82 	bl	dc62e <_ZN6StringC1Ehh>
   d892a:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d892c:	4630      	mov	r0, r6
   d892e:	f004 fa89 	bl	dce44 <_ZN5Print5printEPKc>
   d8932:	a83e      	add	r0, sp, #248	; 0xf8
   d8934:	f003 fdf6 	bl	dc524 <_ZN6StringD1Ev>
  Serial.print('/');
   d8938:	f005 fab2 	bl	ddea0 <_Z16_fetch_usbserialv>
   d893c:	212f      	movs	r1, #47	; 0x2f
   d893e:	f004 fa85 	bl	dce4c <_ZN5Print5printEc>
  Serial.print(String(now.day()));
   d8942:	f005 faad 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8946:	220a      	movs	r2, #10
   d8948:	4606      	mov	r6, r0
   d894a:	78a1      	ldrb	r1, [r4, #2]
   d894c:	a83e      	add	r0, sp, #248	; 0xf8
   d894e:	f003 fe6e 	bl	dc62e <_ZN6StringC1Ehh>
   d8952:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d8954:	4630      	mov	r0, r6
   d8956:	f004 fa75 	bl	dce44 <_ZN5Print5printEPKc>
   d895a:	a83e      	add	r0, sp, #248	; 0xf8
   d895c:	f003 fde2 	bl	dc524 <_ZN6StringD1Ev>
  Serial.print(' ');
   d8960:	f005 fa9e 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8964:	2120      	movs	r1, #32
   d8966:	f004 fa71 	bl	dce4c <_ZN5Print5printEc>
  Serial.print(String(now.hour()));
   d896a:	f005 fa99 	bl	ddea0 <_Z16_fetch_usbserialv>
   d896e:	220a      	movs	r2, #10
   d8970:	4606      	mov	r6, r0
   d8972:	78e1      	ldrb	r1, [r4, #3]
   d8974:	a83e      	add	r0, sp, #248	; 0xf8
   d8976:	f003 fe5a 	bl	dc62e <_ZN6StringC1Ehh>
   d897a:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d897c:	4630      	mov	r0, r6
   d897e:	f004 fa61 	bl	dce44 <_ZN5Print5printEPKc>
   d8982:	a83e      	add	r0, sp, #248	; 0xf8
   d8984:	f003 fdce 	bl	dc524 <_ZN6StringD1Ev>
  Serial.print(':');
   d8988:	f005 fa8a 	bl	ddea0 <_Z16_fetch_usbserialv>
   d898c:	213a      	movs	r1, #58	; 0x3a
   d898e:	f004 fa5d 	bl	dce4c <_ZN5Print5printEc>
  Serial.print(String(now.minute()));
   d8992:	f005 fa85 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8996:	220a      	movs	r2, #10
   d8998:	4606      	mov	r6, r0
   d899a:	7921      	ldrb	r1, [r4, #4]
   d899c:	a83e      	add	r0, sp, #248	; 0xf8
   d899e:	f003 fe46 	bl	dc62e <_ZN6StringC1Ehh>
   d89a2:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d89a4:	4630      	mov	r0, r6
   d89a6:	f004 fa4d 	bl	dce44 <_ZN5Print5printEPKc>
   d89aa:	a83e      	add	r0, sp, #248	; 0xf8
   d89ac:	f003 fdba 	bl	dc524 <_ZN6StringD1Ev>
  Serial.print(':');
   d89b0:	f005 fa76 	bl	ddea0 <_Z16_fetch_usbserialv>
   d89b4:	213a      	movs	r1, #58	; 0x3a
   d89b6:	f004 fa49 	bl	dce4c <_ZN5Print5printEc>
  Serial.print(String(now.second()));
   d89ba:	f005 fa71 	bl	ddea0 <_Z16_fetch_usbserialv>
   d89be:	220a      	movs	r2, #10
   d89c0:	4606      	mov	r6, r0
   d89c2:	7961      	ldrb	r1, [r4, #5]
   d89c4:	a83e      	add	r0, sp, #248	; 0xf8
   d89c6:	f003 fe32 	bl	dc62e <_ZN6StringC1Ehh>
   d89ca:	993e      	ldr	r1, [sp, #248]	; 0xf8
   d89cc:	4630      	mov	r0, r6
   d89ce:	f004 fa39 	bl	dce44 <_ZN5Print5printEPKc>
   d89d2:	a83e      	add	r0, sp, #248	; 0xf8
   d89d4:	f003 fda6 	bl	dc524 <_ZN6StringD1Ev>
  Serial.println();
   d89d8:	f005 fa62 	bl	ddea0 <_Z16_fetch_usbserialv>
   d89dc:	f004 fa39 	bl	dce52 <_ZN5Print7printlnEv>
  char buffer[40];

  if (now.day() == 1 && now.hour() == 15) {
   d89e0:	78a3      	ldrb	r3, [r4, #2]
   d89e2:	2b01      	cmp	r3, #1
   d89e4:	4626      	mov	r6, r4
   d89e6:	d103      	bne.n	d89f0 <loop+0x72c>
   d89e8:	78e3      	ldrb	r3, [r4, #3]
   d89ea:	2b0f      	cmp	r3, #15
   d89ec:	f000 8389 	beq.w	d9102 <loop+0xe3e>
    cleanSD("");
  }

  // On gnre le nopm du fichier  partir de l'heure actuelle, on force 2 caractres par entre
  // exemple: 02 au lieu de 2
  sprintf(buffer,"%02d%02d%02d%02d.jpg", now.day(),now.hour(), now.minute(), now.second());
   d89f0:	7961      	ldrb	r1, [r4, #5]
   d89f2:	78e3      	ldrb	r3, [r4, #3]
   d89f4:	78a2      	ldrb	r2, [r4, #2]
   d89f6:	9101      	str	r1, [sp, #4]
   d89f8:	7921      	ldrb	r1, [r4, #4]
   d89fa:	9100      	str	r1, [sp, #0]
   d89fc:	a83e      	add	r0, sp, #248	; 0xf8
   d89fe:	4970      	ldr	r1, [pc, #448]	; (d8bc0 <loop+0x8fc>)
   d8a00:	f003 f9f2 	bl	dbde8 <sprintf>
  Nametocard = buffer;
   d8a04:	a93e      	add	r1, sp, #248	; 0xf8
   d8a06:	a806      	add	r0, sp, #24
   d8a08:	f003 fe00 	bl	dc60c <_ZN6StringaSEPKc>

  // On dclanche la prise de photo avec le nom gnr prcdemment
  if(!grabPic(Nametocard)){
   d8a0c:	a906      	add	r1, sp, #24
   d8a0e:	a82b      	add	r0, sp, #172	; 0xac
   d8a10:	f003 fdf1 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8a14:	a82b      	add	r0, sp, #172	; 0xac
   d8a16:	f7fd fb8b 	bl	d6130 <_Z7grabPic6String>
   d8a1a:	4604      	mov	r4, r0
   d8a1c:	a82b      	add	r0, sp, #172	; 0xac
   d8a1e:	f003 fd81 	bl	dc524 <_ZN6StringD1Ev>
   d8a22:	b9f4      	cbnz	r4, d8a62 <loop+0x79e>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8a24:	4967      	ldr	r1, [pc, #412]	; (d8bc4 <loop+0x900>)
   d8a26:	a822      	add	r0, sp, #136	; 0x88
   d8a28:	f003 fdc3 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("GrabPic failed, name of file: " + Nametocard, 1);
   d8a2c:	a906      	add	r1, sp, #24
   d8a2e:	a822      	add	r0, sp, #136	; 0x88
   d8a30:	f003 fe9a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8a34:	4601      	mov	r1, r0
   d8a36:	a82b      	add	r0, sp, #172	; 0xac
   d8a38:	f003 fddd 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8a3c:	2101      	movs	r1, #1
   d8a3e:	a82b      	add	r0, sp, #172	; 0xac
   d8a40:	f7fc faf4 	bl	d502c <_Z3log6Stringi>
   d8a44:	a82b      	add	r0, sp, #172	; 0xac
   d8a46:	f003 fd6d 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8a4a:	a822      	add	r0, sp, #136	; 0x88
   d8a4c:	f003 fd6a 	bl	dc524 <_ZN6StringD1Ev>
    delay(5000);
   d8a50:	f241 3088 	movw	r0, #5000	; 0x1388
   d8a54:	f004 fb72 	bl	dd13c <delay>
    goToSleep(300);
   d8a58:	f44f 7096 	mov.w	r0, #300	; 0x12c
   d8a5c:	f7fd f89c 	bl	d5b98 <_Z9goToSleepl>
    goto loop;
   d8a60:	e2ef      	b.n	d9042 <loop+0xd7e>
  }   

  if((fuel.getVCell()*100) < Batt_low_SP) {
   d8a62:	4859      	ldr	r0, [pc, #356]	; (d8bc8 <loop+0x904>)
   d8a64:	f004 fd08 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d8a68:	eddf 7a58 	vldr	s15, [pc, #352]	; d8bcc <loop+0x908>
   d8a6c:	4b58      	ldr	r3, [pc, #352]	; (d8bd0 <loop+0x90c>)
   d8a6e:	ee20 0a27 	vmul.f32	s0, s0, s15
   d8a72:	edd3 7a00 	vldr	s15, [r3]
   d8a76:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   d8a7a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   d8a7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d8a82:	d533      	bpl.n	d8aec <loop+0x828>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8a84:	4953      	ldr	r1, [pc, #332]	; (d8bd4 <loop+0x910>)
   d8a86:	a822      	add	r0, sp, #136	; 0x88
   d8a88:	f003 fd93 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("Battery Low, waiting for recharge: " + String(fuel.getVCell()) + " V", 1);
   d8a8c:	484e      	ldr	r0, [pc, #312]	; (d8bc8 <loop+0x904>)
   d8a8e:	f004 fcf3 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d8a92:	2106      	movs	r1, #6
   d8a94:	a81e      	add	r0, sp, #120	; 0x78
   d8a96:	f003 fe16 	bl	dc6c6 <_ZN6StringC1Efi>
   d8a9a:	a91e      	add	r1, sp, #120	; 0x78
   d8a9c:	a822      	add	r0, sp, #136	; 0x88
   d8a9e:	f003 fe63 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8aa2:	494d      	ldr	r1, [pc, #308]	; (d8bd8 <loop+0x914>)
   d8aa4:	f003 fe6c 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8aa8:	4601      	mov	r1, r0
   d8aaa:	a82b      	add	r0, sp, #172	; 0xac
   d8aac:	f003 fda3 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8ab0:	2101      	movs	r1, #1
   d8ab2:	a82b      	add	r0, sp, #172	; 0xac
   d8ab4:	f7fc faba 	bl	d502c <_Z3log6Stringi>
   d8ab8:	a82b      	add	r0, sp, #172	; 0xac
   d8aba:	f003 fd33 	bl	dc524 <_ZN6StringD1Ev>
   d8abe:	a81e      	add	r0, sp, #120	; 0x78
   d8ac0:	f003 fd30 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8ac4:	a822      	add	r0, sp, #136	; 0x88
   d8ac6:	f003 fd2d 	bl	dc524 <_ZN6StringD1Ev>
    digitalWrite(Cam_on, LOW);
   d8aca:	2100      	movs	r1, #0
   d8acc:	2013      	movs	r0, #19
   d8ace:	f006 f840 	bl	deb52 <digitalWrite>
    delay(1000);
   d8ad2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8ad6:	f004 fb31 	bl	dd13c <delay>
    goToSleep(3600);
   d8ada:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   d8ade:	f7fd f85b 	bl	d5b98 <_Z9goToSleepl>
    delay(1000);
   d8ae2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8ae6:	f004 fb29 	bl	dd13c <delay>
    goto loop;
   d8aea:	e2aa      	b.n	d9042 <loop+0xd7e>
  }

  // On dclenche la synchronisation FTP de l'image ( dsactiver en cas de mode offline) 
  // 3 essais avant d'abandonner, 5 secondes entre les essais
  if(!offlineMode){
   d8aec:	f898 4000 	ldrb.w	r4, [r8]
   d8af0:	2c00      	cmp	r4, #0
   d8af2:	f040 821d 	bne.w	d8f30 <loop+0xc6c>
    int attempts = 0;
    if(!syncFTP(Nametocard, false,ftp_dir, 0)){
   d8af6:	a906      	add	r1, sp, #24
   d8af8:	a822      	add	r0, sp, #136	; 0x88
   d8afa:	f003 fd7c 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8afe:	4937      	ldr	r1, [pc, #220]	; (d8bdc <loop+0x918>)
   d8b00:	a82b      	add	r0, sp, #172	; 0xac
   d8b02:	f003 fd78 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8b06:	4623      	mov	r3, r4
   d8b08:	4621      	mov	r1, r4
   d8b0a:	aa2b      	add	r2, sp, #172	; 0xac
   d8b0c:	a822      	add	r0, sp, #136	; 0x88
   d8b0e:	f7fc fc93 	bl	d5438 <_Z7syncFTP6StringbS_i>
   d8b12:	4604      	mov	r4, r0
   d8b14:	a82b      	add	r0, sp, #172	; 0xac
   d8b16:	f003 fd05 	bl	dc524 <_ZN6StringD1Ev>
   d8b1a:	a822      	add	r0, sp, #136	; 0x88
   d8b1c:	f003 fd02 	bl	dc524 <_ZN6StringD1Ev>
   d8b20:	2c00      	cmp	r4, #0
   d8b22:	d163      	bne.n	d8bec <loop+0x928>
        log("Isync fail", 2);
   d8b24:	492e      	ldr	r1, [pc, #184]	; (d8be0 <loop+0x91c>)
   d8b26:	a82b      	add	r0, sp, #172	; 0xac
   d8b28:	f003 fd43 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8b2c:	a82b      	add	r0, sp, #172	; 0xac
   d8b2e:	2102      	movs	r1, #2
   d8b30:	f7fc fa7c 	bl	d502c <_Z3log6Stringi>
   d8b34:	a82b      	add	r0, sp, #172	; 0xac
   d8b36:	f003 fcf5 	bl	dc524 <_ZN6StringD1Ev>
        while(!Cellular.ready()){
   d8b3a:	482a      	ldr	r0, [pc, #168]	; (d8be4 <loop+0x920>)
   d8b3c:	f7fc f8be 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d8b40:	b920      	cbnz	r0, d8b4c <loop+0x888>
          delay(1000);
   d8b42:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d8b46:	f004 faf9 	bl	dd13c <delay>
  // 3 essais avant d'abandonner, 5 secondes entre les essais
  if(!offlineMode){
    int attempts = 0;
    if(!syncFTP(Nametocard, false,ftp_dir, 0)){
        log("Isync fail", 2);
        while(!Cellular.ready()){
   d8b4a:	e7f6      	b.n	d8b3a <loop+0x876>
   d8b4c:	4f25      	ldr	r7, [pc, #148]	; (d8be4 <loop+0x920>)
   d8b4e:	2500      	movs	r5, #0
          delay(1000);
        }
        while(!syncFTP(Nametocard, true,ftp_dir, 0) && attempts < 1){
   d8b50:	a906      	add	r1, sp, #24
   d8b52:	a822      	add	r0, sp, #136	; 0x88
   d8b54:	f003 fd4f 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8b58:	4920      	ldr	r1, [pc, #128]	; (d8bdc <loop+0x918>)
   d8b5a:	a82b      	add	r0, sp, #172	; 0xac
   d8b5c:	f003 fd4b 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8b60:	2300      	movs	r3, #0
   d8b62:	aa2b      	add	r2, sp, #172	; 0xac
   d8b64:	2101      	movs	r1, #1
   d8b66:	a822      	add	r0, sp, #136	; 0x88
   d8b68:	f7fc fc66 	bl	d5438 <_Z7syncFTP6StringbS_i>
   d8b6c:	b918      	cbnz	r0, d8b76 <loop+0x8b2>
   d8b6e:	fab5 f485 	clz	r4, r5
   d8b72:	0964      	lsrs	r4, r4, #5
   d8b74:	e000      	b.n	d8b78 <loop+0x8b4>
   d8b76:	2400      	movs	r4, #0
   d8b78:	a82b      	add	r0, sp, #172	; 0xac
   d8b7a:	f003 fcd3 	bl	dc524 <_ZN6StringD1Ev>
   d8b7e:	a822      	add	r0, sp, #136	; 0x88
   d8b80:	f003 fcd0 	bl	dc524 <_ZN6StringD1Ev>
   d8b84:	2c00      	cmp	r4, #0
   d8b86:	d03c      	beq.n	d8c02 <loop+0x93e>
          log("Isync fail again", 2);
   d8b88:	4917      	ldr	r1, [pc, #92]	; (d8be8 <loop+0x924>)
   d8b8a:	a82b      	add	r0, sp, #172	; 0xac
   d8b8c:	f003 fd11 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8b90:	2102      	movs	r1, #2
   d8b92:	a82b      	add	r0, sp, #172	; 0xac
   d8b94:	f7fc fa4a 	bl	d502c <_Z3log6Stringi>
   d8b98:	a82b      	add	r0, sp, #172	; 0xac
   d8b9a:	f003 fcc3 	bl	dc524 <_ZN6StringD1Ev>
          Particle.process();
   d8b9e:	f7fc f983 	bl	d4ea8 <_ZN10CloudClass7processEv>
          attempts++;
   d8ba2:	3501      	adds	r5, #1
    }
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   d8ba4:	2200      	movs	r2, #0
   d8ba6:	4611      	mov	r1, r2
   d8ba8:	6878      	ldr	r0, [r7, #4]
   d8baa:	f003 f865 	bl	dbc78 <network_connecting>
          while(Cellular.connecting()) {
   d8bae:	2800      	cmp	r0, #0
   d8bb0:	d0ce      	beq.n	d8b50 <loop+0x88c>
            delay(500);
   d8bb2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   d8bb6:	f004 fac1 	bl	dd13c <delay>
        }
        while(!syncFTP(Nametocard, true,ftp_dir, 0) && attempts < 1){
          log("Isync fail again", 2);
          Particle.process();
          attempts++;
          while(Cellular.connecting()) {
   d8bba:	e7f3      	b.n	d8ba4 <loop+0x8e0>
   d8bbc:	2003debc 	.word	0x2003debc
   d8bc0:	000e216a 	.word	0x000e216a
   d8bc4:	000e217f 	.word	0x000e217f
   d8bc8:	2003deb4 	.word	0x2003deb4
   d8bcc:	42c80000 	.word	0x42c80000
   d8bd0:	2003d6b8 	.word	0x2003d6b8
   d8bd4:	000e219e 	.word	0x000e219e
   d8bd8:	000e21c2 	.word	0x000e21c2
   d8bdc:	2003dec4 	.word	0x2003dec4
   d8be0:	000e21c5 	.word	0x000e21c5
   d8be4:	2003e4c0 	.word	0x2003e4c0
   d8be8:	000e21d0 	.word	0x000e21d0
            delay(500);
          }
        }
      } else {
        log("ISuc", 4);
   d8bec:	49ab      	ldr	r1, [pc, #684]	; (d8e9c <loop+0xbd8>)
   d8bee:	a82b      	add	r0, sp, #172	; 0xac
   d8bf0:	f003 fcdf 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8bf4:	a82b      	add	r0, sp, #172	; 0xac
   d8bf6:	2104      	movs	r1, #4
   d8bf8:	f7fc fa18 	bl	d502c <_Z3log6Stringi>
   d8bfc:	a82b      	add	r0, sp, #172	; 0xac
   d8bfe:	f003 fc91 	bl	dc524 <_ZN6StringD1Ev>
      }   

    attempts = 0;
    // On dclanche la synchronisation FTP du Log ( dsactiver en cas de mode offline) 3 essais...
    if(!syncFTP(String(monthOfTheYear[now.month()-1]) + String(now.year()) + ".txt", true,"/AutoCamDEH/config/" + BDH, 1)){
   d8c02:	7871      	ldrb	r1, [r6, #1]
   d8c04:	4ca6      	ldr	r4, [pc, #664]	; (d8ea0 <loop+0xbdc>)
   d8c06:	3901      	subs	r1, #1
   d8c08:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   d8c0c:	4421      	add	r1, r4
   d8c0e:	a812      	add	r0, sp, #72	; 0x48
   d8c10:	f003 fccf 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d8c14:	a912      	add	r1, sp, #72	; 0x48
   d8c16:	a81a      	add	r0, sp, #104	; 0x68
   d8c18:	f003 fced 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8c1c:	7831      	ldrb	r1, [r6, #0]
   d8c1e:	4ea1      	ldr	r6, [pc, #644]	; (d8ea4 <loop+0xbe0>)
   d8c20:	220a      	movs	r2, #10
   d8c22:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d8c26:	a816      	add	r0, sp, #88	; 0x58
   d8c28:	f003 fd13 	bl	dc652 <_ZN6StringC1Eih>
   d8c2c:	a916      	add	r1, sp, #88	; 0x58
   d8c2e:	a81a      	add	r0, sp, #104	; 0x68
   d8c30:	f003 fd9a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8c34:	499c      	ldr	r1, [pc, #624]	; (d8ea8 <loop+0xbe4>)
   d8c36:	f003 fda3 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8c3a:	4601      	mov	r1, r0
   d8c3c:	a822      	add	r0, sp, #136	; 0x88
   d8c3e:	f003 fcda 	bl	dc5f6 <_ZN6StringC1ERKS_>
	StringSumHelper(const char *p) : String(p) {}
   d8c42:	499a      	ldr	r1, [pc, #616]	; (d8eac <loop+0xbe8>)
   d8c44:	a81e      	add	r0, sp, #120	; 0x78
   d8c46:	f003 fcb4 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8c4a:	4999      	ldr	r1, [pc, #612]	; (d8eb0 <loop+0xbec>)
   d8c4c:	a81e      	add	r0, sp, #120	; 0x78
   d8c4e:	f003 fd8b 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8c52:	4601      	mov	r1, r0
   d8c54:	a82b      	add	r0, sp, #172	; 0xac
   d8c56:	f003 fcce 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8c5a:	2301      	movs	r3, #1
   d8c5c:	aa2b      	add	r2, sp, #172	; 0xac
   d8c5e:	4619      	mov	r1, r3
   d8c60:	a822      	add	r0, sp, #136	; 0x88
   d8c62:	f7fc fbe9 	bl	d5438 <_Z7syncFTP6StringbS_i>
   d8c66:	4605      	mov	r5, r0
   d8c68:	a82b      	add	r0, sp, #172	; 0xac
   d8c6a:	f003 fc5b 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8c6e:	a81e      	add	r0, sp, #120	; 0x78
   d8c70:	f003 fc58 	bl	dc524 <_ZN6StringD1Ev>
   d8c74:	a822      	add	r0, sp, #136	; 0x88
   d8c76:	f003 fc55 	bl	dc524 <_ZN6StringD1Ev>
   d8c7a:	a816      	add	r0, sp, #88	; 0x58
   d8c7c:	f003 fc52 	bl	dc524 <_ZN6StringD1Ev>
   d8c80:	a81a      	add	r0, sp, #104	; 0x68
   d8c82:	f003 fc4f 	bl	dc524 <_ZN6StringD1Ev>
   d8c86:	a812      	add	r0, sp, #72	; 0x48
   d8c88:	f003 fc4c 	bl	dc524 <_ZN6StringD1Ev>
   d8c8c:	4627      	mov	r7, r4
   d8c8e:	2d00      	cmp	r5, #0
   d8c90:	d16f      	bne.n	d8d72 <loop+0xaae>
        log("Lsync fail", 2);
   d8c92:	4988      	ldr	r1, [pc, #544]	; (d8eb4 <loop+0xbf0>)
   d8c94:	a82b      	add	r0, sp, #172	; 0xac
   d8c96:	f003 fc8c 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8c9a:	2102      	movs	r1, #2
   d8c9c:	a82b      	add	r0, sp, #172	; 0xac
   d8c9e:	f7fc f9c5 	bl	d502c <_Z3log6Stringi>
   d8ca2:	a82b      	add	r0, sp, #172	; 0xac
   d8ca4:	f003 fc3e 	bl	dc524 <_ZN6StringD1Ev>
        delay(5000);
   d8ca8:	f241 3088 	movw	r0, #5000	; 0x1388
   d8cac:	f004 fa46 	bl	dd13c <delay>
        while(!Cellular.ready());
   d8cb0:	4881      	ldr	r0, [pc, #516]	; (d8eb8 <loop+0xbf4>)
   d8cb2:	f7fc f803 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d8cb6:	2800      	cmp	r0, #0
   d8cb8:	d0fa      	beq.n	d8cb0 <loop+0x9ec>
   d8cba:	2500      	movs	r5, #0
        while(!syncFTP(String(monthOfTheYear[now.month()-1]) + String(now.year()) + ".txt", true,"/AutoCamDEH/config/" + BDH, 1) && attempts < 1){
   d8cbc:	7871      	ldrb	r1, [r6, #1]
   d8cbe:	3901      	subs	r1, #1
   d8cc0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   d8cc4:	4439      	add	r1, r7
   d8cc6:	a812      	add	r0, sp, #72	; 0x48
   d8cc8:	f003 fc73 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
{
public:
	StringSumHelper(const String &s) : String(s) {}
   d8ccc:	a912      	add	r1, sp, #72	; 0x48
   d8cce:	a81a      	add	r0, sp, #104	; 0x68
   d8cd0:	f003 fc91 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8cd4:	7831      	ldrb	r1, [r6, #0]
   d8cd6:	220a      	movs	r2, #10
   d8cd8:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d8cdc:	a816      	add	r0, sp, #88	; 0x58
   d8cde:	f003 fcb8 	bl	dc652 <_ZN6StringC1Eih>
   d8ce2:	a916      	add	r1, sp, #88	; 0x58
   d8ce4:	a81a      	add	r0, sp, #104	; 0x68
   d8ce6:	f003 fd3f 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8cea:	496f      	ldr	r1, [pc, #444]	; (d8ea8 <loop+0xbe4>)
   d8cec:	f003 fd48 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d8cf0:	4601      	mov	r1, r0
   d8cf2:	a822      	add	r0, sp, #136	; 0x88
   d8cf4:	f003 fc7f 	bl	dc5f6 <_ZN6StringC1ERKS_>
	StringSumHelper(const char *p) : String(p) {}
   d8cf8:	496c      	ldr	r1, [pc, #432]	; (d8eac <loop+0xbe8>)
   d8cfa:	a81e      	add	r0, sp, #120	; 0x78
   d8cfc:	f003 fc59 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8d00:	496b      	ldr	r1, [pc, #428]	; (d8eb0 <loop+0xbec>)
   d8d02:	a81e      	add	r0, sp, #120	; 0x78
   d8d04:	f003 fd30 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8d08:	4601      	mov	r1, r0
   d8d0a:	a82b      	add	r0, sp, #172	; 0xac
   d8d0c:	f003 fc73 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8d10:	2301      	movs	r3, #1
   d8d12:	aa2b      	add	r2, sp, #172	; 0xac
   d8d14:	4619      	mov	r1, r3
   d8d16:	a822      	add	r0, sp, #136	; 0x88
   d8d18:	f7fc fb8e 	bl	d5438 <_Z7syncFTP6StringbS_i>
   d8d1c:	b918      	cbnz	r0, d8d26 <loop+0xa62>
   d8d1e:	fab5 f485 	clz	r4, r5
   d8d22:	0964      	lsrs	r4, r4, #5
   d8d24:	e000      	b.n	d8d28 <loop+0xa64>
   d8d26:	2400      	movs	r4, #0
   d8d28:	a82b      	add	r0, sp, #172	; 0xac
   d8d2a:	f003 fbfb 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8d2e:	a81e      	add	r0, sp, #120	; 0x78
   d8d30:	f003 fbf8 	bl	dc524 <_ZN6StringD1Ev>
   d8d34:	a822      	add	r0, sp, #136	; 0x88
   d8d36:	f003 fbf5 	bl	dc524 <_ZN6StringD1Ev>
   d8d3a:	a816      	add	r0, sp, #88	; 0x58
   d8d3c:	f003 fbf2 	bl	dc524 <_ZN6StringD1Ev>
   d8d40:	a81a      	add	r0, sp, #104	; 0x68
   d8d42:	f003 fbef 	bl	dc524 <_ZN6StringD1Ev>
   d8d46:	a812      	add	r0, sp, #72	; 0x48
   d8d48:	f003 fbec 	bl	dc524 <_ZN6StringD1Ev>
   d8d4c:	b1ec      	cbz	r4, d8d8a <loop+0xac6>
          log("Lsync fail again", 2);
   d8d4e:	495b      	ldr	r1, [pc, #364]	; (d8ebc <loop+0xbf8>)
   d8d50:	a82b      	add	r0, sp, #172	; 0xac
   d8d52:	f003 fc2e 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8d56:	2102      	movs	r1, #2
   d8d58:	a82b      	add	r0, sp, #172	; 0xac
   d8d5a:	f7fc f967 	bl	d502c <_Z3log6Stringi>
   d8d5e:	a82b      	add	r0, sp, #172	; 0xac
   d8d60:	f003 fbe0 	bl	dc524 <_ZN6StringD1Ev>
          attempts++;
   d8d64:	3501      	adds	r5, #1
          while(!Cellular.ready());
   d8d66:	4854      	ldr	r0, [pc, #336]	; (d8eb8 <loop+0xbf4>)
   d8d68:	f7fb ffa8 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d8d6c:	2800      	cmp	r0, #0
   d8d6e:	d0fa      	beq.n	d8d66 <loop+0xaa2>
   d8d70:	e7a4      	b.n	d8cbc <loop+0x9f8>
        }
      } else {
        log("LSuc", 4);
   d8d72:	4953      	ldr	r1, [pc, #332]	; (d8ec0 <loop+0xbfc>)
   d8d74:	a82b      	add	r0, sp, #172	; 0xac
   d8d76:	f003 fc1c 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8d7a:	2104      	movs	r1, #4
   d8d7c:	a82b      	add	r0, sp, #172	; 0xac
   d8d7e:	f7fc f955 	bl	d502c <_Z3log6Stringi>
   d8d82:	a82b      	add	r0, sp, #172	; 0xac
   d8d84:	f003 fbce 	bl	dc524 <_ZN6StringD1Ev>
        attempts = 0;
   d8d88:	2500      	movs	r5, #0
      }   
    sprintf(buffer,"%s/%d/%d/temp/",stationName.c_str(),now.year(), now.month());
   d8d8a:	7872      	ldrb	r2, [r6, #1]
   d8d8c:	7833      	ldrb	r3, [r6, #0]
   d8d8e:	9200      	str	r2, [sp, #0]
   d8d90:	4a4c      	ldr	r2, [pc, #304]	; (d8ec4 <loop+0xc00>)
   d8d92:	494d      	ldr	r1, [pc, #308]	; (d8ec8 <loop+0xc04>)
   d8d94:	6812      	ldr	r2, [r2, #0]
   d8d96:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
   d8d9a:	a83e      	add	r0, sp, #248	; 0xf8
   d8d9c:	f003 f824 	bl	dbde8 <sprintf>
    Serial.println("looking for: " + String(buffer));
   d8da0:	f005 f87e 	bl	ddea0 <_Z16_fetch_usbserialv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8da4:	4949      	ldr	r1, [pc, #292]	; (d8ecc <loop+0xc08>)
   d8da6:	4604      	mov	r4, r0
   d8da8:	a82b      	add	r0, sp, #172	; 0xac
   d8daa:	f003 fc02 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8dae:	a93e      	add	r1, sp, #248	; 0xf8
   d8db0:	a822      	add	r0, sp, #136	; 0x88
   d8db2:	f003 fbfe 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8db6:	a922      	add	r1, sp, #136	; 0x88
   d8db8:	a82b      	add	r0, sp, #172	; 0xac
   d8dba:	f003 fcd5 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8dbe:	6801      	ldr	r1, [r0, #0]
   d8dc0:	4620      	mov	r0, r4
   d8dc2:	f004 f852 	bl	dce6a <_ZN5Print7printlnEPKc>
   d8dc6:	a822      	add	r0, sp, #136	; 0x88
   d8dc8:	f003 fbac 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8dcc:	a82b      	add	r0, sp, #172	; 0xac
   d8dce:	f003 fba9 	bl	dc524 <_ZN6StringD1Ev>
    if(SD.exists(buffer)) {
   d8dd2:	a93e      	add	r1, sp, #248	; 0xf8
   d8dd4:	483e      	ldr	r0, [pc, #248]	; (d8ed0 <loop+0xc0c>)
   d8dd6:	f002 fbc9 	bl	db56c <_ZN5SDLib7SDClass6existsEPKc>
   d8dda:	2800      	cmp	r0, #0
   d8ddc:	f000 809b 	beq.w	d8f16 <loop+0xc52>
      Serial.println("folder temp exists");
   d8de0:	f005 f85e 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8de4:	493b      	ldr	r1, [pc, #236]	; (d8ed4 <loop+0xc10>)
   d8de6:	f004 f840 	bl	dce6a <_ZN5Print7printlnEPKc>
      root = SD.open(buffer);
   d8dea:	aa3e      	add	r2, sp, #248	; 0xf8
   d8dec:	2301      	movs	r3, #1
   d8dee:	4938      	ldr	r1, [pc, #224]	; (d8ed0 <loop+0xc0c>)
   d8df0:	a82b      	add	r0, sp, #172	; 0xac
   d8df2:	f002 fb77 	bl	db4e4 <_ZN5SDLib7SDClass4openEPKch>
   d8df6:	a92b      	add	r1, sp, #172	; 0xac
   d8df8:	4837      	ldr	r0, [pc, #220]	; (d8ed8 <loop+0xc14>)
   d8dfa:	f7fc f901 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
      File BuPic = root.openNextFile();
   d8dfe:	2201      	movs	r2, #1
   d8e00:	4935      	ldr	r1, [pc, #212]	; (d8ed8 <loop+0xc14>)
   d8e02:	a822      	add	r0, sp, #136	; 0x88
   d8e04:	f002 fbea 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
      while(BuPic && !BuPic.isDirectory()){
   d8e08:	a822      	add	r0, sp, #136	; 0x88
   d8e0a:	f001 fc89 	bl	da720 <_ZN5SDLib4FilecvbEv>
   d8e0e:	2800      	cmp	r0, #0
   d8e10:	f000 8182 	beq.w	d9118 <loop+0xe54>
   d8e14:	a822      	add	r0, sp, #136	; 0x88
   d8e16:	f001 fc4b 	bl	da6b0 <_ZN5SDLib4File11isDirectoryEv>
   d8e1a:	2800      	cmp	r0, #0
   d8e1c:	f040 817c 	bne.w	d9118 <loop+0xe54>
        Nametocard = BuPic.name() ;
   d8e20:	a822      	add	r0, sp, #136	; 0x88
   d8e22:	f001 fc43 	bl	da6ac <_ZN5SDLib4File4nameEv>
   d8e26:	4601      	mov	r1, r0
   d8e28:	a806      	add	r0, sp, #24
   d8e2a:	f003 fbef 	bl	dc60c <_ZN6StringaSEPKc>
        Serial.println("Name of offline pic: " + Nametocard);
   d8e2e:	f005 f837 	bl	ddea0 <_Z16_fetch_usbserialv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8e32:	492a      	ldr	r1, [pc, #168]	; (d8edc <loop+0xc18>)
   d8e34:	4604      	mov	r4, r0
   d8e36:	a82b      	add	r0, sp, #172	; 0xac
   d8e38:	f003 fbbb 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d8e3c:	a906      	add	r1, sp, #24
   d8e3e:	a82b      	add	r0, sp, #172	; 0xac
   d8e40:	f003 fc92 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d8e44:	6801      	ldr	r1, [r0, #0]
   d8e46:	4620      	mov	r0, r4
   d8e48:	f004 f80f 	bl	dce6a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8e4c:	a82b      	add	r0, sp, #172	; 0xac
   d8e4e:	f003 fb69 	bl	dc524 <_ZN6StringD1Ev>
        BuPic.close();
   d8e52:	a822      	add	r0, sp, #136	; 0x88
   d8e54:	f001 fc58 	bl	da708 <_ZN5SDLib4File5closeEv>
        while(!syncFTP(Nametocard,false,ftp_dir,2) && attempts < 1) {
   d8e58:	a906      	add	r1, sp, #24
   d8e5a:	a81e      	add	r0, sp, #120	; 0x78
   d8e5c:	f003 fbcb 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8e60:	491f      	ldr	r1, [pc, #124]	; (d8ee0 <loop+0xc1c>)
   d8e62:	a82b      	add	r0, sp, #172	; 0xac
   d8e64:	f003 fbc7 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d8e68:	2302      	movs	r3, #2
   d8e6a:	aa2b      	add	r2, sp, #172	; 0xac
   d8e6c:	2100      	movs	r1, #0
   d8e6e:	a81e      	add	r0, sp, #120	; 0x78
   d8e70:	f7fc fae2 	bl	d5438 <_Z7syncFTP6StringbS_i>
   d8e74:	b918      	cbnz	r0, d8e7e <loop+0xbba>
   d8e76:	fab5 f485 	clz	r4, r5
   d8e7a:	0964      	lsrs	r4, r4, #5
   d8e7c:	e000      	b.n	d8e80 <loop+0xbbc>
   d8e7e:	2400      	movs	r4, #0
   d8e80:	a82b      	add	r0, sp, #172	; 0xac
   d8e82:	f003 fb4f 	bl	dc524 <_ZN6StringD1Ev>
   d8e86:	a81e      	add	r0, sp, #120	; 0x78
   d8e88:	f003 fb4c 	bl	dc524 <_ZN6StringD1Ev>
   d8e8c:	b354      	cbz	r4, d8ee4 <loop+0xc20>
          attempts++;
   d8e8e:	3501      	adds	r5, #1
          while(!Cellular.ready());
   d8e90:	4809      	ldr	r0, [pc, #36]	; (d8eb8 <loop+0xbf4>)
   d8e92:	f7fb ff13 	bl	d4cbc <_ZN5spark13CellularClass5readyEv>
   d8e96:	2800      	cmp	r0, #0
   d8e98:	d0fa      	beq.n	d8e90 <loop+0xbcc>
   d8e9a:	e7dd      	b.n	d8e58 <loop+0xb94>
   d8e9c:	000e21e1 	.word	0x000e21e1
   d8ea0:	2003d780 	.word	0x2003d780
   d8ea4:	2003debc 	.word	0x2003debc
   d8ea8:	000e21e6 	.word	0x000e21e6
   d8eac:	000e2036 	.word	0x000e2036
   d8eb0:	2003df78 	.word	0x2003df78
   d8eb4:	000e21eb 	.word	0x000e21eb
   d8eb8:	2003e4c0 	.word	0x2003e4c0
   d8ebc:	000e21f6 	.word	0x000e21f6
   d8ec0:	000e2207 	.word	0x000e2207
   d8ec4:	2003dea4 	.word	0x2003dea4
   d8ec8:	000e220c 	.word	0x000e220c
   d8ecc:	000e221b 	.word	0x000e221b
   d8ed0:	2003e3d4 	.word	0x2003e3d4
   d8ed4:	000e2229 	.word	0x000e2229
   d8ed8:	2003dd1c 	.word	0x2003dd1c
   d8edc:	000e2285 	.word	0x000e2285
   d8ee0:	2003dec4 	.word	0x2003dec4
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8ee4:	a93e      	add	r1, sp, #248	; 0xf8
   d8ee6:	a82b      	add	r0, sp, #172	; 0xac
   d8ee8:	f003 fb63 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
        }
        SD.remove(buffer + Nametocard);
   d8eec:	a906      	add	r1, sp, #24
   d8eee:	a82b      	add	r0, sp, #172	; 0xac
   d8ef0:	f003 fc3a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
      }

      // Delete the file.
      bool remove(const char *filepath);
      bool remove(const String &filepath) {
        return remove(filepath.c_str());
   d8ef4:	6801      	ldr	r1, [r0, #0]
   d8ef6:	489a      	ldr	r0, [pc, #616]	; (d9160 <loop+0xe9c>)
   d8ef8:	f002 fb62 	bl	db5c0 <_ZN5SDLib7SDClass6removeEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d8efc:	a82b      	add	r0, sp, #172	; 0xac
   d8efe:	f003 fb11 	bl	dc524 <_ZN6StringD1Ev>
        BuPic = root.openNextFile();
   d8f02:	a82b      	add	r0, sp, #172	; 0xac
   d8f04:	2201      	movs	r2, #1
   d8f06:	4997      	ldr	r1, [pc, #604]	; (d9164 <loop+0xea0>)
   d8f08:	f002 fb68 	bl	db5dc <_ZN5SDLib4File12openNextFileEh>
   d8f0c:	a92b      	add	r1, sp, #172	; 0xac
   d8f0e:	a822      	add	r0, sp, #136	; 0x88
   d8f10:	f7fc f876 	bl	d5000 <_ZN5SDLib4FileaSEOS0_>
    Serial.println("looking for: " + String(buffer));
    if(SD.exists(buffer)) {
      Serial.println("folder temp exists");
      root = SD.open(buffer);
      File BuPic = root.openNextFile();
      while(BuPic && !BuPic.isDirectory()){
   d8f14:	e778      	b.n	d8e08 <loop+0xb44>
      root.close();
      Serial.println("Backup Pic dump Done");
      SD.rmdir(buffer);
    } else {

      Serial.println("folder temp doesn't exists");
   d8f16:	f004 ffc3 	bl	ddea0 <_Z16_fetch_usbserialv>
   d8f1a:	4993      	ldr	r1, [pc, #588]	; (d9168 <loop+0xea4>)
   d8f1c:	f003 ffa5 	bl	dce6a <_ZN5Print7printlnEPKc>
    }
    Particle.publish("status", "Sleeping");
   d8f20:	a82b      	add	r0, sp, #172	; 0xac
   d8f22:	4a92      	ldr	r2, [pc, #584]	; (d916c <loop+0xea8>)
   d8f24:	4992      	ldr	r1, [pc, #584]	; (d9170 <loop+0xeac>)
   d8f26:	f7fb fea7 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d8f2a:	a82c      	add	r0, sp, #176	; 0xb0
   d8f2c:	f7fc fe6e 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
  }   

  
  // prlvement de l'heure actuelle pour calculer le nombre de secondes pour "dormir"
  now = rtc.now();
   d8f30:	a82b      	add	r0, sp, #172	; 0xac
   d8f32:	4d90      	ldr	r5, [pc, #576]	; (d9174 <loop+0xeb0>)
   d8f34:	f002 f873 	bl	db01e <_ZN7PCF85233nowEv>
   d8f38:	982b      	ldr	r0, [sp, #172]	; 0xac
   d8f3a:	f8bd 30b0 	ldrh.w	r3, [sp, #176]	; 0xb0
   d8f3e:	6028      	str	r0, [r5, #0]
  rtc.clear_rtc_interrupt_flags();
   d8f40:	488d      	ldr	r0, [pc, #564]	; (d9178 <loop+0xeb4>)
    Particle.publish("status", "Sleeping");
  }   

  
  // prlvement de l'heure actuelle pour calculer le nombre de secondes pour "dormir"
  now = rtc.now();
   d8f42:	80ab      	strh	r3, [r5, #4]
  rtc.clear_rtc_interrupt_flags();
   d8f44:	f002 f93d 	bl	db1c2 <_ZN7PCF852325clear_rtc_interrupt_flagsEv>
  int secsToWakeup = 0;


  // 3 modes d'acquisitions
  
  switch (captureMode)
   d8f48:	4b8c      	ldr	r3, [pc, #560]	; (d917c <loop+0xeb8>)
   d8f4a:	6818      	ldr	r0, [r3, #0]
   d8f4c:	2801      	cmp	r0, #1
   d8f4e:	d015      	beq.n	d8f7c <loop+0xcb8>
   d8f50:	2802      	cmp	r0, #2
   d8f52:	d02d      	beq.n	d8fb0 <loop+0xcec>
   d8f54:	2800      	cmp	r0, #0
   d8f56:	d146      	bne.n	d8fe6 <loop+0xd22>
   d8f58:	78ec      	ldrb	r4, [r5, #3]
   d8f5a:	78ab      	ldrb	r3, [r5, #2]
   d8f5c:	786a      	ldrb	r2, [r5, #1]
   d8f5e:	7829      	ldrb	r1, [r5, #0]
  {
  case 0: //3 img/jour
    if(7 <= now.hour() && now.hour() < 11) {
   d8f60:	2c06      	cmp	r4, #6
   d8f62:	d907      	bls.n	d8f74 <loop+0xcb0>
   d8f64:	2c0a      	cmp	r4, #10
   d8f66:	f240 80e4 	bls.w	d9132 <loop+0xe6e>
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), 11, 0, 0));
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }
    else if(11 <= now.hour() && now.hour() < 15) {
   d8f6a:	2c0e      	cmp	r4, #14
   d8f6c:	f240 80e5 	bls.w	d913a <loop+0xe76>
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), 15, 0, 0));
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }
    else if(15 <= now.hour()) {
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day()+1, 7, 0, 0));
   d8f70:	3301      	adds	r3, #1
   d8f72:	e017      	b.n	d8fa4 <loop+0xce0>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }
    else if(now.hour() < 7) {
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), 7, 0, 0));
   d8f74:	9002      	str	r0, [sp, #8]
   d8f76:	9001      	str	r0, [sp, #4]
   d8f78:	2007      	movs	r0, #7
   d8f7a:	e0e1      	b.n	d9140 <loop+0xe7c>
   d8f7c:	78e8      	ldrb	r0, [r5, #3]
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }      
    break;

  case 1: //12 img/jour
    if(7 <= now.hour() && now.hour() < 18) {
   d8f7e:	1fc3      	subs	r3, r0, #7
   d8f80:	2b0a      	cmp	r3, #10
   d8f82:	d808      	bhi.n	d8f96 <loop+0xcd2>
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), now.hour()+1, 0, 0));
   d8f84:	2400      	movs	r4, #0
   d8f86:	3001      	adds	r0, #1
   d8f88:	78ab      	ldrb	r3, [r5, #2]
   d8f8a:	786a      	ldrb	r2, [r5, #1]
   d8f8c:	7829      	ldrb	r1, [r5, #0]
   d8f8e:	9402      	str	r4, [sp, #8]
   d8f90:	9401      	str	r4, [sp, #4]
   d8f92:	b2c0      	uxtb	r0, r0
   d8f94:	e0d4      	b.n	d9140 <loop+0xe7c>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      } 
    else if (18 >= now.hour()) {
   d8f96:	2812      	cmp	r0, #18
   d8f98:	d825      	bhi.n	d8fe6 <loop+0xd22>
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day()+1, 7, 0, 0));
   d8f9a:	78ab      	ldrb	r3, [r5, #2]
   d8f9c:	786a      	ldrb	r2, [r5, #1]
   d8f9e:	7829      	ldrb	r1, [r5, #0]
   d8fa0:	3301      	adds	r3, #1
   d8fa2:	2000      	movs	r0, #0
   d8fa4:	9002      	str	r0, [sp, #8]
   d8fa6:	9001      	str	r0, [sp, #4]
   d8fa8:	2007      	movs	r0, #7
   d8faa:	9000      	str	r0, [sp, #0]
   d8fac:	b2db      	uxtb	r3, r3
   d8fae:	e0c8      	b.n	d9142 <loop+0xe7e>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }
 
    break; 
  case 2: //24 img/jour
        DateTime wakeupTime(DateTime(now.year(),now.month(),now.day(),now.hour(),0,0) + TimeSpan(0,1,0,0));
   d8fb0:	2400      	movs	r4, #0
   d8fb2:	78ab      	ldrb	r3, [r5, #2]
   d8fb4:	786a      	ldrb	r2, [r5, #1]
   d8fb6:	7829      	ldrb	r1, [r5, #0]
   d8fb8:	9402      	str	r4, [sp, #8]
   d8fba:	9401      	str	r4, [sp, #4]
   d8fbc:	78e8      	ldrb	r0, [r5, #3]
   d8fbe:	9000      	str	r0, [sp, #0]
   d8fc0:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d8fc4:	a82b      	add	r0, sp, #172	; 0xac
   d8fc6:	f001 fedd 	bl	dad84 <_ZN8DateTimeC1Ethhhhh>
   d8fca:	4623      	mov	r3, r4
   d8fcc:	2201      	movs	r2, #1
   d8fce:	4621      	mov	r1, r4
   d8fd0:	9400      	str	r4, [sp, #0]
   d8fd2:	a81e      	add	r0, sp, #120	; 0x78
   d8fd4:	f001 ff84 	bl	daee0 <_ZN8TimeSpanC1Esaaa>
   d8fd8:	a822      	add	r0, sp, #136	; 0x88
   d8fda:	aa1e      	add	r2, sp, #120	; 0x78
   d8fdc:	a92b      	add	r1, sp, #172	; 0xac
   d8fde:	f001 ff72 	bl	daec6 <_ZN8DateTimeplERK8TimeSpan>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();    
   d8fe2:	a822      	add	r0, sp, #136	; 0x88
   d8fe4:	e0b3      	b.n	d914e <loop+0xe8a>

  
  // prlvement de l'heure actuelle pour calculer le nombre de secondes pour "dormir"
  now = rtc.now();
  rtc.clear_rtc_interrupt_flags();
  int secsToWakeup = 0;
   d8fe6:	2400      	movs	r4, #0
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d8fe8:	4965      	ldr	r1, [pc, #404]	; (d9180 <loop+0xebc>)
   d8fea:	a822      	add	r0, sp, #136	; 0x88
   d8fec:	f003 fae1 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  Serial.print(buf[2]);      
  Serial.println(" day, ");  
  */     
 

  log("S " + String(secsToWakeup), 4);
   d8ff0:	220a      	movs	r2, #10
   d8ff2:	4621      	mov	r1, r4
   d8ff4:	a81e      	add	r0, sp, #120	; 0x78
   d8ff6:	f003 fb2c 	bl	dc652 <_ZN6StringC1Eih>
   d8ffa:	a91e      	add	r1, sp, #120	; 0x78
   d8ffc:	a822      	add	r0, sp, #136	; 0x88
   d8ffe:	f003 fbb3 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d9002:	4601      	mov	r1, r0
   d9004:	a82b      	add	r0, sp, #172	; 0xac
   d9006:	f003 faf6 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d900a:	2104      	movs	r1, #4
   d900c:	a82b      	add	r0, sp, #172	; 0xac
   d900e:	f7fc f80d 	bl	d502c <_Z3log6Stringi>
   d9012:	a82b      	add	r0, sp, #172	; 0xac
   d9014:	f003 fa86 	bl	dc524 <_ZN6StringD1Ev>
   d9018:	a81e      	add	r0, sp, #120	; 0x78
   d901a:	f003 fa83 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d901e:	a822      	add	r0, sp, #136	; 0x88
   d9020:	f003 fa80 	bl	dc524 <_ZN6StringD1Ev>
  // On dort pour le nombre prdtermin de secondes. 
  // On peut aussi le repartir avec un front descendant sur la pin D8, 
  // possible ajout d'un bouton de prise d'Image?
  goToSleep(secsToWakeup);
   d9024:	4620      	mov	r0, r4
   d9026:	f7fc fdb7 	bl	d5b98 <_Z9goToSleepl>
  thatTook =  (millis() - previousMillis)/1000;
  log("TT " + String(thatTook), 4);

  // On obtient le niveau de batterie et de signal cell pour le log
  String SOC = String(fuel.getSoC());
  String VCell = String(fuel.getVCell());
   d902a:	a80e      	add	r0, sp, #56	; 0x38
   d902c:	f003 fa7a 	bl	dc524 <_ZN6StringD1Ev>
  // Dcompte du temps de connection en secondes
  thatTook =  (millis() - previousMillis)/1000;
  log("TT " + String(thatTook), 4);

  // On obtient le niveau de batterie et de signal cell pour le log
  String SOC = String(fuel.getSoC());
   d9030:	a80a      	add	r0, sp, #40	; 0x28
   d9032:	f003 fa77 	bl	dc524 <_ZN6StringD1Ev>
  loop:
  //Cellular.on();
  //Particle.connect();
  int secstoTimeout = timeout;
  int SSButton_longpress = 0;
  String Nametocard;
   d9036:	a806      	add	r0, sp, #24
   d9038:	f003 fa74 	bl	dc524 <_ZN6StringD1Ev>
  // possible ajout d'un bouton de prise d'Image?
  goToSleep(secsToWakeup);
  //goToSleep(30);
  //System.sleep(SLEEP_MODE_DEEP);
  //System.reset();
}
   d903c:	b049      	add	sp, #292	; 0x124
   d903e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d9042:	a80e      	add	r0, sp, #56	; 0x38
   d9044:	f003 fa6e 	bl	dc524 <_ZN6StringD1Ev>
   d9048:	a80a      	add	r0, sp, #40	; 0x28
   d904a:	f003 fa6b 	bl	dc524 <_ZN6StringD1Ev>
      delay(5000);
      digitalWrite(statusLed, LOW);
      delay(1000);
      System.sleep(SS_Button, FALLING, 1500);
      delay(1000);
      goto loop;
   d904e:	a806      	add	r0, sp, #24
   d9050:	f003 fa68 	bl	dc524 <_ZN6StringD1Ev>
   d9054:	f7ff b93b 	b.w	d82ce <loop+0xa>
        delay(500);
        secstoTimeout--;
      }

      // Si on a reu confirmation avant la fin du timeout, on synchronise l'horloge interne avec la RTC
      if(secstoTimeout >= 170 && Time.isValid()) {
   d9058:	2ea9      	cmp	r6, #169	; 0xa9
   d905a:	dd36      	ble.n	d90ca <loop+0xe06>
   d905c:	f004 f802 	bl	dd064 <_ZN9TimeClass7isValidEv>
   d9060:	2800      	cmp	r0, #0
   d9062:	d032      	beq.n	d90ca <loop+0xe06>
        rtc.adjust(DateTime(Time.year(), Time.month(), Time.day(), Time.hour(), Time.minute(), Time.second()));
   d9064:	f004 f856 	bl	dd114 <_ZN9TimeClass4yearEv>
   d9068:	4681      	mov	r9, r0
   d906a:	f004 f84b 	bl	dd104 <_ZN9TimeClass5monthEv>
   d906e:	4682      	mov	sl, r0
   d9070:	f004 f83e 	bl	dd0f0 <_ZN9TimeClass3dayEv>
   d9074:	4683      	mov	fp, r0
   d9076:	f004 f81d 	bl	dd0b4 <_ZN9TimeClass4hourEv>
   d907a:	4604      	mov	r4, r0
   d907c:	f004 f824 	bl	dd0c8 <_ZN9TimeClass6minuteEv>
   d9080:	4606      	mov	r6, r0
   d9082:	f004 f82b 	bl	dd0dc <_ZN9TimeClass6secondEv>
   d9086:	b2f6      	uxtb	r6, r6
   d9088:	b2c0      	uxtb	r0, r0
   d908a:	b2e4      	uxtb	r4, r4
   d908c:	fa5f f38b 	uxtb.w	r3, fp
   d9090:	fa5f f28a 	uxtb.w	r2, sl
   d9094:	fa1f f189 	uxth.w	r1, r9
   d9098:	9002      	str	r0, [sp, #8]
   d909a:	9601      	str	r6, [sp, #4]
   d909c:	9400      	str	r4, [sp, #0]
   d909e:	a83e      	add	r0, sp, #248	; 0xf8
   d90a0:	f001 fe70 	bl	dad84 <_ZN8DateTimeC1Ethhhhh>
   d90a4:	a83e      	add	r0, sp, #248	; 0xf8
   d90a6:	f001 ff4e 	bl	daf46 <_ZN7PCF85236adjustERK8DateTime>
        Particle.syncTimeDone();
   d90aa:	f7fb fdd2 	bl	d4c52 <_ZN10CloudClass12syncTimeDoneEv.isra.14>
        Particle.publish("Status","Time Synced!");
   d90ae:	4a35      	ldr	r2, [pc, #212]	; (d9184 <loop+0xec0>)
   d90b0:	4935      	ldr	r1, [pc, #212]	; (d9188 <loop+0xec4>)
   d90b2:	a83e      	add	r0, sp, #248	; 0xf8
   d90b4:	f7fb fde0 	bl	d4c78 <_ZN10CloudClass7publishEPKcS1_.isra.42>
   d90b8:	a83f      	add	r0, sp, #252	; 0xfc
   d90ba:	f7fc fda7 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        log("TSync", 4);
   d90be:	4933      	ldr	r1, [pc, #204]	; (d918c <loop+0xec8>)
   d90c0:	a83e      	add	r0, sp, #248	; 0xf8
   d90c2:	f003 fa76 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d90c6:	2104      	movs	r1, #4
   d90c8:	e004      	b.n	d90d4 <loop+0xe10>
      } else {
        log("Time Sync failed!", 2);
   d90ca:	4931      	ldr	r1, [pc, #196]	; (d9190 <loop+0xecc>)
   d90cc:	a83e      	add	r0, sp, #248	; 0xf8
   d90ce:	f003 fa70 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d90d2:	2102      	movs	r1, #2
   d90d4:	a83e      	add	r0, sp, #248	; 0xf8
   d90d6:	f7fb ffa9 	bl	d502c <_Z3log6Stringi>
   d90da:	a83e      	add	r0, sp, #248	; 0xf8
   d90dc:	f003 fa22 	bl	dc524 <_ZN6StringD1Ev>
      }
      secstoTimeout = timeout;
   d90e0:	682c      	ldr	r4, [r5, #0]
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
   d90e2:	492c      	ldr	r1, [pc, #176]	; (d9194 <loop+0xed0>)
   d90e4:	482c      	ldr	r0, [pc, #176]	; (d9198 <loop+0xed4>)
   d90e6:	f003 fb5d 	bl	dc7a4 <_ZNK6String6equalsEPKc>

      // On attends de recevoir les infos du cloud
      while(stationName == "undef" && secstoTimeout > 0){
   d90ea:	2800      	cmp	r0, #0
   d90ec:	f43f ab62 	beq.w	d87b4 <loop+0x4f0>
   d90f0:	2c00      	cmp	r4, #0
   d90f2:	f77f ab5f 	ble.w	d87b4 <loop+0x4f0>
        delay(1000);
   d90f6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d90fa:	f004 f81f 	bl	dd13c <delay>
        secstoTimeout--;
   d90fe:	3c01      	subs	r4, #1
        log("Time Sync failed!", 2);
      }
      secstoTimeout = timeout;

      // On attends de recevoir les infos du cloud
      while(stationName == "undef" && secstoTimeout > 0){
   d9100:	e7ef      	b.n	d90e2 <loop+0xe1e>
  Serial.print(String(now.second()));
  Serial.println();
  char buffer[40];

  if (now.day() == 1 && now.hour() == 15) {
    cleanSD("");
   d9102:	4926      	ldr	r1, [pc, #152]	; (d919c <loop+0xed8>)
   d9104:	a83e      	add	r0, sp, #248	; 0xf8
   d9106:	f003 fa54 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d910a:	a83e      	add	r0, sp, #248	; 0xf8
   d910c:	f7fc fd94 	bl	d5c38 <_Z7cleanSD6String>
   d9110:	a83e      	add	r0, sp, #248	; 0xf8
   d9112:	f003 fa07 	bl	dc524 <_ZN6StringD1Ev>
   d9116:	e46b      	b.n	d89f0 <loop+0x72c>
          while(!Cellular.ready());
        }
        SD.remove(buffer + Nametocard);
        BuPic = root.openNextFile();
      }
      root.close();
   d9118:	4812      	ldr	r0, [pc, #72]	; (d9164 <loop+0xea0>)
   d911a:	f001 faf5 	bl	da708 <_ZN5SDLib4File5closeEv>
      Serial.println("Backup Pic dump Done");
   d911e:	f004 febf 	bl	ddea0 <_Z16_fetch_usbserialv>
   d9122:	491f      	ldr	r1, [pc, #124]	; (d91a0 <loop+0xedc>)
   d9124:	f003 fea1 	bl	dce6a <_ZN5Print7printlnEPKc>
      SD.rmdir(buffer);
   d9128:	a93e      	add	r1, sp, #248	; 0xf8
   d912a:	480d      	ldr	r0, [pc, #52]	; (d9160 <loop+0xe9c>)
   d912c:	f002 fa3a 	bl	db5a4 <_ZN5SDLib7SDClass5rmdirEPKc>
   d9130:	e6f6      	b.n	d8f20 <loop+0xc5c>
  
  switch (captureMode)
  {
  case 0: //3 img/jour
    if(7 <= now.hour() && now.hour() < 11) {
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), 11, 0, 0));
   d9132:	9002      	str	r0, [sp, #8]
   d9134:	9001      	str	r0, [sp, #4]
   d9136:	200b      	movs	r0, #11
   d9138:	e002      	b.n	d9140 <loop+0xe7c>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
      }
    else if(11 <= now.hour() && now.hour() < 15) {
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), 15, 0, 0));
   d913a:	9002      	str	r0, [sp, #8]
   d913c:	9001      	str	r0, [sp, #4]
   d913e:	200f      	movs	r0, #15
      }      
    break;

  case 1: //12 img/jour
    if(7 <= now.hour() && now.hour() < 18) {
        DateTime wakeupTime(DateTime(now.year(), now.month(), now.day(), now.hour()+1, 0, 0));
   d9140:	9000      	str	r0, [sp, #0]
   d9142:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
   d9146:	a82b      	add	r0, sp, #172	; 0xac
   d9148:	f001 fe1c 	bl	dad84 <_ZN8DateTimeC1Ethhhhh>
        secsToWakeup = wakeupTime.secondstime() - now.secondstime();
   d914c:	a82b      	add	r0, sp, #172	; 0xac
   d914e:	f001 fea7 	bl	daea0 <_ZNK8DateTime11secondstimeEv>
   d9152:	4604      	mov	r4, r0
   d9154:	4628      	mov	r0, r5
   d9156:	f001 fea3 	bl	daea0 <_ZNK8DateTime11secondstimeEv>
   d915a:	1a24      	subs	r4, r4, r0
   d915c:	e744      	b.n	d8fe8 <loop+0xd24>
   d915e:	bf00      	nop
   d9160:	2003e3d4 	.word	0x2003e3d4
   d9164:	2003dd1c 	.word	0x2003dd1c
   d9168:	000e223c 	.word	0x000e223c
   d916c:	000e2257 	.word	0x000e2257
   d9170:	000e1dcc 	.word	0x000e1dcc
   d9174:	2003debc 	.word	0x2003debc
   d9178:	2003dea0 	.word	0x2003dea0
   d917c:	2003de94 	.word	0x2003de94
   d9180:	000e23ad 	.word	0x000e23ad
   d9184:	000e2260 	.word	0x000e2260
   d9188:	000e1fca 	.word	0x000e1fca
   d918c:	000e226d 	.word	0x000e226d
   d9190:	000e2273 	.word	0x000e2273
   d9194:	000e2164 	.word	0x000e2164
   d9198:	2003dea4 	.word	0x2003dea4
   d919c:	000e1eea 	.word	0x000e1eea
   d91a0:	000e229b 	.word	0x000e229b

000d91a4 <setup>:

/* 
* Fonction d'initialisation qui s'excute une seule fois au dmarrage de l'appareil
* V1.1 2019-12-17 
*/
void setup() { 
   d91a4:	b510      	push	{r4, lr}
  //On configure les variables, fonctions et souscriptions disponibles 
  // dans le cloud ainsi que d'autres paramtres
  //Particle.keepAlive(120);
  Cellular.on();
   d91a6:	4887      	ldr	r0, [pc, #540]	; (d93c4 <setup+0x220>)

/* 
* Fonction d'initialisation qui s'excute une seule fois au dmarrage de l'appareil
* V1.1 2019-12-17 
*/
void setup() { 
   d91a8:	b08e      	sub	sp, #56	; 0x38
  //On configure les variables, fonctions et souscriptions disponibles 
  // dans le cloud ainsi que d'autres paramtres
  //Particle.keepAlive(120);
  Cellular.on();
   d91aa:	f7fb fd7b 	bl	d4ca4 <_ZN5spark13CellularClass2onEv>
  fuel.wakeup();   
   d91ae:	4886      	ldr	r0, [pc, #536]	; (d93c8 <setup+0x224>)
   d91b0:	f004 f9e4 	bl	dd57c <_ZN9FuelGauge6wakeupEv>
  fuel.begin();
   d91b4:	4884      	ldr	r0, [pc, #528]	; (d93c8 <setup+0x224>)
   d91b6:	f004 f8f7 	bl	dd3a8 <_ZN9FuelGauge5beginEv>
  pmic.enableBuck();
   d91ba:	4884      	ldr	r0, [pc, #528]	; (d93cc <setup+0x228>)
   d91bc:	f002 feb6 	bl	dbf2c <_ZN4PMIC10enableBuckEv>
  Particle.process();
   d91c0:	f7fb fe72 	bl	d4ea8 <_ZN10CloudClass7processEv>
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return register_function(call_raw_user_function, (void*)func, funcKey);
   d91c4:	4a82      	ldr	r2, [pc, #520]	; (d93d0 <setup+0x22c>)
   d91c6:	4983      	ldr	r1, [pc, #524]	; (d93d4 <setup+0x230>)
   d91c8:	4883      	ldr	r0, [pc, #524]	; (d93d8 <setup+0x234>)
   d91ca:	f004 fadb 	bl	dd784 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
    int publishVitals(system_tick_t period_s = particle::NOW);
    inline int publishVitals(std::chrono::seconds s) { return publishVitals(s.count()); }

    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
    {
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
   d91ce:	2400      	movs	r4, #0
        return _function(name, args...);
    }

    static bool _function(const char *funcKey, user_function_int_str_t* func)
    {
        return register_function(call_raw_user_function, (void*)func, funcKey);
   d91d0:	4a82      	ldr	r2, [pc, #520]	; (d93dc <setup+0x238>)
   d91d2:	4983      	ldr	r1, [pc, #524]	; (d93e0 <setup+0x23c>)
   d91d4:	4880      	ldr	r0, [pc, #512]	; (d93d8 <setup+0x234>)
   d91d6:	f004 fad5 	bl	dd784 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
    int publishVitals(system_tick_t period_s = particle::NOW);
    inline int publishVitals(std::chrono::seconds s) { return publishVitals(s.count()); }

    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
    {
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
   d91da:	4623      	mov	r3, r4
   d91dc:	4622      	mov	r2, r4
   d91de:	4981      	ldr	r1, [pc, #516]	; (d93e4 <setup+0x240>)
   d91e0:	9401      	str	r4, [sp, #4]
   d91e2:	9400      	str	r4, [sp, #0]
   d91e4:	4880      	ldr	r0, [pc, #512]	; (d93e8 <setup+0x244>)
   d91e6:	f002 fdbf 	bl	dbd68 <spark_subscribe>
   d91ea:	2301      	movs	r3, #1
   d91ec:	4622      	mov	r2, r4
   d91ee:	497d      	ldr	r1, [pc, #500]	; (d93e4 <setup+0x240>)
   d91f0:	9401      	str	r4, [sp, #4]
   d91f2:	9400      	str	r4, [sp, #0]
   d91f4:	487d      	ldr	r0, [pc, #500]	; (d93ec <setup+0x248>)
   d91f6:	f002 fdb7 	bl	dbd68 <spark_subscribe>
  Particle.function("Grab Pic", grabPic);
  Particle.function("CleanSD", cleanSD);
  Particle.subscribe("particle/device/ip", handler, MY_DEVICES);
  Particle.subscribe("particle/device/name", handler);  
  Particle.publishVitals();
   d91fa:	f04f 31ff 	mov.w	r1, #4294967295
   d91fe:	487c      	ldr	r0, [pc, #496]	; (d93f0 <setup+0x24c>)
   d9200:	f004 fad7 	bl	dd7b2 <_ZN10CloudClass13publishVitalsEm>
  Particle.publishVitals(300);
   d9204:	f44f 7196 	mov.w	r1, #300	; 0x12c
   d9208:	4879      	ldr	r0, [pc, #484]	; (d93f0 <setup+0x24c>)
   d920a:	f004 fad2 	bl	dd7b2 <_ZN10CloudClass13publishVitalsEm>
  Time.zone(-5);
   d920e:	eeb9 0a04 	vmov.f32	s0, #148	; 0xc0a00000 -5.0
   d9212:	f003 ff0b 	bl	dd02c <_ZN9TimeClass4zoneEf>
  // On initalise les GPIO 
  pinMode(Cam_on, OUTPUT);
   d9216:	2101      	movs	r1, #1
   d9218:	2013      	movs	r0, #19
   d921a:	f005 fc89 	bl	deb30 <pinMode>
  pinMode(statusLed, OUTPUT);
   d921e:	2101      	movs	r1, #1
   d9220:	2007      	movs	r0, #7
   d9222:	f005 fc85 	bl	deb30 <pinMode>
  pinMode(D8, INPUT);
   d9226:	4621      	mov	r1, r4
   d9228:	2008      	movs	r0, #8
   d922a:	f005 fc81 	bl	deb30 <pinMode>
  pinMode(D7, OUTPUT);
   d922e:	2101      	movs	r1, #1
   d9230:	2007      	movs	r0, #7
   d9232:	f005 fc7d 	bl	deb30 <pinMode>
  pinMode(SS_Button, INPUT);
   d9236:	4621      	mov	r1, r4
   d9238:	2006      	movs	r0, #6
   d923a:	f005 fc79 	bl	deb30 <pinMode>
  //pinMode(D5, OUTPUT);
  //pinMode(SD_CS, OUTPUT);  

  //Initialisation I2C (RTC et Arducam)
  Wire.setSpeed(CLOCK_SPEED_100KHZ);
   d923e:	f005 fd2d 	bl	dec9c <_Z19__fetch_global_Wirev>
   d9242:	496c      	ldr	r1, [pc, #432]	; (d93f4 <setup+0x250>)
   d9244:	f004 ffb6 	bl	de1b4 <_ZN7TwoWire8setSpeedEm>
  Wire.begin();
   d9248:	f005 fd28 	bl	dec9c <_Z19__fetch_global_Wirev>
   d924c:	f004 ffb6 	bl	de1bc <_ZN7TwoWire5beginEv>
  
  initSD();
   d9250:	f7fb fe9c 	bl	d4f8c <_Z6initSDv>
    log("Wu RTC", 4);
    delay(1000);
    System.reset();
  }
*/
  if((fuel.getVCell()*100) < Batt_low_SP) {
   d9254:	485c      	ldr	r0, [pc, #368]	; (d93c8 <setup+0x224>)
   d9256:	f004 f90f 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d925a:	eddf 7a67 	vldr	s15, [pc, #412]	; d93f8 <setup+0x254>
   d925e:	4b67      	ldr	r3, [pc, #412]	; (d93fc <setup+0x258>)
   d9260:	ee20 0a27 	vmul.f32	s0, s0, s15
   d9264:	edd3 7a00 	vldr	s15, [r3]
   d9268:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   d926c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   d9270:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   d9274:	d52e      	bpl.n	d92d4 <setup+0x130>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d9276:	4962      	ldr	r1, [pc, #392]	; (d9400 <setup+0x25c>)
   d9278:	a806      	add	r0, sp, #24
   d927a:	f003 f99a 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    log("Battery Low, waiting for recharge: " + String(fuel.getVCell()) + " V", 1);
   d927e:	4852      	ldr	r0, [pc, #328]	; (d93c8 <setup+0x224>)
   d9280:	f004 f8fa 	bl	dd478 <_ZN9FuelGauge8getVCellEv>
   d9284:	2106      	movs	r1, #6
   d9286:	a802      	add	r0, sp, #8
   d9288:	f003 fa1d 	bl	dc6c6 <_ZN6StringC1Efi>
   d928c:	a902      	add	r1, sp, #8
   d928e:	a806      	add	r0, sp, #24
   d9290:	f003 fa6a 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d9294:	495b      	ldr	r1, [pc, #364]	; (d9404 <setup+0x260>)
   d9296:	f003 fa73 	bl	dc780 <_ZplRK15StringSumHelperPKc>
   d929a:	4601      	mov	r1, r0
   d929c:	a80a      	add	r0, sp, #40	; 0x28
   d929e:	f003 f9aa 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d92a2:	2101      	movs	r1, #1
   d92a4:	a80a      	add	r0, sp, #40	; 0x28
   d92a6:	f7fb fec1 	bl	d502c <_Z3log6Stringi>
   d92aa:	a80a      	add	r0, sp, #40	; 0x28
   d92ac:	f003 f93a 	bl	dc524 <_ZN6StringD1Ev>
   d92b0:	a802      	add	r0, sp, #8
   d92b2:	f003 f937 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d92b6:	a806      	add	r0, sp, #24
   d92b8:	f003 f934 	bl	dc524 <_ZN6StringD1Ev>
    digitalWrite(Cam_on, LOW);
   d92bc:	4621      	mov	r1, r4
   d92be:	2013      	movs	r0, #19
   d92c0:	f005 fc47 	bl	deb52 <digitalWrite>
    delay(1000);
   d92c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   d92c8:	f003 ff38 	bl	dd13c <delay>
    goToSleep(3600);
   d92cc:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   d92d0:	f7fc fc62 	bl	d5b98 <_Z9goToSleepl>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d92d4:	494c      	ldr	r1, [pc, #304]	; (d9408 <setup+0x264>)
   d92d6:	a806      	add	r0, sp, #24
   d92d8:	f003 f96b 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
   d92dc:	2200      	movs	r2, #0
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
   d92de:	4611      	mov	r1, r2
   d92e0:	a80a      	add	r0, sp, #40	; 0x28
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
   d92e2:	920a      	str	r2, [sp, #40]	; 0x28
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
   d92e4:	f002 fa9e 	bl	db824 <HAL_Core_Get_Last_Reset_Info>
    }  

  log("Reset Code: " + String(System.resetReason()),4);
   d92e8:	220a      	movs	r2, #10
   d92ea:	990a      	ldr	r1, [sp, #40]	; 0x28
   d92ec:	a802      	add	r0, sp, #8
   d92ee:	f003 f9b0 	bl	dc652 <_ZN6StringC1Eih>
   d92f2:	a902      	add	r1, sp, #8
   d92f4:	a806      	add	r0, sp, #24
   d92f6:	f003 fa37 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d92fa:	4601      	mov	r1, r0
   d92fc:	a80a      	add	r0, sp, #40	; 0x28
   d92fe:	f003 f97a 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d9302:	2104      	movs	r1, #4
   d9304:	a80a      	add	r0, sp, #40	; 0x28
   d9306:	f7fb fe91 	bl	d502c <_Z3log6Stringi>
   d930a:	a80a      	add	r0, sp, #40	; 0x28
   d930c:	f003 f90a 	bl	dc524 <_ZN6StringD1Ev>
   d9310:	a802      	add	r0, sp, #8
   d9312:	f003 f907 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d9316:	a806      	add	r0, sp, #24
   d9318:	f003 f904 	bl	dc524 <_ZN6StringD1Ev>

  //Initialisation de divers priphriques
  rtc.begin();
   d931c:	f001 fdf2 	bl	daf04 <_ZN7PCF85235beginEv>
  Serial.begin(115200);
   d9320:	f004 fdbe 	bl	ddea0 <_Z16_fetch_usbserialv>
   d9324:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
   d9328:	f004 fdae 	bl	dde88 <_ZN9USBSerial5beginEl>
  rtc.clear_rtc_interrupt_flags();
   d932c:	4837      	ldr	r0, [pc, #220]	; (d940c <setup+0x268>)
   d932e:	f001 ff48 	bl	db1c2 <_ZN7PCF852325clear_rtc_interrupt_flagsEv>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   d9332:	4937      	ldr	r1, [pc, #220]	; (d9410 <setup+0x26c>)
   d9334:	a806      	add	r0, sp, #24
   d9336:	f003 f93c 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
  log("Init " + String(VERSION_SLUG), 4);
   d933a:	4936      	ldr	r1, [pc, #216]	; (d9414 <setup+0x270>)
   d933c:	a802      	add	r0, sp, #8
   d933e:	f003 f938 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d9342:	a902      	add	r1, sp, #8
   d9344:	a806      	add	r0, sp, #24
   d9346:	f003 fa0f 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   d934a:	4601      	mov	r1, r0
   d934c:	a80a      	add	r0, sp, #40	; 0x28
   d934e:	f003 f952 	bl	dc5f6 <_ZN6StringC1ERKS_>
   d9352:	2104      	movs	r1, #4
   d9354:	a80a      	add	r0, sp, #40	; 0x28
   d9356:	f7fb fe69 	bl	d502c <_Z3log6Stringi>
   d935a:	a80a      	add	r0, sp, #40	; 0x28
   d935c:	f003 f8e2 	bl	dc524 <_ZN6StringD1Ev>
   d9360:	a802      	add	r0, sp, #8
   d9362:	f003 f8df 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   d9366:	a806      	add	r0, sp, #24
   d9368:	f003 f8dc 	bl	dc524 <_ZN6StringD1Ev>
  
  // Si le rtc n'est pas en fonction, utiliser la date et l'heure 
  // de compilation du programme pour le dmarrer puis redmarer pour vrifier  nouveau
  if (!rtc.isrunning()) {
   d936c:	4827      	ldr	r0, [pc, #156]	; (d940c <setup+0x268>)
   d936e:	f001 fdcb 	bl	daf08 <_ZN7PCF85239isrunningEv>
   d9372:	b9c8      	cbnz	r0, d93a8 <setup+0x204>
    log("RTC is NOT running!", 2);
   d9374:	4928      	ldr	r1, [pc, #160]	; (d9418 <setup+0x274>)
   d9376:	a80a      	add	r0, sp, #40	; 0x28
   d9378:	f003 f91b 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d937c:	2102      	movs	r1, #2
   d937e:	a80a      	add	r0, sp, #40	; 0x28
   d9380:	f7fb fe54 	bl	d502c <_Z3log6Stringi>
   d9384:	a80a      	add	r0, sp, #40	; 0x28
   d9386:	f003 f8cd 	bl	dc524 <_ZN6StringD1Ev>
    // following line sets the RTC to the date & time this sketch was compiled
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
   d938a:	4a24      	ldr	r2, [pc, #144]	; (d941c <setup+0x278>)
   d938c:	4924      	ldr	r1, [pc, #144]	; (d9420 <setup+0x27c>)
   d938e:	a80a      	add	r0, sp, #40	; 0x28
   d9390:	f001 fd0c 	bl	dadac <_ZN8DateTimeC1EPK19__FlashStringHelperS2_>
   d9394:	a80a      	add	r0, sp, #40	; 0x28
   d9396:	f001 fdd6 	bl	daf46 <_ZN7PCF85236adjustERK8DateTime>
    // This line sets the RTC with an explicit date & time, for example to set
    // January 21, 2014 at 3am you would call:
    // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
    delay(5000);
   d939a:	f241 3088 	movw	r0, #5000	; 0x1388
   d939e:	f003 fecd 	bl	dd13c <delay>
    System.reset();
   d93a2:	f002 ff3c 	bl	dc21e <_ZN11SystemClass5resetEv>
   d93a6:	e005      	b.n	d93b4 <setup+0x210>
  } else { //Sinon paramtrer le RTC, ceci tait utilis pour l'alarme. non fonctionnel ACJ
      rtc.config();
   d93a8:	4818      	ldr	r0, [pc, #96]	; (d940c <setup+0x268>)
   d93aa:	f001 ff06 	bl	db1ba <_ZN7PCF85236configEv>
      rtc.clear_rtc_interrupt_flags();
   d93ae:	4817      	ldr	r0, [pc, #92]	; (d940c <setup+0x268>)
   d93b0:	f001 ff07 	bl	db1c2 <_ZN7PCF852325clear_rtc_interrupt_flagsEv>
    }

  // On met  jour nos variables de configuration
  loadConfiguration(configFileName,config);
   d93b4:	4b1b      	ldr	r3, [pc, #108]	; (d9424 <setup+0x280>)
   d93b6:	491c      	ldr	r1, [pc, #112]	; (d9428 <setup+0x284>)
   d93b8:	6818      	ldr	r0, [r3, #0]
   d93ba:	f7fe fd23 	bl	d7e04 <_Z17loadConfigurationPKcR6Config>
}
   d93be:	b00e      	add	sp, #56	; 0x38
   d93c0:	bd10      	pop	{r4, pc}
   d93c2:	bf00      	nop
   d93c4:	2003e4c0 	.word	0x2003e4c0
   d93c8:	2003deb4 	.word	0x2003deb4
   d93cc:	2003df2c 	.word	0x2003df2c
   d93d0:	000e22b0 	.word	0x000e22b0
   d93d4:	000d6131 	.word	0x000d6131
   d93d8:	000dd759 	.word	0x000dd759
   d93dc:	000e22b9 	.word	0x000e22b9
   d93e0:	000d5c39 	.word	0x000d5c39
   d93e4:	000d5229 	.word	0x000d5229
   d93e8:	000e1bbf 	.word	0x000e1bbf
   d93ec:	000e1baa 	.word	0x000e1baa
   d93f0:	2003e6f0 	.word	0x2003e6f0
   d93f4:	000186a0 	.word	0x000186a0
   d93f8:	42c80000 	.word	0x42c80000
   d93fc:	2003d6b8 	.word	0x2003d6b8
   d9400:	000e219e 	.word	0x000e219e
   d9404:	000e21c2 	.word	0x000e21c2
   d9408:	000e22c1 	.word	0x000e22c1
   d940c:	2003dea0 	.word	0x2003dea0
   d9410:	000e22ce 	.word	0x000e22ce
   d9414:	000e22d4 	.word	0x000e22d4
   d9418:	000e22db 	.word	0x000e22db
   d941c:	000e22ef 	.word	0x000e22ef
   d9420:	000e22f8 	.word	0x000e22f8
   d9424:	2003def0 	.word	0x2003def0
   d9428:	2003d6bc 	.word	0x2003d6bc

000d942c <_ZN5SDLib4FileD0Ev>:
#define FILE_READ O_READ
#define FILE_WRITE (O_READ | O_WRITE | O_CREAT | O_APPEND)

namespace SDLib {

  class File : public Stream {
   d942c:	b510      	push	{r4, lr}
   d942e:	2124      	movs	r1, #36	; 0x24
   d9430:	4604      	mov	r4, r0
   d9432:	f005 fc8d 	bl	ded50 <_ZdlPvj>
   d9436:	4620      	mov	r0, r4
   d9438:	bd10      	pop	{r4, pc}
	...

000d943c <_GLOBAL__sub_I_SystemMode>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
   d943c:	4b5e      	ldr	r3, [pc, #376]	; (d95b8 <_GLOBAL__sub_I_SystemMode+0x17c>)
  softDelay(1000);
}

inline void softDelay(uint32_t t) {
  for (uint32_t ms = millis(); millis() - ms < t; Particle.process());  //  safer than a delay()
   d943e:	b570      	push	{r4, r5, r6, lr}
   d9440:	2400      	movs	r4, #0
   d9442:	601c      	str	r4, [r3, #0]
   d9444:	4b5d      	ldr	r3, [pc, #372]	; (d95bc <_GLOBAL__sub_I_SystemMode+0x180>)

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   d9446:	4d5e      	ldr	r5, [pc, #376]	; (d95c0 <_GLOBAL__sub_I_SystemMode+0x184>)
   d9448:	701c      	strb	r4, [r3, #0]
   d944a:	4b5e      	ldr	r3, [pc, #376]	; (d95c4 <_GLOBAL__sub_I_SystemMode+0x188>)
   d944c:	2601      	movs	r6, #1
   d944e:	701e      	strb	r6, [r3, #0]
   d9450:	f002 f930 	bl	db6b4 <HAL_Pin_Map>
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   d9454:	f64f 73ff 	movw	r3, #65535	; 0xffff
   d9458:	816b      	strh	r3, [r5, #10]

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   d945a:	602c      	str	r4, [r5, #0]
   d945c:	80ac      	strh	r4, [r5, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   d945e:	71ac      	strb	r4, [r5, #6]
   d9460:	812c      	strh	r4, [r5, #8]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   d9462:	4630      	mov	r0, r6
   d9464:	f002 fbb2 	bl	dbbcc <set_system_mode>
//./build-local.sh main
//particle flash --usb target/1.5.2/boron/ArduCamTest.bin
//particle flash --usb target/1.4.4/boron/ArduCamTest.bin
//particle flash 44515 target/1.5.2/boron/ArduCamTest.bin
SYSTEM_MODE(AUTOMATIC);
   d9468:	4a57      	ldr	r2, [pc, #348]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d946a:	4958      	ldr	r1, [pc, #352]	; (d95cc <_GLOBAL__sub_I_SystemMode+0x190>)
   d946c:	4628      	mov	r0, r5
   d946e:	f005 fc61 	bl	ded34 <__aeabi_atexit>
SYSTEM_THREAD(ENABLED);
   d9472:	4621      	mov	r1, r4
   d9474:	4630      	mov	r0, r6
   d9476:	f002 fbb9 	bl	dbbec <system_thread_set_state>
const int statusLed = D7; 
const int SPI_CS = D5;
const int SD_CS = A5;
const int Cam_on = A0;
const int SS_Button = D6;
FuelGauge fuel;
   d947a:	4621      	mov	r1, r4
   d947c:	4854      	ldr	r0, [pc, #336]	; (d95d0 <_GLOBAL__sub_I_SystemMode+0x194>)

String configFileName = "CONFIG.JSN";

const int LogEntries = 50;
int logBufIndex = 0;
String logbuffer[LogEntries];
   d947e:	4d55      	ldr	r5, [pc, #340]	; (d95d4 <_GLOBAL__sub_I_SystemMode+0x198>)
const int statusLed = D7; 
const int SPI_CS = D5;
const int SD_CS = A5;
const int Cam_on = A0;
const int SS_Button = D6;
FuelGauge fuel;
   d9480:	f003 ffba 	bl	dd3f8 <_ZN9FuelGaugeC1Eb>
   d9484:	4a50      	ldr	r2, [pc, #320]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d9486:	4954      	ldr	r1, [pc, #336]	; (d95d8 <_GLOBAL__sub_I_SystemMode+0x19c>)
   d9488:	4851      	ldr	r0, [pc, #324]	; (d95d0 <_GLOBAL__sub_I_SystemMode+0x194>)
   d948a:	f005 fc53 	bl	ded34 <__aeabi_atexit>

ApplicationWatchdog wd(90000, WDevent);
   d948e:	f44f 7300 	mov.w	r3, #512	; 0x200
   d9492:	4a52      	ldr	r2, [pc, #328]	; (d95dc <_GLOBAL__sub_I_SystemMode+0x1a0>)
   d9494:	4952      	ldr	r1, [pc, #328]	; (d95e0 <_GLOBAL__sub_I_SystemMode+0x1a4>)
   d9496:	4853      	ldr	r0, [pc, #332]	; (d95e4 <_GLOBAL__sub_I_SystemMode+0x1a8>)
   d9498:	f7fb fcb0 	bl	d4dfc <_ZN19ApplicationWatchdogC1EjPFvvEj>
   d949c:	4a4a      	ldr	r2, [pc, #296]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d949e:	4952      	ldr	r1, [pc, #328]	; (d95e8 <_GLOBAL__sub_I_SystemMode+0x1ac>)
   d94a0:	4850      	ldr	r0, [pc, #320]	; (d95e4 <_GLOBAL__sub_I_SystemMode+0x1a8>)
   d94a2:	f005 fc47 	bl	ded34 <__aeabi_atexit>

PCF8523 rtc;
char monthOfTheYear[12][5] = {"JAN", "FEV", "MAR", "AVR", "MAI", "JUN", "JUL", "AOU", "SEP", "OCT", "NOV", "DEC"};
DateTime now;
   d94a6:	4621      	mov	r1, r4
   d94a8:	4850      	ldr	r0, [pc, #320]	; (d95ec <_GLOBAL__sub_I_SystemMode+0x1b0>)
   d94aa:	f001 fc1d 	bl	dace8 <_ZN8DateTimeC1Em>

String hostname = "142.213.166.184";
   d94ae:	4950      	ldr	r1, [pc, #320]	; (d95f0 <_GLOBAL__sub_I_SystemMode+0x1b4>)
   d94b0:	4850      	ldr	r0, [pc, #320]	; (d95f4 <_GLOBAL__sub_I_SystemMode+0x1b8>)
   d94b2:	f003 f87e 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d94b6:	4a44      	ldr	r2, [pc, #272]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d94b8:	494f      	ldr	r1, [pc, #316]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d94ba:	484e      	ldr	r0, [pc, #312]	; (d95f4 <_GLOBAL__sub_I_SystemMode+0x1b8>)
   d94bc:	f005 fc3a 	bl	ded34 <__aeabi_atexit>
String username = "bp1";
   d94c0:	494e      	ldr	r1, [pc, #312]	; (d95fc <_GLOBAL__sub_I_SystemMode+0x1c0>)
   d94c2:	484f      	ldr	r0, [pc, #316]	; (d9600 <_GLOBAL__sub_I_SystemMode+0x1c4>)
   d94c4:	f003 f875 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d94c8:	4a3f      	ldr	r2, [pc, #252]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d94ca:	494b      	ldr	r1, [pc, #300]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d94cc:	484c      	ldr	r0, [pc, #304]	; (d9600 <_GLOBAL__sub_I_SystemMode+0x1c4>)
   d94ce:	f005 fc31 	bl	ded34 <__aeabi_atexit>
String password = "BlyuHet7";
   d94d2:	494c      	ldr	r1, [pc, #304]	; (d9604 <_GLOBAL__sub_I_SystemMode+0x1c8>)
   d94d4:	484c      	ldr	r0, [pc, #304]	; (d9608 <_GLOBAL__sub_I_SystemMode+0x1cc>)
   d94d6:	f003 f86c 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d94da:	4a3b      	ldr	r2, [pc, #236]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d94dc:	4946      	ldr	r1, [pc, #280]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d94de:	484a      	ldr	r0, [pc, #296]	; (d9608 <_GLOBAL__sub_I_SystemMode+0x1cc>)
   d94e0:	f005 fc28 	bl	ded34 <__aeabi_atexit>
String ftp_dir = "/AutoCamDEH";
   d94e4:	4949      	ldr	r1, [pc, #292]	; (d960c <_GLOBAL__sub_I_SystemMode+0x1d0>)
   d94e6:	484a      	ldr	r0, [pc, #296]	; (d9610 <_GLOBAL__sub_I_SystemMode+0x1d4>)
   d94e8:	f003 f863 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d94ec:	4a36      	ldr	r2, [pc, #216]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d94ee:	4942      	ldr	r1, [pc, #264]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d94f0:	4847      	ldr	r0, [pc, #284]	; (d9610 <_GLOBAL__sub_I_SystemMode+0x1d4>)
   d94f2:	f005 fc1f 	bl	ded34 <__aeabi_atexit>

#define TX_BUFFER_MAX 256
uint8_t buffer[TX_BUFFER_MAX + 1];
int tx_buffer_index = 0;

String configFileName = "CONFIG.JSN";
   d94f6:	4947      	ldr	r1, [pc, #284]	; (d9614 <_GLOBAL__sub_I_SystemMode+0x1d8>)
   d94f8:	4847      	ldr	r0, [pc, #284]	; (d9618 <_GLOBAL__sub_I_SystemMode+0x1dc>)
   d94fa:	f003 f85a 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d94fe:	4a32      	ldr	r2, [pc, #200]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d9500:	493d      	ldr	r1, [pc, #244]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d9502:	4845      	ldr	r0, [pc, #276]	; (d9618 <_GLOBAL__sub_I_SystemMode+0x1dc>)
   d9504:	f005 fc16 	bl	ded34 <__aeabi_atexit>

const int LogEntries = 50;
int logBufIndex = 0;
String logbuffer[LogEntries];
   d9508:	1928      	adds	r0, r5, r4
   d950a:	4944      	ldr	r1, [pc, #272]	; (d961c <_GLOBAL__sub_I_SystemMode+0x1e0>)
   d950c:	3410      	adds	r4, #16
   d950e:	f003 f850 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d9512:	f5b4 7f48 	cmp.w	r4, #800	; 0x320
   d9516:	d1f7      	bne.n	d9508 <_GLOBAL__sub_I_SystemMode+0xcc>
   d9518:	4a2b      	ldr	r2, [pc, #172]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d951a:	4941      	ldr	r1, [pc, #260]	; (d9620 <_GLOBAL__sub_I_SystemMode+0x1e4>)
//};

ArduCAM myCAM(OV2640, SPI_CS);
PMIC pmic;

ParticleFtpClient ftp = ParticleFtpClient();
   d951c:	4c41      	ldr	r4, [pc, #260]	; (d9624 <_GLOBAL__sub_I_SystemMode+0x1e8>)

String configFileName = "CONFIG.JSN";

const int LogEntries = 50;
int logBufIndex = 0;
String logbuffer[LogEntries];
   d951e:	2000      	movs	r0, #0
   d9520:	f005 fc08 	bl	ded34 <__aeabi_atexit>

String stationName = "UNDEF_";
   d9524:	4940      	ldr	r1, [pc, #256]	; (d9628 <_GLOBAL__sub_I_SystemMode+0x1ec>)
   d9526:	4841      	ldr	r0, [pc, #260]	; (d962c <_GLOBAL__sub_I_SystemMode+0x1f0>)
   d9528:	f003 f843 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d952c:	4a26      	ldr	r2, [pc, #152]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d952e:	4932      	ldr	r1, [pc, #200]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d9530:	483e      	ldr	r0, [pc, #248]	; (d962c <_GLOBAL__sub_I_SystemMode+0x1f0>)
   d9532:	f005 fbff 	bl	ded34 <__aeabi_atexit>
String BDH = "00000";
   d9536:	493e      	ldr	r1, [pc, #248]	; (d9630 <_GLOBAL__sub_I_SystemMode+0x1f4>)
   d9538:	483e      	ldr	r0, [pc, #248]	; (d9634 <_GLOBAL__sub_I_SystemMode+0x1f8>)
   d953a:	f003 f83a 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d953e:	4a22      	ldr	r2, [pc, #136]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d9540:	492d      	ldr	r1, [pc, #180]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d9542:	483c      	ldr	r0, [pc, #240]	; (d9634 <_GLOBAL__sub_I_SystemMode+0x1f8>)
   d9544:	f005 fbf6 	bl	ded34 <__aeabi_atexit>
String PublicIP = "no_IP";
   d9548:	493b      	ldr	r1, [pc, #236]	; (d9638 <_GLOBAL__sub_I_SystemMode+0x1fc>)
   d954a:	483c      	ldr	r0, [pc, #240]	; (d963c <_GLOBAL__sub_I_SystemMode+0x200>)
   d954c:	f003 f831 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   d9550:	4a1d      	ldr	r2, [pc, #116]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d9552:	4929      	ldr	r1, [pc, #164]	; (d95f8 <_GLOBAL__sub_I_SystemMode+0x1bc>)
   d9554:	4839      	ldr	r0, [pc, #228]	; (d963c <_GLOBAL__sub_I_SystemMode+0x200>)
   d9556:	f005 fbed 	bl	ded34 <__aeabi_atexit>
//      0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00,
//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x1F, 0x00,
//      0x00, 0x00
//};

ArduCAM myCAM(OV2640, SPI_CS);
   d955a:	2205      	movs	r2, #5
   d955c:	4611      	mov	r1, r2
   d955e:	4838      	ldr	r0, [pc, #224]	; (d9640 <_GLOBAL__sub_I_SystemMode+0x204>)
   d9560:	f7fb f830 	bl	d45c4 <_ZN7ArduCAMC1Ehi>
PMIC pmic;
   d9564:	2100      	movs	r1, #0
   d9566:	4837      	ldr	r0, [pc, #220]	; (d9644 <_GLOBAL__sub_I_SystemMode+0x208>)
   d9568:	f002 fc75 	bl	dbe56 <_ZN4PMICC1Eb>
   d956c:	4a16      	ldr	r2, [pc, #88]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d956e:	4936      	ldr	r1, [pc, #216]	; (d9648 <_GLOBAL__sub_I_SystemMode+0x20c>)
   d9570:	4834      	ldr	r0, [pc, #208]	; (d9644 <_GLOBAL__sub_I_SystemMode+0x208>)
   d9572:	f005 fbdf 	bl	ded34 <__aeabi_atexit>

ParticleFtpClient ftp = ParticleFtpClient();
   d9576:	f44f 72a6 	mov.w	r2, #332	; 0x14c
   d957a:	2100      	movs	r1, #0
   d957c:	4620      	mov	r0, r4
   d957e:	f006 fcf3 	bl	dff68 <memset>
   d9582:	4620      	mov	r0, r4
   d9584:	f005 f9dc 	bl	de940 <_ZN9TCPClientC1Ev>
   d9588:	f104 001c 	add.w	r0, r4, #28
   d958c:	f005 f9d8 	bl	de940 <_ZN9TCPClientC1Ev>
   d9590:	230a      	movs	r3, #10
   d9592:	4a0d      	ldr	r2, [pc, #52]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d9594:	492d      	ldr	r1, [pc, #180]	; (d964c <_GLOBAL__sub_I_SystemMode+0x210>)
   d9596:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   d959a:	4620      	mov	r0, r4
   d959c:	f005 fbca 	bl	ded34 <__aeabi_atexit>

File root;
   d95a0:	482b      	ldr	r0, [pc, #172]	; (d9650 <_GLOBAL__sub_I_SystemMode+0x214>)
   d95a2:	f001 f877 	bl	da694 <_ZN5SDLib4FileC1Ev>
   d95a6:	4a08      	ldr	r2, [pc, #32]	; (d95c8 <_GLOBAL__sub_I_SystemMode+0x18c>)
   d95a8:	492a      	ldr	r1, [pc, #168]	; (d9654 <_GLOBAL__sub_I_SystemMode+0x218>)
   d95aa:	4829      	ldr	r0, [pc, #164]	; (d9650 <_GLOBAL__sub_I_SystemMode+0x214>)
   d95ac:	f005 fbc2 	bl	ded34 <__aeabi_atexit>
  softDelay(1000);
}

inline void softDelay(uint32_t t) {
  for (uint32_t ms = millis(); millis() - ms < t; Particle.process());  //  safer than a delay()
   d95b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
File root;

// The STARTUP call is placed outside of any other function
// What goes inside is any valid code that can be executed. Here, we use a function call.
// Using a single function is preferable to having several `STARTUP()` calls.
STARTUP(startup());
   d95b4:	f7fb bce5 	b.w	d4f82 <_Z7startupv>
   d95b8:	2003e2a8 	.word	0x2003e2a8
   d95bc:	2003df04 	.word	0x2003df04
   d95c0:	2003df30 	.word	0x2003df30
   d95c4:	2003dea1 	.word	0x2003dea1
   d95c8:	2003daf8 	.word	0x2003daf8
   d95cc:	000d4c95 	.word	0x000d4c95
   d95d0:	2003deb4 	.word	0x2003deb4
   d95d4:	2003df88 	.word	0x2003df88
   d95d8:	000dd417 	.word	0x000dd417
   d95dc:	000d5201 	.word	0x000d5201
   d95e0:	00015f90 	.word	0x00015f90
   d95e4:	2003ded4 	.word	0x2003ded4
   d95e8:	000d4cff 	.word	0x000d4cff
   d95ec:	2003debc 	.word	0x2003debc
   d95f0:	000e2304 	.word	0x000e2304
   d95f4:	2003df1c 	.word	0x2003df1c
   d95f8:	000dc525 	.word	0x000dc525
   d95fc:	000e2314 	.word	0x000e2314
   d9600:	2003df40 	.word	0x2003df40
   d9604:	000e2318 	.word	0x000e2318
   d9608:	2003df54 	.word	0x2003df54
   d960c:	000e2321 	.word	0x000e2321
   d9610:	2003dec4 	.word	0x2003dec4
   d9614:	000e2068 	.word	0x000e2068
   d9618:	2003def0 	.word	0x2003def0
   d961c:	000e1eea 	.word	0x000e1eea
   d9620:	000d4c05 	.word	0x000d4c05
   d9624:	2003dd48 	.word	0x2003dd48
   d9628:	000e232d 	.word	0x000e232d
   d962c:	2003dea4 	.word	0x2003dea4
   d9630:	000e2334 	.word	0x000e2334
   d9634:	2003df78 	.word	0x2003df78
   d9638:	000e233a 	.word	0x000e233a
   d963c:	2003df68 	.word	0x2003df68
   d9640:	2003df08 	.word	0x2003df08
   d9644:	2003df2c 	.word	0x2003df2c
   d9648:	000dbe75 	.word	0x000dbe75
   d964c:	000d6941 	.word	0x000d6941
   d9650:	2003dd1c 	.word	0x2003dd1c
   d9654:	000d4c03 	.word	0x000d4c03

000d9658 <_ZN6SdFileD1Ev>:
//------------------------------------------------------------------------------
/**
   \class SdFile
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
   d9658:	4770      	bx	lr

000d965a <_ZN6SdFileD0Ev>:
   d965a:	b510      	push	{r4, lr}
   d965c:	2128      	movs	r1, #40	; 0x28
   d965e:	4604      	mov	r4, r0
   d9660:	f005 fb76 	bl	ded50 <_ZdlPvj>
   d9664:	4620      	mov	r0, r4
   d9666:	bd10      	pop	{r4, pc}

000d9668 <_ZN6SdFile10addClusterEv>:
  // suppress cpplint warnings with NOLINT comment
  void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
   d9668:	b510      	push	{r4, lr}
  if (!vol_->allocContiguous(1, &curCluster_)) {
   d966a:	f100 020c 	add.w	r2, r0, #12
  // suppress cpplint warnings with NOLINT comment
  void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
   d966e:	4604      	mov	r4, r0
  if (!vol_->allocContiguous(1, &curCluster_)) {
   d9670:	2101      	movs	r1, #1
   d9672:	6a40      	ldr	r0, [r0, #36]	; 0x24
   d9674:	f7fa fe40 	bl	d42f8 <_ZN8SdVolume15allocContiguousEmPm>
   d9678:	b160      	cbz	r0, d9694 <_ZN6SdFile10addClusterEv+0x2c>
    return false;
  }

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
   d967a:	6a23      	ldr	r3, [r4, #32]
   d967c:	b92b      	cbnz	r3, d968a <_ZN6SdFile10addClusterEv+0x22>
    firstCluster_ = curCluster_;
   d967e:	68e3      	ldr	r3, [r4, #12]
   d9680:	6223      	str	r3, [r4, #32]
    flags_ |= F_FILE_DIR_DIRTY;
   d9682:	7a23      	ldrb	r3, [r4, #8]
   d9684:	f063 037f 	orn	r3, r3, #127	; 0x7f
   d9688:	7223      	strb	r3, [r4, #8]
  }
  flags_ |= F_FILE_CLUSTER_ADDED;
   d968a:	7a23      	ldrb	r3, [r4, #8]
   d968c:	f043 0320 	orr.w	r3, r3, #32
   d9690:	7223      	strb	r3, [r4, #8]
   d9692:	2001      	movs	r0, #1
  return true;
}
   d9694:	bd10      	pop	{r4, pc}

000d9696 <_ZN6SdFile13addDirClusterEv>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// return with first block of cluster in the cache
uint8_t SdFile::addDirCluster(void) {
   d9696:	b570      	push	{r4, r5, r6, lr}
   d9698:	4605      	mov	r5, r0
  if (!addCluster()) {
   d969a:	f7ff ffe5 	bl	d9668 <_ZN6SdFile10addClusterEv>
   d969e:	b908      	cbnz	r0, d96a4 <_ZN6SdFile13addDirClusterEv+0xe>
    return false;
   d96a0:	2000      	movs	r0, #0
   d96a2:	bd70      	pop	{r4, r5, r6, pc}
  }

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
   d96a4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
    }
    uint32_t clusterStartBlock(uint32_t cluster) const {
      return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);
   d96a6:	68eb      	ldr	r3, [r5, #12]
   d96a8:	7c16      	ldrb	r6, [r2, #16]
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
   d96aa:	7914      	ldrb	r4, [r2, #4]
   d96ac:	3b02      	subs	r3, #2
   d96ae:	fa03 f606 	lsl.w	r6, r3, r6
   d96b2:	6953      	ldr	r3, [r2, #20]
   d96b4:	4433      	add	r3, r6
    if (!SdVolume::cacheZeroBlock(block + i - 1)) {
   d96b6:	1e5e      	subs	r6, r3, #1
    return false;
  }

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
   d96b8:	b13c      	cbz	r4, d96ca <_ZN6SdFile13addDirClusterEv+0x34>
    if (!SdVolume::cacheZeroBlock(block + i - 1)) {
   d96ba:	1930      	adds	r0, r6, r4
   d96bc:	f7fa fd62 	bl	d4184 <_ZN8SdVolume14cacheZeroBlockEm>
   d96c0:	2800      	cmp	r0, #0
   d96c2:	d0ed      	beq.n	d96a0 <_ZN6SdFile13addDirClusterEv+0xa>
    return false;
  }

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
   d96c4:	3c01      	subs	r4, #1
   d96c6:	b2e4      	uxtb	r4, r4
   d96c8:	e7f6      	b.n	d96b8 <_ZN6SdFile13addDirClusterEv+0x22>
    if (!SdVolume::cacheZeroBlock(block + i - 1)) {
      return false;
    }
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
   d96ca:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   d96cc:	7c1a      	ldrb	r2, [r3, #16]
   d96ce:	f44f 7300 	mov.w	r3, #512	; 0x200
   d96d2:	4093      	lsls	r3, r2
   d96d4:	69ea      	ldr	r2, [r5, #28]
   d96d6:	4413      	add	r3, r2
   d96d8:	61eb      	str	r3, [r5, #28]
   d96da:	2001      	movs	r0, #1
  return true;
}
   d96dc:	bd70      	pop	{r4, r5, r6, pc}
	...

000d96e0 <_ZN6SdFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
   d96e0:	b510      	push	{r4, lr}
   d96e2:	4604      	mov	r4, r0
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) {
   d96e4:	6940      	ldr	r0, [r0, #20]
   d96e6:	f7fa fd29 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d96ea:	b118      	cbz	r0, d96f4 <_ZN6SdFile13cacheDirEntryEh+0x14>
    return NULL;
  }
  return SdVolume::cacheBuffer_.dir + dirIndex_;
   d96ec:	7e20      	ldrb	r0, [r4, #24]
   d96ee:	4b02      	ldr	r3, [pc, #8]	; (d96f8 <_ZN6SdFile13cacheDirEntryEh+0x18>)
   d96f0:	eb03 1040 	add.w	r0, r3, r0, lsl #5
}
   d96f4:	bd10      	pop	{r4, pc}
   d96f6:	bf00      	nop
   d96f8:	2003db04 	.word	0x2003db04

000d96fc <_ZN6SdFile7dirNameERK14directoryEntryPc>:
   \a name in standard 8.3 short name format.

   \param[in] dir The directory structure containing the name.
   \param[out] name A 13 byte char array for the formatted name.
*/
void SdFile::dirName(const dir_t& dir, char* name) {
   d96fc:	2200      	movs	r2, #0
   d96fe:	b570      	push	{r4, r5, r6, lr}
   d9700:	3801      	subs	r0, #1
  uint8_t j = 0;
   d9702:	4613      	mov	r3, r2
  for (uint8_t i = 0; i < 11; i++) {
    if (dir.name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      name[j++] = '.';
   d9704:	242e      	movs	r4, #46	; 0x2e
   \param[out] name A 13 byte char array for the formatted name.
*/
void SdFile::dirName(const dir_t& dir, char* name) {
  uint8_t j = 0;
  for (uint8_t i = 0; i < 11; i++) {
    if (dir.name[i] == ' ') {
   d9706:	f810 5f01 	ldrb.w	r5, [r0, #1]!
   d970a:	2d20      	cmp	r5, #32
   d970c:	d008      	beq.n	d9720 <_ZN6SdFile7dirNameERK14directoryEntryPc+0x24>
      continue;
    }
    if (i == 8) {
   d970e:	2a08      	cmp	r2, #8
      name[j++] = '.';
   d9710:	bf02      	ittt	eq
   d9712:	54cc      	strbeq	r4, [r1, r3]
   d9714:	1c5d      	addeq	r5, r3, #1
   d9716:	b2eb      	uxtbeq	r3, r5
    }
    name[j++] = dir.name[i];
   d9718:	1c5d      	adds	r5, r3, #1
   d971a:	7806      	ldrb	r6, [r0, #0]
   d971c:	54ce      	strb	r6, [r1, r3]
   d971e:	b2eb      	uxtb	r3, r5
   d9720:	3201      	adds	r2, #1
   \param[in] dir The directory structure containing the name.
   \param[out] name A 13 byte char array for the formatted name.
*/
void SdFile::dirName(const dir_t& dir, char* name) {
  uint8_t j = 0;
  for (uint8_t i = 0; i < 11; i++) {
   d9722:	2a0b      	cmp	r2, #11
   d9724:	d1ef      	bne.n	d9706 <_ZN6SdFile7dirNameERK14directoryEntryPc+0xa>
    if (i == 8) {
      name[j++] = '.';
    }
    name[j++] = dir.name[i];
  }
  name[j] = 0;
   d9726:	2200      	movs	r2, #0
   d9728:	54ca      	strb	r2, [r1, r3]
   d972a:	bd70      	pop	{r4, r5, r6, pc}

000d972c <_ZN6SdFile10make83NameEPKcPh>:
    }
  }
}
//------------------------------------------------------------------------------
// format directory name field from a 8.3 name string
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
   d972c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   d9730:	460d      	mov	r5, r1
   d9732:	1e4b      	subs	r3, r1, #1
   d9734:	f101 020a 	add.w	r2, r1, #10
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) {
    name[i++] = ' ';
   d9738:	2120      	movs	r1, #32
   d973a:	f803 1f01 	strb.w	r1, [r3, #1]!
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) {
   d973e:	4293      	cmp	r3, r2
   d9740:	d1fb      	bne.n	d973a <_ZN6SdFile10make83NameEPKcPh+0xe>
   d9742:	1e46      	subs	r6, r0, #1
   d9744:	2200      	movs	r2, #0
   d9746:	f04f 0e07 	mov.w	lr, #7
    name[i++] = ' ';
  }
  i = 0;
  while ((c = *str++) != '\0') {
   d974a:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   d974e:	b383      	cbz	r3, d97b2 <_ZN6SdFile10make83NameEPKcPh+0x86>
    if (c == '.') {
   d9750:	2b2e      	cmp	r3, #46	; 0x2e
   d9752:	d106      	bne.n	d9762 <_ZN6SdFile10make83NameEPKcPh+0x36>
      if (n == 10) {
   d9754:	f1be 0f0a 	cmp.w	lr, #10
   d9758:	d030      	beq.n	d97bc <_ZN6SdFile10make83NameEPKcPh+0x90>
        return false;  // only one dot allowed
      }
      n = 10;  // max index for full 8.3 name
      i = 8;   // place for extension
   d975a:	2208      	movs	r2, #8
  while ((c = *str++) != '\0') {
    if (c == '.') {
      if (n == 10) {
        return false;  // only one dot allowed
      }
      n = 10;  // max index for full 8.3 name
   d975c:	f04f 0e0a 	mov.w	lr, #10
   d9760:	e7f3      	b.n	d974a <_ZN6SdFile10make83NameEPKcPh+0x1e>
      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
      while ((b = pgm_read_byte(p++))) if (b == c) {
          return false;
        }
      #elif defined(__arm__)
      const uint8_t valid[] = "|<>^+=?/[];,*\"\\";
   d9762:	4c18      	ldr	r4, [pc, #96]	; (d97c4 <_ZN6SdFile10make83NameEPKcPh+0x98>)
   d9764:	46ec      	mov	ip, sp
   d9766:	f104 0810 	add.w	r8, r4, #16
   d976a:	6820      	ldr	r0, [r4, #0]
   d976c:	6861      	ldr	r1, [r4, #4]
   d976e:	4667      	mov	r7, ip
   d9770:	c703      	stmia	r7!, {r0, r1}
   d9772:	3408      	adds	r4, #8
   d9774:	4544      	cmp	r4, r8
   d9776:	46bc      	mov	ip, r7
   d9778:	d1f7      	bne.n	d976a <_ZN6SdFile10make83NameEPKcPh+0x3e>
   d977a:	f10d 30ff 	add.w	r0, sp, #4294967295
      const uint8_t *p = valid;
      while ((b = *p++)) if (b == c) {
   d977e:	f810 1f01 	ldrb.w	r1, [r0, #1]!
   d9782:	b111      	cbz	r1, d978a <_ZN6SdFile10make83NameEPKcPh+0x5e>
   d9784:	428b      	cmp	r3, r1
   d9786:	d1fa      	bne.n	d977e <_ZN6SdFile10make83NameEPKcPh+0x52>
   d9788:	e018      	b.n	d97bc <_ZN6SdFile10make83NameEPKcPh+0x90>
          return false;
        }
      #endif
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E) {
   d978a:	4596      	cmp	lr, r2
   d978c:	d316      	bcc.n	d97bc <_ZN6SdFile10make83NameEPKcPh+0x90>
   d978e:	f1a3 0121 	sub.w	r1, r3, #33	; 0x21
   d9792:	295d      	cmp	r1, #93	; 0x5d
   d9794:	d812      	bhi.n	d97bc <_ZN6SdFile10make83NameEPKcPh+0x90>
        return false;
      }
      // only upper case allowed in 8.3 names - convert lower to upper
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
   d9796:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
   d979a:	2819      	cmp	r0, #25
   d979c:	f102 0101 	add.w	r1, r2, #1
   d97a0:	bf98      	it	ls
   d97a2:	3b20      	subls	r3, #32
   d97a4:	442a      	add	r2, r5
   d97a6:	b2c9      	uxtb	r1, r1
   d97a8:	bf98      	it	ls
   d97aa:	b2db      	uxtbls	r3, r3
   d97ac:	7013      	strb	r3, [r2, #0]
   d97ae:	460a      	mov	r2, r1
   d97b0:	e7cb      	b.n	d974a <_ZN6SdFile10make83NameEPKcPh+0x1e>
    }
  }
  // must have a file name, extension is optional
  return name[0] != ' ';
   d97b2:	7828      	ldrb	r0, [r5, #0]
   d97b4:	3820      	subs	r0, #32
   d97b6:	bf18      	it	ne
   d97b8:	2001      	movne	r0, #1
   d97ba:	e000      	b.n	d97be <_ZN6SdFile10make83NameEPKcPh+0x92>
  }
  i = 0;
  while ((c = *str++) != '\0') {
    if (c == '.') {
      if (n == 10) {
        return false;  // only one dot allowed
   d97bc:	2000      	movs	r0, #0
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
    }
  }
  // must have a file name, extension is optional
  return name[0] != ' ';
}
   d97be:	b004      	add	sp, #16
   d97c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   d97c4:	000e2340 	.word	0x000e2340

000d97c8 <_ZN6SdFile8openRootEP8SdVolume>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the FAT volume has not been initialized
   or it a FAT12 volume.
*/
uint8_t SdFile::openRoot(SdVolume* vol) {
   d97c8:	b538      	push	{r3, r4, r5, lr}
  // error if file is already open
  if (isOpen()) {
   d97ca:	7a42      	ldrb	r2, [r0, #9]
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the FAT volume has not been initialized
   or it a FAT12 volume.
*/
uint8_t SdFile::openRoot(SdVolume* vol) {
   d97cc:	4604      	mov	r4, r0
   d97ce:	460d      	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
   d97d0:	b10a      	cbz	r2, d97d6 <_ZN6SdFile8openRootEP8SdVolume+0xe>
    return false;
   d97d2:	2000      	movs	r0, #0
   d97d4:	bd38      	pop	{r3, r4, r5, pc}
   d97d6:	f891 3020 	ldrb.w	r3, [r1, #32]
  }

  if (vol->fatType() == 16) {
   d97da:	2b10      	cmp	r3, #16
   d97dc:	d106      	bne.n	d97ec <_ZN6SdFile8openRootEP8SdVolume+0x24>
    type_ = FAT_FILE_TYPE_ROOT16;
   d97de:	2302      	movs	r3, #2
   d97e0:	7243      	strb	r3, [r0, #9]
    firstCluster_ = 0;
   d97e2:	6202      	str	r2, [r0, #32]
    fileSize_ = 32 * vol->rootDirEntryCount();
   d97e4:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
   d97e6:	015b      	lsls	r3, r3, #5
   d97e8:	61c3      	str	r3, [r0, #28]
   d97ea:	e00c      	b.n	d9806 <_ZN6SdFile8openRootEP8SdVolume+0x3e>
  } else if (vol->fatType() == 32) {
   d97ec:	2b20      	cmp	r3, #32
   d97ee:	d1f0      	bne.n	d97d2 <_ZN6SdFile8openRootEP8SdVolume+0xa>
    type_ = FAT_FILE_TYPE_ROOT32;
   d97f0:	2303      	movs	r3, #3
   d97f2:	7243      	strb	r3, [r0, #9]
   d97f4:	6a49      	ldr	r1, [r1, #36]	; 0x24
    firstCluster_ = vol->rootDirStart();
   d97f6:	6201      	str	r1, [r0, #32]
    if (!vol->chainSize(firstCluster_, &fileSize_)) {
   d97f8:	f100 021c 	add.w	r2, r0, #28
   d97fc:	4628      	mov	r0, r5
   d97fe:	f7fa fd11 	bl	d4224 <_ZNK8SdVolume9chainSizeEmPm>
   d9802:	2800      	cmp	r0, #0
   d9804:	d0e5      	beq.n	d97d2 <_ZN6SdFile8openRootEP8SdVolume+0xa>
  vol_ = vol;
  // read only
  flags_ = O_READ;

  // set to start of file
  curCluster_ = 0;
   d9806:	2300      	movs	r3, #0
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
  // read only
  flags_ = O_READ;
   d9808:	2001      	movs	r0, #1
    }
  } else {
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
   d980a:	6265      	str	r5, [r4, #36]	; 0x24
  // read only
  flags_ = O_READ;
   d980c:	7220      	strb	r0, [r4, #8]

  // set to start of file
  curCluster_ = 0;
   d980e:	60e3      	str	r3, [r4, #12]
  curPosition_ = 0;
   d9810:	6123      	str	r3, [r4, #16]

  // root has no directory entry
  dirBlock_ = 0;
   d9812:	6163      	str	r3, [r4, #20]
  dirIndex_ = 0;
   d9814:	7623      	strb	r3, [r4, #24]
  return true;
}
   d9816:	bd38      	pop	{r3, r4, r5, pc}

000d9818 <_ZN6SdFile4readEPvt>:
   if end of file is reached.
   If an error occurs, read() returns -1.  Possible errors include
   read() called before a file has been opened, corrupt file system
   or an I/O error occurred.
*/
int16_t SdFile::read(void* buf, uint16_t nbyte) {
   d9818:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) {
   d981c:	7a43      	ldrb	r3, [r0, #9]
   if end of file is reached.
   If an error occurs, read() returns -1.  Possible errors include
   read() called before a file has been opened, corrupt file system
   or an I/O error occurred.
*/
int16_t SdFile::read(void* buf, uint16_t nbyte) {
   d981e:	4604      	mov	r4, r0
   d9820:	4689      	mov	r9, r1
   d9822:	4617      	mov	r7, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) {
   d9824:	b913      	cbnz	r3, d982c <_ZN6SdFile4readEPvt+0x14>
    return -1;
   d9826:	f04f 30ff 	mov.w	r0, #4294967295
   d982a:	e06d      	b.n	d9908 <_ZN6SdFile4readEPvt+0xf0>
*/
int16_t SdFile::read(void* buf, uint16_t nbyte) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) {
   d982c:	7a03      	ldrb	r3, [r0, #8]
   d982e:	07da      	lsls	r2, r3, #31
   d9830:	d5f9      	bpl.n	d9826 <_ZN6SdFile4readEPvt+0xe>
    return -1;
  }

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) {
   d9832:	69c3      	ldr	r3, [r0, #28]
   d9834:	6902      	ldr	r2, [r0, #16]
   d9836:	1a9b      	subs	r3, r3, r2
   d9838:	429f      	cmp	r7, r3
   d983a:	d900      	bls.n	d983e <_ZN6SdFile4readEPvt+0x26>
    nbyte = fileSize_ - curPosition_;
   d983c:	b29f      	uxth	r7, r3
      n = 512 - offset;
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
        block != SdVolume::cacheBlockNumber_) {
   d983e:	f8df a0d4 	ldr.w	sl, [pc, #212]	; d9914 <_ZN6SdFile4readEPvt+0xfc>
    uint8_t readBlock(uint32_t block, uint8_t* dst) {
      return sdCard_->readBlock(block, dst);
    }
    uint8_t readData(uint32_t block, uint16_t offset,
                     uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
   d9842:	f8df b0d4 	ldr.w	fp, [pc, #212]	; d9918 <_ZN6SdFile4readEPvt+0x100>
  if (nbyte > (fileSize_ - curPosition_)) {
    nbyte = fileSize_ - curPosition_;
  }

  // amount left to read
  uint16_t toRead = nbyte;
   d9846:	46b8      	mov	r8, r7
  while (toRead > 0) {
   d9848:	f1b8 0f00 	cmp.w	r8, #0
   d984c:	d035      	beq.n	d98ba <_ZN6SdFile4readEPvt+0xa2>
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
   d984e:	7a63      	ldrb	r3, [r4, #9]

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
   d9850:	6922      	ldr	r2, [r4, #16]
   d9852:	6a60      	ldr	r0, [r4, #36]	; 0x24
    if (type_ == FAT_FILE_TYPE_ROOT16) {
   d9854:	2b02      	cmp	r3, #2

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
   d9856:	f3c2 0608 	ubfx	r6, r2, #0, #9
   d985a:	ea4f 2352 	mov.w	r3, r2, lsr #9
    if (type_ == FAT_FILE_TYPE_ROOT16) {
   d985e:	d102      	bne.n	d9866 <_ZN6SdFile4readEPvt+0x4e>
      block = vol_->rootDirStart() + (curPosition_ >> 9);
   d9860:	6a40      	ldr	r0, [r0, #36]	; 0x24
   d9862:	4418      	add	r0, r3
   d9864:	e018      	b.n	d9898 <_ZN6SdFile4readEPvt+0x80>
    uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
    uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
    //----------------------------------------------------------------------------
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
   d9866:	7905      	ldrb	r5, [r0, #4]
   d9868:	3d01      	subs	r5, #1
   d986a:	401d      	ands	r5, r3
   d986c:	b2ed      	uxtb	r5, r5
    } else {
      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
      if (offset == 0 && blockOfCluster == 0) {
   d986e:	b95e      	cbnz	r6, d9888 <_ZN6SdFile4readEPvt+0x70>
   d9870:	b955      	cbnz	r5, d9888 <_ZN6SdFile4readEPvt+0x70>
        // start of new cluster
        if (curPosition_ == 0) {
   d9872:	b912      	cbnz	r2, d987a <_ZN6SdFile4readEPvt+0x62>
          // use first cluster in file
          curCluster_ = firstCluster_;
   d9874:	6a23      	ldr	r3, [r4, #32]
   d9876:	60e3      	str	r3, [r4, #12]
   d9878:	e006      	b.n	d9888 <_ZN6SdFile4readEPvt+0x70>
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) {
   d987a:	f104 020c 	add.w	r2, r4, #12
   d987e:	68e1      	ldr	r1, [r4, #12]
   d9880:	f7fa fc9e 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d9884:	2800      	cmp	r0, #0
   d9886:	d0ce      	beq.n	d9826 <_ZN6SdFile4readEPvt+0xe>
            return -1;
          }
        }
      }
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   d9888:	6a63      	ldr	r3, [r4, #36]	; 0x24
   d988a:	68e0      	ldr	r0, [r4, #12]
   d988c:	7c1a      	ldrb	r2, [r3, #16]
   d988e:	695b      	ldr	r3, [r3, #20]
   d9890:	3802      	subs	r0, #2
   d9892:	4090      	lsls	r0, r2
   d9894:	4418      	add	r0, r3
   d9896:	4428      	add	r0, r5
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) {
   d9898:	f5c6 7500 	rsb	r5, r6, #512	; 0x200
      n = 512 - offset;
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
   d989c:	7a23      	ldrb	r3, [r4, #8]
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    }
    uint16_t n = toRead;

    // amount to be read from current block
    if (n > (512 - offset)) {
   d989e:	45a8      	cmp	r8, r5
      n = 512 - offset;
   d98a0:	bfcc      	ite	gt
   d98a2:	b2ad      	uxthgt	r5, r5
   d98a4:	4645      	movle	r5, r8
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
   d98a6:	065b      	lsls	r3, r3, #25
   d98a8:	d402      	bmi.n	d98b0 <_ZN6SdFile4readEPvt+0x98>
   d98aa:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
   d98ae:	d11a      	bne.n	d98e6 <_ZN6SdFile4readEPvt+0xce>
   d98b0:	f8da 3000 	ldr.w	r3, [sl]
   d98b4:	4298      	cmp	r0, r3
   d98b6:	d102      	bne.n	d98be <_ZN6SdFile4readEPvt+0xa6>
   d98b8:	e015      	b.n	d98e6 <_ZN6SdFile4readEPvt+0xce>
      }
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
   d98ba:	b238      	sxth	r0, r7
   d98bc:	e024      	b.n	d9908 <_ZN6SdFile4readEPvt+0xf0>
    uint8_t readBlock(uint32_t block, uint8_t* dst) {
      return sdCard_->readBlock(block, dst);
    }
    uint8_t readData(uint32_t block, uint16_t offset,
                     uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
   d98be:	4601      	mov	r1, r0
   d98c0:	f8cd 9000 	str.w	r9, [sp]
   d98c4:	462b      	mov	r3, r5
   d98c6:	4632      	mov	r2, r6
   d98c8:	f8db 0000 	ldr.w	r0, [fp]
   d98cc:	f000 fd54 	bl	da378 <_ZN7Sd2Card8readDataEmttPh>
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
        block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) {
   d98d0:	2800      	cmp	r0, #0
   d98d2:	d0a8      	beq.n	d9826 <_ZN6SdFile4readEPvt+0xe>
      uint8_t* end = src + n;
      while (src != end) {
        *dst++ = *src++;
      }
    }
    curPosition_ += n;
   d98d4:	6923      	ldr	r3, [r4, #16]
    toRead -= n;
   d98d6:	ebc5 0808 	rsb	r8, r5, r8
      uint8_t* end = src + n;
      while (src != end) {
        *dst++ = *src++;
      }
    }
    curPosition_ += n;
   d98da:	442b      	add	r3, r5
   d98dc:	44a9      	add	r9, r5
   d98de:	6123      	str	r3, [r4, #16]
    toRead -= n;
   d98e0:	fa1f f888 	uxth.w	r8, r8
    nbyte = fileSize_ - curPosition_;
  }

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
   d98e4:	e7b0      	b.n	d9848 <_ZN6SdFile4readEPvt+0x30>
        return -1;
      }
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) {
   d98e6:	2100      	movs	r1, #0
   d98e8:	f7fa fc28 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d98ec:	2800      	cmp	r0, #0
   d98ee:	d09a      	beq.n	d9826 <_ZN6SdFile4readEPvt+0xe>
        return -1;
      }
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
   d98f0:	4b07      	ldr	r3, [pc, #28]	; (d9910 <_ZN6SdFile4readEPvt+0xf8>)
   d98f2:	441e      	add	r6, r3
      uint8_t* end = src + n;
   d98f4:	1971      	adds	r1, r6, r5
   d98f6:	f109 33ff 	add.w	r3, r9, #4294967295
      while (src != end) {
   d98fa:	428e      	cmp	r6, r1
   d98fc:	d0ea      	beq.n	d98d4 <_ZN6SdFile4readEPvt+0xbc>
        *dst++ = *src++;
   d98fe:	f816 2b01 	ldrb.w	r2, [r6], #1
   d9902:	f803 2f01 	strb.w	r2, [r3, #1]!
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) {
        return -1;
      }
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
      uint8_t* end = src + n;
      while (src != end) {
   d9906:	e7f8      	b.n	d98fa <_ZN6SdFile4readEPvt+0xe2>
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
}
   d9908:	b003      	add	sp, #12
   d990a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d990e:	bf00      	nop
   d9910:	2003db04 	.word	0x2003db04
   d9914:	2003d66c 	.word	0x2003d66c
   d9918:	2003db00 	.word	0x2003db00

000d991c <_ZN6SdFile7readDirEP14directoryEntry>:
   A value of zero will be returned if end of file is reached.
   If an error occurs, readDir() returns -1.  Possible errors include
   readDir() called before a directory has been opened, this is not
   a directory file or an I/O error occurred.
*/
int8_t SdFile::readDir(dir_t* dir) {
   d991c:	b538      	push	{r3, r4, r5, lr}
  int8_t n;
  // if not a directory file or miss-positioned return an error
  if (!isDir() || (0X1F & curPosition_)) {
   d991e:	7a43      	ldrb	r3, [r0, #9]
   d9920:	2b01      	cmp	r3, #1
   A value of zero will be returned if end of file is reached.
   If an error occurs, readDir() returns -1.  Possible errors include
   readDir() called before a directory has been opened, this is not
   a directory file or an I/O error occurred.
*/
int8_t SdFile::readDir(dir_t* dir) {
   d9922:	4605      	mov	r5, r0
   d9924:	460c      	mov	r4, r1
  int8_t n;
  // if not a directory file or miss-positioned return an error
  if (!isDir() || (0X1F & curPosition_)) {
   d9926:	d916      	bls.n	d9956 <_ZN6SdFile7readDirEP14directoryEntry+0x3a>
   d9928:	6903      	ldr	r3, [r0, #16]
   d992a:	06da      	lsls	r2, r3, #27
   d992c:	d113      	bne.n	d9956 <_ZN6SdFile7readDirEP14directoryEntry+0x3a>
    return -1;
  }

  while ((n = read(dir, sizeof(dir_t))) == sizeof(dir_t)) {
   d992e:	2220      	movs	r2, #32
   d9930:	4621      	mov	r1, r4
   d9932:	4628      	mov	r0, r5
   d9934:	f7ff ff70 	bl	d9818 <_ZN6SdFile4readEPvt>
   d9938:	b240      	sxtb	r0, r0
   d993a:	2820      	cmp	r0, #32
   d993c:	d109      	bne.n	d9952 <_ZN6SdFile7readDirEP14directoryEntry+0x36>
    // last entry if DIR_NAME_FREE
    if (dir->name[0] == DIR_NAME_FREE) {
   d993e:	7823      	ldrb	r3, [r4, #0]
   d9940:	b163      	cbz	r3, d995c <_ZN6SdFile7readDirEP14directoryEntry+0x40>
      break;
    }
    // skip empty entries and entry for .  and ..
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
   d9942:	2be5      	cmp	r3, #229	; 0xe5
   d9944:	d0f3      	beq.n	d992e <_ZN6SdFile7readDirEP14directoryEntry+0x12>
   d9946:	2b2e      	cmp	r3, #46	; 0x2e
   d9948:	d0f1      	beq.n	d992e <_ZN6SdFile7readDirEP14directoryEntry+0x12>
      continue;
    }
    // return if normal file or subdirectory
    if (DIR_IS_FILE_OR_SUBDIR(dir)) {
   d994a:	7ae3      	ldrb	r3, [r4, #11]
   d994c:	071b      	lsls	r3, r3, #28
   d994e:	d4ee      	bmi.n	d992e <_ZN6SdFile7readDirEP14directoryEntry+0x12>
   d9950:	bd38      	pop	{r3, r4, r5, pc}
      return n;
    }
  }
  // error, end of file, or past last entry
  return n < 0 ? -1 : 0;
   d9952:	17c0      	asrs	r0, r0, #31
   d9954:	bd38      	pop	{r3, r4, r5, pc}
*/
int8_t SdFile::readDir(dir_t* dir) {
  int8_t n;
  // if not a directory file or miss-positioned return an error
  if (!isDir() || (0X1F & curPosition_)) {
    return -1;
   d9956:	f04f 30ff 	mov.w	r0, #4294967295
   d995a:	bd38      	pop	{r3, r4, r5, pc}
    if (DIR_IS_FILE_OR_SUBDIR(dir)) {
      return n;
    }
  }
  // error, end of file, or past last entry
  return n < 0 ? -1 : 0;
   d995c:	4618      	mov	r0, r3
}
   d995e:	bd38      	pop	{r3, r4, r5, pc}

000d9960 <_ZN6SdFile12readDirCacheEv>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
   d9960:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // error if not directory
  if (!isDir()) {
   d9962:	7a43      	ldrb	r3, [r0, #9]
   d9964:	2b01      	cmp	r3, #1
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
   d9966:	4604      	mov	r4, r0
  // error if not directory
  if (!isDir()) {
   d9968:	d801      	bhi.n	d996e <_ZN6SdFile12readDirCacheEv+0xe>
    return NULL;
   d996a:	2000      	movs	r0, #0
   d996c:	e00f      	b.n	d998e <_ZN6SdFile12readDirCacheEv+0x2e>
  }

  // index of entry in cache
  uint8_t i = (curPosition_ >> 5) & 0XF;
   d996e:	6903      	ldr	r3, [r0, #16]
       \return For success read returns the next byte in the file as an int.
       If an error occurs or end of file is reached -1 is returned.
    */
    int16_t read(void) {
      uint8_t b;
      return read(&b, 1) == 1 ? b : -1;
   d9970:	2201      	movs	r2, #1
   d9972:	f10d 0107 	add.w	r1, sp, #7
   d9976:	f3c3 1543 	ubfx	r5, r3, #5, #4
   d997a:	f7ff ff4d 	bl	d9818 <_ZN6SdFile4readEPvt>
   d997e:	2801      	cmp	r0, #1
   d9980:	d1f3      	bne.n	d996a <_ZN6SdFile12readDirCacheEv+0xa>
  if (read() < 0) {
    return NULL;
  }

  // advance to next entry
  curPosition_ += 31;
   d9982:	6923      	ldr	r3, [r4, #16]

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
   d9984:	4803      	ldr	r0, [pc, #12]	; (d9994 <_ZN6SdFile12readDirCacheEv+0x34>)
  if (read() < 0) {
    return NULL;
  }

  // advance to next entry
  curPosition_ += 31;
   d9986:	331f      	adds	r3, #31
   d9988:	6123      	str	r3, [r4, #16]

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
   d998a:	eb00 1045 	add.w	r0, r0, r5, lsl #5
}
   d998e:	b003      	add	sp, #12
   d9990:	bd30      	pop	{r4, r5, pc}
   d9992:	bf00      	nop
   d9994:	2003db04 	.word	0x2003db04

000d9998 <_ZN6SdFile7seekSetEm>:
   \param[in] pos The new position in bytes from the beginning of the file.

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t SdFile::seekSet(uint32_t pos) {
   d9998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   d999a:	7a43      	ldrb	r3, [r0, #9]
   d999c:	4604      	mov	r4, r0
   d999e:	460e      	mov	r6, r1
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) {
   d99a0:	b90b      	cbnz	r3, d99a6 <_ZN6SdFile7seekSetEm+0xe>
    return false;
   d99a2:	2000      	movs	r0, #0
   d99a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t SdFile::seekSet(uint32_t pos) {
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) {
   d99a6:	69c2      	ldr	r2, [r0, #28]
   d99a8:	428a      	cmp	r2, r1
   d99aa:	d3fa      	bcc.n	d99a2 <_ZN6SdFile7seekSetEm+0xa>
    return false;
  }

  if (type_ == FAT_FILE_TYPE_ROOT16) {
   d99ac:	2b02      	cmp	r3, #2
   d99ae:	d001      	beq.n	d99b4 <_ZN6SdFile7seekSetEm+0x1c>
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
   d99b0:	b91e      	cbnz	r6, d99ba <_ZN6SdFile7seekSetEm+0x22>
    // set position to start of file
    curCluster_ = 0;
   d99b2:	60e6      	str	r6, [r4, #12]
    curPosition_ = 0;
   d99b4:	6126      	str	r6, [r4, #16]
    return true;
   d99b6:	2001      	movs	r0, #1
   d99b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   d99ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
   d99bc:	6920      	ldr	r0, [r4, #16]
   d99be:	7c1b      	ldrb	r3, [r3, #16]
   d99c0:	1e42      	subs	r2, r0, #1
   d99c2:	f103 0109 	add.w	r1, r3, #9
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   d99c6:	1e73      	subs	r3, r6, #1
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   d99c8:	40ca      	lsrs	r2, r1
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   d99ca:	40cb      	lsrs	r3, r1

  if (nNew < nCur || curPosition_ == 0) {
   d99cc:	429a      	cmp	r2, r3
   d99ce:	d800      	bhi.n	d99d2 <_ZN6SdFile7seekSetEm+0x3a>
   d99d0:	b928      	cbnz	r0, d99de <_ZN6SdFile7seekSetEm+0x46>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
   d99d2:	6a22      	ldr	r2, [r4, #32]
   d99d4:	60e2      	str	r2, [r4, #12]
   \param[in] pos The new position in bytes from the beginning of the file.

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t SdFile::seekSet(uint32_t pos) {
   d99d6:	461d      	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) {
   d99d8:	f104 070c 	add.w	r7, r4, #12
   d99dc:	e009      	b.n	d99f2 <_ZN6SdFile7seekSetEm+0x5a>
  if (nNew < nCur || curPosition_ == 0) {
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
   d99de:	1a9b      	subs	r3, r3, r2
   d99e0:	e7f9      	b.n	d99d6 <_ZN6SdFile7seekSetEm+0x3e>
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) {
   d99e2:	463a      	mov	r2, r7
   d99e4:	68e1      	ldr	r1, [r4, #12]
   d99e6:	6a60      	ldr	r0, [r4, #36]	; 0x24
   d99e8:	f7fa fbea 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d99ec:	3d01      	subs	r5, #1
   d99ee:	2800      	cmp	r0, #0
   d99f0:	d0d7      	beq.n	d99a2 <_ZN6SdFile7seekSetEm+0xa>
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
   d99f2:	2d00      	cmp	r5, #0
   d99f4:	d1f5      	bne.n	d99e2 <_ZN6SdFile7seekSetEm+0x4a>
   d99f6:	e7dd      	b.n	d99b4 <_ZN6SdFile7seekSetEm+0x1c>

000d99f8 <_ZN6SdFile4syncEh>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include a call to sync() before a file has been
   opened or an I/O error.
*/
uint8_t SdFile::sync(uint8_t blocking) {
   d99f8:	b570      	push	{r4, r5, r6, lr}
  // only allow open files and directories
  if (!isOpen()) {
   d99fa:	7a43      	ldrb	r3, [r0, #9]
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include a call to sync() before a file has been
   opened or an I/O error.
*/
uint8_t SdFile::sync(uint8_t blocking) {
   d99fc:	4604      	mov	r4, r0
   d99fe:	460e      	mov	r6, r1
  // only allow open files and directories
  if (!isOpen()) {
   d9a00:	b343      	cbz	r3, d9a54 <_ZN6SdFile4syncEh+0x5c>
    return false;
  }

  if (flags_ & F_FILE_DIR_DIRTY) {
   d9a02:	f990 3008 	ldrsb.w	r3, [r0, #8]
   d9a06:	2b00      	cmp	r3, #0
   d9a08:	da1a      	bge.n	d9a40 <_ZN6SdFile4syncEh+0x48>
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   d9a0a:	2101      	movs	r1, #1
   d9a0c:	f7ff fe68 	bl	d96e0 <_ZN6SdFile13cacheDirEntryEh>
    if (!d) {
   d9a10:	4605      	mov	r5, r0
   d9a12:	b1f8      	cbz	r0, d9a54 <_ZN6SdFile4syncEh+0x5c>
      return false;
    }

    // do not set filesize for dir files
    if (!isDir()) {
   d9a14:	7a63      	ldrb	r3, [r4, #9]
   d9a16:	2b01      	cmp	r3, #1
      d->fileSize = fileSize_;
   d9a18:	bf9c      	itt	ls
   d9a1a:	69e3      	ldrls	r3, [r4, #28]
   d9a1c:	61c3      	strls	r3, [r0, #28]
    }

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
   d9a1e:	8c23      	ldrh	r3, [r4, #32]
   d9a20:	8343      	strh	r3, [r0, #26]
    d->firstClusterHigh = firstCluster_ >> 16;
   d9a22:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   d9a24:	8283      	strh	r3, [r0, #20]

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
   d9a26:	4b0c      	ldr	r3, [pc, #48]	; (d9a58 <_ZN6SdFile4syncEh+0x60>)
   d9a28:	681b      	ldr	r3, [r3, #0]
   d9a2a:	b12b      	cbz	r3, d9a38 <_ZN6SdFile4syncEh+0x40>
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
   d9a2c:	f100 0116 	add.w	r1, r0, #22
   d9a30:	3018      	adds	r0, #24
   d9a32:	4798      	blx	r3
      d->lastAccessDate = d->lastWriteDate;
   d9a34:	8b2b      	ldrh	r3, [r5, #24]
   d9a36:	826b      	strh	r3, [r5, #18]
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
   d9a38:	7a23      	ldrb	r3, [r4, #8]
   d9a3a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   d9a3e:	7223      	strb	r3, [r4, #8]
  }

  if (!blocking) {
   d9a40:	b91e      	cbnz	r6, d9a4a <_ZN6SdFile4syncEh+0x52>
    flags_ &= ~F_FILE_NON_BLOCKING_WRITE;
   d9a42:	7a23      	ldrb	r3, [r4, #8]
   d9a44:	f023 0310 	bic.w	r3, r3, #16
   d9a48:	7223      	strb	r3, [r4, #8]
  }

  return SdVolume::cacheFlush(blocking);
   d9a4a:	4630      	mov	r0, r6
}
   d9a4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  if (!blocking) {
    flags_ &= ~F_FILE_NON_BLOCKING_WRITE;
  }

  return SdVolume::cacheFlush(blocking);
   d9a50:	f7fa bb52 	b.w	d40f8 <_ZN8SdVolume10cacheFlushEh>
}
   d9a54:	2000      	movs	r0, #0
   d9a56:	bd70      	pop	{r4, r5, r6, pc}
   d9a58:	2003e3b0 	.word	0x2003e3b0

000d9a5c <_ZN6SdFile5closeEv>:

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include no file is open or an I/O error.
*/
uint8_t SdFile::close(void) {
   d9a5c:	b510      	push	{r4, lr}
  if (!sync()) {
   d9a5e:	2101      	movs	r1, #1

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include no file is open or an I/O error.
*/
uint8_t SdFile::close(void) {
   d9a60:	4604      	mov	r4, r0
  if (!sync()) {
   d9a62:	f7ff ffc9 	bl	d99f8 <_ZN6SdFile4syncEh>
   d9a66:	b110      	cbz	r0, d9a6e <_ZN6SdFile5closeEv+0x12>
    return false;
  }
  type_ = FAT_FILE_TYPE_CLOSED;
   d9a68:	2300      	movs	r3, #0
   d9a6a:	7263      	strb	r3, [r4, #9]
  return true;
   d9a6c:	2001      	movs	r0, #1
}
   d9a6e:	bd10      	pop	{r4, pc}

000d9a70 <_ZN6SdFile8truncateEm>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include file is read only, file is a directory,
   \a length is greater than the current file size or an I/O error occurs.
*/
uint8_t SdFile::truncate(uint32_t length) {
   d9a70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  // error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
   d9a72:	7a43      	ldrb	r3, [r0, #9]
   d9a74:	2b01      	cmp	r3, #1
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include file is read only, file is a directory,
   \a length is greater than the current file size or an I/O error occurs.
*/
uint8_t SdFile::truncate(uint32_t length) {
   d9a76:	4604      	mov	r4, r0
   d9a78:	460d      	mov	r5, r1
  // error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
   d9a7a:	d10b      	bne.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
   d9a7c:	7a02      	ldrb	r2, [r0, #8]
   d9a7e:	0792      	lsls	r2, r2, #30
   d9a80:	d508      	bpl.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
    return false;
  }

  // error if length is greater than current size
  if (length > fileSize_) {
   d9a82:	69c2      	ldr	r2, [r0, #28]
   d9a84:	428a      	cmp	r2, r1
   d9a86:	d305      	bcc.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
    return false;
  }

  // fileSize and length are zero - nothing to do
  if (fileSize_ == 0) {
   d9a88:	2a00      	cmp	r2, #0
   d9a8a:	d040      	beq.n	d9b0e <_ZN6SdFile8truncateEm+0x9e>
    return true;
  }

  // remember position for seek after truncation
  uint32_t newPos = curPosition_ > length ? length : curPosition_;
   d9a8c:	6926      	ldr	r6, [r4, #16]

  // position to last cluster in truncated file
  if (!seekSet(length)) {
   d9a8e:	f7ff ff83 	bl	d9998 <_ZN6SdFile7seekSetEm>
   d9a92:	b908      	cbnz	r0, d9a98 <_ZN6SdFile8truncateEm+0x28>
    }
    firstCluster_ = 0;
  } else {
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) {
      return false;
   d9a94:	2000      	movs	r0, #0
   d9a96:	e03b      	b.n	d9b10 <_ZN6SdFile8truncateEm+0xa0>
  // position to last cluster in truncated file
  if (!seekSet(length)) {
    return false;
  }

  if (length == 0) {
   d9a98:	b93d      	cbnz	r5, d9aaa <_ZN6SdFile8truncateEm+0x3a>
    // free all clusters
    if (!vol_->freeChain(firstCluster_)) {
   d9a9a:	6a21      	ldr	r1, [r4, #32]
   d9a9c:	6a60      	ldr	r0, [r4, #36]	; 0x24
   d9a9e:	f7fa fc85 	bl	d43ac <_ZN8SdVolume9freeChainEm>
   d9aa2:	2800      	cmp	r0, #0
   d9aa4:	d0f6      	beq.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
      return false;
    }
    firstCluster_ = 0;
   d9aa6:	6225      	str	r5, [r4, #32]
   d9aa8:	e01e      	b.n	d9ae8 <_ZN6SdFile8truncateEm+0x78>
  } else {
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) {
   d9aaa:	aa01      	add	r2, sp, #4
   d9aac:	68e1      	ldr	r1, [r4, #12]
   d9aae:	6a60      	ldr	r0, [r4, #36]	; 0x24
   d9ab0:	f7fa fb86 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d9ab4:	2800      	cmp	r0, #0
   d9ab6:	d0ed      	beq.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
      return false;
    }

    if (!vol_->isEOC(toFree)) {
   d9ab8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   d9aba:	4b16      	ldr	r3, [pc, #88]	; (d9b14 <_ZN6SdFile8truncateEm+0xa4>)
   d9abc:	f890 7020 	ldrb.w	r7, [r0, #32]
   d9ac0:	9901      	ldr	r1, [sp, #4]
   d9ac2:	f64f 72f8 	movw	r2, #65528	; 0xfff8
   d9ac6:	2f10      	cmp	r7, #16
   d9ac8:	bf08      	it	eq
   d9aca:	4613      	moveq	r3, r2
   d9acc:	4299      	cmp	r1, r3
   d9ace:	d20b      	bcs.n	d9ae8 <_ZN6SdFile8truncateEm+0x78>
      // free extra clusters
      if (!vol_->freeChain(toFree)) {
   d9ad0:	f7fa fc6c 	bl	d43ac <_ZN8SdVolume9freeChainEm>
   d9ad4:	2800      	cmp	r0, #0
   d9ad6:	d0dd      	beq.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
    static uint8_t cacheZeroBlock(uint32_t blockNumber);
    uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
    uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
    uint8_t fatPut(uint32_t cluster, uint32_t value);
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
   d9ad8:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
   d9adc:	68e1      	ldr	r1, [r4, #12]
   d9ade:	6a60      	ldr	r0, [r4, #36]	; 0x24
   d9ae0:	f7fa fbc8 	bl	d4274 <_ZN8SdVolume6fatPutEmm>
        return false;
      }

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) {
   d9ae4:	2800      	cmp	r0, #0
   d9ae6:	d0d5      	beq.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
    }
  }
  fileSize_ = length;

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
   d9ae8:	7a23      	ldrb	r3, [r4, #8]
      if (!vol_->fatPutEOC(curCluster_)) {
        return false;
      }
    }
  }
  fileSize_ = length;
   d9aea:	61e5      	str	r5, [r4, #28]

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
   d9aec:	f063 037f 	orn	r3, r3, #127	; 0x7f
   d9af0:	7223      	strb	r3, [r4, #8]

  if (!sync()) {
   d9af2:	2101      	movs	r1, #1
   d9af4:	4620      	mov	r0, r4
   d9af6:	f7ff ff7f 	bl	d99f8 <_ZN6SdFile4syncEh>
   d9afa:	2800      	cmp	r0, #0
   d9afc:	d0ca      	beq.n	d9a94 <_ZN6SdFile8truncateEm+0x24>
    return false;
  }

  // set file to correct position
  return seekSet(newPos);
   d9afe:	42b5      	cmp	r5, r6
   d9b00:	4629      	mov	r1, r5
   d9b02:	4620      	mov	r0, r4
   d9b04:	bf28      	it	cs
   d9b06:	4631      	movcs	r1, r6
   d9b08:	f7ff ff46 	bl	d9998 <_ZN6SdFile7seekSetEm>
   d9b0c:	e000      	b.n	d9b10 <_ZN6SdFile8truncateEm+0xa0>
    return false;
  }

  // fileSize and length are zero - nothing to do
  if (fileSize_ == 0) {
    return true;
   d9b0e:	4618      	mov	r0, r3
    return false;
  }

  // set file to correct position
  return seekSet(newPos);
}
   d9b10:	b003      	add	sp, #12
   d9b12:	bdf0      	pop	{r4, r5, r6, r7, pc}
   d9b14:	0ffffff8 	.word	0x0ffffff8

000d9b18 <_ZN6SdFile15openCachedEntryEhh>:
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   d9b18:	b538      	push	{r3, r4, r5, lr}
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;
   d9b1a:	4b1d      	ldr	r3, [pc, #116]	; (d9b90 <_ZN6SdFile15openCachedEntryEhh+0x78>)
   d9b1c:	eb03 1341 	add.w	r3, r3, r1, lsl #5
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   d9b20:	4615      	mov	r5, r2
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
   d9b22:	7ada      	ldrb	r2, [r3, #11]
   d9b24:	f012 0f11 	tst.w	r2, #17
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   d9b28:	4604      	mov	r4, r0
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
   d9b2a:	d004      	beq.n	d9b36 <_ZN6SdFile15openCachedEntryEhh+0x1e>
    if (oflag & (O_WRITE | O_TRUNC)) {
   d9b2c:	f015 0f42 	tst.w	r5, #66	; 0x42
   d9b30:	d001      	beq.n	d9b36 <_ZN6SdFile15openCachedEntryEhh+0x1e>
      return false;
   d9b32:	2000      	movs	r0, #0
   d9b34:	bd38      	pop	{r3, r4, r5, pc}
    }
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
  dirBlock_ = SdVolume::cacheBlockNumber_;
   d9b36:	4a17      	ldr	r2, [pc, #92]	; (d9b94 <_ZN6SdFile15openCachedEntryEhh+0x7c>)
    if (oflag & (O_WRITE | O_TRUNC)) {
      return false;
    }
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
   d9b38:	7621      	strb	r1, [r4, #24]
  dirBlock_ = SdVolume::cacheBlockNumber_;
   d9b3a:	6812      	ldr	r2, [r2, #0]
   d9b3c:	6162      	str	r2, [r4, #20]

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
   d9b3e:	8a99      	ldrh	r1, [r3, #20]
   d9b40:	0409      	lsls	r1, r1, #16
   d9b42:	6221      	str	r1, [r4, #32]
  firstCluster_ |= p->firstClusterLow;
   d9b44:	8b5a      	ldrh	r2, [r3, #26]
   d9b46:	4311      	orrs	r1, r2
   d9b48:	6221      	str	r1, [r4, #32]
   d9b4a:	7ada      	ldrb	r2, [r3, #11]

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
   d9b4c:	f012 0218 	ands.w	r2, r2, #24
   d9b50:	d103      	bne.n	d9b5a <_ZN6SdFile15openCachedEntryEhh+0x42>
    fileSize_ = p->fileSize;
   d9b52:	69db      	ldr	r3, [r3, #28]
   d9b54:	61e3      	str	r3, [r4, #28]
    type_ = FAT_FILE_TYPE_NORMAL;
   d9b56:	2301      	movs	r3, #1
   d9b58:	e009      	b.n	d9b6e <_ZN6SdFile15openCachedEntryEhh+0x56>
  } else if (DIR_IS_SUBDIR(p)) {
   d9b5a:	2a10      	cmp	r2, #16
   d9b5c:	d1e9      	bne.n	d9b32 <_ZN6SdFile15openCachedEntryEhh+0x1a>
    if (!vol_->chainSize(firstCluster_, &fileSize_)) {
   d9b5e:	f104 021c 	add.w	r2, r4, #28
   d9b62:	6a60      	ldr	r0, [r4, #36]	; 0x24
   d9b64:	f7fa fb5e 	bl	d4224 <_ZNK8SdVolume9chainSizeEmPm>
   d9b68:	2800      	cmp	r0, #0
   d9b6a:	d0e2      	beq.n	d9b32 <_ZN6SdFile15openCachedEntryEhh+0x1a>
      return false;
    }
    type_ = FAT_FILE_TYPE_SUBDIR;
   d9b6c:	2304      	movs	r3, #4
   d9b6e:	7263      	strb	r3, [r4, #9]
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
   d9b70:	f005 030f 	and.w	r3, r5, #15

  // set to start of file
  curCluster_ = 0;
   d9b74:	2100      	movs	r1, #0
    type_ = FAT_FILE_TYPE_SUBDIR;
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
   d9b76:	7223      	strb	r3, [r4, #8]
  // set to start of file
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) {
   d9b78:	066b      	lsls	r3, r5, #25
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);

  // set to start of file
  curCluster_ = 0;
   d9b7a:	60e1      	str	r1, [r4, #12]
  curPosition_ = 0;
   d9b7c:	6121      	str	r1, [r4, #16]

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) {
   d9b7e:	d504      	bpl.n	d9b8a <_ZN6SdFile15openCachedEntryEhh+0x72>
    return truncate(0);
   d9b80:	4620      	mov	r0, r4
  }
  return true;
}
   d9b82:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  curCluster_ = 0;
  curPosition_ = 0;

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) {
    return truncate(0);
   d9b86:	f7ff bf73 	b.w	d9a70 <_ZN6SdFile8truncateEm>
  }
  return true;
   d9b8a:	2001      	movs	r0, #1
}
   d9b8c:	bd38      	pop	{r3, r4, r5, pc}
   d9b8e:	bf00      	nop
   d9b90:	2003db04 	.word	0x2003db04
   d9b94:	2003d66c 	.word	0x2003d66c

000d9b98 <_ZN6SdFile4openEPS_PKch>:
   the value zero, false, is returned for failure.
   Reasons for failure include this SdFile is already open, \a difFile is not
   a directory, \a fileName is invalid, the file does not exist
   or can't be opened in the access mode specified by oflag.
*/
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
   d9b98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t dname[11];
  dir_t* p;

  // error if already open
  if (isOpen()) {
   d9b9c:	7a44      	ldrb	r4, [r0, #9]
   the value zero, false, is returned for failure.
   Reasons for failure include this SdFile is already open, \a difFile is not
   a directory, \a fileName is invalid, the file does not exist
   or can't be opened in the access mode specified by oflag.
*/
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
   d9b9e:	b085      	sub	sp, #20
   d9ba0:	4606      	mov	r6, r0
   d9ba2:	4688      	mov	r8, r1
   d9ba4:	461f      	mov	r7, r3
  uint8_t dname[11];
  dir_t* p;

  // error if already open
  if (isOpen()) {
   d9ba6:	2c00      	cmp	r4, #0
   d9ba8:	d178      	bne.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
    return false;
  }

  if (!make83Name(fileName, dname)) {
   d9baa:	a901      	add	r1, sp, #4
   d9bac:	4610      	mov	r0, r2
   d9bae:	f7ff fdbd 	bl	d972c <_ZN6SdFile10make83NameEPKcPh>
   d9bb2:	2800      	cmp	r0, #0
   d9bb4:	d072      	beq.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
    return false;
  }
  vol_ = dirFile->vol_;
   d9bb6:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
        emptyFound = true;
        dirIndex_ = index;
        dirBlock_ = SdVolume::cacheBlockNumber_;
   d9bba:	f8df 90fc 	ldr.w	r9, [pc, #252]	; d9cb8 <_ZN6SdFile4openEPS_PKch+0x120>
  }

  if (!make83Name(fileName, dname)) {
    return false;
  }
  vol_ = dirFile->vol_;
   d9bbe:	6273      	str	r3, [r6, #36]	; 0x24
    int8_t readDir(dir_t* dir);
    static uint8_t remove(SdFile* dirFile, const char* fileName);
    uint8_t remove(void);
    /** Set the file's current position to zero. */
    void rewind(void) {
      curPosition_ = curCluster_ = 0;
   d9bc0:	f8c8 400c 	str.w	r4, [r8, #12]
   d9bc4:	f8c8 4010 	str.w	r4, [r8, #16]

  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
   d9bc8:	f8d8 5010 	ldr.w	r5, [r8, #16]
   d9bcc:	f8d8 301c 	ldr.w	r3, [r8, #28]
   d9bd0:	429d      	cmp	r5, r3
   d9bd2:	d221      	bcs.n	d9c18 <_ZN6SdFile4openEPS_PKch+0x80>
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
    p = dirFile->readDirCache();
   d9bd4:	4640      	mov	r0, r8
   d9bd6:	f7ff fec3 	bl	d9960 <_ZN6SdFile12readDirCacheEv>
  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
   d9bda:	f3c5 1543 	ubfx	r5, r5, #5, #4
    p = dirFile->readDirCache();
    if (p == NULL) {
   d9bde:	4601      	mov	r1, r0
   d9be0:	2800      	cmp	r0, #0
   d9be2:	d05b      	beq.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
   d9be4:	7803      	ldrb	r3, [r0, #0]
   d9be6:	b173      	cbz	r3, d9c06 <_ZN6SdFile4openEPS_PKch+0x6e>
   d9be8:	2be5      	cmp	r3, #229	; 0xe5
   d9bea:	d059      	beq.n	d9ca0 <_ZN6SdFile4openEPS_PKch+0x108>
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) {
        break;
      }
    } else if (!memcmp(dname, p->name, 11)) {
   d9bec:	220b      	movs	r2, #11
   d9bee:	a801      	add	r0, sp, #4
   d9bf0:	f006 f9a0 	bl	dff34 <memcmp>
   d9bf4:	2800      	cmp	r0, #0
   d9bf6:	d1e7      	bne.n	d9bc8 <_ZN6SdFile4openEPS_PKch+0x30>
      // don't open existing file if O_CREAT and O_EXCL
      if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) {
   d9bf8:	f007 0330 	and.w	r3, r7, #48	; 0x30
   d9bfc:	2b30      	cmp	r3, #48	; 0x30
   d9bfe:	d04d      	beq.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
        return false;
      }

      // open found file
      return openCachedEntry(0XF & index, oflag);
   d9c00:	463a      	mov	r2, r7
   d9c02:	4629      	mov	r1, r5
   d9c04:	e046      	b.n	d9c94 <_ZN6SdFile4openEPS_PKch+0xfc>
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
   d9c06:	b934      	cbnz	r4, d9c16 <_ZN6SdFile4openEPS_PKch+0x7e>
        emptyFound = true;
        dirIndex_ = index;
        dirBlock_ = SdVolume::cacheBlockNumber_;
   d9c08:	f8d9 3000 	ldr.w	r3, [r9]

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
        emptyFound = true;
        dirIndex_ = index;
   d9c0c:	7635      	strb	r5, [r6, #24]
        dirBlock_ = SdVolume::cacheBlockNumber_;
   d9c0e:	6173      	str	r3, [r6, #20]
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) {
   d9c10:	780b      	ldrb	r3, [r1, #0]
   d9c12:	2b00      	cmp	r3, #0
   d9c14:	d146      	bne.n	d9ca4 <_ZN6SdFile4openEPS_PKch+0x10c>
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
        emptyFound = true;
   d9c16:	2401      	movs	r4, #1
      // open found file
      return openCachedEntry(0XF & index, oflag);
    }
  }
  // only create file if O_CREAT and O_WRITE
  if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) {
   d9c18:	f007 0312 	and.w	r3, r7, #18
   d9c1c:	2b12      	cmp	r3, #18
   d9c1e:	d13d      	bne.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
    return false;
  }

  // cache found slot or add cluster if end of file
  if (emptyFound) {
   d9c20:	b134      	cbz	r4, d9c30 <_ZN6SdFile4openEPS_PKch+0x98>
    p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   d9c22:	2101      	movs	r1, #1
   d9c24:	4630      	mov	r0, r6
   d9c26:	f7ff fd5b 	bl	d96e0 <_ZN6SdFile13cacheDirEntryEh>
    if (!p) {
   d9c2a:	4604      	mov	r4, r0
   d9c2c:	b950      	cbnz	r0, d9c44 <_ZN6SdFile4openEPS_PKch+0xac>
   d9c2e:	e035      	b.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
      return false;
    }
  } else {
    if (dirFile->type_ == FAT_FILE_TYPE_ROOT16) {
   d9c30:	f898 3009 	ldrb.w	r3, [r8, #9]
   d9c34:	2b02      	cmp	r3, #2
   d9c36:	d031      	beq.n	d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
      return false;
    }

    // add and zero cluster for dirFile - first cluster is in cache for write
    if (!dirFile->addDirCluster()) {
   d9c38:	4640      	mov	r0, r8
   d9c3a:	f7ff fd2c 	bl	d9696 <_ZN6SdFile13addDirClusterEv>
   d9c3e:	b368      	cbz	r0, d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
      return false;
    }

    // use first entry in cluster
    dirIndex_ = 0;
   d9c40:	7634      	strb	r4, [r6, #24]
    p = SdVolume::cacheBuffer_.dir;
   d9c42:	4c1b      	ldr	r4, [pc, #108]	; (d9cb0 <_ZN6SdFile4openEPS_PKch+0x118>)
  }
  // initialize as empty file
  memset(p, 0, sizeof(dir_t));
   d9c44:	2220      	movs	r2, #32
   d9c46:	2100      	movs	r1, #0
   d9c48:	4620      	mov	r0, r4
   d9c4a:	f006 f98d 	bl	dff68 <memset>
  memcpy(p->name, dname, 11);
   d9c4e:	ab01      	add	r3, sp, #4
   d9c50:	cb03      	ldmia	r3!, {r0, r1}
   d9c52:	6020      	str	r0, [r4, #0]
   d9c54:	6061      	str	r1, [r4, #4]
   d9c56:	881a      	ldrh	r2, [r3, #0]
   d9c58:	789b      	ldrb	r3, [r3, #2]
   d9c5a:	72a3      	strb	r3, [r4, #10]

  // set timestamps
  if (dateTime_) {
   d9c5c:	4b15      	ldr	r3, [pc, #84]	; (d9cb4 <_ZN6SdFile4openEPS_PKch+0x11c>)
    dirIndex_ = 0;
    p = SdVolume::cacheBuffer_.dir;
  }
  // initialize as empty file
  memset(p, 0, sizeof(dir_t));
  memcpy(p->name, dname, 11);
   d9c5e:	8122      	strh	r2, [r4, #8]

  // set timestamps
  if (dateTime_) {
   d9c60:	681b      	ldr	r3, [r3, #0]
   d9c62:	b12b      	cbz	r3, d9c70 <_ZN6SdFile4openEPS_PKch+0xd8>
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
   d9c64:	f104 010e 	add.w	r1, r4, #14
   d9c68:	f104 0010 	add.w	r0, r4, #16
   d9c6c:	4798      	blx	r3
   d9c6e:	e006      	b.n	d9c7e <_ZN6SdFile4openEPS_PKch+0xe6>
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
   d9c70:	2221      	movs	r2, #33	; 0x21
   d9c72:	7422      	strb	r2, [r4, #16]
    p->creationTime = FAT_DEFAULT_TIME;
   d9c74:	73a3      	strb	r3, [r4, #14]
  if (dateTime_) {
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
   d9c76:	2228      	movs	r2, #40	; 0x28
    p->creationTime = FAT_DEFAULT_TIME;
   d9c78:	2308      	movs	r3, #8
  if (dateTime_) {
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
   d9c7a:	7462      	strb	r2, [r4, #17]
    p->creationTime = FAT_DEFAULT_TIME;
   d9c7c:	73e3      	strb	r3, [r4, #15]
  }
  p->lastAccessDate = p->creationDate;
   d9c7e:	8a23      	ldrh	r3, [r4, #16]
   d9c80:	8263      	strh	r3, [r4, #18]
  p->lastWriteDate = p->creationDate;
   d9c82:	8323      	strh	r3, [r4, #24]
  p->lastWriteTime = p->creationTime;
   d9c84:	89e3      	ldrh	r3, [r4, #14]
   d9c86:	82e3      	strh	r3, [r4, #22]

  // force write of entry to SD
  if (!SdVolume::cacheFlush()) {
   d9c88:	2001      	movs	r0, #1
   d9c8a:	f7fa fa35 	bl	d40f8 <_ZN8SdVolume10cacheFlushEh>
   d9c8e:	b128      	cbz	r0, d9c9c <_ZN6SdFile4openEPS_PKch+0x104>
    return false;
  }

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
   d9c90:	7e31      	ldrb	r1, [r6, #24]
   d9c92:	463a      	mov	r2, r7
   d9c94:	4630      	mov	r0, r6
   d9c96:	f7ff ff3f 	bl	d9b18 <_ZN6SdFile15openCachedEntryEhh>
   d9c9a:	e005      	b.n	d9ca8 <_ZN6SdFile4openEPS_PKch+0x110>
  uint8_t dname[11];
  dir_t* p;

  // error if already open
  if (isOpen()) {
    return false;
   d9c9c:	2000      	movs	r0, #0
   d9c9e:	e003      	b.n	d9ca8 <_ZN6SdFile4openEPS_PKch+0x110>
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
   d9ca0:	2c00      	cmp	r4, #0
   d9ca2:	d0b1      	beq.n	d9c08 <_ZN6SdFile4openEPS_PKch+0x70>
   d9ca4:	2401      	movs	r4, #1
   d9ca6:	e78f      	b.n	d9bc8 <_ZN6SdFile4openEPS_PKch+0x30>
    return false;
  }

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
}
   d9ca8:	b005      	add	sp, #20
   d9caa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d9cae:	bf00      	nop
   d9cb0:	2003db04 	.word	0x2003db04
   d9cb4:	2003e3b0 	.word	0x2003e3b0
   d9cb8:	2003d66c 	.word	0x2003d66c

000d9cbc <_ZN6SdFile7makeDirEPS_PKc>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include this SdFile is already open, \a dir is not a
   directory, \a dirName is invalid or already exists in \a dir.
*/
uint8_t SdFile::makeDir(SdFile* dir, const char* dirName) {
   d9cbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  dir_t d;

  // create a normal file
  if (!open(dir, dirName, O_CREAT | O_EXCL | O_RDWR)) {
   d9cc0:	2333      	movs	r3, #51	; 0x33
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include this SdFile is already open, \a dir is not a
   directory, \a dirName is invalid or already exists in \a dir.
*/
uint8_t SdFile::makeDir(SdFile* dir, const char* dirName) {
   d9cc2:	b089      	sub	sp, #36	; 0x24
   d9cc4:	4607      	mov	r7, r0
   d9cc6:	4688      	mov	r8, r1
  dir_t d;

  // create a normal file
  if (!open(dir, dirName, O_CREAT | O_EXCL | O_RDWR)) {
   d9cc8:	f7ff ff66 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
   d9ccc:	2800      	cmp	r0, #0
   d9cce:	d069      	beq.n	d9da4 <_ZN6SdFile7makeDirEPS_PKc+0xe8>
    return false;
  }

  // convert SdFile to directory
  flags_ = O_READ;
   d9cd0:	2401      	movs	r4, #1
  type_ = FAT_FILE_TYPE_SUBDIR;
   d9cd2:	2304      	movs	r3, #4
  if (!open(dir, dirName, O_CREAT | O_EXCL | O_RDWR)) {
    return false;
  }

  // convert SdFile to directory
  flags_ = O_READ;
   d9cd4:	723c      	strb	r4, [r7, #8]
  type_ = FAT_FILE_TYPE_SUBDIR;
   d9cd6:	727b      	strb	r3, [r7, #9]

  // allocate and zero first cluster
  if (!addDirCluster()) {
   d9cd8:	4638      	mov	r0, r7
   d9cda:	f7ff fcdc 	bl	d9696 <_ZN6SdFile13addDirClusterEv>
   d9cde:	2800      	cmp	r0, #0
   d9ce0:	d060      	beq.n	d9da4 <_ZN6SdFile7makeDirEPS_PKc+0xe8>
    return false;
  }

  // force entry to SD
  if (!sync()) {
   d9ce2:	4621      	mov	r1, r4
   d9ce4:	4638      	mov	r0, r7
   d9ce6:	f7ff fe87 	bl	d99f8 <_ZN6SdFile4syncEh>
   d9cea:	2800      	cmp	r0, #0
   d9cec:	d05a      	beq.n	d9da4 <_ZN6SdFile7makeDirEPS_PKc+0xe8>
    return false;
  }

  // cache entry - should already be in cache due to sync() call
  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   d9cee:	4621      	mov	r1, r4
   d9cf0:	4638      	mov	r0, r7
   d9cf2:	f7ff fcf5 	bl	d96e0 <_ZN6SdFile13cacheDirEntryEh>
  if (!p) {
   d9cf6:	4603      	mov	r3, r0
   d9cf8:	2800      	cmp	r0, #0
   d9cfa:	d053      	beq.n	d9da4 <_ZN6SdFile7makeDirEPS_PKc+0xe8>
    return false;
  }

  // change directory entry  attribute
  p->attributes = DIR_ATT_DIRECTORY;
   d9cfc:	2210      	movs	r2, #16
   d9cfe:	72c2      	strb	r2, [r0, #11]

  // make entry for '.'
  memcpy(&d, p, sizeof(d));
   d9d00:	466d      	mov	r5, sp
   d9d02:	4602      	mov	r2, r0
   d9d04:	f100 0e20 	add.w	lr, r0, #32
   d9d08:	466c      	mov	r4, sp
   d9d0a:	6810      	ldr	r0, [r2, #0]
   d9d0c:	6851      	ldr	r1, [r2, #4]
   d9d0e:	462e      	mov	r6, r5
   d9d10:	c603      	stmia	r6!, {r0, r1}
   d9d12:	3208      	adds	r2, #8
   d9d14:	4572      	cmp	r2, lr
   d9d16:	4635      	mov	r5, r6
   d9d18:	d1f7      	bne.n	d9d0a <_ZN6SdFile7makeDirEPS_PKc+0x4e>
   d9d1a:	8a9d      	ldrh	r5, [r3, #20]
   d9d1c:	8b5e      	ldrh	r6, [r3, #26]
  for (uint8_t i = 1; i < 11; i++) {
    d.name[i] = ' ';
   d9d1e:	2120      	movs	r1, #32

  // change directory entry  attribute
  p->attributes = DIR_ATT_DIRECTORY;

  // make entry for '.'
  memcpy(&d, p, sizeof(d));
   d9d20:	2300      	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    d.name[i] = ' ';
   d9d22:	18e2      	adds	r2, r4, r3
   d9d24:	3301      	adds	r3, #1
  // change directory entry  attribute
  p->attributes = DIR_ATT_DIRECTORY;

  // make entry for '.'
  memcpy(&d, p, sizeof(d));
  for (uint8_t i = 1; i < 11; i++) {
   d9d26:	2b0a      	cmp	r3, #10
    d.name[i] = ' ';
   d9d28:	7051      	strb	r1, [r2, #1]
  // change directory entry  attribute
  p->attributes = DIR_ATT_DIRECTORY;

  // make entry for '.'
  memcpy(&d, p, sizeof(d));
  for (uint8_t i = 1; i < 11; i++) {
   d9d2a:	d1fa      	bne.n	d9d22 <_ZN6SdFile7makeDirEPS_PKc+0x66>
    d.name[i] = ' ';
  }
  d.name[0] = '.';

  // cache block for '.'  and '..'
  uint32_t block = vol_->clusterStartBlock(firstCluster_);
   d9d2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   d9d2e:	6a38      	ldr	r0, [r7, #32]
   d9d30:	7c1a      	ldrb	r2, [r3, #16]
   d9d32:	695b      	ldr	r3, [r3, #20]
   d9d34:	3802      	subs	r0, #2
   d9d36:	4090      	lsls	r0, r2
  // make entry for '.'
  memcpy(&d, p, sizeof(d));
  for (uint8_t i = 1; i < 11; i++) {
    d.name[i] = ' ';
  }
  d.name[0] = '.';
   d9d38:	f04f 092e 	mov.w	r9, #46	; 0x2e

  // cache block for '.'  and '..'
  uint32_t block = vol_->clusterStartBlock(firstCluster_);
  if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   d9d3c:	2101      	movs	r1, #1
   d9d3e:	4418      	add	r0, r3
  // make entry for '.'
  memcpy(&d, p, sizeof(d));
  for (uint8_t i = 1; i < 11; i++) {
    d.name[i] = ' ';
  }
  d.name[0] = '.';
   d9d40:	f88d 9000 	strb.w	r9, [sp]

  // cache block for '.'  and '..'
  uint32_t block = vol_->clusterStartBlock(firstCluster_);
  if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   d9d44:	f7fa f9fa 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d9d48:	b360      	cbz	r0, d9da4 <_ZN6SdFile7makeDirEPS_PKc+0xe8>
    return false;
  }

  // copy '.' to block
  memcpy(&SdVolume::cacheBuffer_.dir[0], &d, sizeof(d));
   d9d4a:	f8ad 5014 	strh.w	r5, [sp, #20]
   d9d4e:	f8ad 601a 	strh.w	r6, [sp, #26]
   d9d52:	4626      	mov	r6, r4
   d9d54:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   d9d56:	4d15      	ldr	r5, [pc, #84]	; (d9dac <_ZN6SdFile7makeDirEPS_PKc+0xf0>)

  // make entry for '..'
  d.name[1] = '.';
   d9d58:	f88d 9001 	strb.w	r9, [sp, #1]
  if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
    return false;
  }

  // copy '.' to block
  memcpy(&SdVolume::cacheBuffer_.dir[0], &d, sizeof(d));
   d9d5c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   d9d5e:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
   d9d62:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

  // make entry for '..'
  d.name[1] = '.';
  if (dir->isRoot()) {
   d9d66:	f898 3009 	ldrb.w	r3, [r8, #9]
  } else {
    d.firstClusterLow = dir->firstCluster_ & 0XFFFF;
    d.firstClusterHigh = dir->firstCluster_ >> 16;
  }
  // copy '..' to block
  memcpy(&SdVolume::cacheBuffer_.dir[1], &d, sizeof(d));
   d9d6a:	4d11      	ldr	r5, [pc, #68]	; (d9db0 <_ZN6SdFile7makeDirEPS_PKc+0xf4>)
  // copy '.' to block
  memcpy(&SdVolume::cacheBuffer_.dir[0], &d, sizeof(d));

  // make entry for '..'
  d.name[1] = '.';
  if (dir->isRoot()) {
   d9d6c:	3b02      	subs	r3, #2
   d9d6e:	2b01      	cmp	r3, #1
    d.firstClusterLow = 0;
    d.firstClusterHigh = 0;
  } else {
    d.firstClusterLow = dir->firstCluster_ & 0XFFFF;
   d9d70:	bf8b      	itete	hi
   d9d72:	f8d8 3020 	ldrhi.w	r3, [r8, #32]
  memcpy(&SdVolume::cacheBuffer_.dir[0], &d, sizeof(d));

  // make entry for '..'
  d.name[1] = '.';
  if (dir->isRoot()) {
    d.firstClusterLow = 0;
   d9d76:	2200      	movls	r2, #0
    d.firstClusterHigh = 0;
  } else {
    d.firstClusterLow = dir->firstCluster_ & 0XFFFF;
   d9d78:	b29a      	uxthhi	r2, r3

  // make entry for '..'
  d.name[1] = '.';
  if (dir->isRoot()) {
    d.firstClusterLow = 0;
    d.firstClusterHigh = 0;
   d9d7a:	4613      	movls	r3, r2
  } else {
    d.firstClusterLow = dir->firstCluster_ & 0XFFFF;
    d.firstClusterHigh = dir->firstCluster_ >> 16;
   d9d7c:	bf88      	it	hi
   d9d7e:	0c1b      	lsrhi	r3, r3, #16
  }
  // copy '..' to block
  memcpy(&SdVolume::cacheBuffer_.dir[1], &d, sizeof(d));
   d9d80:	f8ad 3014 	strh.w	r3, [sp, #20]
   d9d84:	f8ad 201a 	strh.w	r2, [sp, #26]
   d9d88:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   d9d8a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   d9d8c:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   d9d90:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

  // set position after '..'
  curPosition_ = 2 * sizeof(d);
   d9d94:	2340      	movs	r3, #64	; 0x40

  // write first block
  return SdVolume::cacheFlush();
   d9d96:	2001      	movs	r0, #1
  }
  // copy '..' to block
  memcpy(&SdVolume::cacheBuffer_.dir[1], &d, sizeof(d));

  // set position after '..'
  curPosition_ = 2 * sizeof(d);
   d9d98:	613b      	str	r3, [r7, #16]

  // write first block
  return SdVolume::cacheFlush();
}
   d9d9a:	b009      	add	sp, #36	; 0x24
   d9d9c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}

  // set position after '..'
  curPosition_ = 2 * sizeof(d);

  // write first block
  return SdVolume::cacheFlush();
   d9da0:	f7fa b9aa 	b.w	d40f8 <_ZN8SdVolume10cacheFlushEh>
}
   d9da4:	2000      	movs	r0, #0
   d9da6:	b009      	add	sp, #36	; 0x24
   d9da8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   d9dac:	2003db04 	.word	0x2003db04
   d9db0:	2003db24 	.word	0x2003db24

000d9db4 <_ZN6SdFile6removeEv>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the file read-only, is a directory,
   or an I/O error occurred.
*/
uint8_t SdFile::remove(void) {
   d9db4:	b510      	push	{r4, lr}
  // free any clusters - will fail if read-only or directory
  if (!truncate(0)) {
   d9db6:	2100      	movs	r1, #0
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the file read-only, is a directory,
   or an I/O error occurred.
*/
uint8_t SdFile::remove(void) {
   d9db8:	4604      	mov	r4, r0
  // free any clusters - will fail if read-only or directory
  if (!truncate(0)) {
   d9dba:	f7ff fe59 	bl	d9a70 <_ZN6SdFile8truncateEm>
   d9dbe:	b168      	cbz	r0, d9ddc <_ZN6SdFile6removeEv+0x28>
    return false;
  }

  // cache directory entry
  dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   d9dc0:	2101      	movs	r1, #1
   d9dc2:	4620      	mov	r0, r4
   d9dc4:	f7ff fc8c 	bl	d96e0 <_ZN6SdFile13cacheDirEntryEh>
  if (!d) {
   d9dc8:	b140      	cbz	r0, d9ddc <_ZN6SdFile6removeEv+0x28>
    return false;
  }

  // mark entry deleted
  d->name[0] = DIR_NAME_DELETED;
   d9dca:	23e5      	movs	r3, #229	; 0xe5
   d9dcc:	7003      	strb	r3, [r0, #0]

  // set this SdFile closed
  type_ = FAT_FILE_TYPE_CLOSED;
   d9dce:	2300      	movs	r3, #0
   d9dd0:	7263      	strb	r3, [r4, #9]

  // write entry to SD
  return SdVolume::cacheFlush();
   d9dd2:	2001      	movs	r0, #1
}
   d9dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  // set this SdFile closed
  type_ = FAT_FILE_TYPE_CLOSED;

  // write entry to SD
  return SdVolume::cacheFlush();
   d9dd8:	f7fa b98e 	b.w	d40f8 <_ZN8SdVolume10cacheFlushEh>
}
   d9ddc:	2000      	movs	r0, #0
   d9dde:	bd10      	pop	{r4, pc}

000d9de0 <_ZN6SdFile6removeEPS_PKc>:
   the value zero, false, is returned for failure.
   Reasons for failure include the file is a directory, is read only,
   \a dirFile is not a directory, \a fileName is not found
   or an I/O error occurred.
*/
uint8_t SdFile::remove(SdFile* dirFile, const char* fileName) {
   d9de0:	b500      	push	{lr}
   d9de2:	b08b      	sub	sp, #44	; 0x2c
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   d9de4:	2300      	movs	r3, #0
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   d9de6:	4a09      	ldr	r2, [pc, #36]	; (d9e0c <_ZN6SdFile6removeEPS_PKc+0x2c>)
   d9de8:	9301      	str	r3, [sp, #4]
   d9dea:	9200      	str	r2, [sp, #0]
   d9dec:	f88d 3009 	strb.w	r3, [sp, #9]
  SdFile file;
  if (!file.open(dirFile, fileName, O_WRITE)) {
   d9df0:	460a      	mov	r2, r1
   d9df2:	2302      	movs	r3, #2
   d9df4:	4601      	mov	r1, r0
   d9df6:	4668      	mov	r0, sp
   d9df8:	f7ff fece 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
   d9dfc:	b110      	cbz	r0, d9e04 <_ZN6SdFile6removeEPS_PKc+0x24>
    return false;
  }
  return file.remove();
   d9dfe:	4668      	mov	r0, sp
   d9e00:	f7ff ffd8 	bl	d9db4 <_ZN6SdFile6removeEv>
}
   d9e04:	b00b      	add	sp, #44	; 0x2c
   d9e06:	f85d fb04 	ldr.w	pc, [sp], #4
   d9e0a:	bf00      	nop
   d9e0c:	000e2358 	.word	0x000e2358

000d9e10 <_ZN6SdFile5rmDirEv>:
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the file is not a directory, is the root
   directory, is not empty, or an I/O error occurred.
*/
uint8_t SdFile::rmDir(void) {
   d9e10:	b510      	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir()) {
   d9e12:	7a43      	ldrb	r3, [r0, #9]
   d9e14:	2b04      	cmp	r3, #4
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the file is not a directory, is the root
   directory, is not empty, or an I/O error occurred.
*/
uint8_t SdFile::rmDir(void) {
   d9e16:	4604      	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir()) {
   d9e18:	d11f      	bne.n	d9e5a <_ZN6SdFile5rmDirEv+0x4a>
    int8_t readDir(dir_t* dir);
    static uint8_t remove(SdFile* dirFile, const char* fileName);
    uint8_t remove(void);
    /** Set the file's current position to zero. */
    void rewind(void) {
      curPosition_ = curCluster_ = 0;
   d9e1a:	2300      	movs	r3, #0
   d9e1c:	60c3      	str	r3, [r0, #12]
   d9e1e:	6103      	str	r3, [r0, #16]
  }

  rewind();

  // make sure directory is empty
  while (curPosition_ < fileSize_) {
   d9e20:	6922      	ldr	r2, [r4, #16]
   d9e22:	69e3      	ldr	r3, [r4, #28]
   d9e24:	429a      	cmp	r2, r3
   d9e26:	d20d      	bcs.n	d9e44 <_ZN6SdFile5rmDirEv+0x34>
    dir_t* p = readDirCache();
   d9e28:	4620      	mov	r0, r4
   d9e2a:	f7ff fd99 	bl	d9960 <_ZN6SdFile12readDirCacheEv>
    if (p == NULL) {
   d9e2e:	b1a0      	cbz	r0, d9e5a <_ZN6SdFile5rmDirEv+0x4a>
      return false;
    }
    // done if past last used entry
    if (p->name[0] == DIR_NAME_FREE) {
   d9e30:	7803      	ldrb	r3, [r0, #0]
   d9e32:	b13b      	cbz	r3, d9e44 <_ZN6SdFile5rmDirEv+0x34>
      break;
    }
    // skip empty slot or '.' or '..'
    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
   d9e34:	2be5      	cmp	r3, #229	; 0xe5
   d9e36:	d0f3      	beq.n	d9e20 <_ZN6SdFile5rmDirEv+0x10>
   d9e38:	2b2e      	cmp	r3, #46	; 0x2e
   d9e3a:	d0f1      	beq.n	d9e20 <_ZN6SdFile5rmDirEv+0x10>
      continue;
    }
    // error not empty
    if (DIR_IS_FILE_OR_SUBDIR(p)) {
   d9e3c:	7ac3      	ldrb	r3, [r0, #11]
   d9e3e:	071b      	lsls	r3, r3, #28
   d9e40:	d4ee      	bmi.n	d9e20 <_ZN6SdFile5rmDirEv+0x10>
   d9e42:	e00a      	b.n	d9e5a <_ZN6SdFile5rmDirEv+0x4a>
      return false;
    }
  }
  // convert empty directory to normal file for remove
  type_ = FAT_FILE_TYPE_NORMAL;
   d9e44:	2301      	movs	r3, #1
   d9e46:	7263      	strb	r3, [r4, #9]
  flags_ |= O_WRITE;
   d9e48:	7a23      	ldrb	r3, [r4, #8]
   d9e4a:	f043 0302 	orr.w	r3, r3, #2
   d9e4e:	7223      	strb	r3, [r4, #8]
  return remove();
   d9e50:	4620      	mov	r0, r4
}
   d9e52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  type_ = FAT_FILE_TYPE_NORMAL;
  flags_ |= O_WRITE;
  return remove();
   d9e56:	f7ff bfad 	b.w	d9db4 <_ZN6SdFile6removeEv>
}
   d9e5a:	2000      	movs	r0, #0
   d9e5c:	bd10      	pop	{r4, pc}
	...

000d9e60 <_ZN6SdFile5writeEPKvt>:
   \a nbyte.  If an error occurs, write() returns 0.  Possible errors
   include write() is called before a file has been opened, write is called
   for a read-only file, device is full, a corrupt file system or an I/O error.

*/
size_t SdFile::write(const void* buf, uint16_t nbyte) {
   d9e60:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
   d9e64:	7a43      	ldrb	r3, [r0, #9]
   d9e66:	2b01      	cmp	r3, #1
   \a nbyte.  If an error occurs, write() returns 0.  Possible errors
   include write() is called before a file has been opened, write is called
   for a read-only file, device is full, a corrupt file system or an I/O error.

*/
size_t SdFile::write(const void* buf, uint16_t nbyte) {
   d9e68:	4604      	mov	r4, r0
   d9e6a:	4689      	mov	r9, r1
   d9e6c:	4617      	mov	r7, r2
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
   d9e6e:	d10e      	bne.n	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;
   d9e70:	f890 8008 	ldrb.w	r8, [r0, #8]

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
   d9e74:	f018 0f02 	tst.w	r8, #2
   d9e78:	d009      	beq.n	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
    goto writeErrorReturn;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
   d9e7a:	f018 0f04 	tst.w	r8, #4
   d9e7e:	d00a      	beq.n	d9e96 <_ZN6SdFile5writeEPKvt+0x36>
   d9e80:	69e1      	ldr	r1, [r4, #28]
   d9e82:	6923      	ldr	r3, [r4, #16]
   d9e84:	428b      	cmp	r3, r1
   d9e86:	d006      	beq.n	d9e96 <_ZN6SdFile5writeEPKvt+0x36>
    /**
        Set the files current position to end of file.  Useful to position
        a file for append. See seekSet().
    */
    uint8_t seekEnd(void) {
      return seekSet(fileSize_);
   d9e88:	f7ff fd86 	bl	d9998 <_ZN6SdFile7seekSetEm>
    if (!seekEnd()) {
   d9e8c:	b918      	cbnz	r0, d9e96 <_ZN6SdFile5writeEPKvt+0x36>

    size_t printNumber(unsigned long, uint8_t);
    size_t printNumber(unsigned long long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   d9e8e:	2301      	movs	r3, #1
   d9e90:	6063      	str	r3, [r4, #4]

writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
   d9e92:	2000      	movs	r0, #0
   d9e94:	e0a3      	b.n	d9fde <_ZN6SdFile5writeEPKvt+0x17e>
    uint8_t readData(uint32_t block, uint16_t offset,
                     uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
    }
    uint8_t writeBlock(uint32_t block, const uint8_t* dst, uint8_t blocking = 1) {
      return sdCard_->writeBlock(block, dst, blocking);
   d9e96:	f088 0810 	eor.w	r8, r8, #16
   \a nbyte.  If an error occurs, write() returns 0.  Possible errors
   include write() is called before a file has been opened, write is called
   for a read-only file, device is full, a corrupt file system or an I/O error.

*/
size_t SdFile::write(const void* buf, uint16_t nbyte) {
   d9e9a:	46ba      	mov	sl, r7
   d9e9c:	f3c8 1800 	ubfx	r8, r8, #4, #1
   d9ea0:	e036      	b.n	d9f10 <_ZN6SdFile5writeEPKvt+0xb0>
      goto writeErrorReturn;
    }
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   d9ea2:	6a60      	ldr	r0, [r4, #36]	; 0x24
    uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
    uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
    //----------------------------------------------------------------------------
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
   d9ea4:	f890 b004 	ldrb.w	fp, [r0, #4]
   d9ea8:	f10b 3bff 	add.w	fp, fp, #4294967295
   d9eac:	ea0b 2b56 	and.w	fp, fp, r6, lsr #9
    uint16_t blockOffset = curPosition_ & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
   d9eb0:	f01b 0bff 	ands.w	fp, fp, #255	; 0xff
    }
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    uint16_t blockOffset = curPosition_ & 0X1FF;
   d9eb4:	f3c6 0608 	ubfx	r6, r6, #0, #9
    if (blockOfCluster == 0 && blockOffset == 0) {
   d9eb8:	d02f      	beq.n	d9f1a <_ZN6SdFile5writeEPKvt+0xba>
    if (n > nToWrite) {
      n = nToWrite;
    }

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   d9eba:	6a62      	ldr	r2, [r4, #36]	; 0x24
   d9ebc:	68e3      	ldr	r3, [r4, #12]
   d9ebe:	7c11      	ldrb	r1, [r2, #16]
   d9ec0:	6952      	ldr	r2, [r2, #20]
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
   d9ec2:	f5c6 7500 	rsb	r5, r6, #512	; 0x200
   d9ec6:	b2ad      	uxth	r5, r5
   d9ec8:	4555      	cmp	r5, sl
    if (n > nToWrite) {
      n = nToWrite;
    }

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   d9eca:	f1a3 0302 	sub.w	r3, r3, #2
   d9ece:	bf28      	it	cs
   d9ed0:	4655      	movcs	r5, sl
   d9ed2:	408b      	lsls	r3, r1
   d9ed4:	4413      	add	r3, r2
    if (n == 512) {
   d9ed6:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
    if (n > nToWrite) {
      n = nToWrite;
    }

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   d9eda:	449b      	add	fp, r3
    if (n == 512) {
   d9edc:	d13e      	bne.n	d9f5c <_ZN6SdFile5writeEPKvt+0xfc>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
   d9ede:	4b41      	ldr	r3, [pc, #260]	; (d9fe4 <_ZN6SdFile5writeEPKvt+0x184>)
    uint8_t readData(uint32_t block, uint16_t offset,
                     uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
    }
    uint8_t writeBlock(uint32_t block, const uint8_t* dst, uint8_t blocking = 1) {
      return sdCard_->writeBlock(block, dst, blocking);
   d9ee0:	4841      	ldr	r0, [pc, #260]	; (d9fe8 <_ZN6SdFile5writeEPKvt+0x188>)
   d9ee2:	681a      	ldr	r2, [r3, #0]
   d9ee4:	6800      	ldr	r0, [r0, #0]
   d9ee6:	4593      	cmp	fp, r2
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
   d9ee8:	bf04      	itt	eq
   d9eea:	f04f 32ff 	moveq.w	r2, #4294967295
   d9eee:	601a      	streq	r2, [r3, #0]
   d9ef0:	4659      	mov	r1, fp
   d9ef2:	4643      	mov	r3, r8
   d9ef4:	464a      	mov	r2, r9
   d9ef6:	f000 fa53 	bl	da3a0 <_ZN7Sd2Card10writeBlockEmPKhh>
      }
      if (!vol_->writeBlock(block, src, blocking)) {
   d9efa:	2800      	cmp	r0, #0
   d9efc:	d0c7      	beq.n	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
        goto writeErrorReturn;
      }
      src += 512;
   d9efe:	f509 7900 	add.w	r9, r9, #512	; 0x200
      while (dst != end) {
        *dst++ = *src++;
      }
    }
    nToWrite -= n;
    curPosition_ += n;
   d9f02:	6923      	ldr	r3, [r4, #16]
      uint8_t* end = dst + n;
      while (dst != end) {
        *dst++ = *src++;
      }
    }
    nToWrite -= n;
   d9f04:	ebc5 0a0a 	rsb	sl, r5, sl
    curPosition_ += n;
   d9f08:	441d      	add	r5, r3
      uint8_t* end = dst + n;
      while (dst != end) {
        *dst++ = *src++;
      }
    }
    nToWrite -= n;
   d9f0a:	fa1f fa8a 	uxth.w	sl, sl
    curPosition_ += n;
   d9f0e:	6125      	str	r5, [r4, #16]
   d9f10:	6926      	ldr	r6, [r4, #16]
    if (!seekEnd()) {
      goto writeErrorReturn;
    }
  }

  while (nToWrite > 0) {
   d9f12:	f1ba 0f00 	cmp.w	sl, #0
   d9f16:	d1c4      	bne.n	d9ea2 <_ZN6SdFile5writeEPKvt+0x42>
   d9f18:	e047      	b.n	d9faa <_ZN6SdFile5writeEPKvt+0x14a>
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    uint16_t blockOffset = curPosition_ & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
   d9f1a:	2e00      	cmp	r6, #0
   d9f1c:	d1cd      	bne.n	d9eba <_ZN6SdFile5writeEPKvt+0x5a>
      // start of new cluster
      if (curCluster_ == 0) {
   d9f1e:	68e1      	ldr	r1, [r4, #12]
   d9f20:	b919      	cbnz	r1, d9f2a <_ZN6SdFile5writeEPKvt+0xca>
        if (firstCluster_ == 0) {
   d9f22:	6a23      	ldr	r3, [r4, #32]
   d9f24:	b193      	cbz	r3, d9f4c <_ZN6SdFile5writeEPKvt+0xec>
          // allocate first cluster of file
          if (!addCluster()) {
            goto writeErrorReturn;
          }
        } else {
          curCluster_ = firstCluster_;
   d9f26:	60e3      	str	r3, [r4, #12]
   d9f28:	e7c7      	b.n	d9eba <_ZN6SdFile5writeEPKvt+0x5a>
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) {
   d9f2a:	aa01      	add	r2, sp, #4
   d9f2c:	f7fa f948 	bl	d41c0 <_ZNK8SdVolume6fatGetEmPm>
   d9f30:	2800      	cmp	r0, #0
   d9f32:	d054      	beq.n	d9fde <_ZN6SdFile5writeEPKvt+0x17e>
   d9f34:	6a63      	ldr	r3, [r4, #36]	; 0x24
          return false;
        }
        if (vol_->isEOC(next)) {
   d9f36:	9901      	ldr	r1, [sp, #4]
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   d9f38:	f893 0020 	ldrb.w	r0, [r3, #32]
   d9f3c:	4b2b      	ldr	r3, [pc, #172]	; (d9fec <_ZN6SdFile5writeEPKvt+0x18c>)
   d9f3e:	f64f 72f8 	movw	r2, #65528	; 0xfff8
   d9f42:	2810      	cmp	r0, #16
   d9f44:	bf08      	it	eq
   d9f46:	4613      	moveq	r3, r2
   d9f48:	4299      	cmp	r1, r3
   d9f4a:	d305      	bcc.n	d9f58 <_ZN6SdFile5writeEPKvt+0xf8>
          // add cluster if at end of chain
          if (!addCluster()) {
   d9f4c:	4620      	mov	r0, r4
   d9f4e:	f7ff fb8b 	bl	d9668 <_ZN6SdFile10addClusterEv>
   d9f52:	2800      	cmp	r0, #0
   d9f54:	d1b1      	bne.n	d9eba <_ZN6SdFile5writeEPKvt+0x5a>
   d9f56:	e79a      	b.n	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
            goto writeErrorReturn;
          }
        } else {
          curCluster_ = next;
   d9f58:	60e1      	str	r1, [r4, #12]
   d9f5a:	e7ae      	b.n	d9eba <_ZN6SdFile5writeEPKvt+0x5a>
      if (!vol_->writeBlock(block, src, blocking)) {
        goto writeErrorReturn;
      }
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
   d9f5c:	b98e      	cbnz	r6, d9f82 <_ZN6SdFile5writeEPKvt+0x122>
   d9f5e:	6922      	ldr	r2, [r4, #16]
   d9f60:	69e3      	ldr	r3, [r4, #28]
   d9f62:	429a      	cmp	r2, r3
   d9f64:	d30d      	bcc.n	d9f82 <_ZN6SdFile5writeEPKvt+0x122>
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) {
   d9f66:	2001      	movs	r0, #1
   d9f68:	f7fa f8c6 	bl	d40f8 <_ZN8SdVolume10cacheFlushEh>
   d9f6c:	2800      	cmp	r0, #0
   d9f6e:	d08e      	beq.n	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
          goto writeErrorReturn;
        }
        SdVolume::cacheBlockNumber_ = block;
   d9f70:	4b1c      	ldr	r3, [pc, #112]	; (d9fe4 <_ZN6SdFile5writeEPKvt+0x184>)
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
   d9f72:	4a1f      	ldr	r2, [pc, #124]	; (d9ff0 <_ZN6SdFile5writeEPKvt+0x190>)
   d9f74:	f8c3 b000 	str.w	fp, [r3]
   d9f78:	7813      	ldrb	r3, [r2, #0]
   d9f7a:	f043 0301 	orr.w	r3, r3, #1
   d9f7e:	7013      	strb	r3, [r2, #0]
   d9f80:	e006      	b.n	d9f90 <_ZN6SdFile5writeEPKvt+0x130>
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   d9f82:	2101      	movs	r1, #1
   d9f84:	4658      	mov	r0, fp
   d9f86:	f7fa f8d9 	bl	d413c <_ZN8SdVolume13cacheRawBlockEmh>
   d9f8a:	2800      	cmp	r0, #0
   d9f8c:	f43f af7f 	beq.w	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
   d9f90:	4b18      	ldr	r3, [pc, #96]	; (d9ff4 <_ZN6SdFile5writeEPKvt+0x194>)
   d9f92:	441e      	add	r6, r3
      uint8_t* end = dst + n;
   d9f94:	1971      	adds	r1, r6, r5
   d9f96:	464b      	mov	r3, r9
      while (dst != end) {
   d9f98:	428e      	cmp	r6, r1
   d9f9a:	d004      	beq.n	d9fa6 <_ZN6SdFile5writeEPKvt+0x146>
        *dst++ = *src++;
   d9f9c:	f813 2b01 	ldrb.w	r2, [r3], #1
   d9fa0:	f806 2b01 	strb.w	r2, [r6], #1
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) {
   d9fa4:	e7f8      	b.n	d9f98 <_ZN6SdFile5writeEPKvt+0x138>
   d9fa6:	44a9      	add	r9, r5
   d9fa8:	e7ab      	b.n	d9f02 <_ZN6SdFile5writeEPKvt+0xa2>
      }
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
   d9faa:	69e3      	ldr	r3, [r4, #28]
   d9fac:	429e      	cmp	r6, r3
   d9fae:	7a23      	ldrb	r3, [r4, #8]
   d9fb0:	d901      	bls.n	d9fb6 <_ZN6SdFile5writeEPKvt+0x156>
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
   d9fb2:	61e6      	str	r6, [r4, #28]
   d9fb4:	e003      	b.n	d9fbe <_ZN6SdFile5writeEPKvt+0x15e>
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
   d9fb6:	4a10      	ldr	r2, [pc, #64]	; (d9ff8 <_ZN6SdFile5writeEPKvt+0x198>)
   d9fb8:	6812      	ldr	r2, [r2, #0]
   d9fba:	b11a      	cbz	r2, d9fc4 <_ZN6SdFile5writeEPKvt+0x164>
   d9fbc:	b117      	cbz	r7, d9fc4 <_ZN6SdFile5writeEPKvt+0x164>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
   d9fbe:	f063 037f 	orn	r3, r3, #127	; 0x7f
   d9fc2:	7223      	strb	r3, [r4, #8]
  }

  if (flags_ & O_SYNC) {
   d9fc4:	7a23      	ldrb	r3, [r4, #8]
   d9fc6:	071b      	lsls	r3, r3, #28
   d9fc8:	d401      	bmi.n	d9fce <_ZN6SdFile5writeEPKvt+0x16e>
    if (!sync()) {
      goto writeErrorReturn;
    }
  }
  return nbyte;
   d9fca:	4638      	mov	r0, r7
   d9fcc:	e007      	b.n	d9fde <_ZN6SdFile5writeEPKvt+0x17e>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) {
   d9fce:	2101      	movs	r1, #1
   d9fd0:	4620      	mov	r0, r4
   d9fd2:	f7ff fd11 	bl	d99f8 <_ZN6SdFile4syncEh>
   d9fd6:	2800      	cmp	r0, #0
   d9fd8:	f43f af59 	beq.w	d9e8e <_ZN6SdFile5writeEPKvt+0x2e>
   d9fdc:	e7f5      	b.n	d9fca <_ZN6SdFile5writeEPKvt+0x16a>
writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
}
   d9fde:	b003      	add	sp, #12
   d9fe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   d9fe4:	2003d66c 	.word	0x2003d66c
   d9fe8:	2003db00 	.word	0x2003db00
   d9fec:	0ffffff8 	.word	0x0ffffff8
   d9ff0:	2003dd04 	.word	0x2003dd04
   d9ff4:	2003db04 	.word	0x2003db04
   d9ff8:	2003e3b0 	.word	0x2003e3b0

000d9ffc <_ZN6SdFile5writeEh>:
/**
   Write a byte to a file. Required by the Arduino Print class.

   Use SdFile::writeError to check for errors.
*/
size_t SdFile::write(uint8_t b) {
   d9ffc:	b507      	push	{r0, r1, r2, lr}
   d9ffe:	ab02      	add	r3, sp, #8
  return write(&b, 1);
   da000:	2201      	movs	r2, #1
/**
   Write a byte to a file. Required by the Arduino Print class.

   Use SdFile::writeError to check for errors.
*/
size_t SdFile::write(uint8_t b) {
   da002:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return write(&b, 1);
   da006:	4619      	mov	r1, r3
   da008:	f7ff ff2a 	bl	d9e60 <_ZN6SdFile5writeEPKvt>
}
   da00c:	b003      	add	sp, #12
   da00e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000da014 <_ZN6SdFile17availableForWriteEv>:
/**
   Check how many bytes can be written without blocking.

   \return The number of bytes that can be written without blocking.
*/
int SdFile::availableForWrite() {
   da014:	b570      	push	{r4, r5, r6, lr}
  if (!isFile() || !(flags_ & O_WRITE)) {
   da016:	7a43      	ldrb	r3, [r0, #9]
   da018:	2b01      	cmp	r3, #1
/**
   Check how many bytes can be written without blocking.

   \return The number of bytes that can be written without blocking.
*/
int SdFile::availableForWrite() {
   da01a:	4605      	mov	r5, r0
  if (!isFile() || !(flags_ & O_WRITE)) {
   da01c:	d001      	beq.n	da022 <_ZN6SdFile17availableForWriteEv+0xe>
    return 0;
   da01e:	2000      	movs	r0, #0
   da020:	bd70      	pop	{r4, r5, r6, pc}
   Check how many bytes can be written without blocking.

   \return The number of bytes that can be written without blocking.
*/
int SdFile::availableForWrite() {
  if (!isFile() || !(flags_ & O_WRITE)) {
   da022:	7a03      	ldrb	r3, [r0, #8]
   da024:	079a      	lsls	r2, r3, #30
   da026:	d5fa      	bpl.n	da01e <_ZN6SdFile17availableForWriteEv+0xa>
    return 0;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
   da028:	075b      	lsls	r3, r3, #29
   da02a:	d503      	bpl.n	da034 <_ZN6SdFile17availableForWriteEv+0x20>
   da02c:	69e9      	ldr	r1, [r5, #28]
   da02e:	692b      	ldr	r3, [r5, #16]
   da030:	428b      	cmp	r3, r1
   da032:	d105      	bne.n	da040 <_ZN6SdFile17availableForWriteEv+0x2c>
    }
    uint8_t writeBlock(uint32_t block, const uint8_t* dst, uint8_t blocking = 1) {
      return sdCard_->writeBlock(block, dst, blocking);
    }
    uint8_t isBusy(void) {
      return sdCard_->isBusy();
   da034:	4b13      	ldr	r3, [pc, #76]	; (da084 <_ZN6SdFile17availableForWriteEv+0x70>)
   da036:	6818      	ldr	r0, [r3, #0]
   da038:	f000 f9ea 	bl	da410 <_ZN7Sd2Card6isBusyEv>
    if (!seekEnd()) {
      return 0;
    }
  }

  if (vol_->isBusy()) {
   da03c:	b128      	cbz	r0, da04a <_ZN6SdFile17availableForWriteEv+0x36>
   da03e:	e7ee      	b.n	da01e <_ZN6SdFile17availableForWriteEv+0xa>
    /**
        Set the files current position to end of file.  Useful to position
        a file for append. See seekSet().
    */
    uint8_t seekEnd(void) {
      return seekSet(fileSize_);
   da040:	f7ff fcaa 	bl	d9998 <_ZN6SdFile7seekSetEm>
    return 0;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) {
   da044:	2800      	cmp	r0, #0
   da046:	d1f5      	bne.n	da034 <_ZN6SdFile17availableForWriteEv+0x20>
   da048:	e7e9      	b.n	da01e <_ZN6SdFile17availableForWriteEv+0xa>

  if (vol_->isBusy()) {
    return 0;
  }

  if (flags_ & F_FILE_CLUSTER_ADDED) {
   da04a:	7a2b      	ldrb	r3, [r5, #8]
   da04c:	f003 0220 	and.w	r2, r3, #32
   da050:	b142      	cbz	r2, da064 <_ZN6SdFile17availableForWriteEv+0x50>
    // new cluster added, trigger a non-blocking sync
    sync(0);
   da052:	4601      	mov	r1, r0
   da054:	4628      	mov	r0, r5
   da056:	f7ff fccf 	bl	d99f8 <_ZN6SdFile4syncEh>
    flags_ &= ~F_FILE_CLUSTER_ADDED;
   da05a:	7a2b      	ldrb	r3, [r5, #8]
   da05c:	f023 0320 	bic.w	r3, r3, #32
   da060:	722b      	strb	r3, [r5, #8]
   da062:	e7dc      	b.n	da01e <_ZN6SdFile17availableForWriteEv+0xa>
    }
    uint8_t isBusy(void) {
      return sdCard_->isBusy();
    }
    uint8_t isCacheMirrorBlockDirty(void) {
      return (cacheMirrorBlock_ != 0);
   da064:	4a08      	ldr	r2, [pc, #32]	; (da088 <_ZN6SdFile17availableForWriteEv+0x74>)
    return 0;
  }

  if (vol_->isCacheMirrorBlockDirty()) {
   da066:	6812      	ldr	r2, [r2, #0]
   da068:	b112      	cbz	r2, da070 <_ZN6SdFile17availableForWriteEv+0x5c>
    // cache mirror block is dirty, trigger a non-blocking sync
    vol_->cacheMirrorBlockFlush(0);
   da06a:	f7fa f82f 	bl	d40cc <_ZN8SdVolume21cacheMirrorBlockFlushEh>
   da06e:	e7d6      	b.n	da01e <_ZN6SdFile17availableForWriteEv+0xa>
  flags_ |= F_FILE_NON_BLOCKING_WRITE;

  uint16_t blockOffset = curPosition_ & 0X1FF;
  uint16_t n = 512 - blockOffset;

  return n;
   da070:	6928      	ldr	r0, [r5, #16]
    // cache mirror block is dirty, trigger a non-blocking sync
    vol_->cacheMirrorBlockFlush(0);
    return 0;
  }

  flags_ |= F_FILE_NON_BLOCKING_WRITE;
   da072:	f043 0310 	orr.w	r3, r3, #16

  uint16_t blockOffset = curPosition_ & 0X1FF;
  uint16_t n = 512 - blockOffset;

  return n;
   da076:	f3c0 0008 	ubfx	r0, r0, #0, #9
    // cache mirror block is dirty, trigger a non-blocking sync
    vol_->cacheMirrorBlockFlush(0);
    return 0;
  }

  flags_ |= F_FILE_NON_BLOCKING_WRITE;
   da07a:	722b      	strb	r3, [r5, #8]

  uint16_t blockOffset = curPosition_ & 0X1FF;
  uint16_t n = 512 - blockOffset;

  return n;
   da07c:	f5c0 7000 	rsb	r0, r0, #512	; 0x200
   da080:	b280      	uxth	r0, r0
   da082:	bd70      	pop	{r4, r5, r6, pc}
   da084:	2003db00 	.word	0x2003db00
   da088:	2003dafc 	.word	0x2003dafc

000da08c <_GLOBAL__sub_I__ZN6SdFile9dateTime_E>:
   da08c:	f001 bb12 	b.w	db6b4 <HAL_Pin_Map>

000da090 <_ZN7Sd2Card10setSckRateEh>:

   \return The value one, true, is returned for success and the value zero,
   false, is returned for an invalid value of \a sckRateID.
*/
uint8_t Sd2Card::setSckRate(uint8_t sckRateID) {
  if (sckRateID > 6) {
   da090:	2906      	cmp	r1, #6
   for \a scsRateID = 6.

   \return The value one, true, is returned for success and the value zero,
   false, is returned for an invalid value of \a sckRateID.
*/
uint8_t Sd2Card::setSckRate(uint8_t sckRateID) {
   da092:	b510      	push	{r4, lr}
   da094:	f04f 0400 	mov.w	r4, #0
  if (sckRateID > 6) {
   da098:	d903      	bls.n	da0a2 <_ZN7Sd2Card10setSckRateEh+0x12>
      cardCommand(CMD55, 0);
      return cardCommand(cmd, arg);
    }
    uint8_t cardCommand(uint8_t cmd, uint32_t arg);
    void error(uint8_t code) {
      errorCode_ = code;
   da09a:	2316      	movs	r3, #22
   da09c:	7143      	strb	r3, [r0, #5]
    error(SD_CARD_ERROR_SCK_RATE);
    return false;
   da09e:	4620      	mov	r0, r4
   da0a0:	bd10      	pop	{r4, pc}
   da0a2:	4a11      	ldr	r2, [pc, #68]	; (da0e8 <_ZN7Sd2Card10setSckRateEh+0x58>)
  }
  SPCR &= ~((1 << SPR1) | (1 << SPR0));
  SPCR |= (sckRateID & 4 ? (1 << SPR1) : 0)
          | (sckRateID & 2 ? (1 << SPR0) : 0);
  #else // USE_SPI_LIB
  switch (sckRateID) {
   da0a4:	2905      	cmp	r1, #5
   da0a6:	d816      	bhi.n	da0d6 <_ZN7Sd2Card10setSckRateEh+0x46>
   da0a8:	e8df f001 	tbb	[pc, r1]
   da0ac:	0c090603 	.word	0x0c090603
   da0b0:	120f      	.short	0x120f
    SPI_CLK_ARDUINO = 16*MHZ,
    SPI_CLK_PHOTON = 60*MHZ
};

namespace particle {
class __SPISettings : public Printable {
   da0b2:	7114      	strb	r4, [r2, #4]
   da0b4:	4b0d      	ldr	r3, [pc, #52]	; (da0ec <_ZN7Sd2Card10setSckRateEh+0x5c>)
   da0b6:	e010      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0b8:	7114      	strb	r4, [r2, #4]
   da0ba:	4b0d      	ldr	r3, [pc, #52]	; (da0f0 <_ZN7Sd2Card10setSckRateEh+0x60>)
   da0bc:	e00d      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0be:	7114      	strb	r4, [r2, #4]
   da0c0:	4b0c      	ldr	r3, [pc, #48]	; (da0f4 <_ZN7Sd2Card10setSckRateEh+0x64>)
   da0c2:	e00a      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0c4:	7114      	strb	r4, [r2, #4]
   da0c6:	4b0c      	ldr	r3, [pc, #48]	; (da0f8 <_ZN7Sd2Card10setSckRateEh+0x68>)
   da0c8:	e007      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0ca:	7114      	strb	r4, [r2, #4]
   da0cc:	4b0b      	ldr	r3, [pc, #44]	; (da0fc <_ZN7Sd2Card10setSckRateEh+0x6c>)
   da0ce:	e004      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0d0:	7114      	strb	r4, [r2, #4]
   da0d2:	4b0b      	ldr	r3, [pc, #44]	; (da100 <_ZN7Sd2Card10setSckRateEh+0x70>)
   da0d4:	e001      	b.n	da0da <_ZN7Sd2Card10setSckRateEh+0x4a>
   da0d6:	4b0b      	ldr	r3, [pc, #44]	; (da104 <_ZN7Sd2Card10setSckRateEh+0x74>)
   da0d8:	7114      	strb	r4, [r2, #4]
   da0da:	6093      	str	r3, [r2, #8]
   da0dc:	2301      	movs	r3, #1
   da0de:	7313      	strb	r3, [r2, #12]
   da0e0:	7354      	strb	r4, [r2, #13]
   da0e2:	4618      	mov	r0, r3
    case 5:  settings = SPISettings(250000, MSBFIRST, SPI_MODE0); break;
    default: settings = SPISettings(125000, MSBFIRST, SPI_MODE0);
  }
  #endif // USE_SPI_LIB
  return true;
}
   da0e4:	bd10      	pop	{r4, pc}
   da0e6:	bf00      	nop
   da0e8:	2003e3c0 	.word	0x2003e3c0
   da0ec:	017d7840 	.word	0x017d7840
   da0f0:	003d0900 	.word	0x003d0900
   da0f4:	001e8480 	.word	0x001e8480
   da0f8:	000f4240 	.word	0x000f4240
   da0fc:	0007a120 	.word	0x0007a120
   da100:	0003d090 	.word	0x0003d090
   da104:	0001e848 	.word	0x0001e848

000da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>:
namespace particle {

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
   da108:	b538      	push	{r3, r4, r5, lr}
        static SPIClass instance(Interface);
   da10a:	4d09      	ldr	r5, [pc, #36]	; (da130 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv+0x28>)
   da10c:	6829      	ldr	r1, [r5, #0]
   da10e:	f011 0401 	ands.w	r4, r1, #1
   da112:	d10a      	bne.n	da12a <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv+0x22>
   da114:	4628      	mov	r0, r5
   da116:	f7f9 ffd1 	bl	d40bc <__cxa_guard_acquire>
   da11a:	b130      	cbz	r0, da12a <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv+0x22>
   da11c:	4621      	mov	r1, r4
   da11e:	4805      	ldr	r0, [pc, #20]	; (da134 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv+0x2c>)
   da120:	f001 ff78 	bl	dc014 <_ZN8SPIClassC1E17HAL_SPI_Interface>
   da124:	4628      	mov	r0, r5
   da126:	f7f9 ffce 	bl	d40c6 <__cxa_guard_release>
        return instance;
    }
   da12a:	4802      	ldr	r0, [pc, #8]	; (da134 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv+0x2c>)
   da12c:	bd38      	pop	{r3, r4, r5, pc}
   da12e:	bf00      	nop
   da130:	2003e3b4 	.word	0x2003e3b4
   da134:	2003e3b8 	.word	0x2003e3b8

000da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>:
        return instance().setClockSpeed(value, scale);
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
   da138:	b510      	push	{r4, lr}
   da13a:	4604      	mov	r4, r0
        return instance().transfer(data);
   da13c:	f7ff ffe4 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
   da140:	4621      	mov	r1, r4
    }
   da142:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
        return instance().transfer(data);
   da146:	f002 b81d 	b.w	dc184 <_ZN8SPIClass8transferEh>

000da14a <_ZL6spiRecv>:
static  uint8_t spiRec(void) {
  #ifndef USE_SPI_LIB
  spiSend(0XFF);
  return SPDR;
  #else
  return SDCARD_SPI.transfer(0xFF);
   da14a:	20ff      	movs	r0, #255	; 0xff
   da14c:	f7ff bff4 	b.w	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>

000da150 <_ZN7Sd2Card11waitNotBusyEj>:
  return true;
}
#endif
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
   da150:	b538      	push	{r3, r4, r5, lr}
   da152:	460c      	mov	r4, r1
   da154:	f001 fb3e 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
   da158:	4605      	mov	r5, r0
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) {
   da15a:	f7ff fff6 	bl	da14a <_ZL6spiRecv>
   da15e:	28ff      	cmp	r0, #255	; 0xff
   da160:	d006      	beq.n	da170 <_ZN7Sd2Card11waitNotBusyEj+0x20>
   da162:	f001 fb37 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
      return true;
    }
    d = millis() - t0;
  } while (d < timeoutMillis);
   da166:	1b40      	subs	r0, r0, r5
   da168:	42a0      	cmp	r0, r4
   da16a:	d3f6      	bcc.n	da15a <_ZN7Sd2Card11waitNotBusyEj+0xa>
  return false;
   da16c:	2000      	movs	r0, #0
   da16e:	bd38      	pop	{r3, r4, r5, pc}
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) {
      return true;
   da170:	2001      	movs	r0, #1
    }
    d = millis() - t0;
  } while (d < timeoutMillis);
  return false;
}
   da172:	bd38      	pop	{r3, r4, r5, pc}

000da174 <_ZN7Sd2Card14chipSelectHighEv>:
  }
}
//------------------------------------------------------------------------------
static uint8_t chip_select_asserted = 0;

void Sd2Card::chipSelectHigh(void) {
   da174:	b508      	push	{r3, lr}
  digitalWrite(chipSelectPin_, HIGH);
   da176:	2101      	movs	r1, #1
   da178:	7900      	ldrb	r0, [r0, #4]
   da17a:	f004 fcea 	bl	deb52 <digitalWrite>
  #ifdef USE_SPI_LIB
  if (chip_select_asserted) {
   da17e:	4b06      	ldr	r3, [pc, #24]	; (da198 <_ZN7Sd2Card14chipSelectHighEv+0x24>)
   da180:	781a      	ldrb	r2, [r3, #0]
   da182:	b13a      	cbz	r2, da194 <_ZN7Sd2Card14chipSelectHighEv+0x20>
    chip_select_asserted = 0;
   da184:	2200      	movs	r2, #0
   da186:	701a      	strb	r2, [r3, #0]
    }
    int32_t beginTransaction(const particle::__SPISettings& settings) {
        return instance().beginTransaction(settings);
    }
    void endTransaction() {
        instance().endTransaction();
   da188:	f7ff ffbe 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
    SDCARD_SPI.endTransaction();
  }
  #endif
}
   da18c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   da190:	f001 bf6f 	b.w	dc072 <_ZN8SPIClass14endTransactionEv>
   da194:	bd08      	pop	{r3, pc}
   da196:	bf00      	nop
   da198:	2003e3d0 	.word	0x2003e3d0

000da19c <_ZN7Sd2Card7readEndEv>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
   da19c:	b538      	push	{r3, r4, r5, lr}
  if (inBlock_) {
   da19e:	7983      	ldrb	r3, [r0, #6]
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
   da1a0:	4604      	mov	r4, r0
  if (inBlock_) {
   da1a2:	b173      	cbz	r3, da1c2 <_ZN7Sd2Card7readEndEv+0x26>
    }
    // wait for last crc byte
    while (!(SPSR & (1 << SPIF)))
      ;
    #else  // OPTIMIZE_HARDWARE_SPI
    while (offset_++ < 514) {
   da1a4:	f240 2501 	movw	r5, #513	; 0x201
   da1a8:	8923      	ldrh	r3, [r4, #8]
   da1aa:	1c5a      	adds	r2, r3, #1
   da1ac:	42ab      	cmp	r3, r5
   da1ae:	8122      	strh	r2, [r4, #8]
   da1b0:	d802      	bhi.n	da1b8 <_ZN7Sd2Card7readEndEv+0x1c>
      spiRec();
   da1b2:	f7ff ffca 	bl	da14a <_ZL6spiRecv>
   da1b6:	e7f7      	b.n	da1a8 <_ZN7Sd2Card7readEndEv+0xc>
    }
    #endif  // OPTIMIZE_HARDWARE_SPI
    chipSelectHigh();
   da1b8:	4620      	mov	r0, r4
   da1ba:	f7ff ffdb 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
    inBlock_ = 0;
   da1be:	2300      	movs	r3, #0
   da1c0:	71a3      	strb	r3, [r4, #6]
   da1c2:	bd38      	pop	{r3, r4, r5, pc}

000da1c4 <_ZN7Sd2Card14waitStartBlockEv>:
  } while (d < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
   da1c4:	b538      	push	{r3, r4, r5, lr}
   da1c6:	4604      	mov	r4, r0
   da1c8:	f001 fb04 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
   da1cc:	4605      	mov	r5, r0
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
   da1ce:	f7ff ffbc 	bl	da14a <_ZL6spiRecv>
   da1d2:	28ff      	cmp	r0, #255	; 0xff
   da1d4:	72e0      	strb	r0, [r4, #11]
   da1d6:	d107      	bne.n	da1e8 <_ZN7Sd2Card14waitStartBlockEv+0x24>
   da1d8:	f001 fafc 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
   da1dc:	1b40      	subs	r0, r0, r5
   da1de:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
   da1e2:	d9f4      	bls.n	da1ce <_ZN7Sd2Card14waitStartBlockEv+0xa>
   da1e4:	230f      	movs	r3, #15
   da1e6:	e002      	b.n	da1ee <_ZN7Sd2Card14waitStartBlockEv+0x2a>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (status_ != DATA_START_BLOCK) {
   da1e8:	28fe      	cmp	r0, #254	; 0xfe
   da1ea:	d006      	beq.n	da1fa <_ZN7Sd2Card14waitStartBlockEv+0x36>
   da1ec:	230d      	movs	r3, #13
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
   da1ee:	4620      	mov	r0, r4
   da1f0:	7163      	strb	r3, [r4, #5]
   da1f2:	f7ff ffbf 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
  return false;
   da1f6:	2000      	movs	r0, #0
   da1f8:	bd38      	pop	{r3, r4, r5, pc}
  }
  if (status_ != DATA_START_BLOCK) {
    error(SD_CARD_ERROR_READ);
    goto fail;
  }
  return true;
   da1fa:	2001      	movs	r0, #1

fail:
  chipSelectHigh();
  return false;
}
   da1fc:	bd38      	pop	{r3, r4, r5, pc}

000da1fe <_ZN7Sd2Card9writeDataEhPKh>:
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   da1fe:	b570      	push	{r4, r5, r6, lr}
   da200:	4605      	mov	r5, r0
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da202:	4608      	mov	r0, r1
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   da204:	4614      	mov	r4, r2
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da206:	f7ff ff97 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
   da20a:	1e66      	subs	r6, r4, #1
   da20c:	f204 14ff 	addw	r4, r4, #511	; 0x1ff
   da210:	f816 0f01 	ldrb.w	r0, [r6, #1]!
   da214:	f7ff ff90 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
  while (!(SPSR & (1 << SPIF)))
    ;

  #else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
   da218:	42a6      	cmp	r6, r4
   da21a:	d1f9      	bne.n	da210 <_ZN7Sd2Card9writeDataEhPKh+0x12>
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da21c:	20ff      	movs	r0, #255	; 0xff
   da21e:	f7ff ff8b 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
   da222:	20ff      	movs	r0, #255	; 0xff
   da224:	f7ff ff88 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
  }
  #endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
  spiSend(0xff);  // dummy crc

  status_ = spiRec();
   da228:	f7ff ff8f 	bl	da14a <_ZL6spiRecv>
   da22c:	72e8      	strb	r0, [r5, #11]
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
   da22e:	f000 001f 	and.w	r0, r0, #31
   da232:	2805      	cmp	r0, #5
   da234:	d006      	beq.n	da244 <_ZN7Sd2Card9writeDataEhPKh+0x46>
   da236:	2311      	movs	r3, #17
    error(SD_CARD_ERROR_WRITE);
    chipSelectHigh();
   da238:	4628      	mov	r0, r5
   da23a:	716b      	strb	r3, [r5, #5]
   da23c:	f7ff ff9a 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
    return false;
   da240:	2000      	movs	r0, #0
   da242:	bd70      	pop	{r4, r5, r6, pc}
  }
  return true;
   da244:	2001      	movs	r0, #1
}
   da246:	bd70      	pop	{r4, r5, r6, pc}

000da248 <_ZN7Sd2Card13chipSelectLowEv>:
    SDCARD_SPI.endTransaction();
  }
  #endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
   da248:	b510      	push	{r4, lr}
  #ifdef USE_SPI_LIB
  if (!chip_select_asserted) {
   da24a:	4b08      	ldr	r3, [pc, #32]	; (da26c <_ZN7Sd2Card13chipSelectLowEv+0x24>)
   da24c:	781a      	ldrb	r2, [r3, #0]
    SDCARD_SPI.endTransaction();
  }
  #endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
   da24e:	4604      	mov	r4, r0
  #ifdef USE_SPI_LIB
  if (!chip_select_asserted) {
   da250:	b932      	cbnz	r2, da260 <_ZN7Sd2Card13chipSelectLowEv+0x18>
    chip_select_asserted = 1;
   da252:	2201      	movs	r2, #1
   da254:	701a      	strb	r2, [r3, #0]
    }
    int32_t beginTransaction() {
        return instance().beginTransaction();
    }
    int32_t beginTransaction(const particle::__SPISettings& settings) {
        return instance().beginTransaction(settings);
   da256:	f7ff ff57 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
   da25a:	4905      	ldr	r1, [pc, #20]	; (da270 <_ZN7Sd2Card13chipSelectLowEv+0x28>)
   da25c:	f001 ff22 	bl	dc0a4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
    SDCARD_SPI.beginTransaction(settings);
  }
  #endif
  digitalWrite(chipSelectPin_, LOW);
   da260:	7920      	ldrb	r0, [r4, #4]
   da262:	2100      	movs	r1, #0
}
   da264:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
    SDCARD_SPI.beginTransaction(settings);
  }
  #endif
  digitalWrite(chipSelectPin_, LOW);
   da268:	f004 bc73 	b.w	deb52 <digitalWrite>
   da26c:	2003e3d0 	.word	0x2003e3d0
   da270:	2003e3c0 	.word	0x2003e3c0

000da274 <_ZN7Sd2Card11cardCommandEhm>:
  sei();
}
#endif  // SOFTWARE_SPI
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   da274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   da276:	4605      	mov	r5, r0
   da278:	460e      	mov	r6, r1
   da27a:	4617      	mov	r7, r2
  // end read if in partialBlockRead mode
  readEnd();
   da27c:	f7ff ff8e 	bl	da19c <_ZN7Sd2Card7readEndEv>

  // select card
  chipSelectLow();
   da280:	4628      	mov	r0, r5
   da282:	f7ff ffe1 	bl	da248 <_ZN7Sd2Card13chipSelectLowEv>

  // wait up to 300 ms if busy
  waitNotBusy(300);
   da286:	f44f 7196 	mov.w	r1, #300	; 0x12c
   da28a:	4628      	mov	r0, r5
   da28c:	f7ff ff60 	bl	da150 <_ZN7Sd2Card11waitNotBusyEj>
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da290:	f046 0040 	orr.w	r0, r6, #64	; 0x40
   da294:	f7ff ff50 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
   da298:	2418      	movs	r4, #24
   da29a:	fa27 f004 	lsr.w	r0, r7, r4
   da29e:	b2c0      	uxtb	r0, r0
   da2a0:	3c08      	subs	r4, #8
   da2a2:	f7ff ff49 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>

  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) {
   da2a6:	f114 0f08 	cmn.w	r4, #8
   da2aa:	d1f6      	bne.n	da29a <_ZN7Sd2Card11cardCommandEhm+0x26>
    spiSend(arg >> s);
  }

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) {
   da2ac:	b126      	cbz	r6, da2b8 <_ZN7Sd2Card11cardCommandEhm+0x44>
    crc = 0X95;  // correct crc for CMD0 with arg 0
  }
  if (cmd == CMD8) {
    crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
   da2ae:	2e08      	cmp	r6, #8
   da2b0:	bf14      	ite	ne
   da2b2:	20ff      	movne	r0, #255	; 0xff
   da2b4:	2087      	moveq	r0, #135	; 0x87
   da2b6:	e000      	b.n	da2ba <_ZN7Sd2Card11cardCommandEhm+0x46>
  }

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) {
    crc = 0X95;  // correct crc for CMD0 with arg 0
   da2b8:	2095      	movs	r0, #149	; 0x95
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da2ba:	f7ff ff3d 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>
   da2be:	2400      	movs	r4, #0
    crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  }
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++)
   da2c0:	f7ff ff43 	bl	da14a <_ZL6spiRecv>
   da2c4:	0603      	lsls	r3, r0, #24
   da2c6:	72e8      	strb	r0, [r5, #11]
   da2c8:	d503      	bpl.n	da2d2 <_ZN7Sd2Card11cardCommandEhm+0x5e>
   da2ca:	3401      	adds	r4, #1
   da2cc:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
   da2d0:	d1f6      	bne.n	da2c0 <_ZN7Sd2Card11cardCommandEhm+0x4c>
    ;
  return status_;
}
   da2d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000da2d4 <_ZN7Sd2Card8readDataEmttPh.part.10>:
   \param[out] dst Pointer to the location that will receive the data.
   \param[in] count Number of bytes to read
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::readData(uint32_t block,
   da2d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   da2d8:	461d      	mov	r5, r3
                          uint16_t offset, uint16_t count, uint8_t* dst) {
  if (count == 0) {
    return true;
  }
  if ((count + offset) > 512) {
   da2da:	4413      	add	r3, r2
   da2dc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   \param[out] dst Pointer to the location that will receive the data.
   \param[in] count Number of bytes to read
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::readData(uint32_t block,
   da2e0:	4604      	mov	r4, r0
   da2e2:	4616      	mov	r6, r2
   da2e4:	9f06      	ldr	r7, [sp, #24]
                          uint16_t offset, uint16_t count, uint8_t* dst) {
  if (count == 0) {
    return true;
  }
  if ((count + offset) > 512) {
   da2e6:	dc3e      	bgt.n	da366 <_ZN7Sd2Card8readDataEmttPh.part.10+0x92>
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
   da2e8:	7983      	ldrb	r3, [r0, #6]
   da2ea:	b12b      	cbz	r3, da2f8 <_ZN7Sd2Card8readDataEmttPh.part.10+0x24>
   da2ec:	6803      	ldr	r3, [r0, #0]
   da2ee:	428b      	cmp	r3, r1
   da2f0:	d102      	bne.n	da2f8 <_ZN7Sd2Card8readDataEmttPh.part.10+0x24>
   da2f2:	8903      	ldrh	r3, [r0, #8]
   da2f4:	4293      	cmp	r3, r2
   da2f6:	d916      	bls.n	da326 <_ZN7Sd2Card8readDataEmttPh.part.10+0x52>
    block_ = block;
    // use address if not SDHC card
    if (type() != SD_CARD_TYPE_SDHC) {
   da2f8:	7b23      	ldrb	r3, [r4, #12]
  }
  if ((count + offset) > 512) {
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
    block_ = block;
   da2fa:	6021      	str	r1, [r4, #0]
    // use address if not SDHC card
    if (type() != SD_CARD_TYPE_SDHC) {
   da2fc:	2b03      	cmp	r3, #3
      block <<= 9;
   da2fe:	bf18      	it	ne
   da300:	0249      	lslne	r1, r1, #9
    }
    if (cardCommand(CMD17, block)) {
   da302:	460a      	mov	r2, r1
   da304:	4620      	mov	r0, r4
   da306:	2111      	movs	r1, #17
   da308:	f7ff ffb4 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da30c:	4680      	mov	r8, r0
   da30e:	b110      	cbz	r0, da316 <_ZN7Sd2Card8readDataEmttPh.part.10+0x42>
   da310:	2303      	movs	r3, #3
   da312:	7163      	strb	r3, [r4, #5]
   da314:	e027      	b.n	da366 <_ZN7Sd2Card8readDataEmttPh.part.10+0x92>
      error(SD_CARD_ERROR_CMD17);
      goto fail;
    }
    if (!waitStartBlock()) {
   da316:	4620      	mov	r0, r4
   da318:	f7ff ff54 	bl	da1c4 <_ZN7Sd2Card14waitStartBlockEv>
   da31c:	b318      	cbz	r0, da366 <_ZN7Sd2Card8readDataEmttPh.part.10+0x92>
      goto fail;
    }
    offset_ = 0;
    inBlock_ = 1;
   da31e:	2301      	movs	r3, #1
      goto fail;
    }
    if (!waitStartBlock()) {
      goto fail;
    }
    offset_ = 0;
   da320:	f8a4 8008 	strh.w	r8, [r4, #8]
    inBlock_ = 1;
   da324:	71a3      	strb	r3, [r4, #6]
  dst[n] = SPDR;

  #else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (; offset_ < offset; offset_++) {
   da326:	8923      	ldrh	r3, [r4, #8]
   da328:	42b3      	cmp	r3, r6
   da32a:	d205      	bcs.n	da338 <_ZN7Sd2Card8readDataEmttPh.part.10+0x64>
    spiRec();
   da32c:	f7ff ff0d 	bl	da14a <_ZL6spiRecv>
  dst[n] = SPDR;

  #else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (; offset_ < offset; offset_++) {
   da330:	8923      	ldrh	r3, [r4, #8]
   da332:	3301      	adds	r3, #1
   da334:	8123      	strh	r3, [r4, #8]
   da336:	e7f6      	b.n	da326 <_ZN7Sd2Card8readDataEmttPh.part.10+0x52>
   da338:	1e6b      	subs	r3, r5, #1
   da33a:	1e7e      	subs	r6, r7, #1
   da33c:	441f      	add	r7, r3
    spiRec();
  }
  // transfer data
  for (uint16_t i = 0; i < count; i++) {
   da33e:	42be      	cmp	r6, r7
   da340:	d004      	beq.n	da34c <_ZN7Sd2Card8readDataEmttPh.part.10+0x78>
    dst[i] = spiRec();
   da342:	f7ff ff02 	bl	da14a <_ZL6spiRecv>
   da346:	f806 0f01 	strb.w	r0, [r6, #1]!
   da34a:	e7f8      	b.n	da33e <_ZN7Sd2Card8readDataEmttPh.part.10+0x6a>
  }
  #endif  // OPTIMIZE_HARDWARE_SPI

  offset_ += count;
   da34c:	8923      	ldrh	r3, [r4, #8]
  if (!partialBlockRead_ || offset_ >= 512) {
   da34e:	7aa2      	ldrb	r2, [r4, #10]
  for (uint16_t i = 0; i < count; i++) {
    dst[i] = spiRec();
  }
  #endif  // OPTIMIZE_HARDWARE_SPI

  offset_ += count;
   da350:	442b      	add	r3, r5
   da352:	b29b      	uxth	r3, r3
   da354:	8123      	strh	r3, [r4, #8]
  if (!partialBlockRead_ || offset_ >= 512) {
   da356:	b112      	cbz	r2, da35e <_ZN7Sd2Card8readDataEmttPh.part.10+0x8a>
   da358:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   da35c:	d309      	bcc.n	da372 <_ZN7Sd2Card8readDataEmttPh.part.10+0x9e>
    // read rest of data, checksum and set chip select high
    readEnd();
   da35e:	4620      	mov	r0, r4
   da360:	f7ff ff1c 	bl	da19c <_ZN7Sd2Card7readEndEv>
   da364:	e005      	b.n	da372 <_ZN7Sd2Card8readDataEmttPh.part.10+0x9e>
  }
  return true;

fail:
  chipSelectHigh();
   da366:	4620      	mov	r0, r4
   da368:	f7ff ff04 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
  return false;
   da36c:	2000      	movs	r0, #0
   da36e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  offset_ += count;
  if (!partialBlockRead_ || offset_ >= 512) {
    // read rest of data, checksum and set chip select high
    readEnd();
  }
  return true;
   da372:	2001      	movs	r0, #1

fail:
  chipSelectHigh();
  return false;
}
   da374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000da378 <_ZN7Sd2Card8readDataEmttPh>:
   \param[in] count Number of bytes to read
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::readData(uint32_t block,
                          uint16_t offset, uint16_t count, uint8_t* dst) {
   da378:	b410      	push	{r4}
  if (count == 0) {
   da37a:	b11b      	cbz	r3, da384 <_ZN7Sd2Card8readDataEmttPh+0xc>
  return true;

fail:
  chipSelectHigh();
  return false;
}
   da37c:	f85d 4b04 	ldr.w	r4, [sp], #4
   da380:	f7ff bfa8 	b.w	da2d4 <_ZN7Sd2Card8readDataEmttPh.part.10>
   da384:	2001      	movs	r0, #1
   da386:	f85d 4b04 	ldr.w	r4, [sp], #4
   da38a:	4770      	bx	lr

000da38c <_ZN7Sd2Card9readBlockEmPh>:
   \param[out] dst Pointer to the location that will receive the data.

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
   da38c:	b507      	push	{r0, r1, r2, lr}
   da38e:	f44f 7300 	mov.w	r3, #512	; 0x200
   da392:	9200      	str	r2, [sp, #0]
   da394:	2200      	movs	r2, #0
   da396:	f7ff ff9d 	bl	da2d4 <_ZN7Sd2Card8readDataEmttPh.part.10>
  return readData(block, 0, 512, dst);
}
   da39a:	b003      	add	sp, #12
   da39c:	f85d fb04 	ldr.w	pc, [sp], #4

000da3a0 <_ZN7Sd2Card10writeBlockEmPKhh>:
   \param[in] src Pointer to the location of the data to be written.
   \param[in] blocking If the write should be blocking.
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src, uint8_t blocking) {
   da3a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   da3a2:	4617      	mov	r7, r2
   da3a4:	4604      	mov	r4, r0
   da3a6:	461e      	mov	r6, r3
  #if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
   da3a8:	460a      	mov	r2, r1
   da3aa:	b909      	cbnz	r1, da3b0 <_ZN7Sd2Card10writeBlockEmPKhh+0x10>
   da3ac:	2312      	movs	r3, #18
   da3ae:	e029      	b.n	da404 <_ZN7Sd2Card10writeBlockEmPKhh+0x64>
    goto fail;
  }
  #endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
   da3b0:	7b03      	ldrb	r3, [r0, #12]
   da3b2:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
   da3b4:	bf18      	it	ne
   da3b6:	024a      	lslne	r2, r1, #9
  }
  if (cardCommand(CMD24, blockNumber)) {
   da3b8:	2118      	movs	r1, #24
   da3ba:	f7ff ff5b 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da3be:	4605      	mov	r5, r0
   da3c0:	b108      	cbz	r0, da3c6 <_ZN7Sd2Card10writeBlockEmPKhh+0x26>
   da3c2:	2304      	movs	r3, #4
   da3c4:	e01e      	b.n	da404 <_ZN7Sd2Card10writeBlockEmPKhh+0x64>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_BLOCK, src)) {
   da3c6:	463a      	mov	r2, r7
   da3c8:	21fe      	movs	r1, #254	; 0xfe
   da3ca:	4620      	mov	r0, r4
   da3cc:	f7ff ff17 	bl	da1fe <_ZN7Sd2Card9writeDataEhPKh>
   da3d0:	b1c8      	cbz	r0, da406 <_ZN7Sd2Card10writeBlockEmPKhh+0x66>
    goto fail;
  }
  if (blocking) {
   da3d2:	b926      	cbnz	r6, da3de <_ZN7Sd2Card10writeBlockEmPKhh+0x3e>
    if (cardCommand(CMD13, 0) || spiRec()) {
      error(SD_CARD_ERROR_WRITE_PROGRAMMING);
      goto fail;
    }
  }
  chipSelectHigh();
   da3d4:	4620      	mov	r0, r4
   da3d6:	f7ff fecd 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
  return true;
   da3da:	2001      	movs	r0, #1
   da3dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!writeData(DATA_START_BLOCK, src)) {
    goto fail;
  }
  if (blocking) {
    // wait for flash programming to complete
    if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   da3de:	f44f 7116 	mov.w	r1, #600	; 0x258
   da3e2:	4620      	mov	r0, r4
   da3e4:	f7ff feb4 	bl	da150 <_ZN7Sd2Card11waitNotBusyEj>
   da3e8:	b908      	cbnz	r0, da3ee <_ZN7Sd2Card10writeBlockEmPKhh+0x4e>
   da3ea:	2315      	movs	r3, #21
   da3ec:	e00a      	b.n	da404 <_ZN7Sd2Card10writeBlockEmPKhh+0x64>
      error(SD_CARD_ERROR_WRITE_TIMEOUT);
      goto fail;
    }
    // response is r2 so get and check two bytes for nonzero
    if (cardCommand(CMD13, 0) || spiRec()) {
   da3ee:	462a      	mov	r2, r5
   da3f0:	210d      	movs	r1, #13
   da3f2:	4620      	mov	r0, r4
   da3f4:	f7ff ff3e 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da3f8:	b918      	cbnz	r0, da402 <_ZN7Sd2Card10writeBlockEmPKhh+0x62>
   da3fa:	f7ff fea6 	bl	da14a <_ZL6spiRecv>
   da3fe:	2800      	cmp	r0, #0
   da400:	d0e8      	beq.n	da3d4 <_ZN7Sd2Card10writeBlockEmPKhh+0x34>
   da402:	2314      	movs	r3, #20
   da404:	7163      	strb	r3, [r4, #5]
  }
  chipSelectHigh();
  return true;

fail:
  chipSelectHigh();
   da406:	4620      	mov	r0, r4
   da408:	f7ff feb4 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
  return false;
   da40c:	2000      	movs	r0, #0
   da40e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000da410 <_ZN7Sd2Card6isBusyEv>:
/** Check if the SD card is busy

  \return The value one, true, is returned when is busy and
   the value zero, false, is returned for when is NOT busy.
*/
uint8_t Sd2Card::isBusy(void) {
   da410:	b538      	push	{r3, r4, r5, lr}
   da412:	4605      	mov	r5, r0
  chipSelectLow();
   da414:	f7ff ff18 	bl	da248 <_ZN7Sd2Card13chipSelectLowEv>
  byte b = spiRec();
   da418:	f7ff fe97 	bl	da14a <_ZL6spiRecv>
   da41c:	4604      	mov	r4, r0
  chipSelectHigh();
   da41e:	4628      	mov	r0, r5
   da420:	f7ff fea8 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>

  return (b != 0XFF);
}
   da424:	f1b4 00ff 	subs.w	r0, r4, #255	; 0xff
   da428:	bf18      	it	ne
   da42a:	2001      	movne	r0, #1
   da42c:	bd38      	pop	{r3, r4, r5, pc}
	...

000da430 <_ZN7Sd2Card4initEhh>:

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  The reason for failure
   can be determined by calling errorCode() and errorData().
*/
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
   da430:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
   da434:	2500      	movs	r5, #0
  chipSelectPin_ = chipSelectPin;
   da436:	7102      	strb	r2, [r0, #4]
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  The reason for failure
   can be determined by calling errorCode() and errorData().
*/
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
  errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
   da438:	7305      	strb	r5, [r0, #12]
   da43a:	7285      	strb	r5, [r0, #10]
   da43c:	7185      	strb	r5, [r0, #6]
   da43e:	7145      	strb	r5, [r0, #5]

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  The reason for failure
   can be determined by calling errorCode() and errorData().
*/
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
   da440:	4604      	mov	r4, r0
   da442:	460f      	mov	r7, r1
   da444:	f001 f9c6 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
  // 16-bit init start time allows over a minute
  unsigned int t0 = millis();
  uint32_t arg;

  // set pin modes
  pinMode(chipSelectPin_, OUTPUT);
   da448:	2101      	movs	r1, #1
   da44a:	4606      	mov	r6, r0
   da44c:	7920      	ldrb	r0, [r4, #4]
   da44e:	f8df 812c 	ldr.w	r8, [pc, #300]	; da57c <_ZN7Sd2Card4initEhh+0x14c>
   da452:	f004 fb6d 	bl	deb30 <pinMode>
  digitalWrite(chipSelectPin_, HIGH);
   da456:	2101      	movs	r1, #1
   da458:	7920      	ldrb	r0, [r4, #4]
   da45a:	f004 fb7a 	bl	deb52 <digitalWrite>
        static SPIClass instance(Interface);
        return instance;
    }

    void begin() {
        instance().begin();
   da45e:	f7ff fe53 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
   da462:	f001 fde1 	bl	dc028 <_ZN8SPIClass5beginEv>
   da466:	4b44      	ldr	r3, [pc, #272]	; (da578 <_ZN7Sd2Card4initEhh+0x148>)
   da468:	f8c8 3008 	str.w	r3, [r8, #8]
   da46c:	2301      	movs	r3, #1
   da46e:	f888 5004 	strb.w	r5, [r8, #4]
   da472:	f888 300c 	strb.w	r3, [r8, #12]
   da476:	f888 500d 	strb.w	r5, [r8, #13]
    }
    int32_t beginTransaction() {
        return instance().beginTransaction();
    }
    int32_t beginTransaction(const particle::__SPISettings& settings) {
        return instance().beginTransaction(settings);
   da47a:	f7ff fe45 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
   da47e:	4641      	mov	r1, r8
   da480:	f001 fe10 	bl	dc0a4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
   da484:	250a      	movs	r5, #10
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
   da486:	20ff      	movs	r0, #255	; 0xff
   da488:	3d01      	subs	r5, #1
   da48a:	f7ff fe55 	bl	da138 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8transferEh.isra.6>

  // must supply min of 74 clock cycles with CS high.
  #ifdef USE_SPI_LIB
  SDCARD_SPI.beginTransaction(settings);
  #endif
  for (uint8_t i = 0; i < 10; i++) {
   da48e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   da492:	d1f8      	bne.n	da486 <_ZN7Sd2Card4initEhh+0x56>
    }
    void endTransaction() {
        instance().endTransaction();
   da494:	f7ff fe38 	bl	da108 <_ZN8particle8SpiProxyIL17HAL_SPI_Interface0EE8instanceEv>
   da498:	f001 fdeb 	bl	dc072 <_ZN8SPIClass14endTransactionEv>
  }
  #ifdef USE_SPI_LIB
  SDCARD_SPI.endTransaction();
  #endif

  chipSelectLow();
   da49c:	4620      	mov	r0, r4
   da49e:	f7ff fed3 	bl	da248 <_ZN7Sd2Card13chipSelectLowEv>

  // command to go idle in SPI mode
  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
   da4a2:	2200      	movs	r2, #0
   da4a4:	4611      	mov	r1, r2
   da4a6:	4620      	mov	r0, r4
   da4a8:	f7ff fee4 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da4ac:	2801      	cmp	r0, #1
   da4ae:	4605      	mov	r5, r0
   da4b0:	72e0      	strb	r0, [r4, #11]
   da4b2:	d007      	beq.n	da4c4 <_ZN7Sd2Card4initEhh+0x94>
   da4b4:	f001 f98e 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
    unsigned int d = millis() - t0;
    if (d > SD_INIT_TIMEOUT) {
   da4b8:	1b80      	subs	r0, r0, r6
   da4ba:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
   da4be:	d9f0      	bls.n	da4a2 <_ZN7Sd2Card4initEhh+0x72>
   da4c0:	2301      	movs	r3, #1
   da4c2:	e03a      	b.n	da53a <_ZN7Sd2Card4initEhh+0x10a>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
  }
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
   da4c4:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
   da4c8:	2108      	movs	r1, #8
   da4ca:	4620      	mov	r0, r4
   da4cc:	f7ff fed2 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da4d0:	0743      	lsls	r3, r0, #29
   da4d2:	d501      	bpl.n	da4d8 <_ZN7Sd2Card4initEhh+0xa8>
    uint8_t readRegister(uint8_t cmd, void* buf);
    uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
    void chipSelectHigh(void);
    void chipSelectLow(void);
    void type(uint8_t value) {
      type_ = value;
   da4d4:	7325      	strb	r5, [r4, #12]
   da4d6:	e00c      	b.n	da4f2 <_ZN7Sd2Card4initEhh+0xc2>
   da4d8:	2504      	movs	r5, #4
    type(SD_CARD_TYPE_SD1);
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) {
      status_ = spiRec();
   da4da:	f7ff fe36 	bl	da14a <_ZL6spiRecv>
   da4de:	3d01      	subs	r5, #1
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD1);
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) {
   da4e0:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
      status_ = spiRec();
   da4e4:	72e0      	strb	r0, [r4, #11]
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD1);
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) {
   da4e6:	d1f8      	bne.n	da4da <_ZN7Sd2Card4initEhh+0xaa>
      status_ = spiRec();
    }
    if (status_ != 0XAA) {
   da4e8:	28aa      	cmp	r0, #170	; 0xaa
   da4ea:	f04f 0302 	mov.w	r3, #2
   da4ee:	d124      	bne.n	da53a <_ZN7Sd2Card4initEhh+0x10a>
   da4f0:	7323      	strb	r3, [r4, #12]
      goto fail;
    }
    type(SD_CARD_TYPE_SD2);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
   da4f2:	7b23      	ldrb	r3, [r4, #12]
   da4f4:	2b02      	cmp	r3, #2
   da4f6:	bf0c      	ite	eq
   da4f8:	f04f 4580 	moveq.w	r5, #1073741824	; 0x40000000
   da4fc:	2500      	movne	r5, #0
    uint8_t partialBlockRead_;
    uint8_t status_;
    uint8_t type_;
    // private functions
    uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
      cardCommand(CMD55, 0);
   da4fe:	2200      	movs	r2, #0
   da500:	2137      	movs	r1, #55	; 0x37
   da502:	4620      	mov	r0, r4
   da504:	f7ff feb6 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
      return cardCommand(cmd, arg);
   da508:	462a      	mov	r2, r5
   da50a:	2129      	movs	r1, #41	; 0x29
   da50c:	4620      	mov	r0, r4
   da50e:	f7ff feb1 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da512:	4602      	mov	r2, r0

  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
   da514:	72e0      	strb	r0, [r4, #11]
   da516:	b138      	cbz	r0, da528 <_ZN7Sd2Card4initEhh+0xf8>
   da518:	f001 f95c 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
    // check for timeout
    unsigned int d = millis() - t0;
    if (d > SD_INIT_TIMEOUT) {
   da51c:	1b80      	subs	r0, r0, r6
   da51e:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
   da522:	d9ec      	bls.n	da4fe <_ZN7Sd2Card4initEhh+0xce>
    }
    uint8_t cardCommand(uint8_t cmd, uint32_t arg);
    void error(uint8_t code) {
      errorCode_ = code;
   da524:	2308      	movs	r3, #8
   da526:	e008      	b.n	da53a <_ZN7Sd2Card4initEhh+0x10a>
      error(SD_CARD_ERROR_ACMD41);
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
   da528:	7b23      	ldrb	r3, [r4, #12]
   da52a:	2b02      	cmp	r3, #2
   da52c:	d11a      	bne.n	da564 <_ZN7Sd2Card4initEhh+0x134>
    if (cardCommand(CMD58, 0)) {
   da52e:	213a      	movs	r1, #58	; 0x3a
   da530:	4620      	mov	r0, r4
   da532:	f7ff fe9f 	bl	da274 <_ZN7Sd2Card11cardCommandEhm>
   da536:	b138      	cbz	r0, da548 <_ZN7Sd2Card4initEhh+0x118>
   da538:	2306      	movs	r3, #6
  #else  // SOFTWARE_SPI
  return true;
  #endif  // SOFTWARE_SPI

fail:
  chipSelectHigh();
   da53a:	4620      	mov	r0, r4
   da53c:	7163      	strb	r3, [r4, #5]
   da53e:	f7ff fe19 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>
  return false;
}
   da542:	2000      	movs	r0, #0
   da544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiRec() & 0XC0) == 0XC0) {
   da548:	f7ff fdff 	bl	da14a <_ZL6spiRecv>
   da54c:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
   da550:	28c0      	cmp	r0, #192	; 0xc0
    uint8_t readRegister(uint8_t cmd, void* buf);
    uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
    void chipSelectHigh(void);
    void chipSelectLow(void);
    void type(uint8_t value) {
      type_ = value;
   da552:	bf04      	itt	eq
   da554:	2303      	moveq	r3, #3
   da556:	7323      	strbeq	r3, [r4, #12]
      type(SD_CARD_TYPE_SDHC);
    }
    // discard rest of ocr - contains allowed voltage range
    for (uint8_t i = 0; i < 3; i++) {
      spiRec();
   da558:	f7ff fdf7 	bl	da14a <_ZL6spiRecv>
   da55c:	f7ff fdf5 	bl	da14a <_ZL6spiRecv>
   da560:	f7ff fdf3 	bl	da14a <_ZL6spiRecv>
    }
  }
  chipSelectHigh();
   da564:	4620      	mov	r0, r4
   da566:	f7ff fe05 	bl	da174 <_ZN7Sd2Card14chipSelectHighEv>

  #ifndef SOFTWARE_SPI
  return setSckRate(sckRateID);
   da56a:	4639      	mov	r1, r7
   da56c:	4620      	mov	r0, r4
  #endif  // SOFTWARE_SPI

fail:
  chipSelectHigh();
  return false;
}
   da56e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
  }
  chipSelectHigh();

  #ifndef SOFTWARE_SPI
  return setSckRate(sckRateID);
   da572:	f7ff bd8d 	b.w	da090 <_ZN7Sd2Card10setSckRateEh>
   da576:	bf00      	nop
   da578:	0003d090 	.word	0x0003d090
   da57c:	2003e3c0 	.word	0x2003e3c0

000da580 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm>:
  chipSelectLow();
  byte b = spiRec();
  chipSelectHigh();

  return (b != 0XFF);
}
   da580:	b508      	push	{r3, lr}
   da582:	f001 f897 	bl	db6b4 <HAL_Pin_Map>
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
   da586:	4b05      	ldr	r3, [pc, #20]	; (da59c <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0x1c>)
   da588:	4a05      	ldr	r2, [pc, #20]	; (da5a0 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0x20>)
   da58a:	601a      	str	r2, [r3, #0]
   da58c:	2201      	movs	r2, #1
   da58e:	711a      	strb	r2, [r3, #4]
   da590:	2200      	movs	r2, #0
   da592:	609a      	str	r2, [r3, #8]
   da594:	731a      	strb	r2, [r3, #12]
   da596:	735a      	strb	r2, [r3, #13]
   da598:	bd08      	pop	{r3, pc}
   da59a:	bf00      	nop
   da59c:	2003e3c0 	.word	0x2003e3c0
   da5a0:	000e09f4 	.word	0x000e09f4

000da5a4 <_ZN5SDLib4File5writeEh>:
bool File::isDirectory(void) {
  return (_file && _file->isDir());
}


size_t File::write(uint8_t val) {
   da5a4:	b513      	push	{r0, r1, r4, lr}
   da5a6:	ab02      	add	r3, sp, #8
  return write(&val, 1);
   da5a8:	6802      	ldr	r2, [r0, #0]
bool File::isDirectory(void) {
  return (_file && _file->isDir());
}


size_t File::write(uint8_t val) {
   da5aa:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return write(&val, 1);
   da5ae:	68d4      	ldr	r4, [r2, #12]
   da5b0:	4619      	mov	r1, r3
   da5b2:	2201      	movs	r2, #1
   da5b4:	47a0      	blx	r4
}
   da5b6:	b002      	add	sp, #8
   da5b8:	bd10      	pop	{r4, pc}

000da5ba <_ZN5SDLib4File5writeEPKhj>:

size_t File::write(const uint8_t *buf, size_t size) {
   da5ba:	b510      	push	{r4, lr}
  size_t t;
  if (!_file) {
   da5bc:	6a03      	ldr	r3, [r0, #32]

size_t File::write(uint8_t val) {
  return write(&val, 1);
}

size_t File::write(const uint8_t *buf, size_t size) {
   da5be:	4604      	mov	r4, r0
  size_t t;
  if (!_file) {
   da5c0:	b91b      	cbnz	r3, da5ca <_ZN5SDLib4File5writeEPKhj+0x10>
   da5c2:	2301      	movs	r3, #1
   da5c4:	6063      	str	r3, [r4, #4]
    setWriteError();
    return 0;
   da5c6:	2000      	movs	r0, #0
   da5c8:	bd10      	pop	{r4, pc}
   da5ca:	2000      	movs	r0, #0
   da5cc:	6058      	str	r0, [r3, #4]
  }
  _file->clearWriteError();
  t = _file->write(buf, size);
   da5ce:	b292      	uxth	r2, r2
   da5d0:	6a20      	ldr	r0, [r4, #32]
   da5d2:	f7ff fc45 	bl	d9e60 <_ZN6SdFile5writeEPKvt>
   da5d6:	6a23      	ldr	r3, [r4, #32]
  if (_file->getWriteError()) {
   da5d8:	685b      	ldr	r3, [r3, #4]
   da5da:	2b00      	cmp	r3, #0
   da5dc:	d1f1      	bne.n	da5c2 <_ZN5SDLib4File5writeEPKhj+0x8>
    setWriteError();
    return 0;
  }
  return t;
}
   da5de:	bd10      	pop	{r4, pc}

000da5e0 <_ZN5SDLib4File17availableForWriteEv>:

int File::availableForWrite() {
  if (_file) {
   da5e0:	6a00      	ldr	r0, [r0, #32]
   da5e2:	b108      	cbz	r0, da5e8 <_ZN5SDLib4File17availableForWriteEv+0x8>
    return _file->availableForWrite();
   da5e4:	f7ff bd16 	b.w	da014 <_ZN6SdFile17availableForWriteEv>
  }
  return 0;
}
   da5e8:	4770      	bx	lr

000da5ea <_ZN5SDLib4File5flushEv>:

  return n > 0X7FFF ? 0X7FFF : n;
}

void File::flush() {
  if (_file) {
   da5ea:	6a00      	ldr	r0, [r0, #32]
   da5ec:	b110      	cbz	r0, da5f4 <_ZN5SDLib4File5flushEv+0xa>
    _file->sync();
   da5ee:	2101      	movs	r1, #1
   da5f0:	f7ff ba02 	b.w	d99f8 <_ZN6SdFile4syncEh>
   da5f4:	4770      	bx	lr

000da5f6 <_ZN6SdFile4readEv>:
       Read the next byte from a file.

       \return For success read returns the next byte in the file as an int.
       If an error occurs or end of file is reached -1 is returned.
    */
    int16_t read(void) {
   da5f6:	b507      	push	{r0, r1, r2, lr}
      uint8_t b;
      return read(&b, 1) == 1 ? b : -1;
   da5f8:	2201      	movs	r2, #1
   da5fa:	f10d 0107 	add.w	r1, sp, #7
   da5fe:	f7ff f90b 	bl	d9818 <_ZN6SdFile4readEPvt>
   da602:	2801      	cmp	r0, #1
   da604:	bf0c      	ite	eq
   da606:	f89d 0007 	ldrbeq.w	r0, [sp, #7]
   da60a:	f04f 30ff 	movne.w	r0, #4294967295
    }
   da60e:	b003      	add	sp, #12
   da610:	f85d fb04 	ldr.w	pc, [sp], #4

000da614 <_ZN5SDLib4File4readEv>:
    _file->seekCur(-1);
  }
  return c;
}

int File::read() {
   da614:	b508      	push	{r3, lr}
  if (_file) {
   da616:	6a00      	ldr	r0, [r0, #32]
   da618:	b110      	cbz	r0, da620 <_ZN5SDLib4File4readEv+0xc>
    return _file->read();
   da61a:	f7ff ffec 	bl	da5f6 <_ZN6SdFile4readEv>
   da61e:	bd08      	pop	{r3, pc}
  }
  return -1;
   da620:	f04f 30ff 	mov.w	r0, #4294967295
}
   da624:	bd08      	pop	{r3, pc}

000da626 <_ZN5SDLib4File4peekEv>:
    return _file->availableForWrite();
  }
  return 0;
}

int File::peek() {
   da626:	b538      	push	{r3, r4, r5, lr}
   da628:	4605      	mov	r5, r0
  if (! _file) {
   da62a:	6a00      	ldr	r0, [r0, #32]
   da62c:	b150      	cbz	r0, da644 <_ZN5SDLib4File4peekEv+0x1e>
    return 0;
  }

  int c = _file->read();
   da62e:	f7ff ffe2 	bl	da5f6 <_ZN6SdFile4readEv>
  if (c != -1) {
   da632:	1c43      	adds	r3, r0, #1
int File::peek() {
  if (! _file) {
    return 0;
  }

  int c = _file->read();
   da634:	4604      	mov	r4, r0
  if (c != -1) {
   da636:	d004      	beq.n	da642 <_ZN5SDLib4File4peekEv+0x1c>
    _file->seekCur(-1);
   da638:	6a28      	ldr	r0, [r5, #32]
    }
    uint8_t rmDir(void);
    uint8_t rmRfStar(void);
    /** Set the files position to current position + \a pos. See seekSet(). */
    uint8_t seekCur(uint32_t pos) {
      return seekSet(curPosition_ + pos);
   da63a:	6901      	ldr	r1, [r0, #16]
   da63c:	3901      	subs	r1, #1
   da63e:	f7ff f9ab 	bl	d9998 <_ZN6SdFile7seekSetEm>
   da642:	4620      	mov	r0, r4
  }
  return c;
}
   da644:	bd38      	pop	{r3, r4, r5, pc}
	...

000da648 <_ZN5SDLib4FileC1E6SdFilePKc>:
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   da648:	2300      	movs	r3, #0

/* for debugging file open/close leaks
   uint8_t nfilecount=0;
*/

File::File(SdFile f, const char *n) {
   da64a:	b570      	push	{r4, r5, r6, lr}
   da64c:	6043      	str	r3, [r0, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   da64e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   da652:	6083      	str	r3, [r0, #8]
   da654:	4b0e      	ldr	r3, [pc, #56]	; (da690 <_ZN5SDLib4FileC1E6SdFilePKc+0x48>)
   da656:	6003      	str	r3, [r0, #0]
   da658:	4604      	mov	r4, r0
  // oh man you are kidding me, new() doesn't exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile));
   da65a:	2028      	movs	r0, #40	; 0x28

/* for debugging file open/close leaks
   uint8_t nfilecount=0;
*/

File::File(SdFile f, const char *n) {
   da65c:	460d      	mov	r5, r1
   da65e:	4616      	mov	r6, r2
  // oh man you are kidding me, new() doesn't exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile));
   da660:	f001 fbaa 	bl	dbdb8 <malloc>
   da664:	6220      	str	r0, [r4, #32]
  if (_file) {
   da666:	b180      	cbz	r0, da68a <_ZN5SDLib4FileC1E6SdFilePKc+0x42>
    memcpy(_file, &f, sizeof(SdFile));
   da668:	462b      	mov	r3, r5
   da66a:	f105 0228 	add.w	r2, r5, #40	; 0x28
   da66e:	f853 1b04 	ldr.w	r1, [r3], #4
   da672:	f840 1b04 	str.w	r1, [r0], #4
   da676:	4293      	cmp	r3, r2
   da678:	d1f9      	bne.n	da66e <_ZN5SDLib4FileC1E6SdFilePKc+0x26>

    strncpy(_name, n, 12);
   da67a:	220c      	movs	r2, #12
   da67c:	4631      	mov	r1, r6
   da67e:	f104 0010 	add.w	r0, r4, #16
   da682:	f005 fd0e 	bl	e00a2 <strncpy>
    _name[12] = 0;
   da686:	2300      	movs	r3, #0
   da688:	7723      	strb	r3, [r4, #28]
       Serial.print(n);
       Serial.print("\": ");
       Serial.println(nfilecount, DEC);
    */
  }
}
   da68a:	4620      	mov	r0, r4
   da68c:	bd70      	pop	{r4, r5, r6, pc}
   da68e:	bf00      	nop
   da690:	000e2370 	.word	0x000e2370

000da694 <_ZN5SDLib4FileC1Ev>:
   da694:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   da698:	2200      	movs	r2, #0
   da69a:	6081      	str	r1, [r0, #8]

File::File(void) {
   da69c:	4902      	ldr	r1, [pc, #8]	; (da6a8 <_ZN5SDLib4FileC1Ev+0x14>)
   da69e:	6042      	str	r2, [r0, #4]
   da6a0:	6001      	str	r1, [r0, #0]
  _file = 0;
   da6a2:	6202      	str	r2, [r0, #32]
  _name[0] = 0;
   da6a4:	7402      	strb	r2, [r0, #16]
  //Serial.print("Created empty file object");
}
   da6a6:	4770      	bx	lr
   da6a8:	000e2370 	.word	0x000e2370

000da6ac <_ZN5SDLib4File4nameEv>:

// returns a pointer to the file name
char *File::name(void) {
  return _name;
}
   da6ac:	3010      	adds	r0, #16
   da6ae:	4770      	bx	lr

000da6b0 <_ZN5SDLib4File11isDirectoryEv>:

// a directory is a special type of file
bool File::isDirectory(void) {
  return (_file && _file->isDir());
   da6b0:	6a00      	ldr	r0, [r0, #32]
   da6b2:	b120      	cbz	r0, da6be <_ZN5SDLib4File11isDirectoryEv+0xe>
   da6b4:	7a40      	ldrb	r0, [r0, #9]
   da6b6:	2801      	cmp	r0, #1
   da6b8:	bf94      	ite	ls
   da6ba:	2000      	movls	r0, #0
   da6bc:	2001      	movhi	r0, #1
}
   da6be:	4770      	bx	lr

000da6c0 <_ZN5SDLib4File4readEPvt>:
  }
  return -1;
}

// buffered read for more efficient, high speed reading
int File::read(void *buf, uint16_t nbyte) {
   da6c0:	b508      	push	{r3, lr}
  if (_file) {
   da6c2:	6a00      	ldr	r0, [r0, #32]
   da6c4:	b108      	cbz	r0, da6ca <_ZN5SDLib4File4readEPvt+0xa>
    return _file->read(buf, nbyte);
   da6c6:	f7ff f8a7 	bl	d9818 <_ZN6SdFile4readEPvt>
  }
  return 0;
}
   da6ca:	bd08      	pop	{r3, pc}

000da6cc <_ZN5SDLib4File8positionEv>:

  return _file->seekSet(pos);
}

uint32_t File::position() {
  if (! _file) {
   da6cc:	6a03      	ldr	r3, [r0, #32]
   da6ce:	b10b      	cbz	r3, da6d4 <_ZN5SDLib4File8positionEv+0x8>
   da6d0:	6918      	ldr	r0, [r3, #16]
    return -1;
  }
  return _file->curPosition();
   da6d2:	4770      	bx	lr
  return _file->seekSet(pos);
}

uint32_t File::position() {
  if (! _file) {
    return -1;
   da6d4:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return _file->curPosition();
}
   da6d8:	4770      	bx	lr

000da6da <_ZN5SDLib4File4sizeEv>:

uint32_t File::size() {
  if (! _file) {
   da6da:	6a00      	ldr	r0, [r0, #32]
   da6dc:	b100      	cbz	r0, da6e0 <_ZN5SDLib4File4sizeEv+0x6>
   da6de:	69c0      	ldr	r0, [r0, #28]
    return 0;
  }
  return _file->fileSize();
}
   da6e0:	4770      	bx	lr

000da6e2 <_ZN5SDLib4File9availableEv>:
    return _file->read(buf, nbyte);
  }
  return 0;
}

int File::available() {
   da6e2:	b508      	push	{r3, lr}
  if (! _file) {
   da6e4:	6a03      	ldr	r3, [r0, #32]
    return _file->read(buf, nbyte);
  }
  return 0;
}

int File::available() {
   da6e6:	4601      	mov	r1, r0
  if (! _file) {
   da6e8:	b163      	cbz	r3, da704 <_ZN5SDLib4File9availableEv+0x22>
    return 0;
  }

  uint32_t n = size() - position();
   da6ea:	f7ff fff6 	bl	da6da <_ZN5SDLib4File4sizeEv>
   da6ee:	4602      	mov	r2, r0
   da6f0:	4608      	mov	r0, r1
   da6f2:	f7ff ffeb 	bl	da6cc <_ZN5SDLib4File8positionEv>

  return n > 0X7FFF ? 0X7FFF : n;
   da6f6:	f647 73ff 	movw	r3, #32767	; 0x7fff
   da6fa:	1a10      	subs	r0, r2, r0
   da6fc:	4298      	cmp	r0, r3
   da6fe:	bf28      	it	cs
   da700:	4618      	movcs	r0, r3
   da702:	bd08      	pop	{r3, pc}
  return 0;
}

int File::available() {
  if (! _file) {
    return 0;
   da704:	4618      	mov	r0, r3
  }

  uint32_t n = size() - position();

  return n > 0X7FFF ? 0X7FFF : n;
}
   da706:	bd08      	pop	{r3, pc}

000da708 <_ZN5SDLib4File5closeEv>:
    return 0;
  }
  return _file->fileSize();
}

void File::close() {
   da708:	b510      	push	{r4, lr}
   da70a:	4604      	mov	r4, r0
  if (_file) {
   da70c:	6a00      	ldr	r0, [r0, #32]
   da70e:	b130      	cbz	r0, da71e <_ZN5SDLib4File5closeEv+0x16>
    _file->close();
   da710:	f7ff f9a4 	bl	d9a5c <_ZN6SdFile5closeEv>
    free(_file);
   da714:	6a20      	ldr	r0, [r4, #32]
   da716:	f001 fb57 	bl	dbdc8 <free>
    _file = 0;
   da71a:	2300      	movs	r3, #0
   da71c:	6223      	str	r3, [r4, #32]
   da71e:	bd10      	pop	{r4, pc}

000da720 <_ZN5SDLib4FilecvbEv>:
    */
  }
}

File::operator bool() {
  if (_file) {
   da720:	6a00      	ldr	r0, [r0, #32]
   da722:	b118      	cbz	r0, da72c <_ZN5SDLib4FilecvbEv+0xc>
    uint8_t isFile(void) const {
      return type_ == FAT_FILE_TYPE_NORMAL;
    }
    /** \return True if this is a SdFile for an open file/directory else false. */
    uint8_t isOpen(void) const {
      return type_ != FAT_FILE_TYPE_CLOSED;
   da724:	7a40      	ldrb	r0, [r0, #9]
   da726:	3000      	adds	r0, #0
   da728:	bf18      	it	ne
   da72a:	2001      	movne	r0, #1
    return  _file->isOpen();
  }
  return false;
}
   da72c:	4770      	bx	lr

000da72e <_GLOBAL__sub_I__ZN5SDLib4FileC2E6SdFilePKc>:
   da72e:	f000 bfc1 	b.w	db6b4 <HAL_Pin_Map>

000da732 <_GLOBAL__sub_I__ZN17particleftpclient17ParticleFtpClient4openE6Stringti>:
   da732:	f000 bfbf 	b.w	db6b4 <HAL_Pin_Map>

000da736 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv>:
          d_println("Could not connect to PASV port!");
      }
      return data.connected();
  }

  int ParticleFtpClient::parse_response() {
   da736:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
      int tries = 0;
      uint8_t index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
   da73a:	f100 0838 	add.w	r8, r0, #56	; 0x38
          d_println("Could not connect to PASV port!");
      }
      return data.connected();
  }

  int ParticleFtpClient::parse_response() {
   da73e:	4606      	mov	r6, r0
      int tries = 0;
      uint8_t index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
   da740:	f44f 7287 	mov.w	r2, #270	; 0x10e
   da744:	2100      	movs	r1, #0
   da746:	4640      	mov	r0, r8
   da748:	f005 fc0e 	bl	dff68 <memset>
      bool responded = false;
   da74c:	2400      	movs	r4, #0
      return data.connected();
  }

  int ParticleFtpClient::parse_response() {
      int tries = 0;
      uint8_t index = 0;
   da74e:	4625      	mov	r5, r4
      }
      return data.connected();
  }

  int ParticleFtpClient::parse_response() {
      int tries = 0;
   da750:	4627      	mov	r7, r4
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
      bool responded = false;
      d_print("Server response: ");
      while (tries < maxTries && !responded) {
          delay(1000);
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
   da752:	f106 091c 	add.w	r9, r6, #28
      int tries = 0;
      uint8_t index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
      bool responded = false;
      d_print("Server response: ");
      while (tries < maxTries && !responded) {
   da756:	f8d6 3148 	ldr.w	r3, [r6, #328]	; 0x148
   da75a:	429f      	cmp	r7, r3
   da75c:	da17      	bge.n	da78e <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x58>
   da75e:	b9bc      	cbnz	r4, da790 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x5a>
          delay(1000);
   da760:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   da764:	f002 fcea 	bl	dd13c <delay>
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
   da768:	4648      	mov	r0, r9
   da76a:	f004 f84d 	bl	de808 <_ZN9TCPClient9availableEv>
   da76e:	b320      	cbz	r0, da7ba <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x84>
              tries = 0;
              char val = server_cmd_connection.read();
   da770:	4648      	mov	r0, r9
   da772:	f003 fef2 	bl	de55a <_ZN9TCPClient4readEv>
              cmd_response_buffer[index++] = val;
   da776:	1c6b      	adds	r3, r5, #1
   da778:	b2db      	uxtb	r3, r3
   da77a:	4435      	add	r5, r6
              responded = index > 3;
   da77c:	2b03      	cmp	r3, #3
      while (tries < maxTries && !responded) {
          delay(1000);
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
              tries = 0;
              char val = server_cmd_connection.read();
              cmd_response_buffer[index++] = val;
   da77e:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
              responded = index > 3;
   da782:	bf94      	ite	ls
   da784:	2400      	movls	r4, #0
   da786:	2401      	movhi	r4, #1
      bool responded = false;
      d_print("Server response: ");
      while (tries < maxTries && !responded) {
          delay(1000);
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
              tries = 0;
   da788:	2700      	movs	r7, #0
              char val = server_cmd_connection.read();
              cmd_response_buffer[index++] = val;
   da78a:	461d      	mov	r5, r3
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
      bool responded = false;
      d_print("Server response: ");
      while (tries < maxTries && !responded) {
          delay(1000);
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
   da78c:	e7ec      	b.n	da768 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x32>
          }
          tries++;
      }
      if (tries >= maxTries) d_println("Server timed out on response");
      d_println();
      if (!responded) return 0;
   da78e:	b194      	cbz	r4, da7b6 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x80>
      char code_string[4] = { 0 };
   da790:	ac02      	add	r4, sp, #8
   da792:	2300      	movs	r3, #0
   da794:	f844 3d04 	str.w	r3, [r4, #-4]!
      memcpy(code_string, cmd_response_buffer, 3);
   da798:	f8b8 2000 	ldrh.w	r2, [r8]
   da79c:	f898 3002 	ldrb.w	r3, [r8, #2]
   da7a0:	f8ad 2004 	strh.w	r2, [sp, #4]
      server_cmd_connection.flush();
   da7a4:	f106 001c 	add.w	r0, r6, #28
      }
      if (tries >= maxTries) d_println("Server timed out on response");
      d_println();
      if (!responded) return 0;
      char code_string[4] = { 0 };
      memcpy(code_string, cmd_response_buffer, 3);
   da7a8:	70a3      	strb	r3, [r4, #2]
      server_cmd_connection.flush();
   da7aa:	f003 fe41 	bl	de430 <_ZN9TCPClient5flushEv>

      return atoi(code_string);
   da7ae:	4620      	mov	r0, r4
   da7b0:	f005 fa9e 	bl	dfcf0 <atoi>
   da7b4:	e003      	b.n	da7be <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x88>
          }
          tries++;
      }
      if (tries >= maxTries) d_println("Server timed out on response");
      d_println();
      if (!responded) return 0;
   da7b6:	4620      	mov	r0, r4
   da7b8:	e001      	b.n	da7be <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x88>
              char val = server_cmd_connection.read();
              cmd_response_buffer[index++] = val;
              responded = index > 3;
              d_print(val);
          }
          tries++;
   da7ba:	3701      	adds	r7, #1
      int tries = 0;
      uint8_t index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
      bool responded = false;
      d_print("Server response: ");
      while (tries < maxTries && !responded) {
   da7bc:	e7cb      	b.n	da756 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv+0x20>
      char code_string[4] = { 0 };
      memcpy(code_string, cmd_response_buffer, 3);
      server_cmd_connection.flush();

      return atoi(code_string);
  }
   da7be:	b003      	add	sp, #12
   da7c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000da7c4 <_ZN17particleftpclient17ParticleFtpClient4openE6Stringti>:
  #define d_println(message)      ;
  #endif

  #define expect(code)            if (code / 100 != parse_response() / 100) return false;

  bool ParticleFtpClient::open(String hostname, uint16_t port, int timeout) {
   da7c4:	b538      	push	{r3, r4, r5, lr}
      maxTries = timeout;
   da7c6:	f8c0 3148 	str.w	r3, [r0, #328]	; 0x148
  #ifdef PARTICLE_FTP_DEBUG
  //    Serial.begin(9600);
  #endif
      d_println("Connecting...");
      server_cmd_connection.connect(hostname, port);
   da7ca:	f100 041c 	add.w	r4, r0, #28
  #define d_println(message)      ;
  #endif

  #define expect(code)            if (code / 100 != parse_response() / 100) return false;

  bool ParticleFtpClient::open(String hostname, uint16_t port, int timeout) {
   da7ce:	4605      	mov	r5, r0
      maxTries = timeout;
  #ifdef PARTICLE_FTP_DEBUG
  //    Serial.begin(9600);
  #endif
      d_println("Connecting...");
      server_cmd_connection.connect(hostname, port);
   da7d0:	2300      	movs	r3, #0
   da7d2:	6809      	ldr	r1, [r1, #0]
   da7d4:	4620      	mov	r0, r4
   da7d6:	f003 ff03 	bl	de5e0 <_ZN9TCPClient7connectEPKctm>
      if (!server_cmd_connection.connected()) {
   da7da:	4620      	mov	r0, r4
   da7dc:	f003 fe29 	bl	de432 <_ZN9TCPClient9connectedEv>
   da7e0:	b908      	cbnz	r0, da7e6 <_ZN17particleftpclient17ParticleFtpClient4openE6Stringti+0x22>
          d_println("Failed to connect to command port");
          return false;
   da7e2:	2000      	movs	r0, #0
   da7e4:	bd38      	pop	{r3, r4, r5, pc}
      }
      d_println("Waiting for welcome message");
      expect(200);
   da7e6:	4628      	mov	r0, r5
   da7e8:	f7ff ffa5 	bl	da736 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv>
   da7ec:	38c8      	subs	r0, #200	; 0xc8
   da7ee:	2863      	cmp	r0, #99	; 0x63
   da7f0:	d8f7      	bhi.n	da7e2 <_ZN17particleftpclient17ParticleFtpClient4openE6Stringti+0x1e>
      d_println("Welcome received");
      server_cmd_connection.flush(); // Get rid of annoying welcome messages
   da7f2:	4620      	mov	r0, r4
   da7f4:	f003 fe1c 	bl	de430 <_ZN9TCPClient5flushEv>
      return true;
   da7f8:	2001      	movs	r0, #1
  }
   da7fa:	bd38      	pop	{r3, r4, r5, pc}

000da7fc <_ZN17particleftpclient17ParticleFtpClient4sizeE6String>:

  bool ParticleFtpClient::connected() {
      return server_cmd_connection.connected();
  }

  int ParticleFtpClient::size(String filename) {
   da7fc:	b530      	push	{r4, r5, lr}
   da7fe:	b085      	sub	sp, #20
   da800:	4604      	mov	r4, r0
   da802:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da804:	4668      	mov	r0, sp
   da806:	490f      	ldr	r1, [pc, #60]	; (da844 <_ZN17particleftpclient17ParticleFtpClient4sizeE6String+0x48>)
   da808:	f001 fed3 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      server_cmd_connection.println("SIZE " + filename);
   da80c:	4629      	mov	r1, r5
   da80e:	4668      	mov	r0, sp
   da810:	f001 ffaa 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da814:	6801      	ldr	r1, [r0, #0]
   da816:	f104 001c 	add.w	r0, r4, #28
   da81a:	f002 fb26 	bl	dce6a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da81e:	4668      	mov	r0, sp
   da820:	f001 fe80 	bl	dc524 <_ZN6StringD1Ev>
      int result = parse_response();
   da824:	4620      	mov	r0, r4
   da826:	f7ff ff86 	bl	da736 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv>
      if (result / 100 != 2) return -1;
   da82a:	38c8      	subs	r0, #200	; 0xc8
   da82c:	2863      	cmp	r0, #99	; 0x63
   da82e:	d804      	bhi.n	da83a <_ZN17particleftpclient17ParticleFtpClient4sizeE6String+0x3e>
      return atoi(&cmd_response_buffer[4]);
   da830:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   da834:	f005 fa5c 	bl	dfcf0 <atoi>
   da838:	e001      	b.n	da83e <_ZN17particleftpclient17ParticleFtpClient4sizeE6String+0x42>
  }

  int ParticleFtpClient::size(String filename) {
      server_cmd_connection.println("SIZE " + filename);
      int result = parse_response();
      if (result / 100 != 2) return -1;
   da83a:	f04f 30ff 	mov.w	r0, #4294967295
      return atoi(&cmd_response_buffer[4]);
  }
   da83e:	b005      	add	sp, #20
   da840:	bd30      	pop	{r4, r5, pc}
   da842:	bf00      	nop
   da844:	000e2394 	.word	0x000e2394

000da848 <_ZN17particleftpclient17ParticleFtpClient6finishEv>:

  bool ParticleFtpClient::stor(String filename) {
      return pasv_command("STOR " + filename, 150);
  }

  bool ParticleFtpClient::finish() {
   da848:	b510      	push	{r4, lr}
   da84a:	4604      	mov	r4, r0
      data.stop();
   da84c:	f003 ffc4 	bl	de7d8 <_ZN9TCPClient4stopEv>
      expect(200);
   da850:	4620      	mov	r0, r4
   da852:	f7ff ff70 	bl	da736 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv>
   da856:	38c8      	subs	r0, #200	; 0xc8
      return true;
  }
   da858:	2863      	cmp	r0, #99	; 0x63
   da85a:	bf8c      	ite	hi
   da85c:	2000      	movhi	r0, #0
   da85e:	2001      	movls	r0, #1
   da860:	bd10      	pop	{r4, pc}

000da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>:

  bool ParticleFtpClient::abor() {
      return simple_command("ABOR", 200);
  }

  bool ParticleFtpClient::simple_command(String cmd, int successCode) {
   da862:	b538      	push	{r3, r4, r5, lr}
   da864:	4605      	mov	r5, r0
      server_cmd_connection.println(cmd);
   da866:	6809      	ldr	r1, [r1, #0]
   da868:	301c      	adds	r0, #28

  bool ParticleFtpClient::abor() {
      return simple_command("ABOR", 200);
  }

  bool ParticleFtpClient::simple_command(String cmd, int successCode) {
   da86a:	4614      	mov	r4, r2
      server_cmd_connection.println(cmd);
   da86c:	f002 fafd 	bl	dce6a <_ZN5Print7printlnEPKc>
      expect(successCode);
   da870:	4628      	mov	r0, r5
   da872:	f7ff ff60 	bl	da736 <_ZN17particleftpclient17ParticleFtpClient14parse_responseEv>
   da876:	2364      	movs	r3, #100	; 0x64
   da878:	fb94 f4f3 	sdiv	r4, r4, r3
   da87c:	fb90 f0f3 	sdiv	r0, r0, r3
      return true;
  }
   da880:	1a23      	subs	r3, r4, r0
   da882:	4258      	negs	r0, r3
   da884:	4158      	adcs	r0, r3
   da886:	bd38      	pop	{r3, r4, r5, pc}

000da888 <_ZN17particleftpclient17ParticleFtpClient4userE6String>:
      d_println("Welcome received");
      server_cmd_connection.flush(); // Get rid of annoying welcome messages
      return true;
  }

  bool ParticleFtpClient::user(String username) {
   da888:	b530      	push	{r4, r5, lr}
   da88a:	b089      	sub	sp, #36	; 0x24
   da88c:	4604      	mov	r4, r0
   da88e:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da890:	4668      	mov	r0, sp
   da892:	490d      	ldr	r1, [pc, #52]	; (da8c8 <_ZN17particleftpclient17ParticleFtpClient4userE6String+0x40>)
   da894:	f001 fe8d 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    return simple_command("USER " + username, 300);
   da898:	4629      	mov	r1, r5
   da89a:	4668      	mov	r0, sp
   da89c:	f001 ff64 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da8a0:	4601      	mov	r1, r0
   da8a2:	a804      	add	r0, sp, #16
   da8a4:	f001 fea7 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da8a8:	f44f 7296 	mov.w	r2, #300	; 0x12c
   da8ac:	a904      	add	r1, sp, #16
   da8ae:	4620      	mov	r0, r4
   da8b0:	f7ff ffd7 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   da8b4:	4604      	mov	r4, r0
   da8b6:	a804      	add	r0, sp, #16
   da8b8:	f001 fe34 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da8bc:	4668      	mov	r0, sp
   da8be:	f001 fe31 	bl	dc524 <_ZN6StringD1Ev>
  }
   da8c2:	4620      	mov	r0, r4
   da8c4:	b009      	add	sp, #36	; 0x24
   da8c6:	bd30      	pop	{r4, r5, pc}
   da8c8:	000e23a4 	.word	0x000e23a4

000da8cc <_ZN17particleftpclient17ParticleFtpClient4passE6String>:

  bool ParticleFtpClient::pass(String password) {
   da8cc:	b530      	push	{r4, r5, lr}
   da8ce:	b089      	sub	sp, #36	; 0x24
   da8d0:	4604      	mov	r4, r0
   da8d2:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da8d4:	4668      	mov	r0, sp
   da8d6:	490d      	ldr	r1, [pc, #52]	; (da90c <_ZN17particleftpclient17ParticleFtpClient4passE6String+0x40>)
   da8d8:	f001 fe6b 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    return simple_command("PASS " + password, 200);
   da8dc:	4629      	mov	r1, r5
   da8de:	4668      	mov	r0, sp
   da8e0:	f001 ff42 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da8e4:	4601      	mov	r1, r0
   da8e6:	a804      	add	r0, sp, #16
   da8e8:	f001 fe85 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da8ec:	22c8      	movs	r2, #200	; 0xc8
   da8ee:	a904      	add	r1, sp, #16
   da8f0:	4620      	mov	r0, r4
   da8f2:	f7ff ffb6 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   da8f6:	4604      	mov	r4, r0
   da8f8:	a804      	add	r0, sp, #16
   da8fa:	f001 fe13 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da8fe:	4668      	mov	r0, sp
   da900:	f001 fe10 	bl	dc524 <_ZN6StringD1Ev>
  }
   da904:	4620      	mov	r0, r4
   da906:	b009      	add	sp, #36	; 0x24
   da908:	bd30      	pop	{r4, r5, pc}
   da90a:	bf00      	nop
   da90c:	000e23aa 	.word	0x000e23aa

000da910 <_ZN17particleftpclient17ParticleFtpClient3cwdE6String>:
      int result = parse_response();
      if (result / 100 == 200 / 100) return String("");
      return String(cmd_response_buffer);
  }

  bool ParticleFtpClient::cwd(String dirname) {
   da910:	b530      	push	{r4, r5, lr}
   da912:	b089      	sub	sp, #36	; 0x24
   da914:	4604      	mov	r4, r0
   da916:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da918:	4668      	mov	r0, sp
   da91a:	490d      	ldr	r1, [pc, #52]	; (da950 <_ZN17particleftpclient17ParticleFtpClient3cwdE6String+0x40>)
   da91c:	f001 fe49 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return simple_command("CWD " + dirname, 200);
   da920:	4629      	mov	r1, r5
   da922:	4668      	mov	r0, sp
   da924:	f001 ff20 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da928:	4601      	mov	r1, r0
   da92a:	a804      	add	r0, sp, #16
   da92c:	f001 fe63 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da930:	22c8      	movs	r2, #200	; 0xc8
   da932:	a904      	add	r1, sp, #16
   da934:	4620      	mov	r0, r4
   da936:	f7ff ff94 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   da93a:	4604      	mov	r4, r0
   da93c:	a804      	add	r0, sp, #16
   da93e:	f001 fdf1 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da942:	4668      	mov	r0, sp
   da944:	f001 fdee 	bl	dc524 <_ZN6StringD1Ev>
  }
   da948:	4620      	mov	r0, r4
   da94a:	b009      	add	sp, #36	; 0x24
   da94c:	bd30      	pop	{r4, r5, pc}
   da94e:	bf00      	nop
   da950:	000e23b0 	.word	0x000e23b0

000da954 <_ZN17particleftpclient17ParticleFtpClient3mkdE6String>:

  bool ParticleFtpClient::mkd(String dirname) {
   da954:	b530      	push	{r4, r5, lr}
   da956:	b089      	sub	sp, #36	; 0x24
   da958:	4604      	mov	r4, r0
   da95a:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da95c:	4668      	mov	r0, sp
   da95e:	490d      	ldr	r1, [pc, #52]	; (da994 <_ZN17particleftpclient17ParticleFtpClient3mkdE6String+0x40>)
   da960:	f001 fe27 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return simple_command("MKD " + dirname, 200);
   da964:	4629      	mov	r1, r5
   da966:	4668      	mov	r0, sp
   da968:	f001 fefe 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da96c:	4601      	mov	r1, r0
   da96e:	a804      	add	r0, sp, #16
   da970:	f001 fe41 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da974:	22c8      	movs	r2, #200	; 0xc8
   da976:	a904      	add	r1, sp, #16
   da978:	4620      	mov	r0, r4
   da97a:	f7ff ff72 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   da97e:	4604      	mov	r4, r0
   da980:	a804      	add	r0, sp, #16
   da982:	f001 fdcf 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da986:	4668      	mov	r0, sp
   da988:	f001 fdcc 	bl	dc524 <_ZN6StringD1Ev>
  }
   da98c:	4620      	mov	r0, r4
   da98e:	b009      	add	sp, #36	; 0x24
   da990:	bd30      	pop	{r4, r5, pc}
   da992:	bf00      	nop
   da994:	000e23b5 	.word	0x000e23b5

000da998 <_ZN17particleftpclient17ParticleFtpClient4typeE6String>:

  bool ParticleFtpClient::rmd(String dirname) {
      return simple_command("RMD " + dirname, 200);
  }

  bool ParticleFtpClient::type(String typestring) {
   da998:	b530      	push	{r4, r5, lr}
   da99a:	b089      	sub	sp, #36	; 0x24
   da99c:	4604      	mov	r4, r0
   da99e:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da9a0:	4668      	mov	r0, sp
   da9a2:	490d      	ldr	r1, [pc, #52]	; (da9d8 <_ZN17particleftpclient17ParticleFtpClient4typeE6String+0x40>)
   da9a4:	f001 fe05 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return simple_command("TYPE " + typestring, 200);
   da9a8:	4629      	mov	r1, r5
   da9aa:	4668      	mov	r0, sp
   da9ac:	f001 fedc 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da9b0:	4601      	mov	r1, r0
   da9b2:	a804      	add	r0, sp, #16
   da9b4:	f001 fe1f 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da9b8:	22c8      	movs	r2, #200	; 0xc8
   da9ba:	a904      	add	r1, sp, #16
   da9bc:	4620      	mov	r0, r4
   da9be:	f7ff ff50 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   da9c2:	4604      	mov	r4, r0
   da9c4:	a804      	add	r0, sp, #16
   da9c6:	f001 fdad 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   da9ca:	4668      	mov	r0, sp
   da9cc:	f001 fdaa 	bl	dc524 <_ZN6StringD1Ev>
  }
   da9d0:	4620      	mov	r0, r4
   da9d2:	b009      	add	sp, #36	; 0x24
   da9d4:	bd30      	pop	{r4, r5, pc}
   da9d6:	bf00      	nop
   da9d8:	000e23bf 	.word	0x000e23bf

000da9dc <_ZN17particleftpclient17ParticleFtpClient4deleE6String>:

  bool ParticleFtpClient::dele(String filename) {
   da9dc:	b530      	push	{r4, r5, lr}
   da9de:	b089      	sub	sp, #36	; 0x24
   da9e0:	4604      	mov	r4, r0
   da9e2:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   da9e4:	4668      	mov	r0, sp
   da9e6:	490d      	ldr	r1, [pc, #52]	; (daa1c <_ZN17particleftpclient17ParticleFtpClient4deleE6String+0x40>)
   da9e8:	f001 fde3 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return simple_command("DELE " + filename, 200);
   da9ec:	4629      	mov	r1, r5
   da9ee:	4668      	mov	r0, sp
   da9f0:	f001 feba 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   da9f4:	4601      	mov	r1, r0
   da9f6:	a804      	add	r0, sp, #16
   da9f8:	f001 fdfd 	bl	dc5f6 <_ZN6StringC1ERKS_>
   da9fc:	22c8      	movs	r2, #200	; 0xc8
   da9fe:	a904      	add	r1, sp, #16
   daa00:	4620      	mov	r0, r4
   daa02:	f7ff ff2e 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   daa06:	4604      	mov	r4, r0
   daa08:	a804      	add	r0, sp, #16
   daa0a:	f001 fd8b 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   daa0e:	4668      	mov	r0, sp
   daa10:	f001 fd88 	bl	dc524 <_ZN6StringD1Ev>
  }
   daa14:	4620      	mov	r0, r4
   daa16:	b009      	add	sp, #36	; 0x24
   daa18:	bd30      	pop	{r4, r5, pc}
   daa1a:	bf00      	nop
   daa1c:	000e23c5 	.word	0x000e23c5

000daa20 <_ZN17particleftpclient17ParticleFtpClient4quitEv>:

  bool ParticleFtpClient::cdup() {
      return simple_command("CDUP", 200);
  }

  bool ParticleFtpClient::quit() {
   daa20:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   daa22:	4604      	mov	r4, r0
      return simple_command("QUIT", 200);
   daa24:	4907      	ldr	r1, [pc, #28]	; (daa44 <_ZN17particleftpclient17ParticleFtpClient4quitEv+0x24>)
   daa26:	4668      	mov	r0, sp
   daa28:	f001 fdc3 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
   daa2c:	22c8      	movs	r2, #200	; 0xc8
   daa2e:	4669      	mov	r1, sp
   daa30:	4620      	mov	r0, r4
   daa32:	f7ff ff16 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   daa36:	4604      	mov	r4, r0
   daa38:	4668      	mov	r0, sp
   daa3a:	f001 fd73 	bl	dc524 <_ZN6StringD1Ev>
  }
   daa3e:	4620      	mov	r0, r4
   daa40:	b004      	add	sp, #16
   daa42:	bd10      	pop	{r4, pc}
   daa44:	000e23d0 	.word	0x000e23d0

000daa48 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv>:
  bool ParticleFtpClient::pasv_command(String cmd, int successCode) {
      if (!connect_data_port()) return false;
      return simple_command(cmd, successCode);
  }

  bool ParticleFtpClient::connect_data_port() {
   daa48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   daa4c:	4604      	mov	r4, r0
      server_cmd_connection.println("PASV");
   daa4e:	f100 081c 	add.w	r8, r0, #28
  bool ParticleFtpClient::pasv_command(String cmd, int successCode) {
      if (!connect_data_port()) return false;
      return simple_command(cmd, successCode);
  }

  bool ParticleFtpClient::connect_data_port() {
   daa52:	b095      	sub	sp, #84	; 0x54
      server_cmd_connection.println("PASV");
   daa54:	4945      	ldr	r1, [pc, #276]	; (dab6c <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x124>)
   daa56:	4640      	mov	r0, r8
      int tries = 0;
      int index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
   daa58:	f104 0738 	add.w	r7, r4, #56	; 0x38
      if (!connect_data_port()) return false;
      return simple_command(cmd, successCode);
  }

  bool ParticleFtpClient::connect_data_port() {
      server_cmd_connection.println("PASV");
   daa5c:	f002 fa05 	bl	dce6a <_ZN5Print7printlnEPKc>
      int tries = 0;
      int index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
   daa60:	f44f 7287 	mov.w	r2, #270	; 0x10e
   daa64:	2100      	movs	r1, #0
   daa66:	4638      	mov	r0, r7
   daa68:	f005 fa7e 	bl	dff68 <memset>
      bool responded = false;
   daa6c:	2600      	movs	r6, #0
  }

  bool ParticleFtpClient::connect_data_port() {
      server_cmd_connection.println("PASV");
      int tries = 0;
      int index = 0;
   daa6e:	4635      	mov	r5, r6
              d_print(val);
          }

          // Trap for a failure result_code for pasv command, assuming enough chars come through
          if (index >= 4) {
              char code_string[4] = { 0 };
   daa70:	46b1      	mov	r9, r6
      int tries = 0;
      int index = 0;
      memset(cmd_response_buffer, 0, RESPONSE_BUFFER_SIZE);
      bool responded = false;
      d_print("PASV response: ");
      while (tries < maxTries && !responded) {
   daa72:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
   daa76:	2b00      	cmp	r3, #0
   daa78:	dd2c      	ble.n	daad4 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x8c>
   daa7a:	bb5e      	cbnz	r6, daad4 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x8c>
          delay(1000);
   daa7c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   daa80:	f002 fb5c 	bl	dd13c <delay>

          // Receive as much as we can from the buffer
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
   daa84:	4640      	mov	r0, r8
   daa86:	f003 febf 	bl	de808 <_ZN9TCPClient9availableEv>
   daa8a:	b190      	cbz	r0, daab2 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x6a>
   daa8c:	f5b5 7f87 	cmp.w	r5, #270	; 0x10e
   daa90:	d161      	bne.n	dab56 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x10e>
          }

          // Trap for a failure result_code for pasv command, assuming enough chars come through
          if (index >= 4) {
              char code_string[4] = { 0 };
              memcpy(code_string, cmd_response_buffer, 3);
   daa92:	883a      	ldrh	r2, [r7, #0]
   daa94:	78bb      	ldrb	r3, [r7, #2]
              d_print(val);
          }

          // Trap for a failure result_code for pasv command, assuming enough chars come through
          if (index >= 4) {
              char code_string[4] = { 0 };
   daa96:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
              memcpy(code_string, cmd_response_buffer, 3);
              if (atoi(code_string) / 100 != 2) {
   daa9a:	a80e      	add	r0, sp, #56	; 0x38
          }

          // Trap for a failure result_code for pasv command, assuming enough chars come through
          if (index >= 4) {
              char code_string[4] = { 0 };
              memcpy(code_string, cmd_response_buffer, 3);
   daa9c:	f8ad 2038 	strh.w	r2, [sp, #56]	; 0x38
   daaa0:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
              if (atoi(code_string) / 100 != 2) {
   daaa4:	f005 f924 	bl	dfcf0 <atoi>
   daaa8:	38c8      	subs	r0, #200	; 0xc8
   daaaa:	2863      	cmp	r0, #99	; 0x63
   daaac:	d903      	bls.n	daab6 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x6e>
                  return false;
   daaae:	2000      	movs	r0, #0
   daab0:	e059      	b.n	dab66 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x11e>
              cmd_response_buffer[index++] = val;
              d_print(val);
          }

          // Trap for a failure result_code for pasv command, assuming enough chars come through
          if (index >= 4) {
   daab2:	2d03      	cmp	r5, #3
   daab4:	dced      	bgt.n	daa92 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x4a>
                  return false;
              }
          }

          // Make sure we received a full PASV response with closing parentheses
          for (unsigned int i = 0; i < strlen(cmd_response_buffer); i++) {
   daab6:	4638      	mov	r0, r7
   daab8:	f005 fad6 	bl	e0068 <strlen>
   daabc:	3037      	adds	r0, #55	; 0x37
   daabe:	f104 0337 	add.w	r3, r4, #55	; 0x37
   daac2:	4420      	add	r0, r4
   daac4:	4298      	cmp	r0, r3
   daac6:	d0d4      	beq.n	daa72 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x2a>
              if (cmd_response_buffer[i] == ')') {
   daac8:	f813 2f01 	ldrb.w	r2, [r3, #1]!
                  responded = true;
   daacc:	2a29      	cmp	r2, #41	; 0x29
   daace:	bf08      	it	eq
   daad0:	2601      	moveq	r6, #1
                  return false;
              }
          }

          // Make sure we received a full PASV response with closing parentheses
          for (unsigned int i = 0; i < strlen(cmd_response_buffer); i++) {
   daad2:	e7f7      	b.n	daac4 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x7c>
          }
      }

      // Parse pasv IP address and port number
      int pasv_vals[6];
      char* pointer = strtok(cmd_response_buffer, "(,)");
   daad4:	4926      	ldr	r1, [pc, #152]	; (dab70 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x128>)
   daad6:	4638      	mov	r0, r7
   daad8:	f005 faf6 	bl	e00c8 <strtok>
      for (int i = 0; i < 6; i++) {
   daadc:	2500      	movs	r5, #0
          pointer = strtok(NULL, "(,)");
   daade:	4924      	ldr	r1, [pc, #144]	; (dab70 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x128>)
   daae0:	2000      	movs	r0, #0
   daae2:	f005 faf1 	bl	e00c8 <strtok>
          if (pointer == NULL) {
   daae6:	2800      	cmp	r0, #0
   daae8:	d0e1      	beq.n	daaae <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x66>
              d_println("Couldn't parse PASV info");
              return false;
          }
          pasv_vals[i] = atoi(pointer);
   daaea:	f005 f901 	bl	dfcf0 <atoi>
   daaee:	ab02      	add	r3, sp, #8
   daaf0:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
      }

      // Parse pasv IP address and port number
      int pasv_vals[6];
      char* pointer = strtok(cmd_response_buffer, "(,)");
      for (int i = 0; i < 6; i++) {
   daaf4:	3501      	adds	r5, #1
   daaf6:	2d06      	cmp	r5, #6
   daaf8:	d1f1      	bne.n	daade <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x96>
              d_println("Couldn't parse PASV info");
              return false;
          }
          pasv_vals[i] = atoi(pointer);
      }
      IPAddress pasv_ip(pasv_vals[0], pasv_vals[1], pasv_vals[2], pasv_vals[3]);
   daafa:	f89d 0014 	ldrb.w	r0, [sp, #20]
   daafe:	f89d 3010 	ldrb.w	r3, [sp, #16]
   dab02:	f89d 200c 	ldrb.w	r2, [sp, #12]
   dab06:	f89d 1008 	ldrb.w	r1, [sp, #8]
   dab0a:	9000      	str	r0, [sp, #0]
   dab0c:	a808      	add	r0, sp, #32
   dab0e:	f003 f94d 	bl	dddac <_ZN9IPAddressC1Ehhhh>
      d_print("PASV address ");
      d_print(pasv_ip);
      d_print(":");
      d_println(pasv_vals[4] * 256 + pasv_vals[5]);
      data.stop();
   dab12:	4620      	mov	r0, r4
   dab14:	f003 fe60 	bl	de7d8 <_ZN9TCPClient4stopEv>
      data.flush();
   dab18:	4620      	mov	r0, r4
   dab1a:	f003 fc89 	bl	de430 <_ZN9TCPClient5flushEv>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   dab1e:	ae09      	add	r6, sp, #36	; 0x24
   dab20:	4b14      	ldr	r3, [pc, #80]	; (dab74 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x12c>)
   dab22:	930e      	str	r3, [sp, #56]	; 0x38
   dab24:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   dab26:	ad0f      	add	r5, sp, #60	; 0x3c
   dab28:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   dab2a:	6833      	ldr	r3, [r6, #0]
   dab2c:	702b      	strb	r3, [r5, #0]
      data.connect(pasv_ip, pasv_vals[4] * 256 + pasv_vals[5]);
   dab2e:	9a06      	ldr	r2, [sp, #24]
   dab30:	9b07      	ldr	r3, [sp, #28]
   dab32:	eb03 2202 	add.w	r2, r3, r2, lsl #8
   dab36:	b292      	uxth	r2, r2
   dab38:	2300      	movs	r3, #0
   dab3a:	a90e      	add	r1, sp, #56	; 0x38
   dab3c:	4620      	mov	r0, r4
   dab3e:	f003 fdd1 	bl	de6e4 <_ZN9TCPClient7connectE9IPAddresstm>

      if (!data.connected()) {
   dab42:	4620      	mov	r0, r4
   dab44:	f003 fc75 	bl	de432 <_ZN9TCPClient9connectedEv>
          d_println("Could not connect to PASV port!");
      }
      return data.connected();
   dab48:	4620      	mov	r0, r4
   dab4a:	f003 fc72 	bl	de432 <_ZN9TCPClient9connectedEv>
   dab4e:	3000      	adds	r0, #0
   dab50:	bf18      	it	ne
   dab52:	2001      	movne	r0, #1
   dab54:	e007      	b.n	dab66 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x11e>
      while (tries < maxTries && !responded) {
          delay(1000);

          // Receive as much as we can from the buffer
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
              char val = server_cmd_connection.read();
   dab56:	4640      	mov	r0, r8
   dab58:	f003 fcff 	bl	de55a <_ZN9TCPClient4readEv>
              cmd_response_buffer[index++] = val;
   dab5c:	3501      	adds	r5, #1
   dab5e:	1963      	adds	r3, r4, r5
   dab60:	f883 0037 	strb.w	r0, [r3, #55]	; 0x37
      d_print("PASV response: ");
      while (tries < maxTries && !responded) {
          delay(1000);

          // Receive as much as we can from the buffer
          while (server_cmd_connection.available() && index < RESPONSE_BUFFER_SIZE) {
   dab64:	e78e      	b.n	daa84 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv+0x3c>

      if (!data.connected()) {
          d_println("Could not connect to PASV port!");
      }
      return data.connected();
  }
   dab66:	b015      	add	sp, #84	; 0x54
   dab68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   dab6c:	000e23da 	.word	0x000e23da
   dab70:	000e23df 	.word	0x000e23df
   dab74:	000e276c 	.word	0x000e276c

000dab78 <_ZN17particleftpclient17ParticleFtpClient12pasv_commandE6Stringi>:

  String ParticleFtpClient::get_response() {
      return String(cmd_response_buffer);
  }

  bool ParticleFtpClient::pasv_command(String cmd, int successCode) {
   dab78:	b5f0      	push	{r4, r5, r6, r7, lr}
   dab7a:	b085      	sub	sp, #20
   dab7c:	4605      	mov	r5, r0
   dab7e:	460f      	mov	r7, r1
   dab80:	4616      	mov	r6, r2
      if (!connect_data_port()) return false;
   dab82:	f7ff ff61 	bl	daa48 <_ZN17particleftpclient17ParticleFtpClient17connect_data_portEv>
   dab86:	4604      	mov	r4, r0
   dab88:	b160      	cbz	r0, daba4 <_ZN17particleftpclient17ParticleFtpClient12pasv_commandE6Stringi+0x2c>
      return simple_command(cmd, successCode);
   dab8a:	4639      	mov	r1, r7
   dab8c:	4668      	mov	r0, sp
   dab8e:	f001 fd32 	bl	dc5f6 <_ZN6StringC1ERKS_>
   dab92:	4632      	mov	r2, r6
   dab94:	4669      	mov	r1, sp
   dab96:	4628      	mov	r0, r5
   dab98:	f7ff fe63 	bl	da862 <_ZN17particleftpclient17ParticleFtpClient14simple_commandE6Stringi>
   dab9c:	4604      	mov	r4, r0
   dab9e:	4668      	mov	r0, sp
   daba0:	f001 fcc0 	bl	dc524 <_ZN6StringD1Ev>
  }
   daba4:	4620      	mov	r0, r4
   daba6:	b005      	add	sp, #20
   daba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000dabac <_ZN17particleftpclient17ParticleFtpClient4listE6String>:

  bool ParticleFtpClient::quit() {
      return simple_command("QUIT", 200);
  }

  bool ParticleFtpClient::list(String filespec) {
   dabac:	b530      	push	{r4, r5, lr}
   dabae:	b089      	sub	sp, #36	; 0x24
   dabb0:	4604      	mov	r4, r0
   dabb2:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   dabb4:	4668      	mov	r0, sp
   dabb6:	490d      	ldr	r1, [pc, #52]	; (dabec <_ZN17particleftpclient17ParticleFtpClient4listE6String+0x40>)
   dabb8:	f001 fcfb 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return pasv_command("LIST " + filespec, 150);
   dabbc:	4629      	mov	r1, r5
   dabbe:	4668      	mov	r0, sp
   dabc0:	f001 fdd2 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   dabc4:	4601      	mov	r1, r0
   dabc6:	a804      	add	r0, sp, #16
   dabc8:	f001 fd15 	bl	dc5f6 <_ZN6StringC1ERKS_>
   dabcc:	2296      	movs	r2, #150	; 0x96
   dabce:	a904      	add	r1, sp, #16
   dabd0:	4620      	mov	r0, r4
   dabd2:	f7ff ffd1 	bl	dab78 <_ZN17particleftpclient17ParticleFtpClient12pasv_commandE6Stringi>
   dabd6:	4604      	mov	r4, r0
   dabd8:	a804      	add	r0, sp, #16
   dabda:	f001 fca3 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   dabde:	4668      	mov	r0, sp
   dabe0:	f001 fca0 	bl	dc524 <_ZN6StringD1Ev>
  }
   dabe4:	4620      	mov	r0, r4
   dabe6:	b009      	add	sp, #36	; 0x24
   dabe8:	bd30      	pop	{r4, r5, pc}
   dabea:	bf00      	nop
   dabec:	000e23e3 	.word	0x000e23e3

000dabf0 <_ZN17particleftpclient17ParticleFtpClient4storE6String>:

  bool ParticleFtpClient::stor(String filename) {
   dabf0:	b530      	push	{r4, r5, lr}
   dabf2:	b089      	sub	sp, #36	; 0x24
   dabf4:	4604      	mov	r4, r0
   dabf6:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   dabf8:	4668      	mov	r0, sp
   dabfa:	490d      	ldr	r1, [pc, #52]	; (dac30 <_ZN17particleftpclient17ParticleFtpClient4storE6String+0x40>)
   dabfc:	f001 fcd9 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return pasv_command("STOR " + filename, 150);
   dac00:	4629      	mov	r1, r5
   dac02:	4668      	mov	r0, sp
   dac04:	f001 fdb0 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   dac08:	4601      	mov	r1, r0
   dac0a:	a804      	add	r0, sp, #16
   dac0c:	f001 fcf3 	bl	dc5f6 <_ZN6StringC1ERKS_>
   dac10:	2296      	movs	r2, #150	; 0x96
   dac12:	a904      	add	r1, sp, #16
   dac14:	4620      	mov	r0, r4
   dac16:	f7ff ffaf 	bl	dab78 <_ZN17particleftpclient17ParticleFtpClient12pasv_commandE6Stringi>
   dac1a:	4604      	mov	r4, r0
   dac1c:	a804      	add	r0, sp, #16
   dac1e:	f001 fc81 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   dac22:	4668      	mov	r0, sp
   dac24:	f001 fc7e 	bl	dc524 <_ZN6StringD1Ev>
  }
   dac28:	4620      	mov	r0, r4
   dac2a:	b009      	add	sp, #36	; 0x24
   dac2c:	bd30      	pop	{r4, r5, pc}
   dac2e:	bf00      	nop
   dac30:	000e23e9 	.word	0x000e23e9

000dac34 <_ZN17particleftpclient17ParticleFtpClient4retrE6String>:
      data.stop();
      expect(200);
      return true;
  }

  bool ParticleFtpClient::retr(String filename) {
   dac34:	b530      	push	{r4, r5, lr}
   dac36:	b089      	sub	sp, #36	; 0x24
   dac38:	4604      	mov	r4, r0
   dac3a:	460d      	mov	r5, r1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   dac3c:	4668      	mov	r0, sp
   dac3e:	490d      	ldr	r1, [pc, #52]	; (dac74 <_ZN17particleftpclient17ParticleFtpClient4retrE6String+0x40>)
   dac40:	f001 fcb7 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
      return pasv_command("RETR " + filename, 150);
   dac44:	4629      	mov	r1, r5
   dac46:	4668      	mov	r0, sp
   dac48:	f001 fd8e 	bl	dc768 <_ZplRK15StringSumHelperRK6String>
   dac4c:	4601      	mov	r1, r0
   dac4e:	a804      	add	r0, sp, #16
   dac50:	f001 fcd1 	bl	dc5f6 <_ZN6StringC1ERKS_>
   dac54:	2296      	movs	r2, #150	; 0x96
   dac56:	a904      	add	r1, sp, #16
   dac58:	4620      	mov	r0, r4
   dac5a:	f7ff ff8d 	bl	dab78 <_ZN17particleftpclient17ParticleFtpClient12pasv_commandE6Stringi>
   dac5e:	4604      	mov	r4, r0
   dac60:	a804      	add	r0, sp, #16
   dac62:	f001 fc5f 	bl	dc524 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
   dac66:	4668      	mov	r0, sp
   dac68:	f001 fc5c 	bl	dc524 <_ZN6StringD1Ev>
  }
   dac6c:	4620      	mov	r0, r4
   dac6e:	b009      	add	sp, #36	; 0x24
   dac70:	bd30      	pop	{r4, r5, pc}
   dac72:	bf00      	nop
   dac74:	000e23ef 	.word	0x000e23ef

000dac78 <_ZL9date2daysthh>:

const uint8_t daysInMonth [] PROGMEM = { 31,28,31,30,31,30,31,31,30,31,30,31 };

// number of days since 2000/01/01, valid for 2001..2099
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
    if (y >= 2000)
   dac78:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
// utility code, some of this could be exposed in the DateTime API if needed

const uint8_t daysInMonth [] PROGMEM = { 31,28,31,30,31,30,31,31,30,31,30,31 };

// number of days since 2000/01/01, valid for 2001..2099
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
   dac7c:	b530      	push	{r4, r5, lr}
    if (y >= 2000)
        y -= 2000;
   dac7e:	bf28      	it	cs
   dac80:	f5a0 60fa 	subcs.w	r0, r0, #2000	; 0x7d0
    uint16_t days = d;
    for (uint8_t i = 1; i < m; ++i)
        days += pgm_read_byte(daysInMonth + i - 1);
   dac84:	4d10      	ldr	r5, [pc, #64]	; (dacc8 <_ZL9date2daysthh+0x50>)
const uint8_t daysInMonth [] PROGMEM = { 31,28,31,30,31,30,31,31,30,31,30,31 };

// number of days since 2000/01/01, valid for 2001..2099
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
    if (y >= 2000)
        y -= 2000;
   dac86:	bf28      	it	cs
   dac88:	b280      	uxthcs	r0, r0
    uint16_t days = d;
   dac8a:	b292      	uxth	r2, r2
   dac8c:	2300      	movs	r3, #0
   dac8e:	3301      	adds	r3, #1
    for (uint8_t i = 1; i < m; ++i)
   dac90:	b2dc      	uxtb	r4, r3
   dac92:	42a1      	cmp	r1, r4
   dac94:	d905      	bls.n	daca2 <_ZL9date2daysthh+0x2a>
        days += pgm_read_byte(daysInMonth + i - 1);
   dac96:	18ec      	adds	r4, r5, r3
   dac98:	f814 4c01 	ldrb.w	r4, [r4, #-1]
   dac9c:	4422      	add	r2, r4
   dac9e:	b292      	uxth	r2, r2
// number of days since 2000/01/01, valid for 2001..2099
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
    if (y >= 2000)
        y -= 2000;
    uint16_t days = d;
    for (uint8_t i = 1; i < m; ++i)
   daca0:	e7f5      	b.n	dac8e <_ZL9date2daysthh+0x16>
        days += pgm_read_byte(daysInMonth + i - 1);
    if (m > 2 && y % 4 == 0)
   daca2:	2902      	cmp	r1, #2
   daca4:	d903      	bls.n	dacae <_ZL9date2daysthh+0x36>
   daca6:	0783      	lsls	r3, r0, #30
        ++days;
   daca8:	bf04      	itt	eq
   dacaa:	3201      	addeq	r2, #1
   dacac:	b292      	uxtheq	r2, r2
    return days + 365 * y + (y + 3) / 4 - 1;
   dacae:	eb00 03c0 	add.w	r3, r0, r0, lsl #3
   dacb2:	1cc1      	adds	r1, r0, #3
   dacb4:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   dacb8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   dacbc:	1e43      	subs	r3, r0, #1
   dacbe:	eb03 00a1 	add.w	r0, r3, r1, asr #2
   dacc2:	4410      	add	r0, r2
}
   dacc4:	b280      	uxth	r0, r0
   dacc6:	bd30      	pop	{r4, r5, pc}
   dacc8:	000e23f5 	.word	0x000e23f5

000daccc <_ZL6conv2dPKc>:
  ss(copy.ss)
{}

static uint8_t conv2d(const char* p) {
    uint8_t v = 0;
    if ('0' <= *p && *p <= '9')
   daccc:	7803      	ldrb	r3, [r0, #0]
        v = *p - '0';
    return 10 * v + *++p - '0';
   dacce:	7840      	ldrb	r0, [r0, #1]
  ss(copy.ss)
{}

static uint8_t conv2d(const char* p) {
    uint8_t v = 0;
    if ('0' <= *p && *p <= '9')
   dacd0:	3b30      	subs	r3, #48	; 0x30
   dacd2:	b2db      	uxtb	r3, r3
  mm(copy.mm),
  ss(copy.ss)
{}

static uint8_t conv2d(const char* p) {
    uint8_t v = 0;
   dacd4:	2b0a      	cmp	r3, #10
   dacd6:	bf28      	it	cs
   dacd8:	2300      	movcs	r3, #0
    if ('0' <= *p && *p <= '9')
        v = *p - '0';
    return 10 * v + *++p - '0';
   dacda:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   dacde:	3830      	subs	r0, #48	; 0x30
   dace0:	eb00 0043 	add.w	r0, r0, r3, lsl #1
}
   dace4:	b2c0      	uxtb	r0, r0
   dace6:	4770      	bx	lr

000dace8 <_ZN8DateTimeC1Em>:
////////////////////////////////////////////////////////////////////////////////
// DateTime implementation - ignores time zones and DST changes
// NOTE: also ignores leap seconds, see http://en.wikipedia.org/wiki/Leap_second

DateTime::DateTime (uint32_t t) {
  t -= SECONDS_FROM_1970_TO_2000;    // bring to 2000 timestamp from 1970
   dace8:	4b23      	ldr	r3, [pc, #140]	; (dad78 <_ZN8DateTimeC1Em+0x90>)

    ss = t % 60;
   dacea:	223c      	movs	r2, #60	; 0x3c
////////////////////////////////////////////////////////////////////////////////
// DateTime implementation - ignores time zones and DST changes
// NOTE: also ignores leap seconds, see http://en.wikipedia.org/wiki/Leap_second

DateTime::DateTime (uint32_t t) {
  t -= SECONDS_FROM_1970_TO_2000;    // bring to 2000 timestamp from 1970
   dacec:	440b      	add	r3, r1

////////////////////////////////////////////////////////////////////////////////
// DateTime implementation - ignores time zones and DST changes
// NOTE: also ignores leap seconds, see http://en.wikipedia.org/wiki/Leap_second

DateTime::DateTime (uint32_t t) {
   dacee:	b530      	push	{r4, r5, lr}
  t -= SECONDS_FROM_1970_TO_2000;    // bring to 2000 timestamp from 1970

    ss = t % 60;
   dacf0:	fbb3 f4f2 	udiv	r4, r3, r2
   dacf4:	fb02 3114 	mls	r1, r2, r4, r3
   dacf8:	7141      	strb	r1, [r0, #5]
    t /= 60;
    mm = t % 60;
   dacfa:	fbb4 f1f2 	udiv	r1, r4, r2
   dacfe:	fb02 4211 	mls	r2, r2, r1, r4
    t /= 60;
    hh = t % 24;
   dad02:	2418      	movs	r4, #24
DateTime::DateTime (uint32_t t) {
  t -= SECONDS_FROM_1970_TO_2000;    // bring to 2000 timestamp from 1970

    ss = t % 60;
    t /= 60;
    mm = t % 60;
   dad04:	7102      	strb	r2, [r0, #4]
    t /= 60;
    hh = t % 24;
   dad06:	f44f 6261 	mov.w	r2, #3600	; 0xe10
   dad0a:	fbb3 f2f2 	udiv	r2, r3, r2
   dad0e:	fbb2 f1f4 	udiv	r1, r2, r4
   dad12:	fb04 2211 	mls	r2, r4, r1, r2
   dad16:	70c2      	strb	r2, [r0, #3]
    uint16_t days = t / 24;
   dad18:	4a18      	ldr	r2, [pc, #96]	; (dad7c <_ZN8DateTimeC1Em+0x94>)
   dad1a:	fbb3 f3f2 	udiv	r3, r3, r2
    uint8_t leap;
    for (yOff = 0; ; ++yOff) {
   dad1e:	2200      	movs	r2, #0
    ss = t % 60;
    t /= 60;
    mm = t % 60;
    t /= 60;
    hh = t % 24;
    uint16_t days = t / 24;
   dad20:	b29b      	uxth	r3, r3
    uint8_t leap;
    for (yOff = 0; ; ++yOff) {
   dad22:	7002      	strb	r2, [r0, #0]
        leap = yOff % 4 == 0;
   dad24:	7801      	ldrb	r1, [r0, #0]
   dad26:	f011 0403 	ands.w	r4, r1, #3
   dad2a:	bf0c      	ite	eq
   dad2c:	2201      	moveq	r2, #1
   dad2e:	2200      	movne	r2, #0
        if (days < 365 + leap)
   dad30:	f502 75b6 	add.w	r5, r2, #364	; 0x16c
   dad34:	429d      	cmp	r5, r3
   dad36:	da07      	bge.n	dad48 <_ZN8DateTimeC1Em+0x60>
            break;
        days -= 365 + leap;
   dad38:	f5c2 427e 	rsb	r2, r2, #65024	; 0xfe00
   dad3c:	3293      	adds	r2, #147	; 0x93
   dad3e:	4413      	add	r3, r2
    mm = t % 60;
    t /= 60;
    hh = t % 24;
    uint16_t days = t / 24;
    uint8_t leap;
    for (yOff = 0; ; ++yOff) {
   dad40:	3101      	adds	r1, #1
        leap = yOff % 4 == 0;
        if (days < 365 + leap)
            break;
        days -= 365 + leap;
   dad42:	b29b      	uxth	r3, r3
    mm = t % 60;
    t /= 60;
    hh = t % 24;
    uint16_t days = t / 24;
    uint8_t leap;
    for (yOff = 0; ; ++yOff) {
   dad44:	7001      	strb	r1, [r0, #0]
   dad46:	e7ed      	b.n	dad24 <_ZN8DateTimeC1Em+0x3c>
        leap = yOff % 4 == 0;
        if (days < 365 + leap)
            break;
        days -= 365 + leap;
    }
    for (m = 1; ; ++m) {
   dad48:	2201      	movs	r2, #1
        uint8_t daysPerMonth = pgm_read_byte(daysInMonth + m - 1);
   dad4a:	4d0d      	ldr	r5, [pc, #52]	; (dad80 <_ZN8DateTimeC1Em+0x98>)
        leap = yOff % 4 == 0;
        if (days < 365 + leap)
            break;
        days -= 365 + leap;
    }
    for (m = 1; ; ++m) {
   dad4c:	7042      	strb	r2, [r0, #1]
        uint8_t daysPerMonth = pgm_read_byte(daysInMonth + m - 1);
   dad4e:	7841      	ldrb	r1, [r0, #1]
   dad50:	186a      	adds	r2, r5, r1
   dad52:	f812 2c01 	ldrb.w	r2, [r2, #-1]
        if (leap && m == 2)
   dad56:	b91c      	cbnz	r4, dad60 <_ZN8DateTimeC1Em+0x78>
   dad58:	2902      	cmp	r1, #2
            ++daysPerMonth;
   dad5a:	bf04      	itt	eq
   dad5c:	3201      	addeq	r2, #1
   dad5e:	b2d2      	uxtbeq	r2, r2
        if (days < daysPerMonth)
   dad60:	b292      	uxth	r2, r2
   dad62:	4293      	cmp	r3, r2
   dad64:	d304      	bcc.n	dad70 <_ZN8DateTimeC1Em+0x88>
            break;
        days -= daysPerMonth;
   dad66:	1a9b      	subs	r3, r3, r2
        leap = yOff % 4 == 0;
        if (days < 365 + leap)
            break;
        days -= 365 + leap;
    }
    for (m = 1; ; ++m) {
   dad68:	3101      	adds	r1, #1
        uint8_t daysPerMonth = pgm_read_byte(daysInMonth + m - 1);
        if (leap && m == 2)
            ++daysPerMonth;
        if (days < daysPerMonth)
            break;
        days -= daysPerMonth;
   dad6a:	b29b      	uxth	r3, r3
        leap = yOff % 4 == 0;
        if (days < 365 + leap)
            break;
        days -= 365 + leap;
    }
    for (m = 1; ; ++m) {
   dad6c:	7041      	strb	r1, [r0, #1]
   dad6e:	e7ee      	b.n	dad4e <_ZN8DateTimeC1Em+0x66>
            ++daysPerMonth;
        if (days < daysPerMonth)
            break;
        days -= daysPerMonth;
    }
    d = days + 1;
   dad70:	3301      	adds	r3, #1
   dad72:	7083      	strb	r3, [r0, #2]
}
   dad74:	bd30      	pop	{r4, r5, pc}
   dad76:	bf00      	nop
   dad78:	c792bc80 	.word	0xc792bc80
   dad7c:	00015180 	.word	0x00015180
   dad80:	000e23f5 	.word	0x000e23f5

000dad84 <_ZN8DateTimeC1Ethhhhh>:

DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year >= 2000)
   dad84:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
        year -= 2000;
    yOff = year;
    m = month;
    d = day;
   dad88:	7083      	strb	r3, [r0, #2]
    hh = hour;
   dad8a:	f89d 3000 	ldrb.w	r3, [sp]
   dad8e:	70c3      	strb	r3, [r0, #3]
    d = days + 1;
}

DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year >= 2000)
        year -= 2000;
   dad90:	bf28      	it	cs
   dad92:	f5a1 61fa 	subcs.w	r1, r1, #2000	; 0x7d0
    yOff = year;
    m = month;
    d = day;
    hh = hour;
    mm = min;
   dad96:	f89d 3004 	ldrb.w	r3, [sp, #4]
   dad9a:	7103      	strb	r3, [r0, #4]
    d = days + 1;
}

DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year >= 2000)
        year -= 2000;
   dad9c:	bf28      	it	cs
   dad9e:	b289      	uxthcs	r1, r1
    yOff = year;
    m = month;
    d = day;
    hh = hour;
    mm = min;
    ss = sec;
   dada0:	f89d 3008 	ldrb.w	r3, [sp, #8]
}

DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year >= 2000)
        year -= 2000;
    yOff = year;
   dada4:	7001      	strb	r1, [r0, #0]
    m = month;
   dada6:	7042      	strb	r2, [r0, #1]
    d = day;
    hh = hour;
    mm = min;
    ss = sec;
   dada8:	7143      	strb	r3, [r0, #5]
}
   dadaa:	4770      	bx	lr

000dadac <_ZN8DateTimeC1EPK19__FlashStringHelperS2_>:
}

// A convenient constructor for using "the compiler's time":
// This version will save RAM by using PROGMEM to store it by using the F macro.
//   DateTime now (F(__DATE__), F(__TIME__));
DateTime::DateTime (const __FlashStringHelper* date, const __FlashStringHelper* time) {
   dadac:	b530      	push	{r4, r5, lr}
   dadae:	460d      	mov	r5, r1
   dadb0:	b085      	sub	sp, #20
   dadb2:	4604      	mov	r4, r0
    // sample input: date = "Dec 26 2009", time = "12:34:56"
    char buff[11];
    memcpy_P(buff, date, 11);
   dadb4:	6808      	ldr	r0, [r1, #0]
   dadb6:	6849      	ldr	r1, [r1, #4]
   dadb8:	ab01      	add	r3, sp, #4
   dadba:	c303      	stmia	r3!, {r0, r1}
   dadbc:	8928      	ldrh	r0, [r5, #8]
   dadbe:	7aa9      	ldrb	r1, [r5, #10]
   dadc0:	8018      	strh	r0, [r3, #0]
    yOff = conv2d(buff + 9);
    // Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
    switch (buff[0]) {
   dadc2:	ad04      	add	r5, sp, #16
// This version will save RAM by using PROGMEM to store it by using the F macro.
//   DateTime now (F(__DATE__), F(__TIME__));
DateTime::DateTime (const __FlashStringHelper* date, const __FlashStringHelper* time) {
    // sample input: date = "Dec 26 2009", time = "12:34:56"
    char buff[11];
    memcpy_P(buff, date, 11);
   dadc4:	7099      	strb	r1, [r3, #2]
    yOff = conv2d(buff + 9);
   dadc6:	f10d 000d 	add.w	r0, sp, #13
   dadca:	f7ff ff7f 	bl	daccc <_ZL6conv2dPKc>
    // Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
    switch (buff[0]) {
   dadce:	f815 3d0c 	ldrb.w	r3, [r5, #-12]!
//   DateTime now (F(__DATE__), F(__TIME__));
DateTime::DateTime (const __FlashStringHelper* date, const __FlashStringHelper* time) {
    // sample input: date = "Dec 26 2009", time = "12:34:56"
    char buff[11];
    memcpy_P(buff, date, 11);
    yOff = conv2d(buff + 9);
   dadd2:	7020      	strb	r0, [r4, #0]
    // Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
    switch (buff[0]) {
   dadd4:	3b41      	subs	r3, #65	; 0x41
   dadd6:	2b12      	cmp	r3, #18
   dadd8:	d830      	bhi.n	dae3c <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x90>
   dadda:	e8df f003 	tbb	[pc, r3]
   dadde:	2f19      	.short	0x2f19
   dade0:	172f2d2f 	.word	0x172f2d2f
   dade4:	0a2f2f2f 	.word	0x0a2f2f2f
   dade8:	2b202f2f 	.word	0x2b202f2f
   dadec:	2f2f2f29 	.word	0x2f2f2f29
   dadf0:	27          	.byte	0x27
   dadf1:	00          	.byte	0x00
        case 'J': m = buff[1] == 'a' ? 1 : m = buff[2] == 'n' ? 6 : 7; break;
   dadf2:	f89d 3005 	ldrb.w	r3, [sp, #5]
   dadf6:	2b61      	cmp	r3, #97	; 0x61
   dadf8:	d006      	beq.n	dae08 <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x5c>
   dadfa:	f89d 3006 	ldrb.w	r3, [sp, #6]
   dadfe:	2b6e      	cmp	r3, #110	; 0x6e
   dae00:	bf0c      	ite	eq
   dae02:	2306      	moveq	r3, #6
   dae04:	2307      	movne	r3, #7
   dae06:	e018      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
   dae08:	2301      	movs	r3, #1
   dae0a:	e016      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'F': m = 2; break;
   dae0c:	2302      	movs	r3, #2
   dae0e:	e014      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'A': m = buff[2] == 'r' ? 4 : 8; break;
   dae10:	f89d 3006 	ldrb.w	r3, [sp, #6]
   dae14:	2b72      	cmp	r3, #114	; 0x72
   dae16:	bf0c      	ite	eq
   dae18:	2304      	moveq	r3, #4
   dae1a:	2308      	movne	r3, #8
   dae1c:	e00d      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'M': m = buff[2] == 'r' ? 3 : 5; break;
   dae1e:	f89d 3006 	ldrb.w	r3, [sp, #6]
   dae22:	2b72      	cmp	r3, #114	; 0x72
   dae24:	bf0c      	ite	eq
   dae26:	2303      	moveq	r3, #3
   dae28:	2305      	movne	r3, #5
   dae2a:	e006      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'S': m = 9; break;
   dae2c:	2309      	movs	r3, #9
   dae2e:	e004      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'O': m = 10; break;
   dae30:	230a      	movs	r3, #10
   dae32:	e002      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'N': m = 11; break;
   dae34:	230b      	movs	r3, #11
   dae36:	e000      	b.n	dae3a <_ZN8DateTimeC1EPK19__FlashStringHelperS2_+0x8e>
        case 'D': m = 12; break;
   dae38:	230c      	movs	r3, #12
   dae3a:	7063      	strb	r3, [r4, #1]
    }
    d = conv2d(buff + 4);
   dae3c:	a802      	add	r0, sp, #8
   dae3e:	f7ff ff45 	bl	daccc <_ZL6conv2dPKc>
   dae42:	70a0      	strb	r0, [r4, #2]
    memcpy_P(buff, time, 8);
   dae44:	6810      	ldr	r0, [r2, #0]
   dae46:	6851      	ldr	r1, [r2, #4]
   dae48:	462b      	mov	r3, r5
   dae4a:	c303      	stmia	r3!, {r0, r1}
    hh = conv2d(buff);
   dae4c:	4628      	mov	r0, r5
   dae4e:	f7ff ff3d 	bl	daccc <_ZL6conv2dPKc>
   dae52:	70e0      	strb	r0, [r4, #3]
    mm = conv2d(buff + 3);
   dae54:	f10d 0007 	add.w	r0, sp, #7
   dae58:	f7ff ff38 	bl	daccc <_ZL6conv2dPKc>
   dae5c:	7120      	strb	r0, [r4, #4]
    ss = conv2d(buff + 6);
   dae5e:	f10d 000a 	add.w	r0, sp, #10
   dae62:	f7ff ff33 	bl	daccc <_ZL6conv2dPKc>
   dae66:	7160      	strb	r0, [r4, #5]
}
   dae68:	4620      	mov	r0, r4
   dae6a:	b005      	add	sp, #20
   dae6c:	bd30      	pop	{r4, r5, pc}
	...

000dae70 <_ZNK8DateTime8unixtimeEv>:
uint8_t DateTime::dayOfWeek() const {    
    uint16_t day = date2days(yOff, m, d);
    return (day + 6) % 7; // Jan 1, 2000 is a Saturday, i.e. returns 6
}

uint32_t DateTime::unixtime(void) const {
   dae70:	b510      	push	{r4, lr}
   dae72:	4604      	mov	r4, r0
  uint32_t t;
  uint16_t days = date2days(yOff, m, d);
   dae74:	7882      	ldrb	r2, [r0, #2]
   dae76:	7841      	ldrb	r1, [r0, #1]
   dae78:	7800      	ldrb	r0, [r0, #0]
   dae7a:	f7ff fefd 	bl	dac78 <_ZL9date2daysthh>
  t = time2long(days, hh, mm, ss);
   dae7e:	78e2      	ldrb	r2, [r4, #3]
   dae80:	2318      	movs	r3, #24
   dae82:	fb03 2000 	mla	r0, r3, r0, r2
   dae86:	7923      	ldrb	r3, [r4, #4]
   dae88:	223c      	movs	r2, #60	; 0x3c
   dae8a:	fb02 3000 	mla	r0, r2, r0, r3
   dae8e:	7963      	ldrb	r3, [r4, #5]
   dae90:	fb02 3300 	mla	r3, r2, r0, r3
  t += SECONDS_FROM_1970_TO_2000;  // seconds from 1970 to 2000

  return t;
}
   dae94:	4801      	ldr	r0, [pc, #4]	; (dae9c <_ZNK8DateTime8unixtimeEv+0x2c>)
   dae96:	4418      	add	r0, r3
   dae98:	bd10      	pop	{r4, pc}
   dae9a:	bf00      	nop
   dae9c:	386d4380 	.word	0x386d4380

000daea0 <_ZNK8DateTime11secondstimeEv>:

long DateTime::secondstime(void) const {
   daea0:	b510      	push	{r4, lr}
   daea2:	4604      	mov	r4, r0
  long t;
  uint16_t days = date2days(yOff, m, d);
   daea4:	7882      	ldrb	r2, [r0, #2]
   daea6:	7841      	ldrb	r1, [r0, #1]
   daea8:	7800      	ldrb	r0, [r0, #0]
   daeaa:	f7ff fee5 	bl	dac78 <_ZL9date2daysthh>
  t = time2long(days, hh, mm, ss);
  return t;
   daeae:	78e2      	ldrb	r2, [r4, #3]
   daeb0:	2318      	movs	r3, #24
   daeb2:	fb03 2300 	mla	r3, r3, r0, r2
   daeb6:	7920      	ldrb	r0, [r4, #4]
   daeb8:	223c      	movs	r2, #60	; 0x3c
   daeba:	fb02 0303 	mla	r3, r2, r3, r0
   daebe:	7960      	ldrb	r0, [r4, #5]
}
   daec0:	fb02 0003 	mla	r0, r2, r3, r0
   daec4:	bd10      	pop	{r4, pc}

000daec6 <_ZN8DateTimeplERK8TimeSpan>:

DateTime DateTime::operator+(const TimeSpan& span) {
   daec6:	b538      	push	{r3, r4, r5, lr}
   daec8:	4604      	mov	r4, r0
   daeca:	4615      	mov	r5, r2
  return DateTime(unixtime()+span.totalseconds());
   daecc:	4608      	mov	r0, r1
   daece:	f7ff ffcf 	bl	dae70 <_ZNK8DateTime8unixtimeEv>
   daed2:	6829      	ldr	r1, [r5, #0]
   daed4:	4401      	add	r1, r0
   daed6:	4620      	mov	r0, r4
   daed8:	f7ff ff06 	bl	dace8 <_ZN8DateTimeC1Em>
}
   daedc:	4620      	mov	r0, r4
   daede:	bd38      	pop	{r3, r4, r5, pc}

000daee0 <_ZN8TimeSpanC1Esaaa>:

TimeSpan::TimeSpan (int32_t seconds):
  _seconds(seconds)
{}

TimeSpan::TimeSpan (int16_t days, int8_t hours, int8_t minutes, int8_t seconds):
   daee0:	b510      	push	{r4, lr}
  _seconds(days*86400L + hours*3600 + minutes*60 + seconds)
   daee2:	f44f 6461 	mov.w	r4, #3600	; 0xe10
   daee6:	4362      	muls	r2, r4
   daee8:	4c05      	ldr	r4, [pc, #20]	; (daf00 <_ZN8TimeSpanC1Esaaa+0x20>)
   daeea:	fb04 2101 	mla	r1, r4, r1, r2
   daeee:	243c      	movs	r4, #60	; 0x3c
   daef0:	fb04 1303 	mla	r3, r4, r3, r1
   daef4:	f99d 4008 	ldrsb.w	r4, [sp, #8]
   daef8:	4423      	add	r3, r4
   daefa:	6003      	str	r3, [r0, #0]
{}
   daefc:	bd10      	pop	{r4, pc}
   daefe:	bf00      	nop
   daf00:	00015180 	.word	0x00015180

000daf04 <_ZN7PCF85235beginEv>:
static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
static uint8_t bin2bcd (uint8_t val) { return val + 6 * (val / 10); }

uint8_t PCF8523::begin(void) {
  return 1;
}
   daf04:	2001      	movs	r0, #1
   daf06:	4770      	bx	lr

000daf08 <_ZN7PCF85239isrunningEv>:

// Example: bool a = PCF8523.isrunning();
// Returns 1 if RTC is running and 0 it's not 
uint8_t PCF8523::isrunning(void) {
   daf08:	b508      	push	{r3, lr}
  Wire.beginTransmission(PCF8523_ADDRESS);
   daf0a:	f003 fec7 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf0e:	2168      	movs	r1, #104	; 0x68
   daf10:	f003 f98f 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
  Wire._I2C_WRITE(0);
   daf14:	f003 fec2 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf18:	2100      	movs	r1, #0
   daf1a:	f7f9 fb4f 	bl	d45bc <_ZN7TwoWire5writeEi>
  Wire.endTransmission();
   daf1e:	f003 febd 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf22:	f003 f98d 	bl	de240 <_ZN7TwoWire15endTransmissionEv>

  Wire.requestFrom(PCF8523_ADDRESS, 1);
   daf26:	f003 feb9 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf2a:	2201      	movs	r2, #1
   daf2c:	2168      	movs	r1, #104	; 0x68
   daf2e:	f003 f979 	bl	de224 <_ZN7TwoWire11requestFromEhj>
  uint8_t ss = Wire._I2C_READ();
   daf32:	f003 feb3 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf36:	6803      	ldr	r3, [r0, #0]
   daf38:	695b      	ldr	r3, [r3, #20]
   daf3a:	4798      	blx	r3
  ss = ss & 32;
  return !(ss>>5);
   daf3c:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
   daf40:	f080 0001 	eor.w	r0, r0, #1
   daf44:	bd08      	pop	{r3, pc}

000daf46 <_ZN7PCF85236adjustERK8DateTime>:

// Example: PCF8523.adjust (DateTime(2014, 8, 14, 1, 49, 0))
// Sets RTC time to 2014/14/8 1:49 a.m.
void PCF8523::adjust(const DateTime& dt) {
   daf46:	b538      	push	{r3, r4, r5, lr}
   daf48:	4605      	mov	r5, r0
  Wire.beginTransmission(PCF8523_ADDRESS);
   daf4a:	f003 fea7 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf4e:	2168      	movs	r1, #104	; 0x68
   daf50:	f003 f96f 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
  Wire._I2C_WRITE(0x03);
   daf54:	f003 fea2 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf58:	2103      	movs	r1, #3
   daf5a:	f7f9 fb2f 	bl	d45bc <_ZN7TwoWire5writeEi>
  Wire._I2C_WRITE(bin2bcd(dt.second()));
   daf5e:	f003 fe9d 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf62:	796b      	ldrb	r3, [r5, #5]
   daf64:	240a      	movs	r4, #10
   daf66:	fbb3 f1f4 	udiv	r1, r3, r4
   daf6a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   daf6e:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   daf72:	6803      	ldr	r3, [r0, #0]
   daf74:	b2c9      	uxtb	r1, r1
   daf76:	689b      	ldr	r3, [r3, #8]
   daf78:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
   daf7a:	f003 fe8f 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf7e:	792b      	ldrb	r3, [r5, #4]
   daf80:	fbb3 f1f4 	udiv	r1, r3, r4
   daf84:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   daf88:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   daf8c:	6803      	ldr	r3, [r0, #0]
   daf8e:	b2c9      	uxtb	r1, r1
   daf90:	689b      	ldr	r3, [r3, #8]
   daf92:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
   daf94:	f003 fe82 	bl	dec9c <_Z19__fetch_global_Wirev>
   daf98:	78eb      	ldrb	r3, [r5, #3]
   daf9a:	fbb3 f1f4 	udiv	r1, r3, r4
   daf9e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   dafa2:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   dafa6:	6803      	ldr	r3, [r0, #0]
   dafa8:	b2c9      	uxtb	r1, r1
   dafaa:	689b      	ldr	r3, [r3, #8]
   dafac:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(dt.day()));
   dafae:	f003 fe75 	bl	dec9c <_Z19__fetch_global_Wirev>
   dafb2:	78ab      	ldrb	r3, [r5, #2]
   dafb4:	fbb3 f1f4 	udiv	r1, r3, r4
   dafb8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   dafbc:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   dafc0:	6803      	ldr	r3, [r0, #0]
   dafc2:	b2c9      	uxtb	r1, r1
   dafc4:	689b      	ldr	r3, [r3, #8]
   dafc6:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(0));
   dafc8:	f003 fe68 	bl	dec9c <_Z19__fetch_global_Wirev>
   dafcc:	6803      	ldr	r3, [r0, #0]
   dafce:	2100      	movs	r1, #0
   dafd0:	689b      	ldr	r3, [r3, #8]
   dafd2:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(dt.month()));
   dafd4:	f003 fe62 	bl	dec9c <_Z19__fetch_global_Wirev>
   dafd8:	786b      	ldrb	r3, [r5, #1]
   dafda:	fbb3 f1f4 	udiv	r1, r3, r4
   dafde:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   dafe2:	eb03 0141 	add.w	r1, r3, r1, lsl #1
   dafe6:	6803      	ldr	r3, [r0, #0]
   dafe8:	b2c9      	uxtb	r1, r1
   dafea:	689b      	ldr	r3, [r3, #8]
   dafec:	4798      	blx	r3
  Wire._I2C_WRITE(bin2bcd(dt.year() - 2000));
   dafee:	f003 fe55 	bl	dec9c <_Z19__fetch_global_Wirev>
   daff2:	7829      	ldrb	r1, [r5, #0]
   daff4:	6803      	ldr	r3, [r0, #0]
   daff6:	fbb1 f4f4 	udiv	r4, r1, r4
   daffa:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   daffe:	eb01 0144 	add.w	r1, r1, r4, lsl #1
   db002:	689b      	ldr	r3, [r3, #8]
   db004:	b2c9      	uxtb	r1, r1
   db006:	4798      	blx	r3
  Wire._I2C_WRITE(0);
   db008:	f003 fe48 	bl	dec9c <_Z19__fetch_global_Wirev>
   db00c:	2100      	movs	r1, #0
   db00e:	f7f9 fad5 	bl	d45bc <_ZN7TwoWire5writeEi>
  Wire.endTransmission();
   db012:	f003 fe43 	bl	dec9c <_Z19__fetch_global_Wirev>
}
   db016:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  Wire._I2C_WRITE(bin2bcd(dt.day()));
  Wire._I2C_WRITE(bin2bcd(0));
  Wire._I2C_WRITE(bin2bcd(dt.month()));
  Wire._I2C_WRITE(bin2bcd(dt.year() - 2000));
  Wire._I2C_WRITE(0);
  Wire.endTransmission();
   db01a:	f003 b911 	b.w	de240 <_ZN7TwoWire15endTransmissionEv>

000db01e <_ZN7PCF85233nowEv>:
// month = now.month()
// day = now.day()
// hour = now.hour()
// minute = now.minute()
// second = now.second()
DateTime PCF8523::now() {
   db01e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   db022:	4604      	mov	r4, r0
  Wire.beginTransmission(PCF8523_ADDRESS);
   db024:	f003 fe3a 	bl	dec9c <_Z19__fetch_global_Wirev>
   db028:	2168      	movs	r1, #104	; 0x68
   db02a:	f003 f902 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
  Wire._I2C_WRITE(3);   
   db02e:	f003 fe35 	bl	dec9c <_Z19__fetch_global_Wirev>
   db032:	2103      	movs	r1, #3
   db034:	f7f9 fac2 	bl	d45bc <_ZN7TwoWire5writeEi>
  Wire.endTransmission();
   db038:	f003 fe30 	bl	dec9c <_Z19__fetch_global_Wirev>
   db03c:	f003 f900 	bl	de240 <_ZN7TwoWire15endTransmissionEv>

  Wire.requestFrom(PCF8523_ADDRESS, 7);
   db040:	f003 fe2c 	bl	dec9c <_Z19__fetch_global_Wirev>
   db044:	2207      	movs	r2, #7
   db046:	2168      	movs	r1, #104	; 0x68
   db048:	f003 f8ec 	bl	de224 <_ZN7TwoWire11requestFromEhj>
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
   db04c:	f003 fe26 	bl	dec9c <_Z19__fetch_global_Wirev>
   db050:	6803      	ldr	r3, [r0, #0]
   db052:	695b      	ldr	r3, [r3, #20]
   db054:	4798      	blx	r3
   db056:	f000 007f 	and.w	r0, r0, #127	; 0x7f


////////////////////////////////////////////////////////////////////////////////
// PCF8523 implementation

static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
   db05a:	1105      	asrs	r5, r0, #4
   db05c:	eba5 0585 	sub.w	r5, r5, r5, lsl #2
   db060:	eb00 0045 	add.w	r0, r0, r5, lsl #1
   db064:	b2c5      	uxtb	r5, r0
  Wire._I2C_WRITE(3);   
  Wire.endTransmission();

  Wire.requestFrom(PCF8523_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
   db066:	f003 fe19 	bl	dec9c <_Z19__fetch_global_Wirev>
   db06a:	6803      	ldr	r3, [r0, #0]
   db06c:	695b      	ldr	r3, [r3, #20]
   db06e:	4798      	blx	r3


////////////////////////////////////////////////////////////////////////////////
// PCF8523 implementation

static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
   db070:	f3c0 1603 	ubfx	r6, r0, #4, #4
   db074:	eba6 0686 	sub.w	r6, r6, r6, lsl #2
   db078:	eb00 0046 	add.w	r0, r0, r6, lsl #1
   db07c:	b2c6      	uxtb	r6, r0
  Wire.endTransmission();

  Wire.requestFrom(PCF8523_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
   db07e:	f003 fe0d 	bl	dec9c <_Z19__fetch_global_Wirev>
   db082:	6803      	ldr	r3, [r0, #0]
   db084:	695b      	ldr	r3, [r3, #20]
   db086:	4798      	blx	r3


////////////////////////////////////////////////////////////////////////////////
// PCF8523 implementation

static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
   db088:	f3c0 1703 	ubfx	r7, r0, #4, #4
   db08c:	eba7 0787 	sub.w	r7, r7, r7, lsl #2
   db090:	eb00 0047 	add.w	r0, r0, r7, lsl #1
   db094:	b2c7      	uxtb	r7, r0

  Wire.requestFrom(PCF8523_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  uint8_t d = bcd2bin(Wire._I2C_READ());
   db096:	f003 fe01 	bl	dec9c <_Z19__fetch_global_Wirev>
   db09a:	6803      	ldr	r3, [r0, #0]
   db09c:	695b      	ldr	r3, [r3, #20]
   db09e:	4798      	blx	r3


////////////////////////////////////////////////////////////////////////////////
// PCF8523 implementation

static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
   db0a0:	f3c0 1803 	ubfx	r8, r0, #4, #4
   db0a4:	eba8 0888 	sub.w	r8, r8, r8, lsl #2
   db0a8:	eb00 0048 	add.w	r0, r0, r8, lsl #1
   db0ac:	fa5f f880 	uxtb.w	r8, r0
  Wire.requestFrom(PCF8523_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  uint8_t d = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
   db0b0:	f003 fdf4 	bl	dec9c <_Z19__fetch_global_Wirev>
   db0b4:	6803      	ldr	r3, [r0, #0]
   db0b6:	695b      	ldr	r3, [r3, #20]
   db0b8:	4798      	blx	r3
  uint8_t m = bcd2bin(Wire._I2C_READ());
   db0ba:	f003 fdef 	bl	dec9c <_Z19__fetch_global_Wirev>
   db0be:	6803      	ldr	r3, [r0, #0]
   db0c0:	695b      	ldr	r3, [r3, #20]
   db0c2:	4798      	blx	r3


////////////////////////////////////////////////////////////////////////////////
// PCF8523 implementation

static uint8_t bcd2bin (uint8_t val) { return val - 6 * (val >> 4); }
   db0c4:	f3c0 1903 	ubfx	r9, r0, #4, #4
   db0c8:	eba9 0989 	sub.w	r9, r9, r9, lsl #2
   db0cc:	eb00 0049 	add.w	r0, r0, r9, lsl #1
   db0d0:	fa5f f980 	uxtb.w	r9, r0
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  uint8_t d = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
  uint8_t m = bcd2bin(Wire._I2C_READ());
  uint16_t y = bcd2bin(Wire._I2C_READ()) + 2000;
   db0d4:	f003 fde2 	bl	dec9c <_Z19__fetch_global_Wirev>
   db0d8:	6803      	ldr	r3, [r0, #0]
   db0da:	695b      	ldr	r3, [r3, #20]
   db0dc:	4798      	blx	r3
}

DateTime::DateTime (uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec) {
    if (year >= 2000)
        year -= 2000;
    yOff = year;
   db0de:	f3c0 1303 	ubfx	r3, r0, #4, #4
   db0e2:	eba3 0383 	sub.w	r3, r3, r3, lsl #2
   db0e6:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   db0ea:	7020      	strb	r0, [r4, #0]
    m = month;
   db0ec:	f884 9001 	strb.w	r9, [r4, #1]
    d = day;
   db0f0:	f884 8002 	strb.w	r8, [r4, #2]
    hh = hour;
   db0f4:	70e7      	strb	r7, [r4, #3]
    mm = min;
   db0f6:	7126      	strb	r6, [r4, #4]
    ss = sec;
   db0f8:	7165      	strb	r5, [r4, #5]
  Wire._I2C_READ();
  uint8_t m = bcd2bin(Wire._I2C_READ());
  uint16_t y = bcd2bin(Wire._I2C_READ()) + 2000;
  
  return DateTime (y, m, d, hh, mm, ss);
}
   db0fa:	4620      	mov	r0, r4
   db0fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000db100 <_ZN7PCF85238read_regEPhhh>:

// Example: PCF8523.read_reg(buf,size,address);
// Returns:   buf[0] = &address
//            buf[1] = &address + 1
//      ..... buf[size-1] = &address + size
void PCF8523::read_reg(uint8_t* buf, uint8_t size, uint8_t address) {
   db100:	b570      	push	{r4, r5, r6, lr}
   db102:	461d      	mov	r5, r3
   db104:	4614      	mov	r4, r2
   db106:	460e      	mov	r6, r1
  int addrByte = address;
  Wire.beginTransmission(PCF8523_ADDRESS);
   db108:	f003 fdc8 	bl	dec9c <_Z19__fetch_global_Wirev>
   db10c:	2168      	movs	r1, #104	; 0x68
   db10e:	f003 f890 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
  Wire._I2C_WRITE(addrByte);
   db112:	f003 fdc3 	bl	dec9c <_Z19__fetch_global_Wirev>
   db116:	4629      	mov	r1, r5
   db118:	f7f9 fa50 	bl	d45bc <_ZN7TwoWire5writeEi>
  Wire.endTransmission();
   db11c:	f003 fdbe 	bl	dec9c <_Z19__fetch_global_Wirev>
   db120:	f003 f88e 	bl	de240 <_ZN7TwoWire15endTransmissionEv>
  
  Wire.requestFrom((uint8_t) PCF8523_ADDRESS, size);
   db124:	f003 fdba 	bl	dec9c <_Z19__fetch_global_Wirev>
   db128:	4622      	mov	r2, r4
   db12a:	2168      	movs	r1, #104	; 0x68
   db12c:	f003 f87a 	bl	de224 <_ZN7TwoWire11requestFromEhj>
   db130:	3c01      	subs	r4, #1
   db132:	1e75      	subs	r5, r6, #1
   db134:	4434      	add	r4, r6
  for (uint8_t pos = 0; pos < size; ++pos) {
   db136:	42a5      	cmp	r5, r4
   db138:	d007      	beq.n	db14a <_ZN7PCF85238read_regEPhhh+0x4a>
    buf[pos] = Wire._I2C_READ();
   db13a:	f003 fdaf 	bl	dec9c <_Z19__fetch_global_Wirev>
   db13e:	6803      	ldr	r3, [r0, #0]
   db140:	695b      	ldr	r3, [r3, #20]
   db142:	4798      	blx	r3
   db144:	f805 0f01 	strb.w	r0, [r5, #1]!
  Wire.beginTransmission(PCF8523_ADDRESS);
  Wire._I2C_WRITE(addrByte);
  Wire.endTransmission();
  
  Wire.requestFrom((uint8_t) PCF8523_ADDRESS, size);
  for (uint8_t pos = 0; pos < size; ++pos) {
   db148:	e7f5      	b.n	db136 <_ZN7PCF85238read_regEPhhh+0x36>
   db14a:	bd70      	pop	{r4, r5, r6, pc}

000db14c <_ZN7PCF85239write_regEhPhh>:

// Example: PCF8523.write_reg(address,buf,size);
// Write:     buf[0] => &address
//            buf[1] => &address + 1
//      ..... buf[size-1] => &address + size
void PCF8523::write_reg(uint8_t address, uint8_t* buf, uint8_t size) {
   db14c:	b570      	push	{r4, r5, r6, lr}
   db14e:	4614      	mov	r4, r2
   db150:	461d      	mov	r5, r3
   db152:	460e      	mov	r6, r1
  int addrByte = address;
  Wire.beginTransmission(PCF8523_ADDRESS);
   db154:	f003 fda2 	bl	dec9c <_Z19__fetch_global_Wirev>
   db158:	2168      	movs	r1, #104	; 0x68
   db15a:	f003 f86a 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
  Wire._I2C_WRITE(addrByte);
   db15e:	f003 fd9d 	bl	dec9c <_Z19__fetch_global_Wirev>
   db162:	4631      	mov	r1, r6
   db164:	f7f9 fa2a 	bl	d45bc <_ZN7TwoWire5writeEi>
   db168:	3d01      	subs	r5, #1
   db16a:	1e66      	subs	r6, r4, #1
   db16c:	442c      	add	r4, r5
  for (uint8_t pos = 0; pos < size; ++pos) {
   db16e:	42a6      	cmp	r6, r4
   db170:	d007      	beq.n	db182 <_ZN7PCF85239write_regEhPhh+0x36>
    Wire._I2C_WRITE(buf[pos]);
   db172:	f003 fd93 	bl	dec9c <_Z19__fetch_global_Wirev>
   db176:	6803      	ldr	r3, [r0, #0]
   db178:	f816 1f01 	ldrb.w	r1, [r6, #1]!
   db17c:	689b      	ldr	r3, [r3, #8]
   db17e:	4798      	blx	r3
//      ..... buf[size-1] => &address + size
void PCF8523::write_reg(uint8_t address, uint8_t* buf, uint8_t size) {
  int addrByte = address;
  Wire.beginTransmission(PCF8523_ADDRESS);
  Wire._I2C_WRITE(addrByte);
  for (uint8_t pos = 0; pos < size; ++pos) {
   db180:	e7f5      	b.n	db16e <_ZN7PCF85239write_regEhPhh+0x22>
    Wire._I2C_WRITE(buf[pos]);
  }
  Wire.endTransmission();
   db182:	f003 fd8b 	bl	dec9c <_Z19__fetch_global_Wirev>
}
   db186:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  Wire.beginTransmission(PCF8523_ADDRESS);
  Wire._I2C_WRITE(addrByte);
  for (uint8_t pos = 0; pos < size; ++pos) {
    Wire._I2C_WRITE(buf[pos]);
  }
  Wire.endTransmission();
   db18a:	f003 b859 	b.w	de240 <_ZN7TwoWire15endTransmissionEv>

000db18e <_ZN7PCF85238read_regEh>:
}

// Example: val = PCF8523.read_reg(0x08);
// Reads the value in register addressed at 0x08
// and returns data
uint8_t PCF8523::read_reg(uint8_t address) {
   db18e:	b507      	push	{r0, r1, r2, lr}
  uint8_t data;
  read_reg(&data, 1, address);
   db190:	460b      	mov	r3, r1
   db192:	2201      	movs	r2, #1
   db194:	f10d 0107 	add.w	r1, sp, #7
   db198:	f7ff ffb2 	bl	db100 <_ZN7PCF85238read_regEPhhh>
  return data;
}
   db19c:	f89d 0007 	ldrb.w	r0, [sp, #7]
   db1a0:	b003      	add	sp, #12
   db1a2:	f85d fb04 	ldr.w	pc, [sp], #4

000db1a6 <_ZN7PCF85239write_regEhh>:

// Example: PCF8523.write_reg(0x08, 0x25);
// Writes value 0x25 in register addressed at 0x08
void PCF8523::write_reg(uint8_t address, uint8_t data) {
   db1a6:	b513      	push	{r0, r1, r4, lr}
   db1a8:	ac02      	add	r4, sp, #8
  write_reg(address, &data, 1);
   db1aa:	2301      	movs	r3, #1
  return data;
}

// Example: PCF8523.write_reg(0x08, 0x25);
// Writes value 0x25 in register addressed at 0x08
void PCF8523::write_reg(uint8_t address, uint8_t data) {
   db1ac:	f804 2d01 	strb.w	r2, [r4, #-1]!
  write_reg(address, &data, 1);
   db1b0:	4622      	mov	r2, r4
   db1b2:	f7ff ffcb 	bl	db14c <_ZN7PCF85239write_regEhPhh>
}
   db1b6:	b002      	add	sp, #8
   db1b8:	bd10      	pop	{r4, pc}

000db1ba <_ZN7PCF85236configEv>:
void PCF8523::reset(){
    write_reg(PCF8523_CONTROL_1, 0x58);
}

void PCF8523::config(){
    write_reg(PCF8523_CONTROL_1, 0x82);
   db1ba:	2282      	movs	r2, #130	; 0x82
   db1bc:	2100      	movs	r1, #0
   db1be:	f7ff bff2 	b.w	db1a6 <_ZN7PCF85239write_regEhh>

000db1c2 <_ZN7PCF852325clear_rtc_interrupt_flagsEv>:
}

uint8_t PCF8523::clear_rtc_interrupt_flags() {
   db1c2:	b538      	push	{r3, r4, r5, lr}
  uint8_t rc2 = read_reg(PCF8523_CONTROL_2) & (PCF8523_CONTROL_2_SF_BIT | PCF8523_CONTROL_2_AF_BIT);
   db1c4:	2101      	movs	r1, #1

void PCF8523::config(){
    write_reg(PCF8523_CONTROL_1, 0x82);
}

uint8_t PCF8523::clear_rtc_interrupt_flags() {
   db1c6:	4605      	mov	r5, r0
  uint8_t rc2 = read_reg(PCF8523_CONTROL_2) & (PCF8523_CONTROL_2_SF_BIT | PCF8523_CONTROL_2_AF_BIT);
   db1c8:	f7ff ffe1 	bl	db18e <_ZN7PCF85238read_regEh>
  write_reg(PCF8523_CONTROL_2, 0);  // Just zero the whole thing
   db1cc:	2200      	movs	r2, #0
void PCF8523::config(){
    write_reg(PCF8523_CONTROL_1, 0x82);
}

uint8_t PCF8523::clear_rtc_interrupt_flags() {
  uint8_t rc2 = read_reg(PCF8523_CONTROL_2) & (PCF8523_CONTROL_2_SF_BIT | PCF8523_CONTROL_2_AF_BIT);
   db1ce:	4604      	mov	r4, r0
  write_reg(PCF8523_CONTROL_2, 0);  // Just zero the whole thing
   db1d0:	2101      	movs	r1, #1
   db1d2:	4628      	mov	r0, r5
   db1d4:	f7ff ffe7 	bl	db1a6 <_ZN7PCF85239write_regEhh>
  return rc2 != 0;
}
   db1d8:	f014 0007 	ands.w	r0, r4, #7
   db1dc:	bf18      	it	ne
   db1de:	2001      	movne	r0, #1
   db1e0:	bd38      	pop	{r3, r4, r5, pc}

000db1e2 <_GLOBAL__sub_I__ZN8DateTimeC2Em>:
   db1e2:	f000 ba67 	b.w	db6b4 <HAL_Pin_Map>

000db1e6 <_ZN5SDLib7SDClassD1Ev>:
      void rewindDirectory(void);

      using Print::write;
  };

  class SDClass {
   db1e6:	4770      	bx	lr

000db1e8 <_ZN5SDLib19callback_pathExistsER6SdFilePKcbPv>:
     a pointer to an arbitrary object used for context.

  */

  bool callback_pathExists(SdFile& parentDir, const char *filePathComponent,
                           bool /* isLastComponent */, void * /* object */) {
   db1e8:	b510      	push	{r4, lr}
   db1ea:	b08a      	sub	sp, #40	; 0x28
   db1ec:	2300      	movs	r3, #0
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db1ee:	4a0b      	ldr	r2, [pc, #44]	; (db21c <_ZN5SDLib19callback_pathExistsER6SdFilePKcbPv+0x34>)
   db1f0:	9301      	str	r3, [sp, #4]
   db1f2:	9200      	str	r2, [sp, #0]
   db1f4:	f88d 3009 	strb.w	r3, [sp, #9]
    /** \deprecated Use:
       uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
    */
    uint8_t open(SdFile& dirFile, // NOLINT
                 const char* fileName, uint8_t oflag) {
      return open(&dirFile, fileName, oflag);
   db1f8:	460a      	mov	r2, r1
   db1fa:	2301      	movs	r3, #1
   db1fc:	4601      	mov	r1, r0
   db1fe:	4668      	mov	r0, sp
   db200:	f7fe fcca 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
      Returns true if file path exists.

    */
    SdFile child;

    bool exists = child.open(parentDir, filePathComponent, O_RDONLY);
   db204:	2800      	cmp	r0, #0
   db206:	bf14      	ite	ne
   db208:	2401      	movne	r4, #1
   db20a:	2400      	moveq	r4, #0

    if (exists) {
   db20c:	d002      	beq.n	db214 <_ZN5SDLib19callback_pathExistsER6SdFilePKcbPv+0x2c>
      child.close();
   db20e:	4668      	mov	r0, sp
   db210:	f7fe fc24 	bl	d9a5c <_ZN6SdFile5closeEv>
    }

    return exists;
  }
   db214:	4620      	mov	r0, r4
   db216:	b00a      	add	sp, #40	; 0x28
   db218:	bd10      	pop	{r4, pc}
   db21a:	bf00      	nop
   db21c:	000e2358 	.word	0x000e2358

000db220 <_ZN5SDLib20callback_makeDirPathER6SdFilePKcbPv>:



  bool callback_makeDirPath(SdFile& parentDir, const char *filePathComponent,
                            bool isLastComponent, void *object) {
   db220:	b5f0      	push	{r4, r5, r6, r7, lr}
   db222:	b08b      	sub	sp, #44	; 0x2c
   db224:	2400      	movs	r4, #0
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db226:	4f0a      	ldr	r7, [pc, #40]	; (db250 <_ZN5SDLib20callback_makeDirPathER6SdFilePKcbPv+0x30>)
   db228:	9401      	str	r4, [sp, #4]
   db22a:	4605      	mov	r5, r0
   db22c:	460e      	mov	r6, r1
   db22e:	9700      	str	r7, [sp, #0]
   db230:	f88d 4009 	strb.w	r4, [sp, #9]

    */
    bool result = false;
    SdFile child;

    result = callback_pathExists(parentDir, filePathComponent, isLastComponent, object);
   db234:	f7ff ffd8 	bl	db1e8 <_ZN5SDLib19callback_pathExistsER6SdFilePKcbPv>
    if (!result) {
   db238:	b938      	cbnz	r0, db24a <_ZN5SDLib20callback_makeDirPathER6SdFilePKcbPv+0x2a>
    }
    /** \deprecated Use:
       uint8_t SdFile::makeDir(SdFile* dir, const char* dirName);
    */
    uint8_t makeDir(SdFile& dir, const char* dirName) {  // NOLINT
      return makeDir(&dir, dirName);
   db23a:	4632      	mov	r2, r6
   db23c:	4629      	mov	r1, r5
   db23e:	4668      	mov	r0, sp
   db240:	f7fe fd3c 	bl	d9cbc <_ZN6SdFile7makeDirEPS_PKc>
      result = child.makeDir(parentDir, filePathComponent);
   db244:	1b00      	subs	r0, r0, r4
   db246:	bf18      	it	ne
   db248:	2001      	movne	r0, #1
    }

    return result;
  }
   db24a:	b00b      	add	sp, #44	; 0x2c
   db24c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   db24e:	bf00      	nop
   db250:	000e2358 	.word	0x000e2358

000db254 <_ZN5SDLib15callback_removeER6SdFilePKcbPv>:
  */



  bool callback_remove(SdFile& parentDir, const char *filePathComponent,
                       bool isLastComponent, void * /* object */) {
   db254:	b508      	push	{r3, lr}
    if (isLastComponent) {
   db256:	b12a      	cbz	r2, db264 <_ZN5SDLib15callback_removeER6SdFilePKcbPv+0x10>
    }
    /** \deprecated Use:
       static uint8_t SdFile::remove(SdFile* dirFile, const char* fileName);
    */
    static uint8_t remove(SdFile& dirFile, const char* fileName) {  // NOLINT
      return remove(&dirFile, fileName);
   db258:	f7fe fdc2 	bl	d9de0 <_ZN6SdFile6removeEPS_PKc>
      return SdFile::remove(parentDir, filePathComponent);
   db25c:	3000      	adds	r0, #0
   db25e:	bf18      	it	ne
   db260:	2001      	movne	r0, #1
   db262:	bd08      	pop	{r3, pc}
    }
    return true;
   db264:	2001      	movs	r0, #1
  }
   db266:	bd08      	pop	{r3, pc}

000db268 <_ZN5SDLib14callback_rmdirER6SdFilePKcbPv>:

  bool callback_rmdir(SdFile& parentDir, const char *filePathComponent,
                      bool isLastComponent, void * /* object */) {
   db268:	b500      	push	{lr}
   db26a:	b08b      	sub	sp, #44	; 0x2c
    if (isLastComponent) {
   db26c:	b19a      	cbz	r2, db296 <_ZN5SDLib14callback_rmdirER6SdFilePKcbPv+0x2e>
   db26e:	2300      	movs	r3, #0
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db270:	4a0b      	ldr	r2, [pc, #44]	; (db2a0 <_ZN5SDLib14callback_rmdirER6SdFilePKcbPv+0x38>)
   db272:	9301      	str	r3, [sp, #4]
   db274:	9200      	str	r2, [sp, #0]
   db276:	f88d 3009 	strb.w	r3, [sp, #9]
    /** \deprecated Use:
       uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
    */
    uint8_t open(SdFile& dirFile, // NOLINT
                 const char* fileName, uint8_t oflag) {
      return open(&dirFile, fileName, oflag);
   db27a:	460a      	mov	r2, r1
   db27c:	2301      	movs	r3, #1
   db27e:	4601      	mov	r1, r0
   db280:	4668      	mov	r0, sp
   db282:	f7fe fc89 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
      SdFile f;
      if (!f.open(parentDir, filePathComponent, O_READ)) {
   db286:	b138      	cbz	r0, db298 <_ZN5SDLib14callback_rmdirER6SdFilePKcbPv+0x30>
        return false;
      }
      return f.rmDir();
   db288:	4668      	mov	r0, sp
   db28a:	f7fe fdc1 	bl	d9e10 <_ZN6SdFile5rmDirEv>
   db28e:	3000      	adds	r0, #0
   db290:	bf18      	it	ne
   db292:	2001      	movne	r0, #1
   db294:	e000      	b.n	db298 <_ZN5SDLib14callback_rmdirER6SdFilePKcbPv+0x30>
    }
    return true;
   db296:	2001      	movs	r0, #1
  }
   db298:	b00b      	add	sp, #44	; 0x2c
   db29a:	f85d fb04 	ldr.w	pc, [sp], #4
   db29e:	bf00      	nop
   db2a0:	000e2358 	.word	0x000e2358

000db2a4 <_ZN8SdVolume4initEP7Sd2Card>:
       \return The value one, true, is returned for success and
       the value zero, false, is returned for failure.  Reasons for
       failure include not finding a valid partition, not finding a valid
       FAT file system or an I/O error.
    */
    uint8_t init(Sd2Card* dev) {
   db2a4:	b538      	push	{r3, r4, r5, lr}
      return init(dev, 1) ? true : init(dev, 0);
   db2a6:	2201      	movs	r2, #1
       \return The value one, true, is returned for success and
       the value zero, false, is returned for failure.  Reasons for
       failure include not finding a valid partition, not finding a valid
       FAT file system or an I/O error.
    */
    uint8_t init(Sd2Card* dev) {
   db2a8:	4604      	mov	r4, r0
   db2aa:	460d      	mov	r5, r1
      return init(dev, 1) ? true : init(dev, 0);
   db2ac:	f7f9 f8a2 	bl	d43f4 <_ZN8SdVolume4initEP7Sd2Cardh>
   db2b0:	4602      	mov	r2, r0
   db2b2:	b928      	cbnz	r0, db2c0 <_ZN8SdVolume4initEP7Sd2Card+0x1c>
   db2b4:	4629      	mov	r1, r5
   db2b6:	4620      	mov	r0, r4
    }
   db2b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
       the value zero, false, is returned for failure.  Reasons for
       failure include not finding a valid partition, not finding a valid
       FAT file system or an I/O error.
    */
    uint8_t init(Sd2Card* dev) {
      return init(dev, 1) ? true : init(dev, 0);
   db2bc:	f7f9 b89a 	b.w	d43f4 <_ZN8SdVolume4initEP7Sd2Cardh>
    }
   db2c0:	2001      	movs	r0, #1
   db2c2:	bd38      	pop	{r3, r4, r5, pc}

000db2c4 <_ZN5SDLib20getNextPathComponentEPKcPjPc>:
  // Used by `getNextPathComponent`
#define MAX_COMPONENT_LEN 12 // What is max length?
#define PATH_COMPONENT_BUFFER_LEN MAX_COMPONENT_LEN+1

  bool getNextPathComponent(const char *path, unsigned int *p_offset,
                            char *buffer) {
   db2c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    // TODO: Have buffer local to this function, so we know it's the
    //       correct length?

    int bufferOffset = 0;

    int offset = *p_offset;
   db2c6:	680b      	ldr	r3, [r1, #0]

    // Skip root or other separator
    if (path[offset] == '/') {
   db2c8:	5cc4      	ldrb	r4, [r0, r3]
   db2ca:	2c2f      	cmp	r4, #47	; 0x2f
      offset++;
   db2cc:	bf08      	it	eq
   db2ce:	3301      	addeq	r3, #1
   db2d0:	1e56      	subs	r6, r2, #1
  // Used by `getNextPathComponent`
#define MAX_COMPONENT_LEN 12 // What is max length?
#define PATH_COMPONENT_BUFFER_LEN MAX_COMPONENT_LEN+1

  bool getNextPathComponent(const char *path, unsigned int *p_offset,
                            char *buffer) {
   db2d2:	2400      	movs	r4, #0
      offset++;
    }

    // Copy the next next path segment
    while (bufferOffset < MAX_COMPONENT_LEN
           && (path[offset] != '/')
   db2d4:	18c7      	adds	r7, r0, r3
   db2d6:	5d3d      	ldrb	r5, [r7, r4]
   db2d8:	2d2f      	cmp	r5, #47	; 0x2f
   db2da:	d007      	beq.n	db2ec <_ZN5SDLib20getNextPathComponentEPKcPjPc+0x28>
           && (path[offset] != '\0')) {
   db2dc:	b135      	cbz	r5, db2ec <_ZN5SDLib20getNextPathComponentEPKcPjPc+0x28>
      buffer[bufferOffset++] = path[offset++];
   db2de:	3401      	adds	r4, #1
    }

    // Copy the next next path segment
    while (bufferOffset < MAX_COMPONENT_LEN
           && (path[offset] != '/')
           && (path[offset] != '\0')) {
   db2e0:	2c0c      	cmp	r4, #12
      buffer[bufferOffset++] = path[offset++];
   db2e2:	f103 0301 	add.w	r3, r3, #1
   db2e6:	f806 5f01 	strb.w	r5, [r6, #1]!
    }

    // Copy the next next path segment
    while (bufferOffset < MAX_COMPONENT_LEN
           && (path[offset] != '/')
           && (path[offset] != '\0')) {
   db2ea:	d1f4      	bne.n	db2d6 <_ZN5SDLib20getNextPathComponentEPKcPjPc+0x12>
      buffer[bufferOffset++] = path[offset++];
    }

    buffer[bufferOffset] = '\0';
   db2ec:	2500      	movs	r5, #0
   db2ee:	5515      	strb	r5, [r2, r4]

    // Skip trailing separator so we can determine if this
    // is the last component in the path or not.
    if (path[offset] == '/') {
   db2f0:	5cc2      	ldrb	r2, [r0, r3]
   db2f2:	2a2f      	cmp	r2, #47	; 0x2f
      offset++;
   db2f4:	bf08      	it	eq
   db2f6:	3301      	addeq	r3, #1
    }

    *p_offset = offset;
   db2f8:	600b      	str	r3, [r1, #0]

    return (path[offset] != '\0');
   db2fa:	5cc0      	ldrb	r0, [r0, r3]
  }
   db2fc:	3000      	adds	r0, #0
   db2fe:	bf18      	it	ne
   db300:	2001      	movne	r0, #1
   db302:	bdf0      	pop	{r4, r5, r6, r7, pc}

000db304 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_>:
  bool walkPath(const char *filepath, SdFile& parentDir,
                bool(*callback)(SdFile& parentDir,
                                const char *filePathComponent,
                                bool isLastComponent,
                                void *object),
                void *object = NULL) {
   db304:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   db308:	b09b      	sub	sp, #108	; 0x6c
   db30a:	4691      	mov	r9, r2
   db30c:	469a      	mov	sl, r3
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db30e:	4a24      	ldr	r2, [pc, #144]	; (db3a0 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x9c>)
   db310:	9206      	str	r2, [sp, #24]
   db312:	2300      	movs	r3, #0
   db314:	4680      	mov	r8, r0
   db316:	460e      	mov	r6, r1
   db318:	9307      	str	r3, [sp, #28]
   db31a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
   db31e:	9311      	str	r3, [sp, #68]	; 0x44
   db320:	9210      	str	r2, [sp, #64]	; 0x40
   db322:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
    SdFile subfile1;
    SdFile subfile2;

    char buffer[PATH_COMPONENT_BUFFER_LEN];

    unsigned int offset = 0;
   db326:	9301      	str	r3, [sp, #4]
   db328:	460c      	mov	r4, r1
    SdFile *p_parent;
    SdFile *p_child;

    SdFile *p_tmp_sdfile;

    p_child = &subfile1;
   db32a:	af06      	add	r7, sp, #24

    p_parent = &parentDir;

    while (true) {

      bool moreComponents = getNextPathComponent(filepath, &offset, buffer);
   db32c:	aa02      	add	r2, sp, #8
   db32e:	a901      	add	r1, sp, #4
   db330:	4640      	mov	r0, r8
   db332:	f7ff ffc7 	bl	db2c4 <_ZN5SDLib20getNextPathComponentEPKcPjPc>

      bool shouldContinue = callback((*p_parent), buffer, !moreComponents, object);
   db336:	f080 0201 	eor.w	r2, r0, #1

    p_parent = &parentDir;

    while (true) {

      bool moreComponents = getNextPathComponent(filepath, &offset, buffer);
   db33a:	4683      	mov	fp, r0

      bool shouldContinue = callback((*p_parent), buffer, !moreComponents, object);
   db33c:	4653      	mov	r3, sl
   db33e:	b2d2      	uxtb	r2, r2
   db340:	a902      	add	r1, sp, #8
   db342:	4620      	mov	r0, r4
   db344:	47c8      	blx	r9

      if (!shouldContinue) {
   db346:	b938      	cbnz	r0, db358 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x54>
        // TODO: Don't repeat this code?
        // If it's one we've created then we
        // don't need the parent handle anymore.
        if (p_parent != &parentDir) {
   db348:	42b4      	cmp	r4, r6
   db34a:	d101      	bne.n	db350 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x4c>
          (*p_parent).close();
        }
        return false;
   db34c:	2000      	movs	r0, #0
   db34e:	e023      	b.n	db398 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x94>
      if (!shouldContinue) {
        // TODO: Don't repeat this code?
        // If it's one we've created then we
        // don't need the parent handle anymore.
        if (p_parent != &parentDir) {
          (*p_parent).close();
   db350:	4620      	mov	r0, r4
   db352:	f7fe fb83 	bl	d9a5c <_ZN6SdFile5closeEv>
   db356:	e7f9      	b.n	db34c <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x48>
        }
        return false;
      }

      if (!moreComponents) {
   db358:	f1bb 0f00 	cmp.w	fp, #0
   db35c:	d011      	beq.n	db382 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x7e>
    /** \deprecated Use:
       uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
    */
    uint8_t open(SdFile& dirFile, // NOLINT
                 const char* fileName, uint8_t oflag) {
      return open(&dirFile, fileName, oflag);
   db35e:	2301      	movs	r3, #1
   db360:	aa02      	add	r2, sp, #8
   db362:	4621      	mov	r1, r4
   db364:	4638      	mov	r0, r7
   db366:	f7fe fc17 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>

      bool exists = (*p_child).open(*p_parent, buffer, O_RDONLY);

      // If it's one we've created then we
      // don't need the parent handle anymore.
      if (p_parent != &parentDir) {
   db36a:	42b4      	cmp	r4, r6
   db36c:	4605      	mov	r5, r0
   db36e:	d00f      	beq.n	db390 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x8c>
        (*p_parent).close();
   db370:	4620      	mov	r0, r4
   db372:	f7fe fb73 	bl	d9a5c <_ZN6SdFile5closeEv>
      }

      // Handle case when it doesn't exist and we can't continue...
      if (exists) {
   db376:	2d00      	cmp	r5, #0
   db378:	d0e8      	beq.n	db34c <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x48>
        // We alternate between two file handles as we go down
        // the path.
        if (p_parent == &parentDir) {
          p_parent = &subfile2;
   db37a:	4623      	mov	r3, r4
   db37c:	463c      	mov	r4, r7
   db37e:	461f      	mov	r7, r3
   db380:	e7d4      	b.n	db32c <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x28>
      } else {
        return false;
      }
    }

    if (p_parent != &parentDir) {
   db382:	42b4      	cmp	r4, r6
   db384:	d002      	beq.n	db38c <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x88>
      (*p_parent).close(); // TODO: Return/ handle different?
   db386:	4620      	mov	r0, r4
   db388:	f7fe fb68 	bl	d9a5c <_ZN6SdFile5closeEv>
    }

    return true;
   db38c:	2001      	movs	r0, #1
   db38e:	e003      	b.n	db398 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x94>
      if (p_parent != &parentDir) {
        (*p_parent).close();
      }

      // Handle case when it doesn't exist and we can't continue...
      if (exists) {
   db390:	2800      	cmp	r0, #0
   db392:	d0db      	beq.n	db34c <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x48>
        // We alternate between two file handles as we go down
        // the path.
        if (p_parent == &parentDir) {
          p_parent = &subfile2;
   db394:	ac10      	add	r4, sp, #64	; 0x40
   db396:	e7f0      	b.n	db37a <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_+0x76>
    if (p_parent != &parentDir) {
      (*p_parent).close(); // TODO: Return/ handle different?
    }

    return true;
  }
   db398:	b01b      	add	sp, #108	; 0x6c
   db39a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   db39e:	bf00      	nop
   db3a0:	000e2358 	.word	0x000e2358

000db3a4 <_ZN5SDLib7SDClass5beginEh>:

  /* Implementation of class used to create `SDCard` object. */



  bool SDClass::begin(uint8_t csPin) {
   db3a4:	b538      	push	{r3, r4, r5, lr}
    if (root.isOpen()) {
   db3a6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41

  /* Implementation of class used to create `SDCard` object. */



  bool SDClass::begin(uint8_t csPin) {
   db3aa:	4604      	mov	r4, r0
   db3ac:	460d      	mov	r5, r1
    if (root.isOpen()) {
   db3ae:	b113      	cbz	r3, db3b6 <_ZN5SDLib7SDClass5beginEh+0x12>
      root.close();
   db3b0:	3038      	adds	r0, #56	; 0x38
   db3b2:	f7fe fb53 	bl	d9a5c <_ZN6SdFile5closeEv>
      Performs the initialisation required by the sdfatlib library.

      Return true if initialization succeeds, false otherwise.

    */
    return card.init(SPI_HALF_SPEED, csPin) &&
   db3b6:	462a      	mov	r2, r5
   db3b8:	2101      	movs	r1, #1
   db3ba:	4620      	mov	r0, r4
   db3bc:	f7ff f838 	bl	da430 <_ZN7Sd2Card4initEhh>
           volume.init(card) &&
   db3c0:	b908      	cbnz	r0, db3c6 <_ZN5SDLib7SDClass5beginEh+0x22>
   db3c2:	2000      	movs	r0, #0
   db3c4:	bd38      	pop	{r3, r4, r5, pc}
   db3c6:	f104 0510 	add.w	r5, r4, #16
    //------------------------------------------------------------------------------
    #if ALLOW_DEPRECATED_FUNCTIONS
    // Deprecated functions  - suppress cpplint warnings with NOLINT comment
    /** \deprecated Use: uint8_t SdVolume::init(Sd2Card* dev); */
    uint8_t init(Sd2Card& dev) {
      return init(&dev); // NOLINT
   db3ca:	4621      	mov	r1, r4
   db3cc:	4628      	mov	r0, r5
   db3ce:	f7ff ff69 	bl	db2a4 <_ZN8SdVolume4initEP7Sd2Card>
      Performs the initialisation required by the sdfatlib library.

      Return true if initialization succeeds, false otherwise.

    */
    return card.init(SPI_HALF_SPEED, csPin) &&
   db3d2:	2800      	cmp	r0, #0
   db3d4:	d0f5      	beq.n	db3c2 <_ZN5SDLib7SDClass5beginEh+0x1e>
    uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
      return open(&dirFile, index, oflag);
    }
    /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
    uint8_t openRoot(SdVolume& vol) {
      return openRoot(&vol); // NOLINT
   db3d6:	4629      	mov	r1, r5
   db3d8:	f104 0038 	add.w	r0, r4, #56	; 0x38
   db3dc:	f7fe f9f4 	bl	d97c8 <_ZN6SdFile8openRootEP8SdVolume>
           volume.init(card) &&
   db3e0:	3000      	adds	r0, #0
   db3e2:	bf18      	it	ne
   db3e4:	2001      	movne	r0, #1
           root.openRoot(volume);
  }
   db3e6:	bd38      	pop	{r3, r4, r5, pc}

000db3e8 <_ZN5SDLib7SDClass3endEv>:
           root.openRoot(volume);
  }

  //call this when a card is removed. It will allow you to insert and initialise a new card.
  void SDClass::end() {
    root.close();
   db3e8:	3038      	adds	r0, #56	; 0x38
   db3ea:	f7fe bb37 	b.w	d9a5c <_ZN6SdFile5closeEv>
	...

000db3f0 <_ZN6SdFileC1ERKS_>:
const unsigned char BIN = 2;

class String;
class __FlashStringHelper;

class Print
   db3f0:	4a0c      	ldr	r2, [pc, #48]	; (db424 <_ZN6SdFileC1ERKS_+0x34>)
   db3f2:	6002      	str	r2, [r0, #0]
   db3f4:	684a      	ldr	r2, [r1, #4]
   db3f6:	6042      	str	r2, [r0, #4]
//------------------------------------------------------------------------------
/**
   \class SdFile
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
   db3f8:	4a0b      	ldr	r2, [pc, #44]	; (db428 <_ZN6SdFileC1ERKS_+0x38>)
   db3fa:	6002      	str	r2, [r0, #0]
   db3fc:	7a0a      	ldrb	r2, [r1, #8]
   db3fe:	7202      	strb	r2, [r0, #8]
   db400:	7a4a      	ldrb	r2, [r1, #9]
   db402:	7242      	strb	r2, [r0, #9]
   db404:	68ca      	ldr	r2, [r1, #12]
   db406:	60c2      	str	r2, [r0, #12]
   db408:	690a      	ldr	r2, [r1, #16]
   db40a:	6102      	str	r2, [r0, #16]
   db40c:	694a      	ldr	r2, [r1, #20]
   db40e:	6142      	str	r2, [r0, #20]
   db410:	7e0a      	ldrb	r2, [r1, #24]
   db412:	7602      	strb	r2, [r0, #24]
   db414:	69ca      	ldr	r2, [r1, #28]
   db416:	61c2      	str	r2, [r0, #28]
   db418:	6a0a      	ldr	r2, [r1, #32]
   db41a:	6202      	str	r2, [r0, #32]
   db41c:	6a4a      	ldr	r2, [r1, #36]	; 0x24
   db41e:	6242      	str	r2, [r0, #36]	; 0x24
   db420:	4770      	bx	lr
   db422:	bf00      	nop
   db424:	000e2604 	.word	0x000e2604
   db428:	000e2358 	.word	0x000e2358

000db42c <_ZN5SDLib7SDClass12getParentDirEPKcPi>:
  }

  // this little helper is used to traverse paths
  SdFile SDClass::getParentDir(const char *filepath, int *index) {
   db42c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   db430:	b09b      	sub	sp, #108	; 0x6c
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   db432:	2700      	movs	r7, #0
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db434:	4e2a      	ldr	r6, [pc, #168]	; (db4e0 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0xb4>)
   db436:	9707      	str	r7, [sp, #28]
   db438:	4692      	mov	sl, r2
   db43a:	4681      	mov	r9, r0
    uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
      return open(&dirFile, index, oflag);
    }
    /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
    uint8_t openRoot(SdVolume& vol) {
      return openRoot(&vol); // NOLINT
   db43c:	3110      	adds	r1, #16
   db43e:	a806      	add	r0, sp, #24
   db440:	469b      	mov	fp, r3
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db442:	9606      	str	r6, [sp, #24]
   db444:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
   db448:	9711      	str	r7, [sp, #68]	; 0x44
   db44a:	9610      	str	r6, [sp, #64]	; 0x40
   db44c:	f88d 7049 	strb.w	r7, [sp, #73]	; 0x49
    uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
      return open(&dirFile, index, oflag);
    }
    /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
    uint8_t openRoot(SdVolume& vol) {
      return openRoot(&vol); // NOLINT
   db450:	4654      	mov	r4, sl
   db452:	f7fe f9b9 	bl	d97c8 <_ZN6SdFile8openRootEP8SdVolume>

    d1.openRoot(volume); // start with the mostparent, root!

    // we'll use the pointers to swap between the two objects
    SdFile *parent = &d1;
    SdFile *subdir = &d2;
   db456:	f10d 0840 	add.w	r8, sp, #64	; 0x40
    SdFile d2;

    d1.openRoot(volume); // start with the mostparent, root!

    // we'll use the pointers to swap between the two objects
    SdFile *parent = &d1;
   db45a:	ad06      	add	r5, sp, #24
   db45c:	9601      	str	r6, [sp, #4]
    SdFile *subdir = &d2;

    const char *origpath = filepath;

    while (strchr(filepath, '/')) {
   db45e:	212f      	movs	r1, #47	; 0x2f
   db460:	4620      	mov	r0, r4
   db462:	f004 fdb1 	bl	dffc8 <strchr>
   db466:	b378      	cbz	r0, db4c8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x9c>

      // get rid of leading /'s
      if (filepath[0] == '/') {
   db468:	7823      	ldrb	r3, [r4, #0]
   db46a:	2b2f      	cmp	r3, #47	; 0x2f
   db46c:	d107      	bne.n	db47e <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x52>
        filepath++;
        continue;
   db46e:	4643      	mov	r3, r8

    while (strchr(filepath, '/')) {

      // get rid of leading /'s
      if (filepath[0] == '/') {
        filepath++;
   db470:	3401      	adds	r4, #1
        continue;
   db472:	46a8      	mov	r8, r5
   db474:	461d      	mov	r5, r3
   db476:	462b      	mov	r3, r5
   db478:	4645      	mov	r5, r8
   db47a:	4698      	mov	r8, r3
   db47c:	e7ef      	b.n	db45e <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x32>
        // it was in the root directory, so leave now
        break;
      }

      // extract just the name of the next subdirectory
      uint8_t idx = strchr(filepath, '/') - filepath;
   db47e:	1b06      	subs	r6, r0, r4
   db480:	b2f6      	uxtb	r6, r6
   db482:	2e0c      	cmp	r6, #12
   db484:	bf28      	it	cs
   db486:	260c      	movcs	r6, #12
      if (idx > 12) {
        idx = 12;  // don't let them specify long names
      }
      char subdirname[13];
      strncpy(subdirname, filepath, idx);
   db488:	4632      	mov	r2, r6
   db48a:	4621      	mov	r1, r4
   db48c:	a802      	add	r0, sp, #8
   db48e:	f004 fe08 	bl	e00a2 <strncpy>
      subdirname[idx] = 0;
   db492:	ab1a      	add	r3, sp, #104	; 0x68
   db494:	4433      	add	r3, r6

      // close the subdir (we reuse them) if open
      subdir->close();
   db496:	4640      	mov	r0, r8
      if (idx > 12) {
        idx = 12;  // don't let them specify long names
      }
      char subdirname[13];
      strncpy(subdirname, filepath, idx);
      subdirname[idx] = 0;
   db498:	f803 7c60 	strb.w	r7, [r3, #-96]

      // close the subdir (we reuse them) if open
      subdir->close();
   db49c:	f7fe fade 	bl	d9a5c <_ZN6SdFile5closeEv>
      if (! subdir->open(parent, subdirname, O_READ)) {
   db4a0:	2301      	movs	r3, #1
   db4a2:	aa02      	add	r2, sp, #8
   db4a4:	4629      	mov	r1, r5
   db4a6:	4640      	mov	r0, r8
   db4a8:	f7fe fb76 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
   db4ac:	b938      	cbnz	r0, db4be <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x92>
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db4ae:	9b01      	ldr	r3, [sp, #4]
   db4b0:	f8c9 0004 	str.w	r0, [r9, #4]
   db4b4:	f8c9 3000 	str.w	r3, [r9]
   db4b8:	f889 0009 	strb.w	r0, [r9, #9]
   db4bc:	e00c      	b.n	db4d8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0xac>
      }
      // move forward to the next subdirectory
      filepath += idx;

      // we reuse the objects, close it.
      parent->close();
   db4be:	4628      	mov	r0, r5
      if (! subdir->open(parent, subdirname, O_READ)) {
        // failed to open one of the subdirectories
        return SdFile();
      }
      // move forward to the next subdirectory
      filepath += idx;
   db4c0:	4434      	add	r4, r6

      // we reuse the objects, close it.
      parent->close();
   db4c2:	f7fe facb 	bl	d9a5c <_ZN6SdFile5closeEv>
   db4c6:	e7d6      	b.n	db476 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x4a>
      SdFile *t = parent;
      parent = subdir;
      subdir = t;
    }

    *index = (int)(filepath - origpath);
   db4c8:	ebca 0404 	rsb	r4, sl, r4
   db4cc:	f8cb 4000 	str.w	r4, [fp]
    // parent is now the parent directory of the file!
    return *parent;
   db4d0:	4629      	mov	r1, r5
   db4d2:	4648      	mov	r0, r9
   db4d4:	f7ff ff8c 	bl	db3f0 <_ZN6SdFileC1ERKS_>
  }
   db4d8:	4648      	mov	r0, r9
   db4da:	b01b      	add	sp, #108	; 0x6c
   db4dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   db4e0:	000e2358 	.word	0x000e2358

000db4e4 <_ZN5SDLib7SDClass4openEPKch>:


  File SDClass::open(const char *filepath, uint8_t mode) {
   db4e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   db4e6:	b0a1      	sub	sp, #132	; 0x84
   db4e8:	4604      	mov	r4, r0
   db4ea:	461d      	mov	r5, r3
    */

    int pathidx;

    // do the interactive search
    SdFile parentdir = getParentDir(filepath, &pathidx);
   db4ec:	a802      	add	r0, sp, #8
   db4ee:	ab01      	add	r3, sp, #4
    // parent is now the parent directory of the file!
    return *parent;
  }


  File SDClass::open(const char *filepath, uint8_t mode) {
   db4f0:	4617      	mov	r7, r2
    */

    int pathidx;

    // do the interactive search
    SdFile parentdir = getParentDir(filepath, &pathidx);
   db4f2:	f7ff ff9b 	bl	db42c <_ZN5SDLib7SDClass12getParentDirEPKcPi>
    // no more subdirs!

    filepath += pathidx;
   db4f6:	9b01      	ldr	r3, [sp, #4]
   db4f8:	18fe      	adds	r6, r7, r3

    if (! filepath[0]) {
   db4fa:	5cfb      	ldrb	r3, [r7, r3]
   db4fc:	b92b      	cbnz	r3, db50a <_ZN5SDLib7SDClass4openEPKch+0x26>
      // it was the directory itself!
      return File(parentdir, "/");
   db4fe:	a902      	add	r1, sp, #8
   db500:	a816      	add	r0, sp, #88	; 0x58
   db502:	f7ff ff75 	bl	db3f0 <_ZN6SdFileC1ERKS_>
   db506:	4a17      	ldr	r2, [pc, #92]	; (db564 <_ZN5SDLib7SDClass4openEPKch+0x80>)
   db508:	e024      	b.n	db554 <_ZN5SDLib7SDClass4openEPKch+0x70>
   db50a:	2300      	movs	r3, #0
   db50c:	930d      	str	r3, [sp, #52]	; 0x34
   db50e:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39

    // Open the file itself
    SdFile file;

    // failed to open a subdir!
    if (!parentdir.isOpen()) {
   db512:	f89d 3011 	ldrb.w	r3, [sp, #17]
   db516:	4a14      	ldr	r2, [pc, #80]	; (db568 <_ZN5SDLib7SDClass4openEPKch+0x84>)
   db518:	920c      	str	r2, [sp, #48]	; 0x30
   db51a:	b91b      	cbnz	r3, db524 <_ZN5SDLib7SDClass4openEPKch+0x40>
      return File();
   db51c:	4620      	mov	r0, r4
   db51e:	f7ff f8b9 	bl	da694 <_ZN5SDLib4FileC1Ev>
   db522:	e01b      	b.n	db55c <_ZN5SDLib7SDClass4openEPKch+0x78>
    /** \deprecated Use:
       uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
    */
    uint8_t open(SdFile& dirFile, // NOLINT
                 const char* fileName, uint8_t oflag) {
      return open(&dirFile, fileName, oflag);
   db524:	462b      	mov	r3, r5
   db526:	4632      	mov	r2, r6
   db528:	a902      	add	r1, sp, #8
   db52a:	a80c      	add	r0, sp, #48	; 0x30
   db52c:	f7fe fb34 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
    }

    if (! file.open(parentdir, filepath, mode)) {
   db530:	2800      	cmp	r0, #0
   db532:	d0f3      	beq.n	db51c <_ZN5SDLib7SDClass4openEPKch+0x38>
      return File();
    }
    // close the parent
    parentdir.close();
   db534:	a802      	add	r0, sp, #8

    if ((mode & (O_APPEND | O_WRITE)) == (O_APPEND | O_WRITE)) {
   db536:	f005 0506 	and.w	r5, r5, #6

    if (! file.open(parentdir, filepath, mode)) {
      return File();
    }
    // close the parent
    parentdir.close();
   db53a:	f7fe fa8f 	bl	d9a5c <_ZN6SdFile5closeEv>

    if ((mode & (O_APPEND | O_WRITE)) == (O_APPEND | O_WRITE)) {
   db53e:	2d06      	cmp	r5, #6
   db540:	d103      	bne.n	db54a <_ZN5SDLib7SDClass4openEPKch+0x66>
      file.seekSet(file.fileSize());
   db542:	9913      	ldr	r1, [sp, #76]	; 0x4c
   db544:	a80c      	add	r0, sp, #48	; 0x30
   db546:	f7fe fa27 	bl	d9998 <_ZN6SdFile7seekSetEm>
    }
    return File(file, filepath);
   db54a:	a90c      	add	r1, sp, #48	; 0x30
   db54c:	a816      	add	r0, sp, #88	; 0x58
   db54e:	f7ff ff4f 	bl	db3f0 <_ZN6SdFileC1ERKS_>
   db552:	4632      	mov	r2, r6
   db554:	a916      	add	r1, sp, #88	; 0x58
   db556:	4620      	mov	r0, r4
   db558:	f7ff f876 	bl	da648 <_ZN5SDLib4FileC1E6SdFilePKc>
  }
   db55c:	4620      	mov	r0, r4
   db55e:	b021      	add	sp, #132	; 0x84
   db560:	bdf0      	pop	{r4, r5, r6, r7, pc}
   db562:	bf00      	nop
   db564:	000e1afd 	.word	0x000e1afd
   db568:	000e2358 	.word	0x000e2358

000db56c <_ZN5SDLib7SDClass6existsEPKc>:
  //   */
  //  file.close();
  //}


  bool SDClass::exists(const char *filepath) {
   db56c:	b410      	push	{r4}
   db56e:	460c      	mov	r4, r1
    /*

       Returns true if the supplied file path exists.

    */
    return walkPath(filepath, root, callback_pathExists);
   db570:	2300      	movs	r3, #0
   db572:	f100 0138 	add.w	r1, r0, #56	; 0x38
   db576:	4a03      	ldr	r2, [pc, #12]	; (db584 <_ZN5SDLib7SDClass6existsEPKc+0x18>)
   db578:	4620      	mov	r0, r4
  }
   db57a:	f85d 4b04 	ldr.w	r4, [sp], #4
    /*

       Returns true if the supplied file path exists.

    */
    return walkPath(filepath, root, callback_pathExists);
   db57e:	f7ff bec1 	b.w	db304 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_>
   db582:	bf00      	nop
   db584:	000db1e9 	.word	0x000db1e9

000db588 <_ZN5SDLib7SDClass5mkdirEPKc>:
  //   */
  //  return walkPath(filepath, parentDir, callback_pathExists);
  //}


  bool SDClass::mkdir(const char *filepath) {
   db588:	b410      	push	{r4}
   db58a:	460c      	mov	r4, r1
      Makes a single directory or a hierarchy of directories.

      A rough equivalent to `mkdir -p`.

    */
    return walkPath(filepath, root, callback_makeDirPath);
   db58c:	2300      	movs	r3, #0
   db58e:	f100 0138 	add.w	r1, r0, #56	; 0x38
   db592:	4a03      	ldr	r2, [pc, #12]	; (db5a0 <_ZN5SDLib7SDClass5mkdirEPKc+0x18>)
   db594:	4620      	mov	r0, r4
  }
   db596:	f85d 4b04 	ldr.w	r4, [sp], #4
      Makes a single directory or a hierarchy of directories.

      A rough equivalent to `mkdir -p`.

    */
    return walkPath(filepath, root, callback_makeDirPath);
   db59a:	f7ff beb3 	b.w	db304 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_>
   db59e:	bf00      	nop
   db5a0:	000db221 	.word	0x000db221

000db5a4 <_ZN5SDLib7SDClass5rmdirEPKc>:
  }

  bool SDClass::rmdir(const char *filepath) {
   db5a4:	b410      	push	{r4}
   db5a6:	460c      	mov	r4, r1
      Remove a single directory or a hierarchy of directories.

      A rough equivalent to `rm -rf`.

    */
    return walkPath(filepath, root, callback_rmdir);
   db5a8:	2300      	movs	r3, #0
   db5aa:	f100 0138 	add.w	r1, r0, #56	; 0x38
   db5ae:	4a03      	ldr	r2, [pc, #12]	; (db5bc <_ZN5SDLib7SDClass5rmdirEPKc+0x18>)
   db5b0:	4620      	mov	r0, r4
  }
   db5b2:	f85d 4b04 	ldr.w	r4, [sp], #4
      Remove a single directory or a hierarchy of directories.

      A rough equivalent to `rm -rf`.

    */
    return walkPath(filepath, root, callback_rmdir);
   db5b6:	f7ff bea5 	b.w	db304 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_>
   db5ba:	bf00      	nop
   db5bc:	000db269 	.word	0x000db269

000db5c0 <_ZN5SDLib7SDClass6removeEPKc>:
  }

  bool SDClass::remove(const char *filepath) {
   db5c0:	b410      	push	{r4}
   db5c2:	460c      	mov	r4, r1
    return walkPath(filepath, root, callback_remove);
   db5c4:	2300      	movs	r3, #0
   db5c6:	f100 0138 	add.w	r1, r0, #56	; 0x38
   db5ca:	4a03      	ldr	r2, [pc, #12]	; (db5d8 <_ZN5SDLib7SDClass6removeEPKc+0x18>)
   db5cc:	4620      	mov	r0, r4
  }
   db5ce:	f85d 4b04 	ldr.w	r4, [sp], #4
    */
    return walkPath(filepath, root, callback_rmdir);
  }

  bool SDClass::remove(const char *filepath) {
    return walkPath(filepath, root, callback_remove);
   db5d2:	f7ff be97 	b.w	db304 <_ZN5SDLib8walkPathEPKcR6SdFilePFbS3_S1_bPvES4_>
   db5d6:	bf00      	nop
   db5d8:	000db255 	.word	0x000db255

000db5dc <_ZN5SDLib4File12openNextFileEh>:
  }


  // allows you to recurse into a directory
  File File::openNextFile(uint8_t mode) {
   db5dc:	b570      	push	{r4, r5, r6, lr}
   db5de:	4604      	mov	r4, r0
   db5e0:	b0a0      	sub	sp, #128	; 0x80
   db5e2:	460d      	mov	r5, r1
   db5e4:	4616      	mov	r6, r2
    dir_t p;

    //Serial.print("\t\treading dir...");
    while (_file->readDir(&p) > 0) {
   db5e6:	a904      	add	r1, sp, #16
   db5e8:	6a28      	ldr	r0, [r5, #32]
   db5ea:	f7fe f997 	bl	d991c <_ZN6SdFile7readDirEP14directoryEntry>
   db5ee:	2800      	cmp	r0, #0
   db5f0:	dd28      	ble.n	db644 <_ZN5SDLib4File12openNextFileEh+0x68>

      // done if past last used entry
      if (p.name[0] == DIR_NAME_FREE) {
   db5f2:	f89d 3010 	ldrb.w	r3, [sp, #16]
   db5f6:	b32b      	cbz	r3, db644 <_ZN5SDLib4File12openNextFileEh+0x68>
        //Serial.println("end");
        return File();
      }

      // skip deleted entry and entries for . and  ..
      if (p.name[0] == DIR_NAME_DELETED || p.name[0] == '.') {
   db5f8:	2be5      	cmp	r3, #229	; 0xe5
   db5fa:	d0f4      	beq.n	db5e6 <_ZN5SDLib4File12openNextFileEh+0xa>
   db5fc:	2b2e      	cmp	r3, #46	; 0x2e
   db5fe:	d0f2      	beq.n	db5e6 <_ZN5SDLib4File12openNextFileEh+0xa>
        //Serial.println("dots");
        continue;
      }

      // only list subdirectories and files
      if (!DIR_IS_FILE_OR_SUBDIR(&p)) {
   db600:	f89d 301b 	ldrb.w	r3, [sp, #27]
   db604:	f003 0308 	and.w	r3, r3, #8
   db608:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   db60c:	2b00      	cmp	r3, #0
   db60e:	d1ea      	bne.n	db5e6 <_ZN5SDLib4File12openNextFileEh+0xa>
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db610:	4b0f      	ldr	r3, [pc, #60]	; (db650 <_ZN5SDLib4File12openNextFileEh+0x74>)
   db612:	920d      	str	r2, [sp, #52]	; 0x34
      }

      // print file name with possible blank fill
      SdFile f;
      char name[13];
      _file->dirName(p, name);
   db614:	4669      	mov	r1, sp
   db616:	a804      	add	r0, sp, #16
   db618:	930c      	str	r3, [sp, #48]	; 0x30
   db61a:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
   db61e:	f7fe f86d 	bl	d96fc <_ZN6SdFile7dirNameERK14directoryEntryPc>
      //Serial.print("try to open file ");
      //Serial.println(name);

      if (f.open(_file, name, mode)) {
   db622:	4633      	mov	r3, r6
   db624:	466a      	mov	r2, sp
   db626:	6a29      	ldr	r1, [r5, #32]
   db628:	a80c      	add	r0, sp, #48	; 0x30
   db62a:	f7fe fab5 	bl	d9b98 <_ZN6SdFile4openEPS_PKch>
   db62e:	b148      	cbz	r0, db644 <_ZN5SDLib4File12openNextFileEh+0x68>
        //Serial.println("OK!");
        return File(f, name);
   db630:	a90c      	add	r1, sp, #48	; 0x30
   db632:	a816      	add	r0, sp, #88	; 0x58
   db634:	f7ff fedc 	bl	db3f0 <_ZN6SdFileC1ERKS_>
   db638:	466a      	mov	r2, sp
   db63a:	a916      	add	r1, sp, #88	; 0x58
   db63c:	4620      	mov	r0, r4
   db63e:	f7ff f803 	bl	da648 <_ZN5SDLib4FileC1E6SdFilePKc>
   db642:	e002      	b.n	db64a <_ZN5SDLib4File12openNextFileEh+0x6e>
        return File();
      }
    }

    //Serial.println("nothing");
    return File();
   db644:	4620      	mov	r0, r4
   db646:	f7ff f825 	bl	da694 <_ZN5SDLib4FileC1Ev>
  }
   db64a:	4620      	mov	r0, r4
   db64c:	b020      	add	sp, #128	; 0x80
   db64e:	bd70      	pop	{r4, r5, r6, pc}
   db650:	000e2358 	.word	0x000e2358

000db654 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc>:
    }
  }

  SDClass SD;

};
   db654:	b508      	push	{r3, lr}
   db656:	f000 f82d 	bl	db6b4 <HAL_Pin_Map>
   \brief Raw access to SD and SDHC flash memory cards.
*/
class Sd2Card {
  public:
    /** Construct an instance of Sd2Card. */
    Sd2Card(void) : errorCode_(0), inBlock_(0), partialBlockRead_(0), type_(0) {}
   db65a:	480a      	ldr	r0, [pc, #40]	; (db684 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc+0x30>)
    if (isDirectory()) {
      _file->rewind();
    }
  }

  SDClass SD;
   db65c:	490a      	ldr	r1, [pc, #40]	; (db688 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc+0x34>)
   \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
*/
class SdVolume {
  public:
    /** Create an instance of SdVolume */
    SdVolume(void) : allocSearchStart_(2), fatType_(0) {}
   db65e:	2202      	movs	r2, #2
   db660:	2300      	movs	r3, #0
   db662:	6102      	str	r2, [r0, #16]
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db664:	4a09      	ldr	r2, [pc, #36]	; (db68c <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc+0x38>)
   db666:	6382      	str	r2, [r0, #56]	; 0x38
   db668:	7143      	strb	r3, [r0, #5]
   db66a:	7183      	strb	r3, [r0, #6]
   db66c:	7283      	strb	r3, [r0, #10]
   db66e:	7303      	strb	r3, [r0, #12]
   \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
*/
class SdVolume {
  public:
    /** Create an instance of SdVolume */
    SdVolume(void) : allocSearchStart_(2), fatType_(0) {}
   db670:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
   db674:	63c3      	str	r3, [r0, #60]	; 0x3c
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   db676:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
   db67a:	4a05      	ldr	r2, [pc, #20]	; (db690 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc+0x3c>)

};
   db67c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (isDirectory()) {
      _file->rewind();
    }
  }

  SDClass SD;
   db680:	f003 bb58 	b.w	ded34 <__aeabi_atexit>
   db684:	2003e3d4 	.word	0x2003e3d4
   db688:	000db1e7 	.word	0x000db1e7
   db68c:	000e2358 	.word	0x000e2358
   db690:	2003daf8 	.word	0x2003daf8

000db694 <netdb_freeaddrinfo>:

DYNALIB_BEGIN(hal_netdb)

DYNALIB_FN(0, hal_netdb, netdb_gethostbyname, struct hostent*(const char*))
DYNALIB_FN(1, hal_netdb, netdb_gethostbyname_r, int(const char*, struct hostent*, char*, size_t, struct hostent**, int*))
DYNALIB_FN(2, hal_netdb, netdb_freeaddrinfo, void(struct addrinfo*))
   db694:	b508      	push	{r3, lr}
   db696:	4b02      	ldr	r3, [pc, #8]	; (db6a0 <netdb_freeaddrinfo+0xc>)
   db698:	681b      	ldr	r3, [r3, #0]
   db69a:	689b      	ldr	r3, [r3, #8]
   db69c:	9301      	str	r3, [sp, #4]
   db69e:	bd08      	pop	{r3, pc}
   db6a0:	00030268 	.word	0x00030268

000db6a4 <netdb_getaddrinfo>:
DYNALIB_FN(3, hal_netdb, netdb_getaddrinfo, int(const char*, const char*, const struct addrinfo*, struct addrinfo**))
   db6a4:	b508      	push	{r3, lr}
   db6a6:	4b02      	ldr	r3, [pc, #8]	; (db6b0 <netdb_getaddrinfo+0xc>)
   db6a8:	681b      	ldr	r3, [r3, #0]
   db6aa:	68db      	ldr	r3, [r3, #12]
   db6ac:	9301      	str	r3, [sp, #4]
   db6ae:	bd08      	pop	{r3, pc}
   db6b0:	00030268 	.word	0x00030268

000db6b4 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
   db6b4:	b508      	push	{r3, lr}
   db6b6:	4b02      	ldr	r3, [pc, #8]	; (db6c0 <HAL_Pin_Map+0xc>)
   db6b8:	681b      	ldr	r3, [r3, #0]
   db6ba:	681b      	ldr	r3, [r3, #0]
   db6bc:	9301      	str	r3, [sp, #4]
   db6be:	bd08      	pop	{r3, pc}
   db6c0:	0003022c 	.word	0x0003022c

000db6c4 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
   db6c4:	b508      	push	{r3, lr}
   db6c6:	4b02      	ldr	r3, [pc, #8]	; (db6d0 <HAL_Pin_Mode+0xc>)
   db6c8:	681b      	ldr	r3, [r3, #0]
   db6ca:	689b      	ldr	r3, [r3, #8]
   db6cc:	9301      	str	r3, [sp, #4]
   db6ce:	bd08      	pop	{r3, pc}
   db6d0:	0003022c 	.word	0x0003022c

000db6d4 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
   db6d4:	b508      	push	{r3, lr}
   db6d6:	4b02      	ldr	r3, [pc, #8]	; (db6e0 <HAL_Get_Pin_Mode+0xc>)
   db6d8:	681b      	ldr	r3, [r3, #0]
   db6da:	68db      	ldr	r3, [r3, #12]
   db6dc:	9301      	str	r3, [sp, #4]
   db6de:	bd08      	pop	{r3, pc}
   db6e0:	0003022c 	.word	0x0003022c

000db6e4 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
   db6e4:	b508      	push	{r3, lr}
   db6e6:	4b02      	ldr	r3, [pc, #8]	; (db6f0 <HAL_GPIO_Write+0xc>)
   db6e8:	681b      	ldr	r3, [r3, #0]
   db6ea:	691b      	ldr	r3, [r3, #16]
   db6ec:	9301      	str	r3, [sp, #4]
   db6ee:	bd08      	pop	{r3, pc}
   db6f0:	0003022c 	.word	0x0003022c

000db6f4 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
   db6f4:	b508      	push	{r3, lr}
   db6f6:	4b02      	ldr	r3, [pc, #8]	; (db700 <HAL_GPIO_Read+0xc>)
   db6f8:	681b      	ldr	r3, [r3, #0]
   db6fa:	695b      	ldr	r3, [r3, #20]
   db6fc:	9301      	str	r3, [sp, #4]
   db6fe:	bd08      	pop	{r3, pc}
   db700:	0003022c 	.word	0x0003022c

000db704 <HAL_SPI_Begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, HAL_SPI_Begin, void(HAL_SPI_Interface, uint16_t))
   db704:	b508      	push	{r3, lr}
   db706:	4b02      	ldr	r3, [pc, #8]	; (db710 <HAL_SPI_Begin+0xc>)
   db708:	681b      	ldr	r3, [r3, #0]
   db70a:	681b      	ldr	r3, [r3, #0]
   db70c:	9301      	str	r3, [sp, #4]
   db70e:	bd08      	pop	{r3, pc}
   db710:	00030230 	.word	0x00030230

000db714 <HAL_SPI_Send_Receive_Data>:
DYNALIB_FN(1, hal_spi, HAL_SPI_End, void(HAL_SPI_Interface))
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
   db714:	b508      	push	{r3, lr}
   db716:	4b02      	ldr	r3, [pc, #8]	; (db720 <HAL_SPI_Send_Receive_Data+0xc>)
   db718:	681b      	ldr	r3, [r3, #0]
   db71a:	695b      	ldr	r3, [r3, #20]
   db71c:	9301      	str	r3, [sp, #4]
   db71e:	bd08      	pop	{r3, pc}
   db720:	00030230 	.word	0x00030230

000db724 <HAL_SPI_Init>:
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
   db724:	b508      	push	{r3, lr}
   db726:	4b02      	ldr	r3, [pc, #8]	; (db730 <HAL_SPI_Init+0xc>)
   db728:	681b      	ldr	r3, [r3, #0]
   db72a:	69db      	ldr	r3, [r3, #28]
   db72c:	9301      	str	r3, [sp, #4]
   db72e:	bd08      	pop	{r3, pc}
   db730:	00030230 	.word	0x00030230

000db734 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
   db734:	b508      	push	{r3, lr}
   db736:	4b02      	ldr	r3, [pc, #8]	; (db740 <HAL_SPI_Is_Enabled+0xc>)
   db738:	681b      	ldr	r3, [r3, #0]
   db73a:	6a1b      	ldr	r3, [r3, #32]
   db73c:	9301      	str	r3, [sp, #4]
   db73e:	bd08      	pop	{r3, pc}
   db740:	00030230 	.word	0x00030230

000db744 <HAL_SPI_Info>:
DYNALIB_FN(9, hal_spi, HAL_SPI_Info, void(HAL_SPI_Interface, hal_spi_info_t*, void*))
   db744:	b508      	push	{r3, lr}
   db746:	4b02      	ldr	r3, [pc, #8]	; (db750 <HAL_SPI_Info+0xc>)
   db748:	681b      	ldr	r3, [r3, #0]
   db74a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   db74c:	9301      	str	r3, [sp, #4]
   db74e:	bd08      	pop	{r3, pc}
   db750:	00030230 	.word	0x00030230

000db754 <HAL_SPI_Begin_Ext>:
DYNALIB_FN(10, hal_spi, HAL_SPI_DMA_Transfer, void(HAL_SPI_Interface, void*, void*, uint32_t, HAL_SPI_DMA_UserCallback))
DYNALIB_FN(11, hal_spi, HAL_SPI_Begin_Ext, void(HAL_SPI_Interface, SPI_Mode, uint16_t, void*))
   db754:	b508      	push	{r3, lr}
   db756:	4b02      	ldr	r3, [pc, #8]	; (db760 <HAL_SPI_Begin_Ext+0xc>)
   db758:	681b      	ldr	r3, [r3, #0]
   db75a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   db75c:	9301      	str	r3, [sp, #4]
   db75e:	bd08      	pop	{r3, pc}
   db760:	00030230 	.word	0x00030230

000db764 <HAL_SPI_Set_Settings>:
DYNALIB_FN(12, hal_spi, HAL_SPI_Set_Callback_On_Select, void(HAL_SPI_Interface, HAL_SPI_Select_UserCallback, void*))
DYNALIB_FN(13, hal_spi, HAL_SPI_DMA_Transfer_Cancel, void(HAL_SPI_Interface))
DYNALIB_FN(14, hal_spi, HAL_SPI_DMA_Transfer_Status, int32_t(HAL_SPI_Interface, HAL_SPI_TransferStatus*))
DYNALIB_FN(15, hal_spi, HAL_SPI_Set_Settings, int32_t(HAL_SPI_Interface, uint8_t, uint8_t, uint8_t, uint8_t, void*))
   db764:	b508      	push	{r3, lr}
   db766:	4b02      	ldr	r3, [pc, #8]	; (db770 <HAL_SPI_Set_Settings+0xc>)
   db768:	681b      	ldr	r3, [r3, #0]
   db76a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   db76c:	9301      	str	r3, [sp, #4]
   db76e:	bd08      	pop	{r3, pc}
   db770:	00030230 	.word	0x00030230

000db774 <HAL_SPI_Acquire>:
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
DYNALIB_FN(16, hal_spi, HAL_SPI_Acquire, int32_t(HAL_SPI_Interface, const HAL_SPI_AcquireConfig*))
   db774:	b508      	push	{r3, lr}
   db776:	4b02      	ldr	r3, [pc, #8]	; (db780 <HAL_SPI_Acquire+0xc>)
   db778:	681b      	ldr	r3, [r3, #0]
   db77a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   db77c:	9301      	str	r3, [sp, #4]
   db77e:	bd08      	pop	{r3, pc}
   db780:	00030230 	.word	0x00030230

000db784 <HAL_SPI_Release>:
DYNALIB_FN(17, hal_spi, HAL_SPI_Release, int32_t(HAL_SPI_Interface, void*))
   db784:	b508      	push	{r3, lr}
   db786:	4b02      	ldr	r3, [pc, #8]	; (db790 <HAL_SPI_Release+0xc>)
   db788:	681b      	ldr	r3, [r3, #0]
   db78a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   db78c:	9301      	str	r3, [sp, #4]
   db78e:	bd08      	pop	{r3, pc}
   db790:	00030230 	.word	0x00030230

000db794 <if_index_to_name>:
DYNALIB_FN(0, hal_ifapi, if_get_list, int(struct if_list**))
DYNALIB_FN(1, hal_ifapi, if_free_list, int(struct if_list*))
DYNALIB_FN(2, hal_ifapi, if_get_name_index, int(struct if_nameindex**))
DYNALIB_FN(3, hal_ifapi, if_free_name_index, int(struct if_nameindex*))
DYNALIB_FN(4, hal_ifapi, if_name_to_index, int(const char*, uint8_t*))
DYNALIB_FN(5, hal_ifapi, if_index_to_name, int(uint8_t, char*))
   db794:	b508      	push	{r3, lr}
   db796:	4b02      	ldr	r3, [pc, #8]	; (db7a0 <if_index_to_name+0xc>)
   db798:	681b      	ldr	r3, [r3, #0]
   db79a:	695b      	ldr	r3, [r3, #20]
   db79c:	9301      	str	r3, [sp, #4]
   db79e:	bd08      	pop	{r3, pc}
   db7a0:	0003026c 	.word	0x0003026c

000db7a4 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
   db7a4:	b508      	push	{r3, lr}
   db7a6:	4b02      	ldr	r3, [pc, #8]	; (db7b0 <HAL_RNG_GetRandomNumber+0xc>)
   db7a8:	681b      	ldr	r3, [r3, #0]
   db7aa:	685b      	ldr	r3, [r3, #4]
   db7ac:	9301      	str	r3, [sp, #4]
   db7ae:	bd08      	pop	{r3, pc}
   db7b0:	00030218 	.word	0x00030218

000db7b4 <HAL_Delay_Milliseconds>:
#define BASE_IDX 2 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
   db7b4:	b508      	push	{r3, lr}
   db7b6:	4b02      	ldr	r3, [pc, #8]	; (db7c0 <HAL_Delay_Milliseconds+0xc>)
   db7b8:	681b      	ldr	r3, [r3, #0]
   db7ba:	689b      	ldr	r3, [r3, #8]
   db7bc:	9301      	str	r3, [sp, #4]
   db7be:	bd08      	pop	{r3, pc}
   db7c0:	00030218 	.word	0x00030218

000db7c4 <HAL_Delay_Microseconds>:
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
   db7c4:	b508      	push	{r3, lr}
   db7c6:	4b02      	ldr	r3, [pc, #8]	; (db7d0 <HAL_Delay_Microseconds+0xc>)
   db7c8:	681b      	ldr	r3, [r3, #0]
   db7ca:	68db      	ldr	r3, [r3, #12]
   db7cc:	9301      	str	r3, [sp, #4]
   db7ce:	bd08      	pop	{r3, pc}
   db7d0:	00030218 	.word	0x00030218

000db7d4 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
   db7d4:	b508      	push	{r3, lr}
   db7d6:	4b02      	ldr	r3, [pc, #8]	; (db7e0 <HAL_Timer_Get_Milli_Seconds+0xc>)
   db7d8:	681b      	ldr	r3, [r3, #0]
   db7da:	695b      	ldr	r3, [r3, #20]
   db7dc:	9301      	str	r3, [sp, #4]
   db7de:	bd08      	pop	{r3, pc}
   db7e0:	00030218 	.word	0x00030218

000db7e4 <HAL_RTC_Get_UnixTime>:

DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
   db7e4:	b508      	push	{r3, lr}
   db7e6:	4b02      	ldr	r3, [pc, #8]	; (db7f0 <HAL_RTC_Get_UnixTime+0xc>)
   db7e8:	681b      	ldr	r3, [r3, #0]
   db7ea:	69db      	ldr	r3, [r3, #28]
   db7ec:	9301      	str	r3, [sp, #4]
   db7ee:	bd08      	pop	{r3, pc}
   db7f0:	00030218 	.word	0x00030218

000db7f4 <HAL_RTC_Time_Is_Valid>:
DYNALIB_FN(BASE_IDX + 15, hal,HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal,HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal,HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal,HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal,HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, HAL_RTC_Time_Is_Valid, uint8_t(void*))
   db7f4:	b508      	push	{r3, lr}
   db7f6:	4b02      	ldr	r3, [pc, #8]	; (db800 <HAL_RTC_Time_Is_Valid+0xc>)
   db7f8:	681b      	ldr	r3, [r3, #0]
   db7fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   db7fc:	9301      	str	r3, [sp, #4]
   db7fe:	bd08      	pop	{r3, pc}
   db800:	00030218 	.word	0x00030218

000db804 <HAL_Feature_Set>:
DYNALIB_FN(20, hal_core, HAL_Core_System_Reset_FlagSet, bool(RESET_TypeDef))
DYNALIB_FN(21, hal_core, HAL_Core_Runtime_Info, uint32_t(runtime_info_t*, void*))
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
   db804:	b508      	push	{r3, lr}
   db806:	4b02      	ldr	r3, [pc, #8]	; (db810 <HAL_Feature_Set+0xc>)
   db808:	681b      	ldr	r3, [r3, #0]
   db80a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   db80c:	9301      	str	r3, [sp, #4]
   db80e:	bd08      	pop	{r3, pc}
   db810:	00030234 	.word	0x00030234

000db814 <HAL_Core_System_Reset_Ex>:
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
   db814:	b508      	push	{r3, lr}
   db816:	4b02      	ldr	r3, [pc, #8]	; (db820 <HAL_Core_System_Reset_Ex+0xc>)
   db818:	681b      	ldr	r3, [r3, #0]
   db81a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   db81c:	9301      	str	r3, [sp, #4]
   db81e:	bd08      	pop	{r3, pc}
   db820:	00030234 	.word	0x00030234

000db824 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
   db824:	b508      	push	{r3, lr}
   db826:	4b02      	ldr	r3, [pc, #8]	; (db830 <HAL_Core_Get_Last_Reset_Info+0xc>)
   db828:	681b      	ldr	r3, [r3, #0]
   db82a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   db82c:	9301      	str	r3, [sp, #4]
   db82e:	bd08      	pop	{r3, pc}
   db830:	00030234 	.word	0x00030234

000db834 <HAL_Core_Led_Mirror_Pin>:
DYNALIB_FN(28, hal_core, HAL_Core_Button_Mirror_Pin, void(uint16_t, InterruptMode, uint8_t, uint8_t, void*))
DYNALIB_FN(29, hal_core, HAL_Core_Button_Mirror_Pin_Disable, void(uint8_t, uint8_t, void*))
DYNALIB_FN(30, hal_core, HAL_Core_Led_Mirror_Pin, void(uint8_t, pin_t, uint32_t, uint8_t, void*))
   db834:	b508      	push	{r3, lr}
   db836:	4b02      	ldr	r3, [pc, #8]	; (db840 <HAL_Core_Led_Mirror_Pin+0xc>)
   db838:	681b      	ldr	r3, [r3, #0]
   db83a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   db83c:	9301      	str	r3, [sp, #4]
   db83e:	bd08      	pop	{r3, pc}
   db840:	00030234 	.word	0x00030234

000db844 <HAL_Core_Led_Mirror_Pin_Disable>:
DYNALIB_FN(31, hal_core, HAL_Core_Led_Mirror_Pin_Disable, void(uint8_t, uint8_t, void*))
   db844:	b508      	push	{r3, lr}
   db846:	4b02      	ldr	r3, [pc, #8]	; (db850 <HAL_Core_Led_Mirror_Pin_Disable+0xc>)
   db848:	681b      	ldr	r3, [r3, #0]
   db84a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   db84c:	9301      	str	r3, [sp, #4]
   db84e:	bd08      	pop	{r3, pc}
   db850:	00030234 	.word	0x00030234

000db854 <hal_ble_stack_init>:

DYNALIB_BEGIN(hal_ble)

DYNALIB_FN(0, hal_ble, hal_ble_lock, int(void*))
DYNALIB_FN(1, hal_ble, hal_ble_unlock, int(void*))
DYNALIB_FN(2, hal_ble, hal_ble_stack_init, int(void*))
   db854:	b508      	push	{r3, lr}
   db856:	4b02      	ldr	r3, [pc, #8]	; (db860 <hal_ble_stack_init+0xc>)
   db858:	681b      	ldr	r3, [r3, #0]
   db85a:	689b      	ldr	r3, [r3, #8]
   db85c:	9301      	str	r3, [sp, #4]
   db85e:	bd08      	pop	{r3, pc}
   db860:	00030278 	.word	0x00030278

000db864 <hal_ble_stack_deinit>:
DYNALIB_FN(3, hal_ble, hal_ble_stack_deinit, int(void*))
   db864:	b508      	push	{r3, lr}
   db866:	4b02      	ldr	r3, [pc, #8]	; (db870 <hal_ble_stack_deinit+0xc>)
   db868:	681b      	ldr	r3, [r3, #0]
   db86a:	68db      	ldr	r3, [r3, #12]
   db86c:	9301      	str	r3, [sp, #4]
   db86e:	bd08      	pop	{r3, pc}
   db870:	00030278 	.word	0x00030278

000db874 <hal_ble_gap_disconnect>:
DYNALIB_FN(33, hal_ble, hal_ble_gap_stop_scan, int(void*))
DYNALIB_FN(34, hal_ble, hal_ble_gap_connect_deprecated, int(const hal_ble_addr_t*, void*))
DYNALIB_FN(35, hal_ble, hal_ble_gap_is_connecting, bool(const hal_ble_addr_t*, void*))
DYNALIB_FN(36, hal_ble, hal_ble_gap_is_connected, bool(const hal_ble_addr_t*, void*))
DYNALIB_FN(37, hal_ble, hal_ble_gap_connect_cancel, int(const hal_ble_addr_t*, void*))
DYNALIB_FN(38, hal_ble, hal_ble_gap_disconnect, int(hal_ble_conn_handle_t, void*))
   db874:	b508      	push	{r3, lr}
   db876:	4b03      	ldr	r3, [pc, #12]	; (db884 <hal_ble_gap_disconnect+0x10>)
   db878:	681b      	ldr	r3, [r3, #0]
   db87a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   db87e:	9301      	str	r3, [sp, #4]
   db880:	bd08      	pop	{r3, pc}
   db882:	0000      	.short	0x0000
   db884:	00030278 	.word	0x00030278

000db888 <hal_ble_set_callback_on_periph_link_events>:
DYNALIB_FN(56, hal_ble, hal_ble_gatt_client_read, ssize_t(hal_ble_conn_handle_t, hal_ble_attr_handle_t, uint8_t*, size_t, void*))

DYNALIB_FN(57, hal_ble, hal_ble_gap_connect, int(const hal_ble_conn_cfg_t*, hal_ble_conn_handle_t*, void*))
DYNALIB_FN(58, hal_ble, hal_ble_gap_get_connection_info, int(hal_ble_conn_handle_t, hal_ble_conn_info_t*, void*))
DYNALIB_FN(59, hal_ble, hal_ble_gatt_server_add_characteristic, int(const hal_ble_char_init_t*, hal_ble_char_handles_t*, void*))
DYNALIB_FN(60, hal_ble, hal_ble_set_callback_on_periph_link_events, int(hal_ble_on_link_evt_cb_t, void*, void*))
   db888:	b508      	push	{r3, lr}
   db88a:	4b03      	ldr	r3, [pc, #12]	; (db898 <hal_ble_set_callback_on_periph_link_events+0x10>)
   db88c:	681b      	ldr	r3, [r3, #0]
   db88e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   db892:	9301      	str	r3, [sp, #4]
   db894:	bd08      	pop	{r3, pc}
   db896:	0000      	.short	0x0000
   db898:	00030278 	.word	0x00030278

000db89c <os_thread_create>:

DYNALIB_BEGIN(hal_concurrent)

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
   db89c:	b508      	push	{r3, lr}
   db89e:	4b02      	ldr	r3, [pc, #8]	; (db8a8 <os_thread_create+0xc>)
   db8a0:	681b      	ldr	r3, [r3, #0]
   db8a2:	685b      	ldr	r3, [r3, #4]
   db8a4:	9301      	str	r3, [sp, #4]
   db8a6:	bd08      	pop	{r3, pc}
   db8a8:	00030248 	.word	0x00030248

000db8ac <os_thread_is_current>:
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
   db8ac:	b508      	push	{r3, lr}
   db8ae:	4b02      	ldr	r3, [pc, #8]	; (db8b8 <os_thread_is_current+0xc>)
   db8b0:	681b      	ldr	r3, [r3, #0]
   db8b2:	689b      	ldr	r3, [r3, #8]
   db8b4:	9301      	str	r3, [sp, #4]
   db8b6:	bd08      	pop	{r3, pc}
   db8b8:	00030248 	.word	0x00030248

000db8bc <os_thread_join>:
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
   db8bc:	b508      	push	{r3, lr}
   db8be:	4b02      	ldr	r3, [pc, #8]	; (db8c8 <os_thread_join+0xc>)
   db8c0:	681b      	ldr	r3, [r3, #0]
   db8c2:	691b      	ldr	r3, [r3, #16]
   db8c4:	9301      	str	r3, [sp, #4]
   db8c6:	bd08      	pop	{r3, pc}
   db8c8:	00030248 	.word	0x00030248

000db8cc <os_thread_cleanup>:
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
   db8cc:	b508      	push	{r3, lr}
   db8ce:	4b02      	ldr	r3, [pc, #8]	; (db8d8 <os_thread_cleanup+0xc>)
   db8d0:	681b      	ldr	r3, [r3, #0]
   db8d2:	695b      	ldr	r3, [r3, #20]
   db8d4:	9301      	str	r3, [sp, #4]
   db8d6:	bd08      	pop	{r3, pc}
   db8d8:	00030248 	.word	0x00030248

000db8dc <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
   db8dc:	b508      	push	{r3, lr}
   db8de:	4b02      	ldr	r3, [pc, #8]	; (db8e8 <os_mutex_recursive_create+0xc>)
   db8e0:	681b      	ldr	r3, [r3, #0]
   db8e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   db8e4:	9301      	str	r3, [sp, #4]
   db8e6:	bd08      	pop	{r3, pc}
   db8e8:	00030248 	.word	0x00030248

000db8ec <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
   db8ec:	b508      	push	{r3, lr}
   db8ee:	4b02      	ldr	r3, [pc, #8]	; (db8f8 <os_mutex_recursive_destroy+0xc>)
   db8f0:	681b      	ldr	r3, [r3, #0]
   db8f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   db8f4:	9301      	str	r3, [sp, #4]
   db8f6:	bd08      	pop	{r3, pc}
   db8f8:	00030248 	.word	0x00030248

000db8fc <os_mutex_recursive_lock>:
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
   db8fc:	b508      	push	{r3, lr}
   db8fe:	4b02      	ldr	r3, [pc, #8]	; (db908 <os_mutex_recursive_lock+0xc>)
   db900:	681b      	ldr	r3, [r3, #0]
   db902:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   db904:	9301      	str	r3, [sp, #4]
   db906:	bd08      	pop	{r3, pc}
   db908:	00030248 	.word	0x00030248

000db90c <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
   db90c:	b508      	push	{r3, lr}
   db90e:	4b02      	ldr	r3, [pc, #8]	; (db918 <os_mutex_recursive_unlock+0xc>)
   db910:	681b      	ldr	r3, [r3, #0]
   db912:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   db914:	9301      	str	r3, [sp, #4]
   db916:	bd08      	pop	{r3, pc}
   db918:	00030248 	.word	0x00030248

000db91c <os_thread_exit>:

DYNALIB_FN(23, hal_concurrent, os_queue_create, int(os_queue_t*, size_t, size_t, void*))
DYNALIB_FN(24, hal_concurrent, os_queue_destroy, int(os_queue_t, void*))
DYNALIB_FN(25, hal_concurrent, os_queue_put, int(os_queue_t, const void* item, system_tick_t, void*))
DYNALIB_FN(26, hal_concurrent, os_queue_take, int(os_queue_t, void* item, system_tick_t, void*))
DYNALIB_FN(27, hal_concurrent, os_thread_exit, os_result_t(os_thread_t))
   db91c:	b508      	push	{r3, lr}
   db91e:	4b02      	ldr	r3, [pc, #8]	; (db928 <os_thread_exit+0xc>)
   db920:	681b      	ldr	r3, [r3, #0]
   db922:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   db924:	9301      	str	r3, [sp, #4]
   db926:	bd08      	pop	{r3, pc}
   db928:	00030248 	.word	0x00030248

000db92c <inet_inet_ntop>:
DYNALIB_FN(0, hal_inet, inet_inet_addr, in_addr_t(const char*))
DYNALIB_FN(1, hal_inet, inet_inet_aton, int(const char*, struct in_addr*))
DYNALIB_FN(2, hal_inet, inet_inet_network, in_addr_t(const char*))
DYNALIB_FN(3, hal_inet, inet_inet_ntoa, char*(struct in_addr))
DYNALIB_FN(4, hal_inet, inet_inet_ntoa_r, char*(struct in_addr, char*, socklen_t))
DYNALIB_FN(5, hal_inet, inet_inet_ntop, const char*(int, const void*, char*, socklen_t))
   db92c:	b508      	push	{r3, lr}
   db92e:	4b02      	ldr	r3, [pc, #8]	; (db938 <inet_inet_ntop+0xc>)
   db930:	681b      	ldr	r3, [r3, #0]
   db932:	695b      	ldr	r3, [r3, #20]
   db934:	9301      	str	r3, [sp, #4]
   db936:	bd08      	pop	{r3, pc}
   db938:	00030264 	.word	0x00030264

000db93c <inet_htonl>:
DYNALIB_FN(6, hal_inet, inet_inet_pton, int(int, const char*, void*))
DYNALIB_FN(7, hal_inet, inet_ntohl, uint32_t(uint32_t))
DYNALIB_FN(8, hal_inet, inet_htonl, uint32_t(uint32_t))
   db93c:	b508      	push	{r3, lr}
   db93e:	4b02      	ldr	r3, [pc, #8]	; (db948 <inet_htonl+0xc>)
   db940:	681b      	ldr	r3, [r3, #0]
   db942:	6a1b      	ldr	r3, [r3, #32]
   db944:	9301      	str	r3, [sp, #4]
   db946:	bd08      	pop	{r3, pc}
   db948:	00030264 	.word	0x00030264

000db94c <inet_htons>:
DYNALIB_FN(9, hal_inet, inet_ntohs, uint16_t(uint16_t))
DYNALIB_FN(10, hal_inet, inet_htons, uint16_t(uint16_t))
   db94c:	b508      	push	{r3, lr}
   db94e:	4b02      	ldr	r3, [pc, #8]	; (db958 <inet_htons+0xc>)
   db950:	681b      	ldr	r3, [r3, #0]
   db952:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   db954:	9301      	str	r3, [sp, #4]
   db956:	bd08      	pop	{r3, pc}
   db958:	00030264 	.word	0x00030264

000db95c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
   db95c:	b508      	push	{r3, lr}
   db95e:	4b02      	ldr	r3, [pc, #8]	; (db968 <HAL_USART_Init+0xc>)
   db960:	681b      	ldr	r3, [r3, #0]
   db962:	681b      	ldr	r3, [r3, #0]
   db964:	9301      	str	r3, [sp, #4]
   db966:	bd08      	pop	{r3, pc}
   db968:	0003023c 	.word	0x0003023c

000db96c <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
   db96c:	b508      	push	{r3, lr}
   db96e:	4b02      	ldr	r3, [pc, #8]	; (db978 <HAL_USART_Write_Data+0xc>)
   db970:	681b      	ldr	r3, [r3, #0]
   db972:	68db      	ldr	r3, [r3, #12]
   db974:	9301      	str	r3, [sp, #4]
   db976:	bd08      	pop	{r3, pc}
   db978:	0003023c 	.word	0x0003023c

000db97c <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
   db97c:	b508      	push	{r3, lr}
   db97e:	4b02      	ldr	r3, [pc, #8]	; (db988 <HAL_USART_Available_Data+0xc>)
   db980:	681b      	ldr	r3, [r3, #0]
   db982:	691b      	ldr	r3, [r3, #16]
   db984:	9301      	str	r3, [sp, #4]
   db986:	bd08      	pop	{r3, pc}
   db988:	0003023c 	.word	0x0003023c

000db98c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
   db98c:	b508      	push	{r3, lr}
   db98e:	4b02      	ldr	r3, [pc, #8]	; (db998 <HAL_USART_Read_Data+0xc>)
   db990:	681b      	ldr	r3, [r3, #0]
   db992:	695b      	ldr	r3, [r3, #20]
   db994:	9301      	str	r3, [sp, #4]
   db996:	bd08      	pop	{r3, pc}
   db998:	0003023c 	.word	0x0003023c

000db99c <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
   db99c:	b508      	push	{r3, lr}
   db99e:	4b02      	ldr	r3, [pc, #8]	; (db9a8 <HAL_USART_Peek_Data+0xc>)
   db9a0:	681b      	ldr	r3, [r3, #0]
   db9a2:	699b      	ldr	r3, [r3, #24]
   db9a4:	9301      	str	r3, [sp, #4]
   db9a6:	bd08      	pop	{r3, pc}
   db9a8:	0003023c 	.word	0x0003023c

000db9ac <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
   db9ac:	b508      	push	{r3, lr}
   db9ae:	4b02      	ldr	r3, [pc, #8]	; (db9b8 <HAL_USART_Flush_Data+0xc>)
   db9b0:	681b      	ldr	r3, [r3, #0]
   db9b2:	69db      	ldr	r3, [r3, #28]
   db9b4:	9301      	str	r3, [sp, #4]
   db9b6:	bd08      	pop	{r3, pc}
   db9b8:	0003023c 	.word	0x0003023c

000db9bc <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
   db9bc:	b508      	push	{r3, lr}
   db9be:	4b02      	ldr	r3, [pc, #8]	; (db9c8 <HAL_USART_Is_Enabled+0xc>)
   db9c0:	681b      	ldr	r3, [r3, #0]
   db9c2:	6a1b      	ldr	r3, [r3, #32]
   db9c4:	9301      	str	r3, [sp, #4]
   db9c6:	bd08      	pop	{r3, pc}
   db9c8:	0003023c 	.word	0x0003023c

000db9cc <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
   db9cc:	b508      	push	{r3, lr}
   db9ce:	4b02      	ldr	r3, [pc, #8]	; (db9d8 <HAL_USART_Available_Data_For_Write+0xc>)
   db9d0:	681b      	ldr	r3, [r3, #0]
   db9d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   db9d4:	9301      	str	r3, [sp, #4]
   db9d6:	bd08      	pop	{r3, pc}
   db9d8:	0003023c 	.word	0x0003023c

000db9dc <HAL_I2C_Set_Speed>:
#define BASE_IDX 16 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
   db9dc:	b508      	push	{r3, lr}
   db9de:	4b02      	ldr	r3, [pc, #8]	; (db9e8 <HAL_I2C_Set_Speed+0xc>)
   db9e0:	681b      	ldr	r3, [r3, #0]
   db9e2:	681b      	ldr	r3, [r3, #0]
   db9e4:	9301      	str	r3, [sp, #4]
   db9e6:	bd08      	pop	{r3, pc}
   db9e8:	00030228 	.word	0x00030228

000db9ec <HAL_I2C_Begin>:
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
   db9ec:	b508      	push	{r3, lr}
   db9ee:	4b02      	ldr	r3, [pc, #8]	; (db9f8 <HAL_I2C_Begin+0xc>)
   db9f0:	681b      	ldr	r3, [r3, #0]
   db9f2:	68db      	ldr	r3, [r3, #12]
   db9f4:	9301      	str	r3, [sp, #4]
   db9f6:	bd08      	pop	{r3, pc}
   db9f8:	00030228 	.word	0x00030228

000db9fc <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, const HAL_I2C_Transmission_Config*))
   db9fc:	b508      	push	{r3, lr}
   db9fe:	4b02      	ldr	r3, [pc, #8]	; (dba08 <HAL_I2C_Begin_Transmission+0xc>)
   dba00:	681b      	ldr	r3, [r3, #0]
   dba02:	699b      	ldr	r3, [r3, #24]
   dba04:	9301      	str	r3, [sp, #4]
   dba06:	bd08      	pop	{r3, pc}
   dba08:	00030228 	.word	0x00030228

000dba0c <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
   dba0c:	b508      	push	{r3, lr}
   dba0e:	4b02      	ldr	r3, [pc, #8]	; (dba18 <HAL_I2C_End_Transmission+0xc>)
   dba10:	681b      	ldr	r3, [r3, #0]
   dba12:	69db      	ldr	r3, [r3, #28]
   dba14:	9301      	str	r3, [sp, #4]
   dba16:	bd08      	pop	{r3, pc}
   dba18:	00030228 	.word	0x00030228

000dba1c <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
   dba1c:	b508      	push	{r3, lr}
   dba1e:	4b02      	ldr	r3, [pc, #8]	; (dba28 <HAL_I2C_Write_Data+0xc>)
   dba20:	681b      	ldr	r3, [r3, #0]
   dba22:	6a1b      	ldr	r3, [r3, #32]
   dba24:	9301      	str	r3, [sp, #4]
   dba26:	bd08      	pop	{r3, pc}
   dba28:	00030228 	.word	0x00030228

000dba2c <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
   dba2c:	b508      	push	{r3, lr}
   dba2e:	4b02      	ldr	r3, [pc, #8]	; (dba38 <HAL_I2C_Available_Data+0xc>)
   dba30:	681b      	ldr	r3, [r3, #0]
   dba32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   dba34:	9301      	str	r3, [sp, #4]
   dba36:	bd08      	pop	{r3, pc}
   dba38:	00030228 	.word	0x00030228

000dba3c <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
   dba3c:	b508      	push	{r3, lr}
   dba3e:	4b02      	ldr	r3, [pc, #8]	; (dba48 <HAL_I2C_Read_Data+0xc>)
   dba40:	681b      	ldr	r3, [r3, #0]
   dba42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   dba44:	9301      	str	r3, [sp, #4]
   dba46:	bd08      	pop	{r3, pc}
   dba48:	00030228 	.word	0x00030228

000dba4c <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
   dba4c:	b508      	push	{r3, lr}
   dba4e:	4b02      	ldr	r3, [pc, #8]	; (dba58 <HAL_I2C_Peek_Data+0xc>)
   dba50:	681b      	ldr	r3, [r3, #0]
   dba52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   dba54:	9301      	str	r3, [sp, #4]
   dba56:	bd08      	pop	{r3, pc}
   dba58:	00030228 	.word	0x00030228

000dba5c <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
   dba5c:	b508      	push	{r3, lr}
   dba5e:	4b02      	ldr	r3, [pc, #8]	; (dba68 <HAL_I2C_Flush_Data+0xc>)
   dba60:	681b      	ldr	r3, [r3, #0]
   dba62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   dba64:	9301      	str	r3, [sp, #4]
   dba66:	bd08      	pop	{r3, pc}
   dba68:	00030228 	.word	0x00030228

000dba6c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
   dba6c:	b508      	push	{r3, lr}
   dba6e:	4b02      	ldr	r3, [pc, #8]	; (dba78 <HAL_I2C_Is_Enabled+0xc>)
   dba70:	681b      	ldr	r3, [r3, #0]
   dba72:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   dba74:	9301      	str	r3, [sp, #4]
   dba76:	bd08      	pop	{r3, pc}
   dba78:	00030228 	.word	0x00030228

000dba7c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, int(HAL_I2C_Interface, const HAL_I2C_Config*))
   dba7c:	b508      	push	{r3, lr}
   dba7e:	4b02      	ldr	r3, [pc, #8]	; (dba88 <HAL_I2C_Init+0xc>)
   dba80:	681b      	ldr	r3, [r3, #0]
   dba82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   dba84:	9301      	str	r3, [sp, #4]
   dba86:	bd08      	pop	{r3, pc}
   dba88:	00030228 	.word	0x00030228

000dba8c <HAL_I2C_Acquire>:
DYNALIB_FN(BASE_IDX + 17, hal_i2c, HAL_I2C_Reset, uint8_t(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 18, hal_i2c, HAL_I2C_Acquire, int32_t(HAL_I2C_Interface, void*))
   dba8c:	b508      	push	{r3, lr}
   dba8e:	4b02      	ldr	r3, [pc, #8]	; (dba98 <HAL_I2C_Acquire+0xc>)
   dba90:	681b      	ldr	r3, [r3, #0]
   dba92:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   dba94:	9301      	str	r3, [sp, #4]
   dba96:	bd08      	pop	{r3, pc}
   dba98:	00030228 	.word	0x00030228

000dba9c <HAL_I2C_Release>:
DYNALIB_FN(BASE_IDX + 19, hal_i2c, HAL_I2C_Release, int32_t(HAL_I2C_Interface, void*))
   dba9c:	b508      	push	{r3, lr}
   dba9e:	4b02      	ldr	r3, [pc, #8]	; (dbaa8 <HAL_I2C_Release+0xc>)
   dbaa0:	681b      	ldr	r3, [r3, #0]
   dbaa2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   dbaa4:	9301      	str	r3, [sp, #4]
   dbaa6:	bd08      	pop	{r3, pc}
   dbaa8:	00030228 	.word	0x00030228

000dbaac <HAL_I2C_Request_Data_Ex>:
DYNALIB_FN(BASE_IDX + 20, hal_i2c, HAL_I2C_Request_Data_Ex, int32_t(HAL_I2C_Interface, const HAL_I2C_Transmission_Config*, void*))
   dbaac:	b508      	push	{r3, lr}
   dbaae:	4b02      	ldr	r3, [pc, #8]	; (dbab8 <HAL_I2C_Request_Data_Ex+0xc>)
   dbab0:	681b      	ldr	r3, [r3, #0]
   dbab2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   dbab4:	9301      	str	r3, [sp, #4]
   dbab6:	bd08      	pop	{r3, pc}
   dbab8:	00030228 	.word	0x00030228

000dbabc <sock_setsockopt>:
DYNALIB_FN(1, hal_socket, sock_bind, int(int, const struct sockaddr*, socklen_t))
DYNALIB_FN(2, hal_socket, sock_shutdown, int(int, int))
DYNALIB_FN(3, hal_socket, sock_getpeername, int(int, struct sockaddr*, socklen_t*))
DYNALIB_FN(4, hal_socket, sock_getsockname, int(int, struct sockaddr*, socklen_t*))
DYNALIB_FN(5, hal_socket, sock_getsockopt, int(int, int, int, void*, socklen_t*))
DYNALIB_FN(6, hal_socket, sock_setsockopt, int(int, int, int, const void*, socklen_t))
   dbabc:	b508      	push	{r3, lr}
   dbabe:	4b02      	ldr	r3, [pc, #8]	; (dbac8 <sock_setsockopt+0xc>)
   dbac0:	681b      	ldr	r3, [r3, #0]
   dbac2:	699b      	ldr	r3, [r3, #24]
   dbac4:	9301      	str	r3, [sp, #4]
   dbac6:	bd08      	pop	{r3, pc}
   dbac8:	00030238 	.word	0x00030238

000dbacc <sock_close>:
DYNALIB_FN(7, hal_socket, sock_close, int(int))
   dbacc:	b508      	push	{r3, lr}
   dbace:	4b02      	ldr	r3, [pc, #8]	; (dbad8 <sock_close+0xc>)
   dbad0:	681b      	ldr	r3, [r3, #0]
   dbad2:	69db      	ldr	r3, [r3, #28]
   dbad4:	9301      	str	r3, [sp, #4]
   dbad6:	bd08      	pop	{r3, pc}
   dbad8:	00030238 	.word	0x00030238

000dbadc <sock_connect>:
DYNALIB_FN(8, hal_socket, sock_connect, int(int, const struct sockaddr*, socklen_t))
   dbadc:	b508      	push	{r3, lr}
   dbade:	4b02      	ldr	r3, [pc, #8]	; (dbae8 <sock_connect+0xc>)
   dbae0:	681b      	ldr	r3, [r3, #0]
   dbae2:	6a1b      	ldr	r3, [r3, #32]
   dbae4:	9301      	str	r3, [sp, #4]
   dbae6:	bd08      	pop	{r3, pc}
   dbae8:	00030238 	.word	0x00030238

000dbaec <sock_recv>:
DYNALIB_FN(9, hal_socket, sock_listen, int(int, int))
DYNALIB_FN(10, hal_socket, sock_recv, int(int, void*, size_t, int))
   dbaec:	b508      	push	{r3, lr}
   dbaee:	4b02      	ldr	r3, [pc, #8]	; (dbaf8 <sock_recv+0xc>)
   dbaf0:	681b      	ldr	r3, [r3, #0]
   dbaf2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   dbaf4:	9301      	str	r3, [sp, #4]
   dbaf6:	bd08      	pop	{r3, pc}
   dbaf8:	00030238 	.word	0x00030238

000dbafc <sock_send>:
DYNALIB_FN(11, hal_socket, sock_recvfrom, int(int, void*, size_t, int, struct sockaddr*, socklen_t*))
DYNALIB_FN(12, hal_socket, sock_send, int(int, const void*, size_t, int))
   dbafc:	b508      	push	{r3, lr}
   dbafe:	4b02      	ldr	r3, [pc, #8]	; (dbb08 <sock_send+0xc>)
   dbb00:	681b      	ldr	r3, [r3, #0]
   dbb02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   dbb04:	9301      	str	r3, [sp, #4]
   dbb06:	bd08      	pop	{r3, pc}
   dbb08:	00030238 	.word	0x00030238

000dbb0c <sock_socket>:
DYNALIB_FN(13, hal_socket, sock_sendto, int(int, const void*, size_t, int, const struct sockaddr*, socklen_t))
DYNALIB_FN(14, hal_socket, sock_socket, int(int, int, int))
   dbb0c:	b508      	push	{r3, lr}
   dbb0e:	4b02      	ldr	r3, [pc, #8]	; (dbb18 <sock_socket+0xc>)
   dbb10:	681b      	ldr	r3, [r3, #0]
   dbb12:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   dbb14:	9301      	str	r3, [sp, #4]
   dbb16:	bd08      	pop	{r3, pc}
   dbb18:	00030238 	.word	0x00030238

000dbb1c <cellular_signal>:
DYNALIB_FN(12, hal_cellular, cellular_sim_ready, bool(void*))
DYNALIB_FN(13, hal_cellular, cellular_cancel, void(bool, bool, void*))
DYNALIB_FN(14, hal_cellular, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(15, hal_cellular, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
DYNALIB_FN(16, hal_cellular, inet_ping, int(const HAL_IPAddress*, network_interface_t, uint8_t, void*))
DYNALIB_FN(17, hal_cellular, cellular_signal, cellular_result_t(CellularSignalHal*, cellular_signal_t*))
   dbb1c:	b508      	push	{r3, lr}
   dbb1e:	4b02      	ldr	r3, [pc, #8]	; (dbb28 <cellular_signal+0xc>)
   dbb20:	681b      	ldr	r3, [r3, #0]
   dbb22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   dbb24:	9301      	str	r3, [sp, #4]
   dbb26:	bd08      	pop	{r3, pc}
   dbb28:	00030274 	.word	0x00030274

000dbb2c <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
   dbb2c:	b508      	push	{r3, lr}
   dbb2e:	4b02      	ldr	r3, [pc, #8]	; (dbb38 <HAL_USB_USART_Init+0xc>)
   dbb30:	681b      	ldr	r3, [r3, #0]
   dbb32:	681b      	ldr	r3, [r3, #0]
   dbb34:	9301      	str	r3, [sp, #4]
   dbb36:	bd08      	pop	{r3, pc}
   dbb38:	0003024c 	.word	0x0003024c

000dbb3c <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
   dbb3c:	b508      	push	{r3, lr}
   dbb3e:	4b02      	ldr	r3, [pc, #8]	; (dbb48 <HAL_USB_USART_Begin+0xc>)
   dbb40:	681b      	ldr	r3, [r3, #0]
   dbb42:	685b      	ldr	r3, [r3, #4]
   dbb44:	9301      	str	r3, [sp, #4]
   dbb46:	bd08      	pop	{r3, pc}
   dbb48:	0003024c 	.word	0x0003024c

000dbb4c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
   dbb4c:	b508      	push	{r3, lr}
   dbb4e:	4b02      	ldr	r3, [pc, #8]	; (dbb58 <HAL_USB_USART_Available_Data+0xc>)
   dbb50:	681b      	ldr	r3, [r3, #0]
   dbb52:	691b      	ldr	r3, [r3, #16]
   dbb54:	9301      	str	r3, [sp, #4]
   dbb56:	bd08      	pop	{r3, pc}
   dbb58:	0003024c 	.word	0x0003024c

000dbb5c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
   dbb5c:	b508      	push	{r3, lr}
   dbb5e:	4b02      	ldr	r3, [pc, #8]	; (dbb68 <HAL_USB_USART_Available_Data_For_Write+0xc>)
   dbb60:	681b      	ldr	r3, [r3, #0]
   dbb62:	695b      	ldr	r3, [r3, #20]
   dbb64:	9301      	str	r3, [sp, #4]
   dbb66:	bd08      	pop	{r3, pc}
   dbb68:	0003024c 	.word	0x0003024c

000dbb6c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   dbb6c:	b508      	push	{r3, lr}
   dbb6e:	4b02      	ldr	r3, [pc, #8]	; (dbb78 <HAL_USB_USART_Receive_Data+0xc>)
   dbb70:	681b      	ldr	r3, [r3, #0]
   dbb72:	699b      	ldr	r3, [r3, #24]
   dbb74:	9301      	str	r3, [sp, #4]
   dbb76:	bd08      	pop	{r3, pc}
   dbb78:	0003024c 	.word	0x0003024c

000dbb7c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   dbb7c:	b508      	push	{r3, lr}
   dbb7e:	4b02      	ldr	r3, [pc, #8]	; (dbb88 <HAL_USB_USART_Send_Data+0xc>)
   dbb80:	681b      	ldr	r3, [r3, #0]
   dbb82:	69db      	ldr	r3, [r3, #28]
   dbb84:	9301      	str	r3, [sp, #4]
   dbb86:	bd08      	pop	{r3, pc}
   dbb88:	0003024c 	.word	0x0003024c

000dbb8c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
   dbb8c:	b508      	push	{r3, lr}
   dbb8e:	4b02      	ldr	r3, [pc, #8]	; (dbb98 <HAL_USB_USART_Flush_Data+0xc>)
   dbb90:	681b      	ldr	r3, [r3, #0]
   dbb92:	6a1b      	ldr	r3, [r3, #32]
   dbb94:	9301      	str	r3, [sp, #4]
   dbb96:	bd08      	pop	{r3, pc}
   dbb98:	0003024c 	.word	0x0003024c

000dbb9c <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
   dbb9c:	b508      	push	{r3, lr}
   dbb9e:	4b02      	ldr	r3, [pc, #8]	; (dbba8 <panic_+0xc>)
   dbba0:	681b      	ldr	r3, [r3, #0]
   dbba2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   dbba4:	9301      	str	r3, [sp, #4]
   dbba6:	bd08      	pop	{r3, pc}
   dbba8:	00030260 	.word	0x00030260

000dbbac <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
   dbbac:	b508      	push	{r3, lr}
   dbbae:	4b02      	ldr	r3, [pc, #8]	; (dbbb8 <log_message+0xc>)
   dbbb0:	681b      	ldr	r3, [r3, #0]
   dbbb2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   dbbb4:	9301      	str	r3, [sp, #4]
   dbbb6:	bd08      	pop	{r3, pc}
   dbbb8:	00030260 	.word	0x00030260

000dbbbc <system_mode>:
#include "system_power.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
   dbbbc:	b508      	push	{r3, lr}
   dbbbe:	4b02      	ldr	r3, [pc, #8]	; (dbbc8 <system_mode+0xc>)
   dbbc0:	681b      	ldr	r3, [r3, #0]
   dbbc2:	681b      	ldr	r3, [r3, #0]
   dbbc4:	9301      	str	r3, [sp, #4]
   dbbc6:	bd08      	pop	{r3, pc}
   dbbc8:	00030220 	.word	0x00030220

000dbbcc <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
   dbbcc:	b508      	push	{r3, lr}
   dbbce:	4b02      	ldr	r3, [pc, #8]	; (dbbd8 <set_system_mode+0xc>)
   dbbd0:	681b      	ldr	r3, [r3, #0]
   dbbd2:	685b      	ldr	r3, [r3, #4]
   dbbd4:	9301      	str	r3, [sp, #4]
   dbbd6:	bd08      	pop	{r3, pc}
   dbbd8:	00030220 	.word	0x00030220

000dbbdc <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
   dbbdc:	b508      	push	{r3, lr}
   dbbde:	4b02      	ldr	r3, [pc, #8]	; (dbbe8 <system_delay_ms+0xc>)
   dbbe0:	681b      	ldr	r3, [r3, #0]
   dbbe2:	695b      	ldr	r3, [r3, #20]
   dbbe4:	9301      	str	r3, [sp, #4]
   dbbe6:	bd08      	pop	{r3, pc}
   dbbe8:	00030220 	.word	0x00030220

000dbbec <system_thread_set_state>:
DYNALIB_FN(6, system, system_sleep, int(Spark_Sleep_TypeDef, long, uint32_t, void*))
DYNALIB_FN(7, system, system_sleep_pin, int(uint16_t, uint16_t, long, uint32_t, void*))
DYNALIB_FN(8, system, system_subscribe_event, int(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(9, system, system_unsubscribe_event, void(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(10, system, system_button_pushed_duration, uint16_t(uint8_t, void*))
DYNALIB_FN(11, system, system_thread_set_state, void(spark::feature::State, void*))
   dbbec:	b508      	push	{r3, lr}
   dbbee:	4b02      	ldr	r3, [pc, #8]	; (dbbf8 <system_thread_set_state+0xc>)
   dbbf0:	681b      	ldr	r3, [r3, #0]
   dbbf2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   dbbf4:	9301      	str	r3, [sp, #4]
   dbbf6:	bd08      	pop	{r3, pc}
   dbbf8:	00030220 	.word	0x00030220

000dbbfc <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
   dbbfc:	b508      	push	{r3, lr}
   dbbfe:	4b02      	ldr	r3, [pc, #8]	; (dbc08 <application_thread_current+0xc>)
   dbc00:	681b      	ldr	r3, [r3, #0]
   dbc02:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   dbc04:	9301      	str	r3, [sp, #4]
   dbc06:	bd08      	pop	{r3, pc}
   dbc08:	00030220 	.word	0x00030220

000dbc0c <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
   dbc0c:	b508      	push	{r3, lr}
   dbc0e:	4b02      	ldr	r3, [pc, #8]	; (dbc18 <application_thread_invoke+0xc>)
   dbc10:	681b      	ldr	r3, [r3, #0]
   dbc12:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   dbc14:	9301      	str	r3, [sp, #4]
   dbc16:	bd08      	pop	{r3, pc}
   dbc18:	00030220 	.word	0x00030220

000dbc1c <system_thread_get_state>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
   dbc1c:	b508      	push	{r3, lr}
   dbc1e:	4b02      	ldr	r3, [pc, #8]	; (dbc28 <system_thread_get_state+0xc>)
   dbc20:	681b      	ldr	r3, [r3, #0]
   dbc22:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   dbc24:	9301      	str	r3, [sp, #4]
   dbc26:	bd08      	pop	{r3, pc}
   dbc28:	00030220 	.word	0x00030220

000dbc2c <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
   dbc2c:	b508      	push	{r3, lr}
   dbc2e:	4b03      	ldr	r3, [pc, #12]	; (dbc3c <system_ctrl_set_app_request_handler+0x10>)
   dbc30:	681b      	ldr	r3, [r3, #0]
   dbc32:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   dbc36:	9301      	str	r3, [sp, #4]
   dbc38:	bd08      	pop	{r3, pc}
   dbc3a:	0000      	.short	0x0000
   dbc3c:	00030220 	.word	0x00030220

000dbc40 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
   dbc40:	b508      	push	{r3, lr}
   dbc42:	4b03      	ldr	r3, [pc, #12]	; (dbc50 <system_ctrl_set_result+0x10>)
   dbc44:	681b      	ldr	r3, [r3, #0]
   dbc46:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   dbc4a:	9301      	str	r3, [sp, #4]
   dbc4c:	bd08      	pop	{r3, pc}
   dbc4e:	0000      	.short	0x0000
   dbc50:	00030220 	.word	0x00030220

000dbc54 <system_sleep_pins>:

DYNALIB_FN(BASE_IDX + 13, system, system_pool_alloc, void*(size_t, void*))
DYNALIB_FN(BASE_IDX + 14, system, system_pool_free, void(void*, void*))
DYNALIB_FN(BASE_IDX + 15, system, system_sleep_pins, int(const uint16_t*, size_t, const InterruptMode*, size_t, long, uint32_t, void*))
   dbc54:	b508      	push	{r3, lr}
   dbc56:	4b03      	ldr	r3, [pc, #12]	; (dbc64 <system_sleep_pins+0x10>)
   dbc58:	681b      	ldr	r3, [r3, #0]
   dbc5a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
   dbc5e:	9301      	str	r3, [sp, #4]
   dbc60:	bd08      	pop	{r3, pc}
   dbc62:	0000      	.short	0x0000
   dbc64:	00030220 	.word	0x00030220

000dbc68 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
   dbc68:	b508      	push	{r3, lr}
   dbc6a:	4b02      	ldr	r3, [pc, #8]	; (dbc74 <network_connect+0xc>)
   dbc6c:	681b      	ldr	r3, [r3, #0]
   dbc6e:	685b      	ldr	r3, [r3, #4]
   dbc70:	9301      	str	r3, [sp, #4]
   dbc72:	bd08      	pop	{r3, pc}
   dbc74:	00030240 	.word	0x00030240

000dbc78 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
   dbc78:	b508      	push	{r3, lr}
   dbc7a:	4b02      	ldr	r3, [pc, #8]	; (dbc84 <network_connecting+0xc>)
   dbc7c:	681b      	ldr	r3, [r3, #0]
   dbc7e:	689b      	ldr	r3, [r3, #8]
   dbc80:	9301      	str	r3, [sp, #4]
   dbc82:	bd08      	pop	{r3, pc}
   dbc84:	00030240 	.word	0x00030240

000dbc88 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
   dbc88:	b508      	push	{r3, lr}
   dbc8a:	4b02      	ldr	r3, [pc, #8]	; (dbc94 <network_disconnect+0xc>)
   dbc8c:	681b      	ldr	r3, [r3, #0]
   dbc8e:	68db      	ldr	r3, [r3, #12]
   dbc90:	9301      	str	r3, [sp, #4]
   dbc92:	bd08      	pop	{r3, pc}
   dbc94:	00030240 	.word	0x00030240

000dbc98 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
   dbc98:	b508      	push	{r3, lr}
   dbc9a:	4b02      	ldr	r3, [pc, #8]	; (dbca4 <network_ready+0xc>)
   dbc9c:	681b      	ldr	r3, [r3, #0]
   dbc9e:	691b      	ldr	r3, [r3, #16]
   dbca0:	9301      	str	r3, [sp, #4]
   dbca2:	bd08      	pop	{r3, pc}
   dbca4:	00030240 	.word	0x00030240

000dbca8 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
   dbca8:	b508      	push	{r3, lr}
   dbcaa:	4b02      	ldr	r3, [pc, #8]	; (dbcb4 <network_on+0xc>)
   dbcac:	681b      	ldr	r3, [r3, #0]
   dbcae:	695b      	ldr	r3, [r3, #20]
   dbcb0:	9301      	str	r3, [sp, #4]
   dbcb2:	bd08      	pop	{r3, pc}
   dbcb4:	00030240 	.word	0x00030240

000dbcb8 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
   dbcb8:	b508      	push	{r3, lr}
   dbcba:	4b02      	ldr	r3, [pc, #8]	; (dbcc4 <network_off+0xc>)
   dbcbc:	681b      	ldr	r3, [r3, #0]
   dbcbe:	699b      	ldr	r3, [r3, #24]
   dbcc0:	9301      	str	r3, [sp, #4]
   dbcc2:	bd08      	pop	{r3, pc}
   dbcc4:	00030240 	.word	0x00030240

000dbcc8 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
   dbcc8:	b508      	push	{r3, lr}
   dbcca:	4b02      	ldr	r3, [pc, #8]	; (dbcd4 <network_listen+0xc>)
   dbccc:	681b      	ldr	r3, [r3, #0]
   dbcce:	69db      	ldr	r3, [r3, #28]
   dbcd0:	9301      	str	r3, [sp, #4]
   dbcd2:	bd08      	pop	{r3, pc}
   dbcd4:	00030240 	.word	0x00030240

000dbcd8 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
   dbcd8:	b508      	push	{r3, lr}
   dbcda:	4b02      	ldr	r3, [pc, #8]	; (dbce4 <network_listening+0xc>)
   dbcdc:	681b      	ldr	r3, [r3, #0]
   dbcde:	6a1b      	ldr	r3, [r3, #32]
   dbce0:	9301      	str	r3, [sp, #4]
   dbce2:	bd08      	pop	{r3, pc}
   dbce4:	00030240 	.word	0x00030240

000dbce8 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
   dbce8:	b508      	push	{r3, lr}
   dbcea:	4b02      	ldr	r3, [pc, #8]	; (dbcf4 <network_set_listen_timeout+0xc>)
   dbcec:	681b      	ldr	r3, [r3, #0]
   dbcee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   dbcf0:	9301      	str	r3, [sp, #4]
   dbcf2:	bd08      	pop	{r3, pc}
   dbcf4:	00030240 	.word	0x00030240

000dbcf8 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
   dbcf8:	b508      	push	{r3, lr}
   dbcfa:	4b02      	ldr	r3, [pc, #8]	; (dbd04 <network_get_listen_timeout+0xc>)
   dbcfc:	681b      	ldr	r3, [r3, #0]
   dbcfe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   dbd00:	9301      	str	r3, [sp, #4]
   dbd02:	bd08      	pop	{r3, pc}
   dbd04:	00030240 	.word	0x00030240

000dbd08 <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
   dbd08:	b508      	push	{r3, lr}
   dbd0a:	4b02      	ldr	r3, [pc, #8]	; (dbd14 <spark_function+0xc>)
   dbd0c:	681b      	ldr	r3, [r3, #0]
   dbd0e:	685b      	ldr	r3, [r3, #4]
   dbd10:	9301      	str	r3, [sp, #4]
   dbd12:	bd08      	pop	{r3, pc}
   dbd14:	00030244 	.word	0x00030244

000dbd18 <spark_process>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
   dbd18:	b508      	push	{r3, lr}
   dbd1a:	4b02      	ldr	r3, [pc, #8]	; (dbd24 <spark_process+0xc>)
   dbd1c:	681b      	ldr	r3, [r3, #0]
   dbd1e:	689b      	ldr	r3, [r3, #8]
   dbd20:	9301      	str	r3, [sp, #4]
   dbd22:	bd08      	pop	{r3, pc}
   dbd24:	00030244 	.word	0x00030244

000dbd28 <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
   dbd28:	b508      	push	{r3, lr}
   dbd2a:	4b02      	ldr	r3, [pc, #8]	; (dbd34 <spark_cloud_flag_connect+0xc>)
   dbd2c:	681b      	ldr	r3, [r3, #0]
   dbd2e:	68db      	ldr	r3, [r3, #12]
   dbd30:	9301      	str	r3, [sp, #4]
   dbd32:	bd08      	pop	{r3, pc}
   dbd34:	00030244 	.word	0x00030244

000dbd38 <spark_cloud_flag_disconnect>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
   dbd38:	b508      	push	{r3, lr}
   dbd3a:	4b02      	ldr	r3, [pc, #8]	; (dbd44 <spark_cloud_flag_disconnect+0xc>)
   dbd3c:	681b      	ldr	r3, [r3, #0]
   dbd3e:	691b      	ldr	r3, [r3, #16]
   dbd40:	9301      	str	r3, [sp, #4]
   dbd42:	bd08      	pop	{r3, pc}
   dbd44:	00030244 	.word	0x00030244

000dbd48 <spark_cloud_flag_connected>:
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
   dbd48:	b508      	push	{r3, lr}
   dbd4a:	4b02      	ldr	r3, [pc, #8]	; (dbd54 <spark_cloud_flag_connected+0xc>)
   dbd4c:	681b      	ldr	r3, [r3, #0]
   dbd4e:	695b      	ldr	r3, [r3, #20]
   dbd50:	9301      	str	r3, [sp, #4]
   dbd52:	bd08      	pop	{r3, pc}
   dbd54:	00030244 	.word	0x00030244

000dbd58 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
   dbd58:	b508      	push	{r3, lr}
   dbd5a:	4b02      	ldr	r3, [pc, #8]	; (dbd64 <spark_send_event+0xc>)
   dbd5c:	681b      	ldr	r3, [r3, #0]
   dbd5e:	6a1b      	ldr	r3, [r3, #32]
   dbd60:	9301      	str	r3, [sp, #4]
   dbd62:	bd08      	pop	{r3, pc}
   dbd64:	00030244 	.word	0x00030244

000dbd68 <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
   dbd68:	b508      	push	{r3, lr}
   dbd6a:	4b02      	ldr	r3, [pc, #8]	; (dbd74 <spark_subscribe+0xc>)
   dbd6c:	681b      	ldr	r3, [r3, #0]
   dbd6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   dbd70:	9301      	str	r3, [sp, #4]
   dbd72:	bd08      	pop	{r3, pc}
   dbd74:	00030244 	.word	0x00030244

000dbd78 <spark_sync_time>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
   dbd78:	b508      	push	{r3, lr}
   dbd7a:	4b02      	ldr	r3, [pc, #8]	; (dbd84 <spark_sync_time+0xc>)
   dbd7c:	681b      	ldr	r3, [r3, #0]
   dbd7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   dbd80:	9301      	str	r3, [sp, #4]
   dbd82:	bd08      	pop	{r3, pc}
   dbd84:	00030244 	.word	0x00030244

000dbd88 <spark_sync_time_pending>:
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
   dbd88:	b508      	push	{r3, lr}
   dbd8a:	4b02      	ldr	r3, [pc, #8]	; (dbd94 <spark_sync_time_pending+0xc>)
   dbd8c:	681b      	ldr	r3, [r3, #0]
   dbd8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   dbd90:	9301      	str	r3, [sp, #4]
   dbd92:	bd08      	pop	{r3, pc}
   dbd94:	00030244 	.word	0x00030244

000dbd98 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
   dbd98:	b508      	push	{r3, lr}
   dbd9a:	4b02      	ldr	r3, [pc, #8]	; (dbda4 <spark_set_random_seed_from_cloud_handler+0xc>)
   dbd9c:	681b      	ldr	r3, [r3, #0]
   dbd9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   dbda0:	9301      	str	r3, [sp, #4]
   dbda2:	bd08      	pop	{r3, pc}
   dbda4:	00030244 	.word	0x00030244

000dbda8 <spark_publish_vitals>:
DYNALIB_FN(16, system_cloud, spark_publish_vitals, int(system_tick_t, void*))
   dbda8:	b508      	push	{r3, lr}
   dbdaa:	4b02      	ldr	r3, [pc, #8]	; (dbdb4 <spark_publish_vitals+0xc>)
   dbdac:	681b      	ldr	r3, [r3, #0]
   dbdae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   dbdb0:	9301      	str	r3, [sp, #4]
   dbdb2:	bd08      	pop	{r3, pc}
   dbdb4:	00030244 	.word	0x00030244

000dbdb8 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
   dbdb8:	b508      	push	{r3, lr}
   dbdba:	4b02      	ldr	r3, [pc, #8]	; (dbdc4 <malloc+0xc>)
   dbdbc:	681b      	ldr	r3, [r3, #0]
   dbdbe:	681b      	ldr	r3, [r3, #0]
   dbdc0:	9301      	str	r3, [sp, #4]
   dbdc2:	bd08      	pop	{r3, pc}
   dbdc4:	0003021c 	.word	0x0003021c

000dbdc8 <free>:
DYNALIB_FN(1, rt, free, void(void*))
   dbdc8:	b508      	push	{r3, lr}
   dbdca:	4b02      	ldr	r3, [pc, #8]	; (dbdd4 <free+0xc>)
   dbdcc:	681b      	ldr	r3, [r3, #0]
   dbdce:	685b      	ldr	r3, [r3, #4]
   dbdd0:	9301      	str	r3, [sp, #4]
   dbdd2:	bd08      	pop	{r3, pc}
   dbdd4:	0003021c 	.word	0x0003021c

000dbdd8 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
   dbdd8:	b508      	push	{r3, lr}
   dbdda:	4b02      	ldr	r3, [pc, #8]	; (dbde4 <realloc+0xc>)
   dbddc:	681b      	ldr	r3, [r3, #0]
   dbdde:	689b      	ldr	r3, [r3, #8]
   dbde0:	9301      	str	r3, [sp, #4]
   dbde2:	bd08      	pop	{r3, pc}
   dbde4:	0003021c 	.word	0x0003021c

000dbde8 <sprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
   dbde8:	b508      	push	{r3, lr}
   dbdea:	4b02      	ldr	r3, [pc, #8]	; (dbdf4 <sprintf+0xc>)
   dbdec:	681b      	ldr	r3, [r3, #0]
   dbdee:	68db      	ldr	r3, [r3, #12]
   dbdf0:	9301      	str	r3, [sp, #4]
   dbdf2:	bd08      	pop	{r3, pc}
   dbdf4:	0003021c 	.word	0x0003021c

000dbdf8 <siscanf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
   dbdf8:	b508      	push	{r3, lr}
   dbdfa:	4b02      	ldr	r3, [pc, #8]	; (dbe04 <siscanf+0xc>)
   dbdfc:	681b      	ldr	r3, [r3, #0]
   dbdfe:	699b      	ldr	r3, [r3, #24]
   dbe00:	9301      	str	r3, [sp, #4]
   dbe02:	bd08      	pop	{r3, pc}
   dbe04:	0003021c 	.word	0x0003021c

000dbe08 <vsnprintf>:
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
   dbe08:	b508      	push	{r3, lr}
   dbe0a:	4b02      	ldr	r3, [pc, #8]	; (dbe14 <vsnprintf+0xc>)
   dbe0c:	681b      	ldr	r3, [r3, #0]
   dbe0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   dbe10:	9301      	str	r3, [sp, #4]
   dbe12:	bd08      	pop	{r3, pc}
   dbe14:	0003021c 	.word	0x0003021c

000dbe18 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
   dbe18:	b508      	push	{r3, lr}
   dbe1a:	4b02      	ldr	r3, [pc, #8]	; (dbe24 <abort+0xc>)
   dbe1c:	681b      	ldr	r3, [r3, #0]
   dbe1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   dbe20:	9301      	str	r3, [sp, #4]
   dbe22:	bd08      	pop	{r3, pc}
   dbe24:	0003021c 	.word	0x0003021c

000dbe28 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
   dbe28:	b508      	push	{r3, lr}
   dbe2a:	4b02      	ldr	r3, [pc, #8]	; (dbe34 <_malloc_r+0xc>)
   dbe2c:	681b      	ldr	r3, [r3, #0]
   dbe2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   dbe30:	9301      	str	r3, [sp, #4]
   dbe32:	bd08      	pop	{r3, pc}
   dbe34:	0003021c 	.word	0x0003021c

000dbe38 <__errno>:
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
   dbe38:	b508      	push	{r3, lr}
   dbe3a:	4b02      	ldr	r3, [pc, #8]	; (dbe44 <__errno+0xc>)
   dbe3c:	681b      	ldr	r3, [r3, #0]
   dbe3e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   dbe40:	9301      	str	r3, [sp, #4]
   dbe42:	bd08      	pop	{r3, pc}
   dbe44:	0003021c 	.word	0x0003021c

000dbe48 <_ZN4PMIC4lockEv>:
    pmicWireInstance()->write(address);
    pmicWireInstance()->write(DATA);
    pmicWireInstance()->endTransmission(true);
}

bool PMIC::lock() {
   dbe48:	b508      	push	{r3, lr}
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbe4a:	f002 ff4d 	bl	dece8 <_Z20__fetch_global_Wire1v>
    pmicWireInstance()->endTransmission(true);
}

bool PMIC::lock() {
    return pmicWireInstance()->lock();
}
   dbe4e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    pmicWireInstance()->write(DATA);
    pmicWireInstance()->endTransmission(true);
}

bool PMIC::lock() {
    return pmicWireInstance()->lock();
   dbe52:	f002 b9fc 	b.w	de24e <_ZN7TwoWire4lockEv>

000dbe56 <_ZN4PMICC1Eb>:

} // anonymous

#include <mutex>

PMIC::PMIC(bool _lock) :
   dbe56:	b510      	push	{r4, lr}
   dbe58:	4604      	mov	r4, r0
    lock_(_lock)
   dbe5a:	7001      	strb	r1, [r0, #0]
{
    if (lock_) {
   dbe5c:	b109      	cbz	r1, dbe62 <_ZN4PMICC1Eb+0xc>
        lock();
   dbe5e:	f7ff fff3 	bl	dbe48 <_ZN4PMIC4lockEv>
    }
}
   dbe62:	4620      	mov	r0, r4
   dbe64:	bd10      	pop	{r4, pc}

000dbe66 <_ZN4PMIC6unlockEv>:

bool PMIC::lock() {
    return pmicWireInstance()->lock();
}

bool PMIC::unlock() {
   dbe66:	b508      	push	{r3, lr}
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbe68:	f002 ff3e 	bl	dece8 <_Z20__fetch_global_Wire1v>
    return pmicWireInstance()->lock();
}

bool PMIC::unlock() {
    return pmicWireInstance()->unlock();
}
   dbe6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
bool PMIC::lock() {
    return pmicWireInstance()->lock();
}

bool PMIC::unlock() {
    return pmicWireInstance()->unlock();
   dbe70:	f002 b9f6 	b.w	de260 <_ZN7TwoWire6unlockEv>

000dbe74 <_ZN4PMICD1Ev>:
    if (lock_) {
        lock();
    }
}

PMIC::~PMIC()
   dbe74:	b510      	push	{r4, lr}
{
    if (lock_) {
   dbe76:	7803      	ldrb	r3, [r0, #0]
    if (lock_) {
        lock();
    }
}

PMIC::~PMIC()
   dbe78:	4604      	mov	r4, r0
{
    if (lock_) {
   dbe7a:	b10b      	cbz	r3, dbe80 <_ZN4PMICD1Ev+0xc>
        unlock();
   dbe7c:	f7ff fff3 	bl	dbe66 <_ZN4PMIC6unlockEv>
    }
}
   dbe80:	4620      	mov	r0, r4
   dbe82:	bd10      	pop	{r4, pc}

000dbe84 <_ZNSt10lock_guardI4PMICED1Ev>:
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
   dbe84:	b510      	push	{r4, lr}
   dbe86:	4604      	mov	r4, r0
      { _M_device.unlock(); }
   dbe88:	6800      	ldr	r0, [r0, #0]
   dbe8a:	f7ff ffec 	bl	dbe66 <_ZN4PMIC6unlockEv>
   dbe8e:	4620      	mov	r0, r4
   dbe90:	bd10      	pop	{r4, pc}

000dbe92 <_ZN4PMIC12readRegisterEh>:
 * Function Name  :
 * Description    :
 * Input          :
 * Return         :
 *******************************************************************************/
byte PMIC::readRegister(byte startAddress) {
   dbe92:	b537      	push	{r0, r1, r2, r4, r5, lr}
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
   dbe94:	ac02      	add	r4, sp, #8
   dbe96:	460d      	mov	r5, r1
   dbe98:	f844 0d04 	str.w	r0, [r4, #-4]!
      { _M_device.lock(); }
   dbe9c:	f7ff ffd4 	bl	dbe48 <_ZN4PMIC4lockEv>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbea0:	f002 ff22 	bl	dece8 <_Z20__fetch_global_Wire1v>
 * Return         :
 *******************************************************************************/
byte PMIC::readRegister(byte startAddress) {
    std::lock_guard<PMIC> l(*this);
    byte DATA = 0;
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
   dbea4:	216b      	movs	r1, #107	; 0x6b
   dbea6:	f002 f9c4 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbeaa:	f002 ff1d 	bl	dece8 <_Z20__fetch_global_Wire1v>
 *******************************************************************************/
byte PMIC::readRegister(byte startAddress) {
    std::lock_guard<PMIC> l(*this);
    byte DATA = 0;
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(startAddress);
   dbeae:	6803      	ldr	r3, [r0, #0]
   dbeb0:	4629      	mov	r1, r5
   dbeb2:	689b      	ldr	r3, [r3, #8]
   dbeb4:	4798      	blx	r3
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbeb6:	f002 ff17 	bl	dece8 <_Z20__fetch_global_Wire1v>
byte PMIC::readRegister(byte startAddress) {
    std::lock_guard<PMIC> l(*this);
    byte DATA = 0;
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(startAddress);
    pmicWireInstance()->endTransmission(true);
   dbeba:	2101      	movs	r1, #1
   dbebc:	f002 f9bc 	bl	de238 <_ZN7TwoWire15endTransmissionEh>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbec0:	f002 ff12 	bl	dece8 <_Z20__fetch_global_Wire1v>
    byte DATA = 0;
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(startAddress);
    pmicWireInstance()->endTransmission(true);

    pmicWireInstance()->requestFrom(PMIC_ADDRESS, 1, true);
   dbec4:	2301      	movs	r3, #1
   dbec6:	461a      	mov	r2, r3
   dbec8:	216b      	movs	r1, #107	; 0x6b
   dbeca:	f002 f999 	bl	de200 <_ZN7TwoWire11requestFromEhjh>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbece:	f002 ff0b 	bl	dece8 <_Z20__fetch_global_Wire1v>
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(startAddress);
    pmicWireInstance()->endTransmission(true);

    pmicWireInstance()->requestFrom(PMIC_ADDRESS, 1, true);
    DATA = pmicWireInstance()->read();
   dbed2:	6803      	ldr	r3, [r0, #0]
   dbed4:	695b      	ldr	r3, [r3, #20]
   dbed6:	4798      	blx	r3
   dbed8:	4605      	mov	r5, r0
 * Description    :
 * Input          :
 * Return         :
 *******************************************************************************/
byte PMIC::readRegister(byte startAddress) {
    std::lock_guard<PMIC> l(*this);
   dbeda:	4620      	mov	r0, r4
   dbedc:	f7ff ffd2 	bl	dbe84 <_ZNSt10lock_guardI4PMICED1Ev>
    pmicWireInstance()->endTransmission(true);

    pmicWireInstance()->requestFrom(PMIC_ADDRESS, 1, true);
    DATA = pmicWireInstance()->read();
    return DATA;
}
   dbee0:	b2e8      	uxtb	r0, r5
   dbee2:	b003      	add	sp, #12
   dbee4:	bd30      	pop	{r4, r5, pc}

000dbee6 <_ZN4PMIC13writeRegisterEhh>:
 * Function Name  :
 * Description    :
 * Input          :
 * Return         :
 *******************************************************************************/
void PMIC::writeRegister(byte address, byte DATA) {
   dbee6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
   dbee8:	ac02      	add	r4, sp, #8
   dbeea:	4615      	mov	r5, r2
   dbeec:	460e      	mov	r6, r1
   dbeee:	f844 0d04 	str.w	r0, [r4, #-4]!
      { _M_device.lock(); }
   dbef2:	f7ff ffa9 	bl	dbe48 <_ZN4PMIC4lockEv>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbef6:	f002 fef7 	bl	dece8 <_Z20__fetch_global_Wire1v>
 * Input          :
 * Return         :
 *******************************************************************************/
void PMIC::writeRegister(byte address, byte DATA) {
    std::lock_guard<PMIC> l(*this);
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
   dbefa:	216b      	movs	r1, #107	; 0x6b
   dbefc:	f002 f999 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbf00:	f002 fef2 	bl	dece8 <_Z20__fetch_global_Wire1v>
 * Return         :
 *******************************************************************************/
void PMIC::writeRegister(byte address, byte DATA) {
    std::lock_guard<PMIC> l(*this);
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(address);
   dbf04:	6803      	ldr	r3, [r0, #0]
   dbf06:	4631      	mov	r1, r6
   dbf08:	689b      	ldr	r3, [r3, #8]
   dbf0a:	4798      	blx	r3
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbf0c:	f002 feec 	bl	dece8 <_Z20__fetch_global_Wire1v>
 *******************************************************************************/
void PMIC::writeRegister(byte address, byte DATA) {
    std::lock_guard<PMIC> l(*this);
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(address);
    pmicWireInstance()->write(DATA);
   dbf10:	6803      	ldr	r3, [r0, #0]
   dbf12:	4629      	mov	r1, r5
   dbf14:	689b      	ldr	r3, [r3, #8]
   dbf16:	4798      	blx	r3
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dbf18:	f002 fee6 	bl	dece8 <_Z20__fetch_global_Wire1v>
void PMIC::writeRegister(byte address, byte DATA) {
    std::lock_guard<PMIC> l(*this);
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(address);
    pmicWireInstance()->write(DATA);
    pmicWireInstance()->endTransmission(true);
   dbf1c:	2101      	movs	r1, #1
   dbf1e:	f002 f98b 	bl	de238 <_ZN7TwoWire15endTransmissionEh>
 * Description    :
 * Input          :
 * Return         :
 *******************************************************************************/
void PMIC::writeRegister(byte address, byte DATA) {
    std::lock_guard<PMIC> l(*this);
   dbf22:	4620      	mov	r0, r4
   dbf24:	f7ff ffae 	bl	dbe84 <_ZNSt10lock_guardI4PMICED1Ev>
    pmicWireInstance()->beginTransmission(PMIC_ADDRESS);
    pmicWireInstance()->write(address);
    pmicWireInstance()->write(DATA);
    pmicWireInstance()->endTransmission(true);
}
   dbf28:	b002      	add	sp, #8
   dbf2a:	bd70      	pop	{r4, r5, r6, pc}

000dbf2c <_ZN4PMIC10enableBuckEv>:
 * Function Name  : enableBuck
 * Description    :
 * Input          : NONE
 * Return         :
 *******************************************************************************/
bool PMIC::enableBuck(void) {
   dbf2c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
   dbf2e:	ac02      	add	r4, sp, #8
   dbf30:	4605      	mov	r5, r0
   dbf32:	f844 0d04 	str.w	r0, [r4, #-4]!
      { _M_device.lock(); }
   dbf36:	f7ff ff87 	bl	dbe48 <_ZN4PMIC4lockEv>
    std::lock_guard<PMIC> l(*this);
    byte DATA = readRegister(INPUT_SOURCE_REGISTER);
   dbf3a:	2100      	movs	r1, #0
   dbf3c:	4628      	mov	r0, r5
   dbf3e:	f7ff ffa8 	bl	dbe92 <_ZN4PMIC12readRegisterEh>
    writeRegister(INPUT_SOURCE_REGISTER, (DATA & 0b01111111));
   dbf42:	2100      	movs	r1, #0
   dbf44:	f000 027f 	and.w	r2, r0, #127	; 0x7f
   dbf48:	4628      	mov	r0, r5
   dbf4a:	f7ff ffcc 	bl	dbee6 <_ZN4PMIC13writeRegisterEhh>
 * Description    :
 * Input          : NONE
 * Return         :
 *******************************************************************************/
bool PMIC::enableBuck(void) {
    std::lock_guard<PMIC> l(*this);
   dbf4e:	4620      	mov	r0, r4
   dbf50:	f7ff ff98 	bl	dbe84 <_ZNSt10lock_guardI4PMICED1Ev>
    byte DATA = readRegister(INPUT_SOURCE_REGISTER);
    writeRegister(INPUT_SOURCE_REGISTER, (DATA & 0b01111111));
    return 1;
}
   dbf54:	2001      	movs	r0, #1
   dbf56:	b003      	add	sp, #12
   dbf58:	bd30      	pop	{r4, r5, pc}

000dbf5a <_ZN4PMIC11disableBuckEv>:
 * Function Name  : disableBuck
 * Description    :
 * Input          : NONE
 * Return         :
 *******************************************************************************/
bool PMIC::disableBuck(void) {
   dbf5a:	b537      	push	{r0, r1, r2, r4, r5, lr}
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
   dbf5c:	ac02      	add	r4, sp, #8
   dbf5e:	4605      	mov	r5, r0
   dbf60:	f844 0d04 	str.w	r0, [r4, #-4]!
      { _M_device.lock(); }
   dbf64:	f7ff ff70 	bl	dbe48 <_ZN4PMIC4lockEv>
    std::lock_guard<PMIC> l(*this);
    byte DATA = readRegister(INPUT_SOURCE_REGISTER);
   dbf68:	2100      	movs	r1, #0
   dbf6a:	4628      	mov	r0, r5
   dbf6c:	f7ff ff91 	bl	dbe92 <_ZN4PMIC12readRegisterEh>
    writeRegister(INPUT_SOURCE_REGISTER, (DATA | 0b10000000));
   dbf70:	f060 027f 	orn	r2, r0, #127	; 0x7f
   dbf74:	b2d2      	uxtb	r2, r2
   dbf76:	2100      	movs	r1, #0
   dbf78:	4628      	mov	r0, r5
   dbf7a:	f7ff ffb4 	bl	dbee6 <_ZN4PMIC13writeRegisterEhh>
 * Description    :
 * Input          : NONE
 * Return         :
 *******************************************************************************/
bool PMIC::disableBuck(void) {
    std::lock_guard<PMIC> l(*this);
   dbf7e:	4620      	mov	r0, r4
   dbf80:	f7ff ff80 	bl	dbe84 <_ZNSt10lock_guardI4PMICED1Ev>
    byte DATA = readRegister(INPUT_SOURCE_REGISTER);
    writeRegister(INPUT_SOURCE_REGISTER, (DATA | 0b10000000));
    return 1;
}
   dbf84:	2001      	movs	r0, #1
   dbf86:	b003      	add	sp, #12
   dbf88:	bd30      	pop	{r4, r5, pc}

000dbf8a <_ZN5spark13EthernetClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   dbf8a:	2200      	movs	r2, #0
   dbf8c:	4611      	mov	r1, r2
   dbf8e:	6840      	ldr	r0, [r0, #4]
   dbf90:	f7ff bea2 	b.w	dbcd8 <network_listening>

000dbf94 <_ZN5spark13EthernetClass16getListenTimeoutEv>:
    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
    }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   dbf94:	2200      	movs	r2, #0
   dbf96:	4611      	mov	r1, r2
   dbf98:	6840      	ldr	r0, [r0, #4]
   dbf9a:	f7ff bead 	b.w	dbcf8 <network_get_listen_timeout>

000dbf9e <_ZN5spark13EthernetClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   dbf9e:	2200      	movs	r2, #0
   dbfa0:	6840      	ldr	r0, [r0, #4]
   dbfa2:	f7ff bea1 	b.w	dbce8 <network_set_listen_timeout>

000dbfa6 <_ZN5spark13EthernetClass6listenEb>:
    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   dbfa6:	2200      	movs	r2, #0
   dbfa8:	f081 0101 	eor.w	r1, r1, #1
   dbfac:	6840      	ldr	r0, [r0, #4]
   dbfae:	f7ff be8b 	b.w	dbcc8 <network_listen>

000dbfb2 <_ZN5spark13EthernetClass3offEv>:
    void on() {
        network_on(*this, 0, 0, NULL);
    }

    void off() {
        network_off(*this, 0, 0, NULL);
   dbfb2:	2300      	movs	r3, #0
   dbfb4:	461a      	mov	r2, r3
   dbfb6:	4619      	mov	r1, r3
   dbfb8:	6840      	ldr	r0, [r0, #4]
   dbfba:	f7ff be7d 	b.w	dbcb8 <network_off>

000dbfbe <_ZN5spark13EthernetClass2onEv>:
    EthernetClass() :
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
    }

    void on() {
        network_on(*this, 0, 0, NULL);
   dbfbe:	2300      	movs	r3, #0
   dbfc0:	461a      	mov	r2, r3
   dbfc2:	4619      	mov	r1, r3
   dbfc4:	6840      	ldr	r0, [r0, #4]
   dbfc6:	f7ff be6f 	b.w	dbca8 <network_on>

000dbfca <_ZN5spark13EthernetClass5readyEv>:
    bool listening(void) {
        return network_listening(*this, 0, NULL);
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   dbfca:	2200      	movs	r2, #0
   dbfcc:	4611      	mov	r1, r2
   dbfce:	6840      	ldr	r0, [r0, #4]
   dbfd0:	f7ff be62 	b.w	dbc98 <network_ready>

000dbfd4 <_ZN5spark13EthernetClass10connectingEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   dbfd4:	2200      	movs	r2, #0
   dbfd6:	4611      	mov	r1, r2
   dbfd8:	6840      	ldr	r0, [r0, #4]
   dbfda:	f7ff be4d 	b.w	dbc78 <network_connecting>

000dbfde <_ZN5spark13EthernetClass10disconnectEv>:
    }

    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   dbfde:	2200      	movs	r2, #0
   dbfe0:	2102      	movs	r1, #2
   dbfe2:	6840      	ldr	r0, [r0, #4]
   dbfe4:	f7ff be50 	b.w	dbc88 <network_disconnect>

000dbfe8 <_ZN5spark13EthernetClass7connectEj>:
    void off() {
        network_off(*this, 0, 0, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   dbfe8:	2300      	movs	r3, #0
   dbfea:	461a      	mov	r2, r3
   dbfec:	6840      	ldr	r0, [r0, #4]
   dbfee:	f7ff be3b 	b.w	dbc68 <network_connect>
	...

000dbff4 <_GLOBAL__sub_I__ZN5spark8EthernetE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
   dbff4:	4b02      	ldr	r3, [pc, #8]	; (dc000 <_GLOBAL__sub_I__ZN5spark8EthernetE+0xc>)
   dbff6:	2203      	movs	r2, #3
   dbff8:	605a      	str	r2, [r3, #4]
    }

class EthernetClass : public NetworkClass {
public:
    EthernetClass() :
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
   dbffa:	4a02      	ldr	r2, [pc, #8]	; (dc004 <_GLOBAL__sub_I__ZN5spark8EthernetE+0x10>)
   dbffc:	601a      	str	r2, [r3, #0]
   dbffe:	4770      	bx	lr
   dc000:	2003e438 	.word	0x2003e438
   dc004:	000e240c 	.word	0x000e240c

000dc008 <_ZN8SPIClass4lockEv.isra.0>:
  }

  int lock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    return HAL_SPI_Acquire(_spi, nullptr);
   dc008:	2100      	movs	r1, #0
   dc00a:	f7ff bbb3 	b.w	db774 <HAL_SPI_Acquire>

000dc00e <_ZN8SPIClass6unlockEv.isra.1>:
  }

  void unlock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    HAL_SPI_Release(_spi, nullptr);
   dc00e:	2100      	movs	r1, #0
   dc010:	f7ff bbb8 	b.w	db784 <HAL_SPI_Release>

000dc014 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(HAL_SPI_Interface spi)
   dc014:	b510      	push	{r4, lr}
   dc016:	4604      	mov	r4, r0
{
    _spi = spi;
   dc018:	7001      	strb	r1, [r0, #0]
    HAL_SPI_Init(_spi);
   dc01a:	4608      	mov	r0, r1
   dc01c:	f7ff fb82 	bl	db724 <HAL_SPI_Init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
   dc020:	2300      	movs	r3, #0
   dc022:	6063      	str	r3, [r4, #4]
}
   dc024:	4620      	mov	r0, r4
   dc026:	bd10      	pop	{r4, pc}

000dc028 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
   dc028:	b510      	push	{r4, lr}
   dc02a:	4604      	mov	r4, r0
    // TODO: Fetch default pin from HAL
    if (!lock())
   dc02c:	7800      	ldrb	r0, [r0, #0]
   dc02e:	f7ff ffeb 	bl	dc008 <_ZN8SPIClass4lockEv.isra.0>
   dc032:	b948      	cbnz	r0, dc048 <_ZN8SPIClass5beginEv+0x20>
    {
        HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
   dc034:	7820      	ldrb	r0, [r4, #0]
   dc036:	f64f 71ff 	movw	r1, #65535	; 0xffff
   dc03a:	f7ff fb63 	bl	db704 <HAL_SPI_Begin>
        unlock();
   dc03e:	7820      	ldrb	r0, [r4, #0]
    }
}
   dc040:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
    // TODO: Fetch default pin from HAL
    if (!lock())
    {
        HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
        unlock();
   dc044:	f7ff bfe3 	b.w	dc00e <_ZN8SPIClass6unlockEv.isra.1>
   dc048:	bd10      	pop	{r4, pc}

000dc04a <_ZN8SPIClass5beginE8SPI_Modet>:
        unlock();
    }
}

void SPIClass::begin(SPI_Mode mode, uint16_t ss_pin)
{
   dc04a:	b570      	push	{r4, r5, r6, lr}
   dc04c:	4604      	mov	r4, r0
    if (!lock())
   dc04e:	7800      	ldrb	r0, [r0, #0]
        unlock();
    }
}

void SPIClass::begin(SPI_Mode mode, uint16_t ss_pin)
{
   dc050:	460d      	mov	r5, r1
   dc052:	4616      	mov	r6, r2
    if (!lock())
   dc054:	f7ff ffd8 	bl	dc008 <_ZN8SPIClass4lockEv.isra.0>
   dc058:	4603      	mov	r3, r0
   dc05a:	b948      	cbnz	r0, dc070 <_ZN8SPIClass5beginE8SPI_Modet+0x26>
    {
        HAL_SPI_Begin_Ext(_spi, mode, ss_pin, NULL);
   dc05c:	7820      	ldrb	r0, [r4, #0]
   dc05e:	4632      	mov	r2, r6
   dc060:	4629      	mov	r1, r5
   dc062:	f7ff fb77 	bl	db754 <HAL_SPI_Begin_Ext>
        unlock();
   dc066:	7820      	ldrb	r0, [r4, #0]
    }
}
   dc068:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void SPIClass::begin(SPI_Mode mode, uint16_t ss_pin)
{
    if (!lock())
    {
        HAL_SPI_Begin_Ext(_spi, mode, ss_pin, NULL);
        unlock();
   dc06c:	f7ff bfcf 	b.w	dc00e <_ZN8SPIClass6unlockEv.isra.1>
   dc070:	bd70      	pop	{r4, r5, r6, pc}

000dc072 <_ZN8SPIClass14endTransactionEv>:
}

void SPIClass::endTransaction()
{
    // Release peripheral
    unlock();
   dc072:	7800      	ldrb	r0, [r0, #0]
   dc074:	f7ff bfcb 	b.w	dc00e <_ZN8SPIClass6unlockEv.isra.1>

000dc078 <_ZN8SPIClass19computeClockDividerEjjRhRj>:
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
   dc078:	0840      	lsrs	r0, r0, #1
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
   dc07a:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
   dc07c:	6018      	str	r0, [r3, #0]
   dc07e:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale < 7)
   dc080:	6818      	ldr	r0, [r3, #0]
   dc082:	4288      	cmp	r0, r1
   dc084:	b2e5      	uxtb	r5, r4
   dc086:	d906      	bls.n	dc096 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
   dc088:	3401      	adds	r4, #1
   dc08a:	2c08      	cmp	r4, #8
   dc08c:	d002      	beq.n	dc094 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
   dc08e:	0840      	lsrs	r0, r0, #1
   dc090:	6018      	str	r0, [r3, #0]
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
    while (clock > targetSpeed && scale < 7)
   dc092:	e7f5      	b.n	dc080 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
   dc094:	2507      	movs	r5, #7
    {
        clock >>= 1;
        scale++;
    }
    divider = clock_divisors[scale];
   dc096:	4b02      	ldr	r3, [pc, #8]	; (dc0a0 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
   dc098:	5d5b      	ldrb	r3, [r3, r5]
   dc09a:	7013      	strb	r3, [r2, #0]
   dc09c:	bd30      	pop	{r4, r5, pc}
   dc09e:	bf00      	nop
   dc0a0:	000e2438 	.word	0x000e2438

000dc0a4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>:
{
    return lock();
}

int32_t SPIClass::beginTransaction(const particle::__SPISettings& settings)
{
   dc0a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   dc0a8:	4607      	mov	r7, r0
   dc0aa:	b08f      	sub	sp, #60	; 0x3c
    // Lock peripheral
    CHECK(lock());
   dc0ac:	7800      	ldrb	r0, [r0, #0]
{
    return lock();
}

int32_t SPIClass::beginTransaction(const particle::__SPISettings& settings)
{
   dc0ae:	460e      	mov	r6, r1
    // Lock peripheral
    CHECK(lock());
   dc0b0:	f7ff ffaa 	bl	dc008 <_ZN8SPIClass4lockEv.isra.0>
   dc0b4:	2800      	cmp	r0, #0
   dc0b6:	db62      	blt.n	dc17e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xda>

    // Collect existing SPI info
    hal_spi_info_t spi_info;
    querySpiInfo(_spi, &spi_info);
   dc0b8:	783c      	ldrb	r4, [r7, #0]
 * \warning This method is NOT THREADSAFE and callers will need to utilize
 *          HAL synchronization primatives.
 */
static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
    memset(info, 0, sizeof(hal_spi_info_t));
   dc0ba:	2214      	movs	r2, #20
   dc0bc:	2100      	movs	r1, #0
   dc0be:	a809      	add	r0, sp, #36	; 0x24
   dc0c0:	f003 ff52 	bl	dff68 <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
   dc0c4:	230b      	movs	r3, #11
    HAL_SPI_Info(spi, info, nullptr);
   dc0c6:	4620      	mov	r0, r4
   dc0c8:	2200      	movs	r2, #0
   dc0ca:	a909      	add	r1, sp, #36	; 0x24
 *          HAL synchronization primatives.
 */
static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
    memset(info, 0, sizeof(hal_spi_info_t));
    info->version = HAL_SPI_INFO_VERSION_1;
   dc0cc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    HAL_SPI_Info(spi, info, nullptr);
   dc0d0:	f7ff fb38 	bl	db744 <HAL_SPI_Info>
/**
 * \brief Extract SPI Settings from SPI Info Structure
 */
static particle::__SPISettings spiSettingsFromSpiInfo(hal_spi_info_t* info)
{
    if (!info || !info->enabled || info->default_settings)
   dc0d4:	f89d 402d 	ldrb.w	r4, [sp, #45]	; 0x2d
   dc0d8:	b154      	cbz	r4, dc0f0 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x4c>
   dc0da:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
   dc0de:	b935      	cbnz	r5, dc0ee <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x4a>
    {
        return particle::__SPISettings();
    }
    return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
   dc0e0:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   dc0e4:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
   dc0e8:	f89d 4035 	ldrb.w	r4, [sp, #53]	; 0x35
   dc0ec:	e003      	b.n	dc0f6 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x52>
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
   dc0ee:	2400      	movs	r4, #0
   dc0f0:	46a1      	mov	r9, r4
   dc0f2:	46a0      	mov	r8, r4
   dc0f4:	2501      	movs	r5, #1
   dc0f6:	7933      	ldrb	r3, [r6, #4]
  }

  bool operator==(const __SPISettings& other) const
  {
    if (default_ && other.default_)
   dc0f8:	b105      	cbz	r5, dc0fc <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x58>
   dc0fa:	b9bb      	cbnz	r3, dc12c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x88>
      return true;

    if (default_ == other.default_ &&
   dc0fc:	429d      	cmp	r5, r3
   dc0fe:	d10b      	bne.n	dc118 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x74>
   dc100:	68b2      	ldr	r2, [r6, #8]
   dc102:	4542      	cmp	r2, r8
   dc104:	d108      	bne.n	dc118 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x74>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
   dc106:	f88d 9020 	strb.w	r9, [sp, #32]
   dc10a:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
   dc10e:	f8bd 1020 	ldrh.w	r1, [sp, #32]
   dc112:	89b2      	ldrh	r2, [r6, #12]
   dc114:	4291      	cmp	r1, r2
   dc116:	d009      	beq.n	dc12c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x88>
    particle::__SPISettings spi_settings = spiSettingsFromSpiInfo(&spi_info);

    // Reconfigure SPI peripheral (if necessary)
    if (settings != spi_settings)
    {
        if (settings.default_)
   dc118:	b153      	cbz	r3, dc130 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x8c>
        {
            HAL_SPI_Set_Settings(_spi, settings.default_, 0, 0, 0, nullptr);
   dc11a:	2400      	movs	r4, #0
   dc11c:	7838      	ldrb	r0, [r7, #0]
   dc11e:	9401      	str	r4, [sp, #4]
   dc120:	9400      	str	r4, [sp, #0]
   dc122:	4623      	mov	r3, r4
   dc124:	4622      	mov	r2, r4
   dc126:	2101      	movs	r1, #1

            // Ensure inequality aside from computed clock value
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
            {
                HAL_SPI_Set_Settings(_spi, settings.default_, divisor, settings.bitOrder_,
                                     settings.dataMode_, nullptr);
   dc128:	f7ff fb1c 	bl	db764 <HAL_SPI_Set_Settings>
            }
        }
    }

    return 0;
   dc12c:	2000      	movs	r0, #0
   dc12e:	e026      	b.n	dc17e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xda>
            HAL_SPI_Set_Settings(_spi, settings.default_, 0, 0, 0, nullptr);
        }
        else
        {
            // Compute valid clock value and clock divider from supplied clock value
            uint8_t divisor = 0;
   dc130:	f88d 300f 	strb.w	r3, [sp, #15]
            unsigned int clock; // intentionally left uninitialized
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
                                clock);
   dc134:	68b1      	ldr	r1, [r6, #8]
   dc136:	980a      	ldr	r0, [sp, #40]	; 0x28
   dc138:	ab04      	add	r3, sp, #16
   dc13a:	f10d 020f 	add.w	r2, sp, #15
   dc13e:	f7ff ff9b 	bl	dc078 <_ZN8SPIClass19computeClockDividerEjjRhRj>
   dc142:	7931      	ldrb	r1, [r6, #4]
    return false;
  }

  bool operator<=(const __SPISettings& other) const
  {
    if (default_ && other.default_)
   dc144:	b105      	cbz	r5, dc148 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa4>
   dc146:	b9b1      	cbnz	r1, dc176 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd2>
      return true;

    if (default_ == other.default_ &&
   dc148:	42a9      	cmp	r1, r5
   dc14a:	d008      	beq.n	dc15e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xba>

            // Ensure inequality aside from computed clock value
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
            {
                HAL_SPI_Set_Settings(_spi, settings.default_, divisor, settings.bitOrder_,
                                     settings.dataMode_, nullptr);
   dc14c:	2400      	movs	r4, #0
   dc14e:	7838      	ldrb	r0, [r7, #0]
   dc150:	9401      	str	r4, [sp, #4]
   dc152:	7b74      	ldrb	r4, [r6, #13]
   dc154:	7b33      	ldrb	r3, [r6, #12]
   dc156:	f89d 200f 	ldrb.w	r2, [sp, #15]
   dc15a:	9400      	str	r4, [sp, #0]
   dc15c:	e7e4      	b.n	dc128 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x84>
   dc15e:	68b3      	ldr	r3, [r6, #8]
   dc160:	4543      	cmp	r3, r8
   dc162:	d3f3      	bcc.n	dc14c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa8>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
   dc164:	f88d 9020 	strb.w	r9, [sp, #32]
   dc168:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
   dc16c:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   dc170:	89b3      	ldrh	r3, [r6, #12]
   dc172:	429a      	cmp	r2, r3
   dc174:	d1ea      	bne.n	dc14c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa8>
            unsigned int clock; // intentionally left uninitialized
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
                                clock);

            // Ensure inequality aside from computed clock value
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
   dc176:	9b04      	ldr	r3, [sp, #16]
   dc178:	4543      	cmp	r3, r8
   dc17a:	d1e7      	bne.n	dc14c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa8>
   dc17c:	e7d6      	b.n	dc12c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x88>
            }
        }
    }

    return 0;
}
   dc17e:	b00f      	add	sp, #60	; 0x3c
   dc180:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000dc184 <_ZN8SPIClass8transferEh>:

    return clock;
}

byte SPIClass::transfer(byte _data)
{
   dc184:	b508      	push	{r3, lr}
    return static_cast<byte>(HAL_SPI_Send_Receive_Data(_spi, _data));
   dc186:	7800      	ldrb	r0, [r0, #0]
   dc188:	f7ff fac4 	bl	db714 <HAL_SPI_Send_Receive_Data>
}
   dc18c:	b2c0      	uxtb	r0, r0
   dc18e:	bd08      	pop	{r3, pc}

000dc190 <_ZN8SPIClass9isEnabledEv>:
bool SPIClass::isEnabled()
{
    // XXX: pinAvailable() will call this method potentially even from
    // interrupt context. `enabled` flag in HAL is usually just a volatile
    // variable, so it's fine not to acquire the lock here.
    return HAL_SPI_Is_Enabled(_spi);
   dc190:	7800      	ldrb	r0, [r0, #0]
   dc192:	f7ff bacf 	b.w	db734 <HAL_SPI_Is_Enabled>

000dc196 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
   dc196:	b510      	push	{r4, lr}
   dc198:	4604      	mov	r4, r0
        if (wakeupSource_) {
   dc19a:	6800      	ldr	r0, [r0, #0]
   dc19c:	b118      	cbz	r0, dc1a6 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2+0x10>
            free(wakeupSource_);
   dc19e:	f7ff fe13 	bl	dbdc8 <free>
            wakeupSource_ = nullptr;
   dc1a2:	2300      	movs	r3, #0
   dc1a4:	6023      	str	r3, [r4, #0]
   dc1a6:	bd10      	pop	{r4, pc}

000dc1a8 <_ZN17SystemSleepResultaSEOS_>:
            wakeupSource_ = result.wakeupSource_;
            result.wakeupSource_ = nullptr;
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
   dc1a8:	b538      	push	{r3, r4, r5, lr}
        error_ = result.error_;
   dc1aa:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   dc1ae:	8083      	strh	r3, [r0, #4]
        compatResult_ = result.compatResult_;
   dc1b0:	460b      	mov	r3, r1
            wakeupSource_ = result.wakeupSource_;
            result.wakeupSource_ = nullptr;
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
   dc1b2:	460d      	mov	r5, r1
        error_ = result.error_;
        compatResult_ = result.compatResult_;
   dc1b4:	f853 2f06 	ldr.w	r2, [r3, #6]!
   dc1b8:	f8c0 2006 	str.w	r2, [r0, #6]
   dc1bc:	889b      	ldrh	r3, [r3, #4]
   dc1be:	8143      	strh	r3, [r0, #10]
            wakeupSource_ = result.wakeupSource_;
            result.wakeupSource_ = nullptr;
        }
    }

    SystemSleepResult& operator=(SystemSleepResult&& result) {
   dc1c0:	4604      	mov	r4, r0
        error_ = result.error_;
        compatResult_ = result.compatResult_;
        freeWakeupSourceMemory();
   dc1c2:	f7ff ffe8 	bl	dc196 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
        if (result.wakeupSource_) {
   dc1c6:	682b      	ldr	r3, [r5, #0]
   dc1c8:	b113      	cbz	r3, dc1d0 <_ZN17SystemSleepResultaSEOS_+0x28>
            wakeupSource_ = result.wakeupSource_;
   dc1ca:	6023      	str	r3, [r4, #0]
            result.wakeupSource_ = nullptr;
   dc1cc:	2300      	movs	r3, #0
   dc1ce:	602b      	str	r3, [r5, #0]
        }
        return *this;
    }
   dc1d0:	4620      	mov	r0, r4
   dc1d2:	bd38      	pop	{r3, r4, r5, pc}

000dc1d4 <_ZN17SystemSleepResult13toSleepResultEv>:
    system_error_t error() const {
        return error_;
    }

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
   dc1d4:	f9b1 3004 	ldrsh.w	r3, [r1, #4]

    system_error_t error() const {
        return error_;
    }

    SleepResult toSleepResult() {
   dc1d8:	b510      	push	{r4, lr}
        if (error_ || wakeupSource_) {
   dc1da:	b90b      	cbnz	r3, dc1e0 <_ZN17SystemSleepResult13toSleepResultEv+0xc>
   dc1dc:	680a      	ldr	r2, [r1, #0]
   dc1de:	b19a      	cbz	r2, dc208 <_ZN17SystemSleepResult13toSleepResultEv+0x34>
   dc1e0:	680c      	ldr	r4, [r1, #0]
    hal_wakeup_source_base_t** halWakeupSource() {
        return &wakeupSource_;
    }

    SystemSleepWakeupReason wakeupReason() const {
        if (wakeupSource_) {
   dc1e2:	b15c      	cbz	r4, dc1fc <_ZN17SystemSleepResult13toSleepResultEv+0x28>
        return error_;
    }

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
            switch (wakeupReason()) {
   dc1e4:	88a2      	ldrh	r2, [r4, #4]
   dc1e6:	2a01      	cmp	r2, #1
   dc1e8:	d003      	beq.n	dc1f2 <_ZN17SystemSleepResult13toSleepResultEv+0x1e>
   dc1ea:	2a04      	cmp	r2, #4
   dc1ec:	d106      	bne.n	dc1fc <_ZN17SystemSleepResult13toSleepResultEv+0x28>
                case SystemSleepWakeupReason::BY_GPIO: {
                    compatResult_ = SleepResult(WAKEUP_REASON_PIN, error(), wakeupPin());
                    break;
                }
                case SystemSleepWakeupReason::BY_RTC: {
                    compatResult_ = SleepResult(WAKEUP_REASON_RTC, error());
   dc1ee:	2202      	movs	r2, #2
   dc1f0:	e005      	b.n	dc1fe <_ZN17SystemSleepResult13toSleepResultEv+0x2a>
        }
    }

    pin_t wakeupPin() const {
        if (wakeupReason() == SystemSleepWakeupReason::BY_GPIO) {
            return reinterpret_cast<hal_wakeup_source_gpio_t*>(wakeupSource_)->pin;
   dc1f2:	89a4      	ldrh	r4, [r4, #12]

    SleepResult toSleepResult() {
        if (error_ || wakeupSource_) {
            switch (wakeupReason()) {
                case SystemSleepWakeupReason::BY_GPIO: {
                    compatResult_ = SleepResult(WAKEUP_REASON_PIN, error(), wakeupPin());
   dc1f4:	814c      	strh	r4, [r1, #10]
   dc1f6:	718a      	strb	r2, [r1, #6]
   dc1f8:	810b      	strh	r3, [r1, #8]
                    break;
   dc1fa:	e005      	b.n	dc208 <_ZN17SystemSleepResult13toSleepResultEv+0x34>
                case SystemSleepWakeupReason::BY_RTC: {
                    compatResult_ = SleepResult(WAKEUP_REASON_RTC, error());
                    break;
                }
                default: {
                    compatResult_ = SleepResult(WAKEUP_REASON_UNKNOWN, error());
   dc1fc:	2204      	movs	r2, #4
   dc1fe:	810b      	strh	r3, [r1, #8]
   dc200:	f64f 73ff 	movw	r3, #65535	; 0xffff
   dc204:	718a      	strb	r2, [r1, #6]
   dc206:	814b      	strh	r3, [r1, #10]
                    break;
                }
            }
        }
        return compatResult_;
   dc208:	f851 3f06 	ldr.w	r3, [r1, #6]!
   dc20c:	6003      	str	r3, [r0, #0]
   dc20e:	888b      	ldrh	r3, [r1, #4]
   dc210:	8083      	strh	r3, [r0, #4]
    }
   dc212:	bd10      	pop	{r4, pc}

000dc214 <_ZN11SystemClass5resetEm>:
    reset(0);
}

void SystemClass::reset(uint32_t data)
{
    HAL_Core_System_Reset_Ex(RESET_REASON_USER, data, nullptr);
   dc214:	4601      	mov	r1, r0
   dc216:	2200      	movs	r2, #0
   dc218:	208c      	movs	r0, #140	; 0x8c
   dc21a:	f7ff bafb 	b.w	db814 <HAL_Core_System_Reset_Ex>

000dc21e <_ZN11SystemClass5resetEv>:
    HAL_Core_Enter_Bootloader(persist);
}

void SystemClass::reset(void)
{
    reset(0);
   dc21e:	2000      	movs	r0, #0
   dc220:	f7ff bff8 	b.w	dc214 <_ZN11SystemClass5resetEm>

000dc224 <_ZN11SleepResultC1EiPKtj>:
bool SystemClass::enableFeature(const WiFiTesterFeature feature) {
    WiFiTester::init();
    return true;
}

SleepResult::SleepResult(int ret, const pin_t* pins, size_t pinsSize) {
   dc224:	b510      	push	{r4, lr}
   dc226:	2400      	movs	r4, #0
   dc228:	7004      	strb	r4, [r0, #0]
   dc22a:	8044      	strh	r4, [r0, #2]
    if (ret > 0) {
   dc22c:	2900      	cmp	r1, #0
bool SystemClass::enableFeature(const WiFiTesterFeature feature) {
    WiFiTester::init();
    return true;
}

SleepResult::SleepResult(int ret, const pin_t* pins, size_t pinsSize) {
   dc22e:	f64f 74ff 	movw	r4, #65535	; 0xffff
   dc232:	8084      	strh	r4, [r0, #4]
    if (ret > 0) {
   dc234:	dd07      	ble.n	dc246 <_ZN11SleepResultC1EiPKtj+0x22>
        // pin
        --ret;
        if ((size_t)ret < pinsSize) {
   dc236:	3901      	subs	r1, #1
   dc238:	4299      	cmp	r1, r3
   dc23a:	d209      	bcs.n	dc250 <_ZN11SleepResultC1EiPKtj+0x2c>
            pin_ = pins[ret];
   dc23c:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   dc240:	8083      	strh	r3, [r0, #4]
            reason_ = WAKEUP_REASON_PIN;
   dc242:	2301      	movs	r3, #1
   dc244:	e001      	b.n	dc24a <_ZN11SleepResultC1EiPKtj+0x26>
            err_ = SYSTEM_ERROR_NONE;
        }
    } else if (ret == 0) {
   dc246:	d102      	bne.n	dc24e <_ZN11SleepResultC1EiPKtj+0x2a>
        reason_ = WAKEUP_REASON_RTC;
   dc248:	2302      	movs	r3, #2
   dc24a:	7003      	strb	r3, [r0, #0]
   dc24c:	bd10      	pop	{r4, pc}
        err_ = SYSTEM_ERROR_NONE;
    } else {
        err_ = static_cast<system_error_t>(ret);
   dc24e:	8041      	strh	r1, [r0, #2]
    }
}
   dc250:	bd10      	pop	{r4, pc}
	...

000dc254 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE>:
    int ret = system_sleep(sleepMode, seconds, flags.value(), NULL);
    System.systemSleepResult_ = SystemSleepResult(SleepResult(WAKEUP_REASON_NONE, static_cast<system_error_t>(ret)));
    return System.systemSleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
   dc254:	b5f0      	push	{r4, r5, r6, r7, lr}
   dc256:	b08b      	sub	sp, #44	; 0x2c
   dc258:	4617      	mov	r7, r2
   dc25a:	461a      	mov	r2, r3
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
   dc25c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   dc25e:	9301      	str	r3, [sp, #4]
    int ret = system_sleep(sleepMode, seconds, flags.value(), NULL);
    System.systemSleepResult_ = SystemSleepResult(SleepResult(WAKEUP_REASON_NONE, static_cast<system_error_t>(ret)));
    return System.systemSleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
   dc260:	460e      	mov	r6, r1
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
   dc262:	2400      	movs	r4, #0
   dc264:	9b11      	ldr	r3, [sp, #68]	; 0x44
   dc266:	9402      	str	r4, [sp, #8]
    int ret = system_sleep(sleepMode, seconds, flags.value(), NULL);
    System.systemSleepResult_ = SystemSleepResult(SleepResult(WAKEUP_REASON_NONE, static_cast<system_error_t>(ret)));
    return System.systemSleepResult_;
}

SleepResult SystemClass::sleepPinImpl(const uint16_t* pins, size_t pins_count, const InterruptMode* modes, size_t modes_count, long seconds, SleepOptionFlags flags) {
   dc268:	4605      	mov	r5, r0
    int ret = system_sleep_pins(pins, pins_count, modes, modes_count, seconds, flags.value(), nullptr);
   dc26a:	9300      	str	r3, [sp, #0]
   dc26c:	4639      	mov	r1, r7
   dc26e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   dc270:	4630      	mov	r0, r6
   dc272:	f7ff fcef 	bl	dbc54 <system_sleep_pins>
    System.systemSleepResult_ = SystemSleepResult(SleepResult(ret, pins, pins_count));
   dc276:	463b      	mov	r3, r7
   dc278:	4632      	mov	r2, r6
   dc27a:	4601      	mov	r1, r0
   dc27c:	a805      	add	r0, sp, #20
   dc27e:	f7ff ffd1 	bl	dc224 <_ZN11SleepResultC1EiPKtj>
    }

    SystemSleepResult(SleepResult r)
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE),
              compatResult_(r) {
   dc282:	9407      	str	r4, [sp, #28]
   dc284:	f8ad 4020 	strh.w	r4, [sp, #32]
   dc288:	4c0d      	ldr	r4, [pc, #52]	; (dc2c0 <_ZN11SystemClass12sleepPinImplEPKtjPK13InterruptModejlN8particle5FlagsI19SleepOptionFlagTypemEE+0x6c>)
   dc28a:	f89d 1014 	ldrb.w	r1, [sp, #20]
   dc28e:	f9bd 2016 	ldrsh.w	r2, [sp, #22]
   dc292:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   dc296:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
   dc29a:	4620      	mov	r0, r4
   dc29c:	a907      	add	r1, sp, #28
   dc29e:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
   dc2a2:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
   dc2a6:	f7ff ff7f 	bl	dc1a8 <_ZN17SystemSleepResultaSEOS_>
        }
        return *this;
    }

    ~SystemSleepResult() {
        freeWakeupSourceMemory();
   dc2aa:	a807      	add	r0, sp, #28
   dc2ac:	f7ff ff73 	bl	dc196 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
        }
        return compatResult_;
    }

    operator SleepResult() {
        return toSleepResult();
   dc2b0:	4628      	mov	r0, r5
   dc2b2:	4621      	mov	r1, r4
   dc2b4:	f7ff ff8e 	bl	dc1d4 <_ZN17SystemSleepResult13toSleepResultEv>
    return System.systemSleepResult_;
}
   dc2b8:	4628      	mov	r0, r5
   dc2ba:	b00b      	add	sp, #44	; 0x2c
   dc2bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   dc2be:	bf00      	nop
   dc2c0:	2003e440 	.word	0x2003e440

000dc2c4 <_ZNK11SleepResult12wokenUpByRtcEv>:
   dc2c4:	7800      	ldrb	r0, [r0, #0]
   dc2c6:	3802      	subs	r0, #2
   dc2c8:	2801      	cmp	r0, #1
   dc2ca:	bf8c      	ite	hi
   dc2cc:	2000      	movhi	r0, #0
   dc2ce:	2001      	movls	r0, #1
   dc2d0:	4770      	bx	lr

000dc2d2 <_ZNK11SleepResult12wokenUpByPinEv>:
bool SleepResult::wokenUpByRtc() const {
    return reason_ == WAKEUP_REASON_RTC || reason_ == WAKEUP_REASON_PIN_OR_RTC;
}

bool SleepResult::wokenUpByPin() const {
    return reason_ == WAKEUP_REASON_PIN || reason_ == WAKEUP_REASON_PIN_OR_RTC;
   dc2d2:	7800      	ldrb	r0, [r0, #0]
   dc2d4:	2801      	cmp	r0, #1
   dc2d6:	d002      	beq.n	dc2de <_ZNK11SleepResult12wokenUpByPinEv+0xc>
   dc2d8:	1ec3      	subs	r3, r0, #3
   dc2da:	4258      	negs	r0, r3
   dc2dc:	4158      	adcs	r0, r3
}
   dc2de:	4770      	bx	lr

000dc2e0 <_GLOBAL__sub_I_System>:
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
   dc2e0:	b510      	push	{r4, lr}

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   dc2e2:	4c09      	ldr	r4, [pc, #36]	; (dc308 <_GLOBAL__sub_I_System+0x28>)
   dc2e4:	2000      	movs	r0, #0
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   dc2e6:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   dc2ea:	6020      	str	r0, [r4, #0]
   dc2ec:	80a0      	strh	r0, [r4, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
   dc2ee:	71a0      	strb	r0, [r4, #6]
   dc2f0:	8120      	strh	r0, [r4, #8]
   dc2f2:	8163      	strh	r3, [r4, #10]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   dc2f4:	f7ff fc6a 	bl	dbbcc <set_system_mode>

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
   dc2f8:	4620      	mov	r0, r4
   dc2fa:	4a04      	ldr	r2, [pc, #16]	; (dc30c <_GLOBAL__sub_I_System+0x2c>)
   dc2fc:	4904      	ldr	r1, [pc, #16]	; (dc310 <_GLOBAL__sub_I_System+0x30>)
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
   dc2fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
   dc302:	f002 bd17 	b.w	ded34 <__aeabi_atexit>
   dc306:	bf00      	nop
   dc308:	2003e440 	.word	0x2003e440
   dc30c:	2003daf8 	.word	0x2003daf8
   dc310:	000d4c95 	.word	0x000d4c95

000dc314 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
   dc314:	b510      	push	{r4, lr}
   dc316:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
   dc318:	f003 fea6 	bl	e0068 <strlen>
   dc31c:	3801      	subs	r0, #1
   dc31e:	1823      	adds	r3, r4, r0
   dc320:	4620      	mov	r0, r4
	while(i<j){
   dc322:	4298      	cmp	r0, r3
   dc324:	d206      	bcs.n	dc334 <_Z11str_reversePc+0x20>
		c = *i;
   dc326:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
   dc328:	7819      	ldrb	r1, [r3, #0]
   dc32a:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
   dc32e:	f803 2901 	strb.w	r2, [r3], #-1
__attribute__((weak)) void str_reverse(char* buffer){
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
	while(i<j){
   dc332:	e7f6      	b.n	dc322 <_Z11str_reversePc+0xe>
   dc334:	bd10      	pop	{r4, pc}

000dc336 <ltoa>:



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
   dc336:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      int i = 2;
      long uarg;
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
   dc33a:	1e93      	subs	r3, r2, #2
            base = 10;                    /* can only use 0-9, A-Z        */
   dc33c:	2b23      	cmp	r3, #35	; 0x23



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
   dc33e:	4615      	mov	r5, r2
   dc340:	b08c      	sub	sp, #48	; 0x30
      int i = 2;
      long uarg;
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
   dc342:	bf34      	ite	cc
   dc344:	4615      	movcc	r5, r2
   dc346:	250a      	movcs	r5, #10
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
   dc348:	2300      	movs	r3, #0

      if (10 == base && N < 0L)
   dc34a:	2d0a      	cmp	r5, #10



//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
   dc34c:	460c      	mov	r4, r1
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
   dc34e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c

      if (10 == base && N < 0L)
   dc352:	d107      	bne.n	dc364 <ltoa+0x2e>
   dc354:	4298      	cmp	r0, r3
   dc356:	da05      	bge.n	dc364 <ltoa+0x2e>
      {
            *head++ = '-';
   dc358:	232d      	movs	r3, #45	; 0x2d
   dc35a:	f101 0801 	add.w	r8, r1, #1
   dc35e:	700b      	strb	r3, [r1, #0]
            uarg    = -N;
   dc360:	4240      	negs	r0, r0
   dc362:	e001      	b.n	dc368 <ltoa+0x32>
      }
      else  uarg = N;

      if (uarg)
   dc364:	b1b0      	cbz	r0, dc394 <ltoa+0x5e>
   dc366:	46a0      	mov	r8, r4
   dc368:	f10d 062b 	add.w	r6, sp, #43	; 0x2b
   dc36c:	2701      	movs	r7, #1
      {
            for (i = 1; uarg; ++i)
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
   dc36e:	462a      	mov	r2, r5
   dc370:	4601      	mov	r1, r0
   dc372:	a801      	add	r0, sp, #4
   dc374:	f003 fdca 	bl	dff0c <ldiv>
   dc378:	9b02      	ldr	r3, [sp, #8]
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
                  uarg    = r.quot;
   dc37a:	9801      	ldr	r0, [sp, #4]
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
   dc37c:	2b09      	cmp	r3, #9
   dc37e:	bfcc      	ite	gt
   dc380:	2237      	movgt	r2, #55	; 0x37
   dc382:	2230      	movle	r2, #48	; 0x30
   dc384:	fa52 f383 	uxtab	r3, r2, r3
   dc388:	f806 3901 	strb.w	r3, [r6], #-1
      }
      else  uarg = N;

      if (uarg)
      {
            for (i = 1; uarg; ++i)
   dc38c:	3701      	adds	r7, #1
   dc38e:	2800      	cmp	r0, #0
   dc390:	d1ed      	bne.n	dc36e <ltoa+0x38>
   dc392:	e006      	b.n	dc3a2 <ltoa+0x6c>
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';
   dc394:	2330      	movs	r3, #48	; 0x30
   dc396:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
   dc39a:	46a0      	mov	r8, r4
   dc39c:	f10d 062a 	add.w	r6, sp, #42	; 0x2a


//convert long to string
__attribute__((weak)) char *ltoa(long N, char *str, int base)
{
      int i = 2;
   dc3a0:	2702      	movs	r7, #2
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';

      memcpy(head, ++tail, i);
   dc3a2:	463a      	mov	r2, r7
   dc3a4:	1c71      	adds	r1, r6, #1
   dc3a6:	4640      	mov	r0, r8
   dc3a8:	f003 fdd3 	bl	dff52 <memcpy>
      return str;
}
   dc3ac:	4620      	mov	r0, r4
   dc3ae:	b00c      	add	sp, #48	; 0x30
   dc3b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000dc3b4 <ultoa>:

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
   dc3b4:	b570      	push	{r4, r5, r6, lr}
   dc3b6:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
   dc3b8:	1e91      	subs	r1, r2, #2
   dc3ba:	2922      	cmp	r1, #34	; 0x22
   dc3bc:	d820      	bhi.n	dc400 <ultoa+0x4c>
   dc3be:	4625      	mov	r5, r4
   dc3c0:	4629      	mov	r1, r5
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
   dc3c2:	b910      	cbnz	r0, dc3ca <ultoa+0x16>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
   dc3c4:	4423      	add	r3, r4
            *ptr++ = '0';
   dc3c6:	2230      	movs	r2, #48	; 0x30
   dc3c8:	e00e      	b.n	dc3e8 <ultoa+0x34>
	div_t result;
	while(a){
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
   dc3ca:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
   dc3ce:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
   dc3d2:	b2c1      	uxtb	r1, r0
   dc3d4:	f805 1b01 	strb.w	r1, [r5], #1
            if(result.rem<10){
   dc3d8:	2809      	cmp	r0, #9
                *ptr += '0';
   dc3da:	bf94      	ite	ls
   dc3dc:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
   dc3de:	3157      	addhi	r1, #87	; 0x57
   dc3e0:	f805 1c01 	strb.w	r1, [r5, #-1]
            }
            ++ptr;
            a = result.quot;
   dc3e4:	4630      	mov	r0, r6
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
   dc3e6:	e7eb      	b.n	dc3c0 <ultoa+0xc>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
   dc3e8:	4299      	cmp	r1, r3
   dc3ea:	d202      	bcs.n	dc3f2 <ultoa+0x3e>
            *ptr++ = '0';
   dc3ec:	f801 2b01 	strb.w	r2, [r1], #1
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
   dc3f0:	e7fa      	b.n	dc3e8 <ultoa+0x34>
            *ptr++ = '0';

	*ptr = '\0';
   dc3f2:	2300      	movs	r3, #0
	str_reverse(buffer);
   dc3f4:	4620      	mov	r0, r4
            a = result.quot;
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';

	*ptr = '\0';
   dc3f6:	700b      	strb	r3, [r1, #0]
	str_reverse(buffer);
   dc3f8:	f7ff ff8c 	bl	dc314 <_Z11str_reversePc>
	return buffer;
   dc3fc:	4620      	mov	r0, r4
   dc3fe:	bd70      	pop	{r4, r5, r6, pc}
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
	if(radix<2 || radix>36){
		return NULL;
   dc400:	2000      	movs	r0, #0
            *ptr++ = '0';

	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}
   dc402:	bd70      	pop	{r4, r5, r6, pc}

000dc404 <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
   dc404:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
   dc406:	1e03      	subs	r3, r0, #0
	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
   dc408:	460c      	mov	r4, r1
   dc40a:	4615      	mov	r5, r2
	if(a<0){
   dc40c:	da0b      	bge.n	dc426 <itoa+0x22>
		*buffer = '-';
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
   dc40e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
   dc412:	f04f 022d 	mov.w	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
   dc416:	bf14      	ite	ne
   dc418:	4258      	negne	r0, r3
   dc41a:	4618      	moveq	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
   dc41c:	2301      	movs	r3, #1
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
   dc41e:	700a      	strb	r2, [r1, #0]
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
		ultoa((unsigned)v, buffer + 1, radix);
   dc420:	462a      	mov	r2, r5
   dc422:	4419      	add	r1, r3
   dc424:	e000      	b.n	dc428 <itoa+0x24>
	}else{
		ultoa(a, buffer, radix);
   dc426:	2301      	movs	r3, #1
   dc428:	f7ff ffc4 	bl	dc3b4 <ultoa>
	}
	return buffer;
}
   dc42c:	4620      	mov	r0, r4
   dc42e:	bd38      	pop	{r3, r4, r5, pc}

000dc430 <utoa>:

__attribute__((weak)) char* utoa(unsigned a, char* buffer, int radix) {
   dc430:	b508      	push	{r3, lr}
    return ultoa(a, buffer, radix);
   dc432:	2301      	movs	r3, #1
   dc434:	f7ff ffbe 	bl	dc3b4 <ultoa>
}
   dc438:	bd08      	pop	{r3, pc}
	...

000dc43c <_Z4dtoadhPc>:
#include "string_convert.h"

//These are very crude implementations - will refine later
//------------------------------------------------------------------------------------------

void dtoa (double val, unsigned char prec, char *sout) {
   dc43c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   dc440:	ec59 8b10 	vmov	r8, r9, d0
   dc444:	4607      	mov	r7, r0
   dc446:	460e      	mov	r6, r1
    bool negative = val<0;
    if (negative) {
   dc448:	2200      	movs	r2, #0
   dc44a:	2300      	movs	r3, #0
   dc44c:	ee10 0a10 	vmov	r0, s0
   dc450:	4649      	mov	r1, r9
   dc452:	f003 fa05 	bl	df860 <__aeabi_dcmplt>
   dc456:	b128      	cbz	r0, dc464 <_Z4dtoadhPc+0x28>
        val = -val;
   dc458:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
   dc45c:	4699      	mov	r9, r3
        *sout++ = '-';
   dc45e:	232d      	movs	r3, #45	; 0x2d
   dc460:	7033      	strb	r3, [r6, #0]
   dc462:	3601      	adds	r6, #1
   dc464:	2300      	movs	r3, #0
    }
    long scale = 1;
   dc466:	2401      	movs	r4, #1
    for (uint8_t i=0; i<prec; i++)
        scale *= 10;
   dc468:	220a      	movs	r2, #10
    if (negative) {
        val = -val;
        *sout++ = '-';
    }
    long scale = 1;
    for (uint8_t i=0; i<prec; i++)
   dc46a:	b2d9      	uxtb	r1, r3
   dc46c:	428f      	cmp	r7, r1
   dc46e:	d902      	bls.n	dc476 <_Z4dtoadhPc+0x3a>
        scale *= 10;
   dc470:	4354      	muls	r4, r2
   dc472:	3301      	adds	r3, #1
    if (negative) {
        val = -val;
        *sout++ = '-';
    }
    long scale = 1;
    for (uint8_t i=0; i<prec; i++)
   dc474:	e7f9      	b.n	dc46a <_Z4dtoadhPc+0x2e>
        scale *= 10;
    val *= scale;   // capture all the significant digits
   dc476:	4620      	mov	r0, r4
   dc478:	f002 ff1a 	bl	df2b0 <__aeabi_i2d>
   dc47c:	4642      	mov	r2, r8
   dc47e:	464b      	mov	r3, r9
   dc480:	f002 ff7c 	bl	df37c <__aeabi_dmul>
   dc484:	4682      	mov	sl, r0
   dc486:	468b      	mov	fp, r1
    uint64_t fixed = uint64_t(val);
   dc488:	f003 fa9a 	bl	df9c0 <__aeabi_d2ulz>
   dc48c:	4680      	mov	r8, r0
   dc48e:	4689      	mov	r9, r1
    if ((val-fixed)>=0.5)    // round last digit
   dc490:	f002 ff3e 	bl	df310 <__aeabi_ul2d>
   dc494:	4602      	mov	r2, r0
   dc496:	460b      	mov	r3, r1
   dc498:	4650      	mov	r0, sl
   dc49a:	4659      	mov	r1, fp
   dc49c:	f002 fdba 	bl	df014 <__aeabi_dsub>
   dc4a0:	2200      	movs	r2, #0
   dc4a2:	4b17      	ldr	r3, [pc, #92]	; (dc500 <_Z4dtoadhPc+0xc4>)
   dc4a4:	f003 f9f0 	bl	df888 <__aeabi_dcmpge>
   dc4a8:	b118      	cbz	r0, dc4b2 <_Z4dtoadhPc+0x76>
        fixed++;
   dc4aa:	f118 0801 	adds.w	r8, r8, #1
   dc4ae:	f149 0900 	adc.w	r9, r9, #0

    unsigned long first = (unsigned long)(fixed / scale);
   dc4b2:	17e5      	asrs	r5, r4, #31
    unsigned long second = (unsigned long)(fixed % scale);

    ultoa(first, sout, 10, 1);
   dc4b4:	4622      	mov	r2, r4
   dc4b6:	462b      	mov	r3, r5
   dc4b8:	4640      	mov	r0, r8
   dc4ba:	4649      	mov	r1, r9
   dc4bc:	f003 fa68 	bl	df990 <__aeabi_uldivmod>
   dc4c0:	2301      	movs	r3, #1
   dc4c2:	220a      	movs	r2, #10
   dc4c4:	4631      	mov	r1, r6
   dc4c6:	f7ff ff75 	bl	dc3b4 <ultoa>
    if (prec) {
   dc4ca:	b1af      	cbz	r7, dc4f8 <_Z4dtoadhPc+0xbc>
        sout += strlen(sout);
   dc4cc:	4630      	mov	r0, r6
   dc4ce:	f003 fdcb 	bl	e0068 <strlen>
        *sout++ = '.';
   dc4d2:	232e      	movs	r3, #46	; 0x2e
   dc4d4:	5433      	strb	r3, [r6, r0]
        ultoa(second, sout, 10, prec);
   dc4d6:	3001      	adds	r0, #1
   dc4d8:	4406      	add	r6, r0
   dc4da:	4622      	mov	r2, r4
   dc4dc:	462b      	mov	r3, r5
   dc4de:	4640      	mov	r0, r8
   dc4e0:	4649      	mov	r1, r9
   dc4e2:	f003 fa55 	bl	df990 <__aeabi_uldivmod>
   dc4e6:	463b      	mov	r3, r7
   dc4e8:	4610      	mov	r0, r2
   dc4ea:	4631      	mov	r1, r6
   dc4ec:	220a      	movs	r2, #10
    }
}
   dc4ee:	b001      	add	sp, #4
   dc4f0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    ultoa(first, sout, 10, 1);
    if (prec) {
        sout += strlen(sout);
        *sout++ = '.';
        ultoa(second, sout, 10, prec);
   dc4f4:	f7ff bf5e 	b.w	dc3b4 <ultoa>
    }
}
   dc4f8:	b001      	add	sp, #4
   dc4fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   dc4fe:	bf00      	nop
   dc500:	3fe00000 	.word	0x3fe00000

000dc504 <_ZN6StringC1EOS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc504:	2300      	movs	r3, #0
   dc506:	6003      	str	r3, [r0, #0]
	capacity = 0;
   dc508:	6043      	str	r3, [r0, #4]
	len = 0;
   dc50a:	6083      	str	r3, [r0, #8]
	flags = 0;
   dc50c:	7303      	strb	r3, [r0, #12]
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
   dc50e:	b510      	push	{r4, lr}
			return;
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
   dc510:	680c      	ldr	r4, [r1, #0]
   dc512:	6004      	str	r4, [r0, #0]
	capacity = rhs.capacity;
   dc514:	684c      	ldr	r4, [r1, #4]
   dc516:	6044      	str	r4, [r0, #4]
	len = rhs.len;
   dc518:	688c      	ldr	r4, [r1, #8]
   dc51a:	6084      	str	r4, [r0, #8]
	rhs.buffer = NULL;
   dc51c:	600b      	str	r3, [r1, #0]
	rhs.capacity = 0;
   dc51e:	604b      	str	r3, [r1, #4]
	rhs.len = 0;
   dc520:	608b      	str	r3, [r1, #8]
#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
{
	init();
	move(rval);
}
   dc522:	bd10      	pop	{r4, pc}

000dc524 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
   dc524:	b510      	push	{r4, lr}
   dc526:	4604      	mov	r4, r0
{
	free(buffer);
   dc528:	6800      	ldr	r0, [r0, #0]
   dc52a:	f7ff fc4d 	bl	dbdc8 <free>
}
   dc52e:	4620      	mov	r0, r4
   dc530:	bd10      	pop	{r4, pc}

000dc532 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
   dc532:	b510      	push	{r4, lr}
   dc534:	4604      	mov	r4, r0
	if (buffer) free(buffer);
   dc536:	6800      	ldr	r0, [r0, #0]
   dc538:	b108      	cbz	r0, dc53e <_ZN6String10invalidateEv+0xc>
   dc53a:	f7ff fc45 	bl	dbdc8 <free>
	buffer = NULL;
   dc53e:	2300      	movs	r3, #0
   dc540:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
   dc542:	60a3      	str	r3, [r4, #8]
   dc544:	6063      	str	r3, [r4, #4]
   dc546:	bd10      	pop	{r4, pc}

000dc548 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
   dc548:	b538      	push	{r3, r4, r5, lr}
   dc54a:	4604      	mov	r4, r0
   dc54c:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
   dc54e:	6800      	ldr	r0, [r0, #0]
   dc550:	3101      	adds	r1, #1
   dc552:	f7ff fc41 	bl	dbdd8 <realloc>
	if (newbuffer) {
   dc556:	b110      	cbz	r0, dc55e <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
   dc558:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
   dc55c:	2001      	movs	r0, #1
	}
	return 0;
}
   dc55e:	bd38      	pop	{r3, r4, r5, pc}

000dc560 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
   dc560:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
   dc562:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
   dc564:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
   dc566:	b113      	cbz	r3, dc56e <_ZN6String7reserveEj+0xe>
   dc568:	6843      	ldr	r3, [r0, #4]
   dc56a:	428b      	cmp	r3, r1
   dc56c:	d207      	bcs.n	dc57e <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
   dc56e:	4620      	mov	r0, r4
   dc570:	f7ff ffea 	bl	dc548 <_ZN6String12changeBufferEj>
   dc574:	b120      	cbz	r0, dc580 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
   dc576:	68a3      	ldr	r3, [r4, #8]
   dc578:	b90b      	cbnz	r3, dc57e <_ZN6String7reserveEj+0x1e>
   dc57a:	6822      	ldr	r2, [r4, #0]
   dc57c:	7013      	strb	r3, [r2, #0]
   dc57e:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
   dc580:	bd10      	pop	{r4, pc}

000dc582 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   dc582:	b570      	push	{r4, r5, r6, lr}
   dc584:	460e      	mov	r6, r1
	if (!reserve(length)) {
   dc586:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   dc588:	4604      	mov	r4, r0
   dc58a:	4615      	mov	r5, r2
	if (!reserve(length)) {
   dc58c:	f7ff ffe8 	bl	dc560 <_ZN6String7reserveEj>
   dc590:	b918      	cbnz	r0, dc59a <_ZN6String4copyEPKcj+0x18>
		invalidate();
   dc592:	4620      	mov	r0, r4
   dc594:	f7ff ffcd 	bl	dc532 <_ZN6String10invalidateEv>
		return *this;
   dc598:	e009      	b.n	dc5ae <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
   dc59a:	462a      	mov	r2, r5
   dc59c:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
   dc59e:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
   dc5a0:	6820      	ldr	r0, [r4, #0]
   dc5a2:	f003 fcd6 	bl	dff52 <memcpy>
	buffer[len] = 0;
   dc5a6:	6822      	ldr	r2, [r4, #0]
   dc5a8:	68a3      	ldr	r3, [r4, #8]
   dc5aa:	2100      	movs	r1, #0
   dc5ac:	54d1      	strb	r1, [r2, r3]
	return *this;
}
   dc5ae:	4620      	mov	r0, r4
   dc5b0:	bd70      	pop	{r4, r5, r6, pc}

000dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
   dc5b2:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc5b4:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
   dc5b6:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc5b8:	6003      	str	r3, [r0, #0]
	capacity = 0;
   dc5ba:	6043      	str	r3, [r0, #4]
	len = 0;
   dc5bc:	6083      	str	r3, [r0, #8]
	flags = 0;
   dc5be:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
   dc5c0:	460d      	mov	r5, r1
   dc5c2:	b139      	cbz	r1, dc5d4 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
   dc5c4:	4608      	mov	r0, r1
   dc5c6:	f003 fd4f 	bl	e0068 <strlen>
   dc5ca:	4629      	mov	r1, r5
   dc5cc:	4602      	mov	r2, r0
   dc5ce:	4620      	mov	r0, r4
   dc5d0:	f7ff ffd7 	bl	dc582 <_ZN6String4copyEPKcj>
}
   dc5d4:	4620      	mov	r0, r4
   dc5d6:	bd38      	pop	{r3, r4, r5, pc}

000dc5d8 <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
   dc5d8:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
   dc5da:	b510      	push	{r4, lr}
   dc5dc:	460b      	mov	r3, r1
   dc5de:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
   dc5e0:	d007      	beq.n	dc5f2 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
   dc5e2:	6809      	ldr	r1, [r1, #0]
   dc5e4:	b119      	cbz	r1, dc5ee <_ZN6StringaSERKS_+0x16>
   dc5e6:	689a      	ldr	r2, [r3, #8]
   dc5e8:	f7ff ffcb 	bl	dc582 <_ZN6String4copyEPKcj>
   dc5ec:	e001      	b.n	dc5f2 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
   dc5ee:	f7ff ffa0 	bl	dc532 <_ZN6String10invalidateEv>

	return *this;
}
   dc5f2:	4620      	mov	r0, r4
   dc5f4:	bd10      	pop	{r4, pc}

000dc5f6 <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
   dc5f6:	b510      	push	{r4, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc5f8:	2300      	movs	r3, #0
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
   dc5fa:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc5fc:	6003      	str	r3, [r0, #0]
	capacity = 0;
   dc5fe:	6043      	str	r3, [r0, #4]
	len = 0;
   dc600:	6083      	str	r3, [r0, #8]
	flags = 0;
   dc602:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
   dc604:	f7ff ffe8 	bl	dc5d8 <_ZN6StringaSERKS_>
}
   dc608:	4620      	mov	r0, r4
   dc60a:	bd10      	pop	{r4, pc}

000dc60c <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
   dc60c:	b538      	push	{r3, r4, r5, lr}
   dc60e:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
   dc610:	460c      	mov	r4, r1
   dc612:	b141      	cbz	r1, dc626 <_ZN6StringaSEPKc+0x1a>
   dc614:	4608      	mov	r0, r1
   dc616:	f003 fd27 	bl	e0068 <strlen>
   dc61a:	4621      	mov	r1, r4
   dc61c:	4602      	mov	r2, r0
   dc61e:	4628      	mov	r0, r5
   dc620:	f7ff ffaf 	bl	dc582 <_ZN6String4copyEPKcj>
   dc624:	e001      	b.n	dc62a <_ZN6StringaSEPKc+0x1e>
	else invalidate();
   dc626:	f7ff ff84 	bl	dc532 <_ZN6String10invalidateEv>

	return *this;
}
   dc62a:	4628      	mov	r0, r5
   dc62c:	bd38      	pop	{r3, r4, r5, pc}

000dc62e <_ZN6StringC1Ehh>:
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
}

String::String(unsigned char value, unsigned char base)
   dc62e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   dc630:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc632:	2300      	movs	r3, #0
   dc634:	6023      	str	r3, [r4, #0]
	capacity = 0;
   dc636:	6063      	str	r3, [r4, #4]
	len = 0;
   dc638:	60a3      	str	r3, [r4, #8]
	flags = 0;
   dc63a:	7323      	strb	r3, [r4, #12]
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
}

String::String(unsigned char value, unsigned char base)
   dc63c:	4608      	mov	r0, r1
{
	init();
	char buf[9];
	utoa(value, buf, base);
   dc63e:	a901      	add	r1, sp, #4
   dc640:	f7ff fef6 	bl	dc430 <utoa>
	*this = buf;
   dc644:	a901      	add	r1, sp, #4
   dc646:	4620      	mov	r0, r4
   dc648:	f7ff ffe0 	bl	dc60c <_ZN6StringaSEPKc>
}
   dc64c:	4620      	mov	r0, r4
   dc64e:	b004      	add	sp, #16
   dc650:	bd10      	pop	{r4, pc}

000dc652 <_ZN6StringC1Eih>:

String::String(int value, unsigned char base)
   dc652:	b510      	push	{r4, lr}
   dc654:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc656:	2300      	movs	r3, #0
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
   dc658:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc65a:	6023      	str	r3, [r4, #0]
	capacity = 0;
   dc65c:	6063      	str	r3, [r4, #4]
	len = 0;
   dc65e:	60a3      	str	r3, [r4, #8]
	flags = 0;
   dc660:	7323      	strb	r3, [r4, #12]
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
   dc662:	4608      	mov	r0, r1
{
	init();
	char buf[34];
	itoa(value, buf, base);
   dc664:	a901      	add	r1, sp, #4
   dc666:	f7ff fecd 	bl	dc404 <itoa>
	*this = buf;
   dc66a:	a901      	add	r1, sp, #4
   dc66c:	4620      	mov	r0, r4
   dc66e:	f7ff ffcd 	bl	dc60c <_ZN6StringaSEPKc>
}
   dc672:	4620      	mov	r0, r4
   dc674:	b00a      	add	sp, #40	; 0x28
   dc676:	bd10      	pop	{r4, pc}

000dc678 <_ZN6StringC1Elh>:
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
   dc678:	b510      	push	{r4, lr}
   dc67a:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc67c:	2300      	movs	r3, #0
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
   dc67e:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc680:	6023      	str	r3, [r4, #0]
	capacity = 0;
   dc682:	6063      	str	r3, [r4, #4]
	len = 0;
   dc684:	60a3      	str	r3, [r4, #8]
	flags = 0;
   dc686:	7323      	strb	r3, [r4, #12]
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
   dc688:	4608      	mov	r0, r1
{
	init();
	char buf[34];
	ltoa(value, buf, base);
   dc68a:	a901      	add	r1, sp, #4
   dc68c:	f7ff fe53 	bl	dc336 <ltoa>
	*this = buf;
   dc690:	a901      	add	r1, sp, #4
   dc692:	4620      	mov	r0, r4
   dc694:	f7ff ffba 	bl	dc60c <_ZN6StringaSEPKc>
}
   dc698:	4620      	mov	r0, r4
   dc69a:	b00a      	add	sp, #40	; 0x28
   dc69c:	bd10      	pop	{r4, pc}

000dc69e <_ZN6StringC1Emh>:

String::String(unsigned long value, unsigned char base)
   dc69e:	b510      	push	{r4, lr}
   dc6a0:	4604      	mov	r4, r0
   dc6a2:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc6a4:	2300      	movs	r3, #0
   dc6a6:	6023      	str	r3, [r4, #0]
	capacity = 0;
   dc6a8:	6063      	str	r3, [r4, #4]
	len = 0;
   dc6aa:	60a3      	str	r3, [r4, #8]
	flags = 0;
   dc6ac:	7323      	strb	r3, [r4, #12]
	char buf[34];
	ltoa(value, buf, base);
	*this = buf;
}

String::String(unsigned long value, unsigned char base)
   dc6ae:	4608      	mov	r0, r1
{
	init();
	char buf[33];
	ultoa(value, buf, base);
   dc6b0:	2301      	movs	r3, #1
   dc6b2:	a901      	add	r1, sp, #4
   dc6b4:	f7ff fe7e 	bl	dc3b4 <ultoa>
	*this = buf;
   dc6b8:	a901      	add	r1, sp, #4
   dc6ba:	4620      	mov	r0, r4
   dc6bc:	f7ff ffa6 	bl	dc60c <_ZN6StringaSEPKc>
}
   dc6c0:	4620      	mov	r0, r4
   dc6c2:	b00a      	add	sp, #40	; 0x28
   dc6c4:	bd10      	pop	{r4, pc}

000dc6c6 <_ZN6StringC1Efi>:

String::String(float value, int decimalPlaces)
   dc6c6:	b530      	push	{r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc6c8:	2300      	movs	r3, #0
	char buf[33];
	ultoa(value, buf, base);
	*this = buf;
}

String::String(float value, int decimalPlaces)
   dc6ca:	b08b      	sub	sp, #44	; 0x2c
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
   dc6cc:	6003      	str	r3, [r0, #0]
	capacity = 0;
   dc6ce:	6043      	str	r3, [r0, #4]
	len = 0;
   dc6d0:	6083      	str	r3, [r0, #8]
	flags = 0;
   dc6d2:	7303      	strb	r3, [r0, #12]
	char buf[33];
	ultoa(value, buf, base);
	*this = buf;
}

String::String(float value, int decimalPlaces)
   dc6d4:	4604      	mov	r4, r0
{
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
   dc6d6:	ee10 0a10 	vmov	r0, s0
   dc6da:	b2cd      	uxtb	r5, r1
   dc6dc:	f002 fdfa 	bl	df2d4 <__aeabi_f2d>
   dc6e0:	ec41 0b10 	vmov	d0, r0, r1
   dc6e4:	a901      	add	r1, sp, #4
   dc6e6:	4628      	mov	r0, r5
   dc6e8:	f7ff fea8 	bl	dc43c <_Z4dtoadhPc>
        *this = buf;
   dc6ec:	a901      	add	r1, sp, #4
   dc6ee:	4620      	mov	r0, r4
   dc6f0:	f7ff ff8c 	bl	dc60c <_ZN6StringaSEPKc>
}
   dc6f4:	4620      	mov	r0, r4
   dc6f6:	b00b      	add	sp, #44	; 0x2c
   dc6f8:	bd30      	pop	{r4, r5, pc}

000dc6fa <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
   dc6fa:	b570      	push	{r4, r5, r6, lr}
   dc6fc:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
   dc6fe:	460e      	mov	r6, r1
   dc700:	b909      	cbnz	r1, dc706 <_ZN6String6concatEPKcj+0xc>
   dc702:	2000      	movs	r0, #0
   dc704:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
   dc706:	b16a      	cbz	r2, dc724 <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
   dc708:	6883      	ldr	r3, [r0, #8]
   dc70a:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
   dc70c:	4629      	mov	r1, r5
   dc70e:	f7ff ff27 	bl	dc560 <_ZN6String7reserveEj>
   dc712:	2800      	cmp	r0, #0
   dc714:	d0f5      	beq.n	dc702 <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
   dc716:	6820      	ldr	r0, [r4, #0]
   dc718:	68a3      	ldr	r3, [r4, #8]
   dc71a:	4631      	mov	r1, r6
   dc71c:	4418      	add	r0, r3
   dc71e:	f003 fc6b 	bl	dfff8 <strcpy>
	len = newlen;
   dc722:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
   dc724:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
   dc726:	bd70      	pop	{r4, r5, r6, pc}

000dc728 <_ZN6String6concatERKS_>:
/*  concat                                   */
/*********************************************/

unsigned char String::concat(const String &s)
{
	return concat(s.buffer, s.len);
   dc728:	688a      	ldr	r2, [r1, #8]
   dc72a:	6809      	ldr	r1, [r1, #0]
   dc72c:	f7ff bfe5 	b.w	dc6fa <_ZN6String6concatEPKcj>

000dc730 <_ZN6String6concatEPKc>:
	len = newlen;
	return 1;
}

unsigned char String::concat(const char *cstr)
{
   dc730:	b538      	push	{r3, r4, r5, lr}
   dc732:	4605      	mov	r5, r0
	if (!cstr) return 0;
   dc734:	460c      	mov	r4, r1
	return concat(cstr, strlen(cstr));
}
   dc736:	4608      	mov	r0, r1
	return 1;
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
   dc738:	b141      	cbz	r1, dc74c <_ZN6String6concatEPKc+0x1c>
	return concat(cstr, strlen(cstr));
   dc73a:	f003 fc95 	bl	e0068 <strlen>
   dc73e:	4621      	mov	r1, r4
   dc740:	4602      	mov	r2, r0
   dc742:	4628      	mov	r0, r5
}
   dc744:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
   dc748:	f7ff bfd7 	b.w	dc6fa <_ZN6String6concatEPKcj>
}
   dc74c:	bd38      	pop	{r3, r4, r5, pc}

000dc74e <_ZN6String6concatEc>:
unsigned char String::concat(const __FlashStringHelper * str) {
	return concat(reinterpret_cast<const char*>(str));
}

unsigned char String::concat(char c)
{
   dc74e:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
   dc750:	2300      	movs	r3, #0
}

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
   dc752:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	return concat(buf, 1);
   dc756:	2201      	movs	r2, #1
   dc758:	a901      	add	r1, sp, #4

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
   dc75a:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
   dc75e:	f7ff ffcc 	bl	dc6fa <_ZN6String6concatEPKcj>
}
   dc762:	b003      	add	sp, #12
   dc764:	f85d fb04 	ldr.w	pc, [sp], #4

000dc768 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
   dc768:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
   dc76a:	688a      	ldr	r2, [r1, #8]
   dc76c:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
   dc76e:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
   dc770:	f7ff ffc3 	bl	dc6fa <_ZN6String6concatEPKcj>
   dc774:	b910      	cbnz	r0, dc77c <_ZplRK15StringSumHelperRK6String+0x14>
   dc776:	4620      	mov	r0, r4
   dc778:	f7ff fedb 	bl	dc532 <_ZN6String10invalidateEv>
	return a;
}
   dc77c:	4620      	mov	r0, r4
   dc77e:	bd10      	pop	{r4, pc}

000dc780 <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
   dc780:	b538      	push	{r3, r4, r5, lr}
   dc782:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
   dc784:	460d      	mov	r5, r1
   dc786:	b141      	cbz	r1, dc79a <_ZplRK15StringSumHelperPKc+0x1a>
   dc788:	4608      	mov	r0, r1
   dc78a:	f003 fc6d 	bl	e0068 <strlen>
   dc78e:	4629      	mov	r1, r5
   dc790:	4602      	mov	r2, r0
   dc792:	4620      	mov	r0, r4
   dc794:	f7ff ffb1 	bl	dc6fa <_ZN6String6concatEPKcj>
   dc798:	b910      	cbnz	r0, dc7a0 <_ZplRK15StringSumHelperPKc+0x20>
   dc79a:	4620      	mov	r0, r4
   dc79c:	f7ff fec9 	bl	dc532 <_ZN6String10invalidateEv>
	return a;
}
   dc7a0:	4620      	mov	r0, r4
   dc7a2:	bd38      	pop	{r3, r4, r5, pc}

000dc7a4 <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
   dc7a4:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
   dc7a6:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
   dc7a8:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
   dc7aa:	b912      	cbnz	r2, dc7b2 <_ZNK6String6equalsEPKc+0xe>
   dc7ac:	b919      	cbnz	r1, dc7b6 <_ZNK6String6equalsEPKc+0x12>
   dc7ae:	2001      	movs	r0, #1
   dc7b0:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
   dc7b2:	b911      	cbnz	r1, dc7ba <_ZNK6String6equalsEPKc+0x16>
   dc7b4:	6803      	ldr	r3, [r0, #0]
   dc7b6:	7818      	ldrb	r0, [r3, #0]
   dc7b8:	e002      	b.n	dc7c0 <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
   dc7ba:	6800      	ldr	r0, [r0, #0]
   dc7bc:	f003 fc12 	bl	dffe4 <strcmp>
   dc7c0:	fab0 f080 	clz	r0, r0
   dc7c4:	0940      	lsrs	r0, r0, #5
}
   dc7c6:	bd08      	pop	{r3, pc}

000dc7c8 <_ZNK6String8endsWithERKS_>:
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}

unsigned char String::endsWith( const String &s2 ) const
{
   dc7c8:	b508      	push	{r3, lr}
	if ( len < s2.len || !buffer || !s2.buffer) return 0;
   dc7ca:	6883      	ldr	r3, [r0, #8]
   dc7cc:	688a      	ldr	r2, [r1, #8]
   dc7ce:	4293      	cmp	r3, r2
   dc7d0:	d30b      	bcc.n	dc7ea <_ZNK6String8endsWithERKS_+0x22>
   dc7d2:	6800      	ldr	r0, [r0, #0]
   dc7d4:	b160      	cbz	r0, dc7f0 <_ZNK6String8endsWithERKS_+0x28>
   dc7d6:	6809      	ldr	r1, [r1, #0]
   dc7d8:	b149      	cbz	r1, dc7ee <_ZNK6String8endsWithERKS_+0x26>
	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
   dc7da:	1a9b      	subs	r3, r3, r2
   dc7dc:	4418      	add	r0, r3
   dc7de:	f003 fc01 	bl	dffe4 <strcmp>
   dc7e2:	fab0 f080 	clz	r0, r0
   dc7e6:	0940      	lsrs	r0, r0, #5
   dc7e8:	bd08      	pop	{r3, pc}
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}

unsigned char String::endsWith( const String &s2 ) const
{
	if ( len < s2.len || !buffer || !s2.buffer) return 0;
   dc7ea:	2000      	movs	r0, #0
   dc7ec:	bd08      	pop	{r3, pc}
   dc7ee:	4608      	mov	r0, r1
	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
}
   dc7f0:	bd08      	pop	{r3, pc}

000dc7f2 <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
   dc7f2:	6800      	ldr	r0, [r0, #0]
   dc7f4:	b108      	cbz	r0, dc7fa <_ZNK6String5toIntEv+0x8>
   dc7f6:	f003 ba7f 	b.w	dfcf8 <atol>
	return 0;
}
   dc7fa:	4770      	bx	lr

000dc7fc <_ZN6String6formatEPKcz>:
    StringPrintableHelper help(*this);
    printable.printTo(help);
}

String String::format(const char* fmt, ...)
{
   dc7fc:	b40e      	push	{r1, r2, r3}
   dc7fe:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
   dc800:	ac09      	add	r4, sp, #36	; 0x24
   dc802:	4605      	mov	r5, r0
   dc804:	f854 7b04 	ldr.w	r7, [r4], #4
    va_list marker;
    va_start(marker, fmt);
   dc808:	9401      	str	r4, [sp, #4]
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
   dc80a:	4623      	mov	r3, r4
   dc80c:	463a      	mov	r2, r7
   dc80e:	2105      	movs	r1, #5
   dc810:	a802      	add	r0, sp, #8
   dc812:	f7ff faf9 	bl	dbe08 <vsnprintf>
    va_end(marker);

    String result;
   dc816:	490c      	ldr	r1, [pc, #48]	; (dc848 <_ZN6String6formatEPKcz+0x4c>)
{
    va_list marker;
    va_start(marker, fmt);
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
   dc818:	4606      	mov	r6, r0
    va_end(marker);

    String result;
   dc81a:	4628      	mov	r0, r5
   dc81c:	f7ff fec9 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    result.reserve(n);  // internally adds +1 for null terminator
   dc820:	4631      	mov	r1, r6
   dc822:	4628      	mov	r0, r5
   dc824:	f7ff fe9c 	bl	dc560 <_ZN6String7reserveEj>
    if (result.buffer) {
   dc828:	6828      	ldr	r0, [r5, #0]
   dc82a:	b130      	cbz	r0, dc83a <_ZN6String6formatEPKcz+0x3e>
        va_start(marker, fmt);
        n = vsnprintf(result.buffer, n+1, fmt, marker);
   dc82c:	4623      	mov	r3, r4
   dc82e:	463a      	mov	r2, r7
   dc830:	1c71      	adds	r1, r6, #1
    va_end(marker);

    String result;
    result.reserve(n);  // internally adds +1 for null terminator
    if (result.buffer) {
        va_start(marker, fmt);
   dc832:	9401      	str	r4, [sp, #4]
        n = vsnprintf(result.buffer, n+1, fmt, marker);
   dc834:	f7ff fae8 	bl	dbe08 <vsnprintf>
        va_end(marker);
        result.len = n;
   dc838:	60a8      	str	r0, [r5, #8]
    }
    return result;
}
   dc83a:	4628      	mov	r0, r5
   dc83c:	b004      	add	sp, #16
   dc83e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   dc842:	b003      	add	sp, #12
   dc844:	4770      	bx	lr
   dc846:	bf00      	nop
   dc848:	000e1eea 	.word	0x000e1eea

000dc84c <_ZNSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   dc84c:	4770      	bx	lr

000dc84e <_ZNSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
   dc84e:	2000      	movs	r0, #0
   dc850:	4770      	bx	lr

000dc852 <_ZNSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   dc852:	b510      	push	{r4, lr}
   dc854:	2114      	movs	r1, #20
   dc856:	4604      	mov	r4, r0
   dc858:	f002 fa7a 	bl	ded50 <_ZdlPvj>
   dc85c:	4620      	mov	r0, r4
   dc85e:	bd10      	pop	{r4, pc}

000dc860 <_ZNSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   dc860:	f7f7 bc1d 	b.w	d409e <_ZdlPv>

000dc864 <_ZN14RecursiveMutexD1Ev>:
    RecursiveMutex() : handle_(nullptr)
    {
        os_mutex_recursive_create(&handle_);
    }

    ~RecursiveMutex() {
   dc864:	b510      	push	{r4, lr}
   dc866:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (handle_) {
   dc868:	6800      	ldr	r0, [r0, #0]
   dc86a:	b108      	cbz	r0, dc870 <_ZN14RecursiveMutexD1Ev+0xc>
            os_mutex_recursive_destroy(handle_);
   dc86c:	f7ff f83e 	bl	db8ec <os_mutex_recursive_destroy>
        os_mutex_recursive_create(&handle_);
    }

    ~RecursiveMutex() {
        dispose();
    }
   dc870:	4620      	mov	r0, r4
   dc872:	bd10      	pop	{r4, pc}

000dc874 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.102>:


/*******************************************************
 * BlePeerDevice class
 */
BlePeerDevice::BlePeerDevice()
   dc874:	b508      	push	{r3, lr}
        : impl_(std::make_shared<BlePeerDeviceImpl>()) {
    if (!impl()) {
        SPARK_ASSERT(false);
   dc876:	200a      	movs	r0, #10
   dc878:	4a02      	ldr	r2, [pc, #8]	; (dc884 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.102+0x10>)
   dc87a:	2100      	movs	r1, #0
   dc87c:	f7ff f98e 	bl	dbb9c <panic_>
    }
}
   dc880:	bd08      	pop	{r3, pc}
   dc882:	bf00      	nop
   dc884:	000db7c5 	.word	0x000db7c5

000dc888 <_ZN8particle3ble13WiringBleLockC1Ev>:

namespace ble {

class WiringBleLock {
public:
    WiringBleLock() :
   dc888:	b510      	push	{r4, lr}
            locked_(false) {
   dc88a:	2300      	movs	r3, #0
   dc88c:	7003      	strb	r3, [r0, #0]
            os_mutex_recursive_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
   dc88e:	4b04      	ldr	r3, [pc, #16]	; (dc8a0 <_ZN8particle3ble13WiringBleLockC1Ev+0x18>)

namespace ble {

class WiringBleLock {
public:
    WiringBleLock() :
   dc890:	4604      	mov	r4, r0
   dc892:	6818      	ldr	r0, [r3, #0]
   dc894:	f7ff f832 	bl	db8fc <os_mutex_recursive_lock>
        lock.locked_ = false;
    }

    void lock() {
        mutex_.lock();
        locked_ = true;
   dc898:	2301      	movs	r3, #1
   dc89a:	7023      	strb	r3, [r4, #0]
class WiringBleLock {
public:
    WiringBleLock() :
            locked_(false) {
        lock();
    }
   dc89c:	4620      	mov	r0, r4
   dc89e:	bd10      	pop	{r4, pc}
   dc8a0:	2003e454 	.word	0x2003e454

000dc8a4 <_ZN8particle3ble13WiringBleLockD1Ev>:

    ~WiringBleLock() {
   dc8a4:	b510      	push	{r4, lr}
        if (locked_) {
   dc8a6:	7803      	ldrb	r3, [r0, #0]
    WiringBleLock() :
            locked_(false) {
        lock();
    }

    ~WiringBleLock() {
   dc8a8:	4604      	mov	r4, r0
        if (locked_) {
   dc8aa:	b11b      	cbz	r3, dc8b4 <_ZN8particle3ble13WiringBleLockD1Ev+0x10>
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    void unlock() { os_mutex_recursive_unlock(handle_); }
   dc8ac:	4b02      	ldr	r3, [pc, #8]	; (dc8b8 <_ZN8particle3ble13WiringBleLockD1Ev+0x14>)
   dc8ae:	6818      	ldr	r0, [r3, #0]
   dc8b0:	f7ff f82c 	bl	db90c <os_mutex_recursive_unlock>
            unlock();
        }
    }
   dc8b4:	4620      	mov	r0, r4
   dc8b6:	bd10      	pop	{r4, pc}
   dc8b8:	2003e454 	.word	0x2003e454

000dc8bc <_ZNK8particle10BleAddresseqERKS0_>:
BleAddress& BleAddress::operator=(const uint8_t addr[BLE_SIG_ADDR_LEN]) {
    memcpy(address_.addr, addr, BLE_SIG_ADDR_LEN);
    return *this;
}

bool BleAddress::operator==(const BleAddress& addr) const {
   dc8bc:	b508      	push	{r3, lr}
    if (address_.addr_type == addr.address_.addr_type && !memcmp(address_.addr, addr.address_.addr, BLE_SIG_ADDR_LEN)) {
   dc8be:	7982      	ldrb	r2, [r0, #6]
   dc8c0:	798b      	ldrb	r3, [r1, #6]
   dc8c2:	429a      	cmp	r2, r3
   dc8c4:	d106      	bne.n	dc8d4 <_ZNK8particle10BleAddresseqERKS0_+0x18>
   dc8c6:	2206      	movs	r2, #6
   dc8c8:	f003 fb34 	bl	dff34 <memcmp>
   dc8cc:	fab0 f080 	clz	r0, r0
   dc8d0:	0940      	lsrs	r0, r0, #5
   dc8d2:	bd08      	pop	{r3, pc}
        return true;
    }
    return false;
   dc8d4:	2000      	movs	r0, #0
}
   dc8d6:	bd08      	pop	{r3, pc}

000dc8d8 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>:
    void onDisconnectedCallback(BleOnDisconnectedCallback callback, void* context) {
        disconnectedCb_ = callback;
        disconnectedContext_ = context;
    }

    BlePeerDevice* findPeerDevice(BleConnectionHandle connHandle) {
   dc8d8:	b510      	push	{r4, lr}
   dc8da:	6983      	ldr	r3, [r0, #24]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
   dc8dc:	69c2      	ldr	r2, [r0, #28]
   dc8de:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        for (auto& peer : peers_) {
   dc8e2:	4293      	cmp	r3, r2
   dc8e4:	4618      	mov	r0, r3
   dc8e6:	d006      	beq.n	dc8f6 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt+0x1e>
            if (peer.impl()->connHandle() == connHandle) {
   dc8e8:	6804      	ldr	r4, [r0, #0]
   dc8ea:	8824      	ldrh	r4, [r4, #0]
   dc8ec:	428c      	cmp	r4, r1
   dc8ee:	f103 0308 	add.w	r3, r3, #8
   dc8f2:	d1f6      	bne.n	dc8e2 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt+0xa>
   dc8f4:	bd10      	pop	{r4, pc}
                return &peer;
            }
        }
        return nullptr;
   dc8f6:	2000      	movs	r0, #0
    }
   dc8f8:	bd10      	pop	{r4, pc}

000dc8fa <_ZNK8particle13BlePeerDevice7addressEv>:

void BlePeerDevice::bind(const BleAddress& address) const {
    impl()->address() = address;
}

BleAddress BlePeerDevice::address() const {
   dc8fa:	b510      	push	{r4, lr}
    return impl()->address();
   dc8fc:	680a      	ldr	r2, [r1, #0]
   dc8fe:	f852 3f02 	ldr.w	r3, [r2, #2]!
   dc902:	6003      	str	r3, [r0, #0]
   dc904:	6853      	ldr	r3, [r2, #4]
   dc906:	6043      	str	r3, [r0, #4]
}
   dc908:	bd10      	pop	{r4, pc}

000dc90a <_ZNK8particle13BlePeerDeviceeqERKS0_>:

bool BlePeerDevice::operator==(const BlePeerDevice& device) const {
   dc90a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (impl()->connHandle() == device.impl()->connHandle() && address() == device.address()) {
   dc90c:	6802      	ldr	r2, [r0, #0]
   dc90e:	680b      	ldr	r3, [r1, #0]
   dc910:	8812      	ldrh	r2, [r2, #0]
   dc912:	881b      	ldrh	r3, [r3, #0]
   dc914:	429a      	cmp	r2, r3

BleAddress BlePeerDevice::address() const {
    return impl()->address();
}

bool BlePeerDevice::operator==(const BlePeerDevice& device) const {
   dc916:	460c      	mov	r4, r1
    if (impl()->connHandle() == device.impl()->connHandle() && address() == device.address()) {
   dc918:	d10c      	bne.n	dc934 <_ZNK8particle13BlePeerDeviceeqERKS0_+0x2a>
   dc91a:	4601      	mov	r1, r0
   dc91c:	4668      	mov	r0, sp
   dc91e:	f7ff ffec 	bl	dc8fa <_ZNK8particle13BlePeerDevice7addressEv>
   dc922:	4621      	mov	r1, r4
   dc924:	a802      	add	r0, sp, #8
   dc926:	f7ff ffe8 	bl	dc8fa <_ZNK8particle13BlePeerDevice7addressEv>
   dc92a:	a902      	add	r1, sp, #8
   dc92c:	4668      	mov	r0, sp
   dc92e:	f7ff ffc5 	bl	dc8bc <_ZNK8particle10BleAddresseqERKS0_>
   dc932:	b900      	cbnz	r0, dc936 <_ZNK8particle13BlePeerDeviceeqERKS0_+0x2c>
        return true;
    }
    return false;
   dc934:	2000      	movs	r0, #0
}
   dc936:	b004      	add	sp, #16
   dc938:	bd10      	pop	{r4, pc}
	...

000dc93c <_ZN8particle14BleLocalDeviceC1Ev>:


/*******************************************************
 * BleLocalDevice class
 */
BleLocalDevice::BleLocalDevice()
   dc93c:	b510      	push	{r4, lr}
   dc93e:	4604      	mov	r4, r0

  /// std::make_unique for single objects
  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
   dc940:	2034      	movs	r0, #52	; 0x34
   dc942:	f7f7 fbaa 	bl	d409a <_Znwj>
   dc946:	4601      	mov	r1, r0
   dc948:	b168      	cbz	r0, dc966 <_ZN8particle14BleLocalDeviceC1Ev+0x2a>
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
   dc94a:	2300      	movs	r3, #0
   dc94c:	6003      	str	r3, [r0, #0]
   dc94e:	6043      	str	r3, [r0, #4]
   dc950:	6083      	str	r3, [r0, #8]
   dc952:	60c3      	str	r3, [r0, #12]
   dc954:	6103      	str	r3, [r0, #16]
   dc956:	6143      	str	r3, [r0, #20]
   dc958:	6183      	str	r3, [r0, #24]
   dc95a:	61c3      	str	r3, [r0, #28]
   dc95c:	6203      	str	r3, [r0, #32]
public:
    BleLocalDeviceImpl()
            : connectedCb_(nullptr),
              disconnectedCb_(nullptr),
              connectedContext_(nullptr),
              disconnectedContext_(nullptr) {
   dc95e:	6243      	str	r3, [r0, #36]	; 0x24
   dc960:	6283      	str	r3, [r0, #40]	; 0x28
   dc962:	62c3      	str	r3, [r0, #44]	; 0x2c
   dc964:	6303      	str	r3, [r0, #48]	; 0x30
   dc966:	6021      	str	r1, [r4, #0]
/*******************************************************
 * BleLocalDevice class
 */
BleLocalDevice::BleLocalDevice()
        : impl_(std::make_unique<BleLocalDeviceImpl>()) {
    if (!impl()) {
   dc968:	b919      	cbnz	r1, dc972 <_ZN8particle14BleLocalDeviceC1Ev+0x36>
        SPARK_ASSERT(false);
   dc96a:	4a0a      	ldr	r2, [pc, #40]	; (dc994 <_ZN8particle14BleLocalDeviceC1Ev+0x58>)
   dc96c:	200a      	movs	r0, #10
   dc96e:	f7ff f915 	bl	dbb9c <panic_>
    }
    SPARK_ASSERT(hal_ble_stack_init(nullptr) == SYSTEM_ERROR_NONE);
   dc972:	2000      	movs	r0, #0
   dc974:	f7fe ff6e 	bl	db854 <hal_ble_stack_init>
   dc978:	b120      	cbz	r0, dc984 <_ZN8particle14BleLocalDeviceC1Ev+0x48>
   dc97a:	4a06      	ldr	r2, [pc, #24]	; (dc994 <_ZN8particle14BleLocalDeviceC1Ev+0x58>)
   dc97c:	2100      	movs	r1, #0
   dc97e:	200a      	movs	r0, #10
   dc980:	f7ff f90c 	bl	dbb9c <panic_>
    hal_ble_set_callback_on_periph_link_events(impl()->onBleLinkEvents, impl(), nullptr);
   dc984:	2200      	movs	r2, #0
   dc986:	6821      	ldr	r1, [r4, #0]
   dc988:	4803      	ldr	r0, [pc, #12]	; (dc998 <_ZN8particle14BleLocalDeviceC1Ev+0x5c>)
   dc98a:	f7fe ff7d 	bl	db888 <hal_ble_set_callback_on_periph_link_events>
}
   dc98e:	4620      	mov	r0, r4
   dc990:	bd10      	pop	{r4, pc}
   dc992:	bf00      	nop
   dc994:	000db7c5 	.word	0x000db7c5
   dc998:	000dcc89 	.word	0x000dcc89

000dc99c <_ZN8particle14BleLocalDevice11getInstanceEv>:

BleLocalDevice& BleLocalDevice::getInstance() {
   dc99c:	b510      	push	{r4, lr}
    static BleLocalDevice instance;
   dc99e:	4c0a      	ldr	r4, [pc, #40]	; (dc9c8 <_ZN8particle14BleLocalDevice11getInstanceEv+0x2c>)
   dc9a0:	6823      	ldr	r3, [r4, #0]
   dc9a2:	07db      	lsls	r3, r3, #31
   dc9a4:	d40e      	bmi.n	dc9c4 <_ZN8particle14BleLocalDevice11getInstanceEv+0x28>
   dc9a6:	4620      	mov	r0, r4
   dc9a8:	f7f7 fb88 	bl	d40bc <__cxa_guard_acquire>
   dc9ac:	b150      	cbz	r0, dc9c4 <_ZN8particle14BleLocalDevice11getInstanceEv+0x28>
   dc9ae:	4807      	ldr	r0, [pc, #28]	; (dc9cc <_ZN8particle14BleLocalDevice11getInstanceEv+0x30>)
   dc9b0:	f7ff ffc4 	bl	dc93c <_ZN8particle14BleLocalDeviceC1Ev>
   dc9b4:	4620      	mov	r0, r4
   dc9b6:	f7f7 fb86 	bl	d40c6 <__cxa_guard_release>
   dc9ba:	4a05      	ldr	r2, [pc, #20]	; (dc9d0 <_ZN8particle14BleLocalDevice11getInstanceEv+0x34>)
   dc9bc:	4905      	ldr	r1, [pc, #20]	; (dc9d4 <_ZN8particle14BleLocalDevice11getInstanceEv+0x38>)
   dc9be:	4803      	ldr	r0, [pc, #12]	; (dc9cc <_ZN8particle14BleLocalDevice11getInstanceEv+0x30>)
   dc9c0:	f002 f9b8 	bl	ded34 <__aeabi_atexit>
    return instance;
}
   dc9c4:	4801      	ldr	r0, [pc, #4]	; (dc9cc <_ZN8particle14BleLocalDevice11getInstanceEv+0x30>)
   dc9c6:	bd10      	pop	{r4, pc}
   dc9c8:	2003e450 	.word	0x2003e450
   dc9cc:	2003e44c 	.word	0x2003e44c
   dc9d0:	2003daf8 	.word	0x2003daf8
   dc9d4:	000dca4d 	.word	0x000dca4d

000dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
   dc9d8:	680b      	ldr	r3, [r1, #0]
   dc9da:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
   dc9dc:	b113      	cbz	r3, dc9e4 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
   dc9de:	685a      	ldr	r2, [r3, #4]
   dc9e0:	3201      	adds	r2, #1
   dc9e2:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
   dc9e4:	4770      	bx	lr

000dc9e6 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
   dc9e6:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   dc9e8:	6804      	ldr	r4, [r0, #0]
   dc9ea:	6843      	ldr	r3, [r0, #4]
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
   dc9ec:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
   dc9ee:	eb04 06c3 	add.w	r6, r4, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dc9f2:	42a6      	cmp	r6, r4
   dc9f4:	d004      	beq.n	dca00 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev+0x1a>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dc9f6:	1d20      	adds	r0, r4, #4
   dc9f8:	f7f9 f908 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dc9fc:	3408      	adds	r4, #8
   dc9fe:	e7f8      	b.n	dc9f2 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev+0xc>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
   dca00:	6828      	ldr	r0, [r5, #0]
   dca02:	f7ff f9e1 	bl	dbdc8 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
   dca06:	4628      	mov	r0, r5
   dca08:	bd70      	pop	{r4, r5, r6, pc}

000dca0a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
   dca0a:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   dca0c:	6804      	ldr	r4, [r0, #0]
   dca0e:	6843      	ldr	r3, [r0, #4]
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
   dca10:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
   dca12:	eb04 06c3 	add.w	r6, r4, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dca16:	42a6      	cmp	r6, r4
   dca18:	d004      	beq.n	dca24 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev+0x1a>
   dca1a:	1d20      	adds	r0, r4, #4
   dca1c:	f7f9 f8f6 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dca20:	3408      	adds	r4, #8
   dca22:	e7f8      	b.n	dca16 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev+0xc>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
   dca24:	6828      	ldr	r0, [r5, #0]
   dca26:	f7ff f9cf 	bl	dbdc8 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
   dca2a:	4628      	mov	r0, r5
   dca2c:	bd70      	pop	{r4, r5, r6, pc}

000dca2e <_ZNSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
   dca2e:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
   dca30:	6904      	ldr	r4, [r0, #16]
              address_(),
              servicesDiscovered_(false),
              characteristicsDiscovered_(false) {
    }

    ~BlePeerDeviceImpl() = default;
   dca32:	f104 0018 	add.w	r0, r4, #24
   dca36:	f7ff ffe8 	bl	dca0a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
   dca3a:	f104 000c 	add.w	r0, r4, #12
   dca3e:	f7ff ffd2 	bl	dc9e6 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>
   dca42:	4620      	mov	r0, r4
   dca44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   dca48:	f7f7 bb29 	b.w	d409e <_ZdlPv>

000dca4c <_ZN8particle14BleLocalDeviceD1Ev>:
        return impl_.get();
    }

private:
    BleLocalDevice();
    ~BleLocalDevice() = default;
   dca4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   dca4e:	6804      	ldr	r4, [r0, #0]
   dca50:	4607      	mov	r7, r0
   dca52:	b1c4      	cbz	r4, dca86 <_ZN8particle14BleLocalDeviceD1Ev+0x3a>
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
   dca54:	69a5      	ldr	r5, [r4, #24]
   dca56:	69e3      	ldr	r3, [r4, #28]
   dca58:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dca5c:	42ae      	cmp	r6, r5
   dca5e:	d004      	beq.n	dca6a <_ZN8particle14BleLocalDeviceD1Ev+0x1e>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dca60:	1d28      	adds	r0, r5, #4
   dca62:	f7f9 f8d3 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dca66:	3508      	adds	r5, #8
   dca68:	e7f8      	b.n	dca5c <_ZN8particle14BleLocalDeviceD1Ev+0x10>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
   dca6a:	69a0      	ldr	r0, [r4, #24]
   dca6c:	f7ff f9ac 	bl	dbdc8 <free>
              disconnectedCb_(nullptr),
              connectedContext_(nullptr),
              disconnectedContext_(nullptr) {
    }

    ~BleLocalDeviceImpl() = default;
   dca70:	f104 000c 	add.w	r0, r4, #12
   dca74:	f7ff ffc9 	bl	dca0a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
   dca78:	4620      	mov	r0, r4
   dca7a:	f7ff ffb4 	bl	dc9e6 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   dca7e:	2134      	movs	r1, #52	; 0x34
   dca80:	4620      	mov	r0, r4
   dca82:	f002 f965 	bl	ded50 <_ZdlPvj>
   dca86:	4638      	mov	r0, r7
   dca88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000dca8c <_ZN8particle13BlePeerDeviceC1Ev>:


/*******************************************************
 * BlePeerDevice class
 */
BlePeerDevice::BlePeerDevice()
   dca8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
   dca8e:	2500      	movs	r5, #0
   dca90:	6005      	str	r5, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
   dca92:	6045      	str	r5, [r0, #4]
   dca94:	4606      	mov	r6, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   dca96:	2024      	movs	r0, #36	; 0x24
   dca98:	f7f7 faff 	bl	d409a <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   dca9c:	4604      	mov	r4, r0
   dca9e:	b178      	cbz	r0, dcac0 <_ZN8particle13BlePeerDeviceC1Ev+0x34>
public:
    BlePeerDeviceImpl()
            : connHandle_(BLE_INVALID_CONN_HANDLE),
              address_(),
              servicesDiscovered_(false),
              characteristicsDiscovered_(false) {
   dcaa0:	4603      	mov	r3, r0
   dcaa2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   dcaa6:	f823 2b02 	strh.w	r2, [r3], #2

/*******************************************************
 * BleAddress class
 */
BleAddress::BleAddress()
        : address_{} {
   dcaaa:	f8c0 5002 	str.w	r5, [r0, #2]
   dcaae:	605d      	str	r5, [r3, #4]
public:
    BlePeerDeviceImpl()
            : connHandle_(BLE_INVALID_CONN_HANDLE),
              address_(),
              servicesDiscovered_(false),
              characteristicsDiscovered_(false) {
   dcab0:	7285      	strb	r5, [r0, #10]
   dcab2:	72c5      	strb	r5, [r0, #11]
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
   dcab4:	60c5      	str	r5, [r0, #12]
   dcab6:	6105      	str	r5, [r0, #16]
   dcab8:	6145      	str	r5, [r0, #20]
   dcaba:	6185      	str	r5, [r0, #24]
   dcabc:	61c5      	str	r5, [r0, #28]
   dcabe:	6205      	str	r5, [r0, #32]
	__shared_count(_Ptr __p, _Deleter __d)
	: __shared_count(__p, std::move(__d), allocator<void>())
	{ }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
	__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
   dcac0:	2300      	movs	r3, #0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   dcac2:	2014      	movs	r0, #20
   dcac4:	9301      	str	r3, [sp, #4]
   dcac6:	f7f7 fae8 	bl	d409a <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
   dcaca:	4603      	mov	r3, r0
   dcacc:	b128      	cbz	r0, dcada <_ZN8particle13BlePeerDeviceC1Ev+0x4e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
   dcace:	2201      	movs	r2, #1
   dcad0:	6042      	str	r2, [r0, #4]
   dcad2:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
   dcad4:	4a08      	ldr	r2, [pc, #32]	; (dcaf8 <_ZN8particle13BlePeerDeviceC1Ev+0x6c>)
   dcad6:	6002      	str	r2, [r0, #0]
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
   dcad8:	6104      	str	r4, [r0, #16]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
   dcada:	a802      	add	r0, sp, #8
   dcadc:	6872      	ldr	r2, [r6, #4]
   dcade:	f840 2d04 	str.w	r2, [r0, #-4]!
	_M_pi = __tmp;
   dcae2:	6073      	str	r3, [r6, #4]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
   dcae4:	6034      	str	r4, [r6, #0]
	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
	  // 2070. allocate_shared should use allocator_traits<A>::construct
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
   dcae6:	f7f9 f891 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
/*******************************************************
 * BlePeerDevice class
 */
BlePeerDevice::BlePeerDevice()
        : impl_(std::make_shared<BlePeerDeviceImpl>()) {
    if (!impl()) {
   dcaea:	6833      	ldr	r3, [r6, #0]
   dcaec:	b90b      	cbnz	r3, dcaf2 <_ZN8particle13BlePeerDeviceC1Ev+0x66>
   dcaee:	f7ff fec1 	bl	dc874 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.102>
        SPARK_ASSERT(false);
    }
}
   dcaf2:	4630      	mov	r0, r6
   dcaf4:	b002      	add	sp, #8
   dcaf6:	bd70      	pop	{r4, r5, r6, pc}
   dcaf8:	000e2448 	.word	0x000e2448

000dcafc <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE5clearEv>:
    }
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
   dcafc:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   dcafe:	6804      	ldr	r4, [r0, #0]
   dcb00:	6843      	ldr	r3, [r0, #4]
    }
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
   dcb02:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
   dcb04:	eb04 06c3 	add.w	r6, r4, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dcb08:	42a6      	cmp	r6, r4
   dcb0a:	d004      	beq.n	dcb16 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE5clearEv+0x1a>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dcb0c:	1d20      	adds	r0, r4, #4
   dcb0e:	f7f9 f87d 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcb12:	3408      	adds	r4, #8
   dcb14:	e7f8      	b.n	dcb08 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE5clearEv+0xc>
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
    size_ = 0;
   dcb16:	2300      	movs	r3, #0
   dcb18:	606b      	str	r3, [r5, #4]
   dcb1a:	bd70      	pop	{r4, r5, r6, pc}

000dcb1c <_ZNK8particle14BleLocalDevice3offEv>:
    WiringBleLock lk;
    CHECK(hal_ble_stack_init(nullptr));
    return SYSTEM_ERROR_NONE;
}

int BleLocalDevice::off() const {
   dcb1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   dcb1e:	4605      	mov	r5, r0
    WiringBleLock lk;
   dcb20:	a801      	add	r0, sp, #4
   dcb22:	f7ff feb1 	bl	dc888 <_ZN8particle3ble13WiringBleLockC1Ev>
    CHECK(hal_ble_stack_deinit(nullptr));
   dcb26:	2000      	movs	r0, #0
   dcb28:	f7fe fe9c 	bl	db864 <hal_ble_stack_deinit>
   dcb2c:	2800      	cmp	r0, #0
   dcb2e:	db05      	blt.n	dcb3c <_ZNK8particle14BleLocalDevice3offEv+0x20>
    Vector<BleCharacteristic>& characteristics() {
        return characteristics_;
    }

    Vector<BlePeerDevice>& peers() {
        return peers_;
   dcb30:	6828      	ldr	r0, [r5, #0]
}

int BleLocalDevice::off() const {
    WiringBleLock lk;
    CHECK(hal_ble_stack_deinit(nullptr));
    impl()->peers().clear();
   dcb32:	3018      	adds	r0, #24
   dcb34:	f7ff ffe2 	bl	dcafc <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE5clearEv>
    return SYSTEM_ERROR_NONE;
   dcb38:	2400      	movs	r4, #0
   dcb3a:	e000      	b.n	dcb3e <_ZNK8particle14BleLocalDevice3offEv+0x22>
   dcb3c:	4604      	mov	r4, r0
    CHECK(hal_ble_stack_init(nullptr));
    return SYSTEM_ERROR_NONE;
}

int BleLocalDevice::off() const {
    WiringBleLock lk;
   dcb3e:	a801      	add	r0, sp, #4
   dcb40:	f7ff feb0 	bl	dc8a4 <_ZN8particle3ble13WiringBleLockD1Ev>
    CHECK(hal_ble_stack_deinit(nullptr));
    impl()->peers().clear();
    return SYSTEM_ERROR_NONE;
}
   dcb44:	4620      	mov	r0, r4
   dcb46:	b003      	add	sp, #12
   dcb48:	bd30      	pop	{r4, r5, pc}

000dcb4a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
   dcb4a:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
   dcb4c:	b570      	push	{r4, r5, r6, lr}
   dcb4e:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
   dcb50:	d91a      	bls.n	dcb88 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x3e>
   dcb52:	4290      	cmp	r0, r2
   dcb54:	d219      	bcs.n	dcb8a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x40>
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
   dcb56:	f1a1 0608 	sub.w	r6, r1, #8
   dcb5a:	1a51      	subs	r1, r2, r1
   dcb5c:	3904      	subs	r1, #4
   dcb5e:	1f15      	subs	r5, r2, #4
   dcb60:	1844      	adds	r4, r0, r1
            for (; end != p; --end, --dest) {
   dcb62:	1f2b      	subs	r3, r5, #4
   dcb64:	429e      	cmp	r6, r3
   dcb66:	d025      	beq.n	dcbb4 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x6a>
                new(dest) T(std::move(*end));
   dcb68:	2c04      	cmp	r4, #4
   dcb6a:	d007      	beq.n	dcb7c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x32>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dcb6c:	f855 3c04 	ldr.w	r3, [r5, #-4]
   dcb70:	f844 3c04 	str.w	r3, [r4, #-4]
   dcb74:	4629      	mov	r1, r5
   dcb76:	4620      	mov	r0, r4
   dcb78:	f7ff ff2e 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dcb7c:	4628      	mov	r0, r5
   dcb7e:	f7f9 f845 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcb82:	3d08      	subs	r5, #8
   dcb84:	3c08      	subs	r4, #8
   dcb86:	e7ec      	b.n	dcb62 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x18>
                end->~T();
            }
        } else if (dest != p) {
   dcb88:	d014      	beq.n	dcbb4 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x6a>
   dcb8a:	1d0c      	adds	r4, r1, #4
   dcb8c:	1d06      	adds	r6, r0, #4
            for (; p != end; ++p, ++dest) {
   dcb8e:	1f23      	subs	r3, r4, #4
   dcb90:	429d      	cmp	r5, r3
   dcb92:	d00f      	beq.n	dcbb4 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x6a>
                new(dest) T(std::move(*p));
   dcb94:	2e04      	cmp	r6, #4
   dcb96:	d007      	beq.n	dcba8 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x5e>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dcb98:	f854 3c04 	ldr.w	r3, [r4, #-4]
   dcb9c:	f846 3c04 	str.w	r3, [r6, #-4]
   dcba0:	4621      	mov	r1, r4
   dcba2:	4630      	mov	r0, r6
   dcba4:	f7ff ff18 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dcba8:	4620      	mov	r0, r4
   dcbaa:	f7f9 f82f 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcbae:	3408      	adds	r4, #8
   dcbb0:	3608      	adds	r6, #8
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
   dcbb2:	e7ec      	b.n	dcb8e <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x44>
   dcbb4:	bd70      	pop	{r4, r5, r6, pc}

000dcbb6 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_>:
    move(p, p + n, data_ + size_);
    size_ -= n;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
   dcbb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    T* const p = find(data_, data_ + size_, value);
   dcbba:	6804      	ldr	r4, [r0, #0]
   dcbbc:	6843      	ldr	r3, [r0, #4]
    move(p, p + n, data_ + size_);
    size_ -= n;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
   dcbbe:	4605      	mov	r5, r0
   dcbc0:	4688      	mov	r8, r1
    T* const p = find(data_, data_ + size_, value);
   dcbc2:	eb04 07c3 	add.w	r7, r4, r3, lsl #3
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
   dcbc6:	42a7      	cmp	r7, r4
   dcbc8:	d018      	beq.n	dcbfc <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x46>
            if (*p == value) {
   dcbca:	4641      	mov	r1, r8
   dcbcc:	4620      	mov	r0, r4
   dcbce:	f7ff fe9c 	bl	dc90a <_ZNK8particle13BlePeerDeviceeqERKS0_>
   dcbd2:	4606      	mov	r6, r0
   dcbd4:	b908      	cbnz	r0, dcbda <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x24>
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
   dcbd6:	3408      	adds	r4, #8
   dcbd8:	e7f5      	b.n	dcbc6 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x10>
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
   dcbda:	b18c      	cbz	r4, dcc00 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x4a>
   dcbdc:	1d20      	adds	r0, r4, #4
   dcbde:	f7f9 f815 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
   dcbe2:	682b      	ldr	r3, [r5, #0]
   dcbe4:	686a      	ldr	r2, [r5, #4]
   dcbe6:	f104 0108 	add.w	r1, r4, #8
   dcbea:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   dcbee:	4620      	mov	r0, r4
   dcbf0:	f7ff ffab 	bl	dcb4a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    --size_;
   dcbf4:	686b      	ldr	r3, [r5, #4]
   dcbf6:	3b01      	subs	r3, #1
   dcbf8:	606b      	str	r3, [r5, #4]
    return true;
   dcbfa:	e002      	b.n	dcc02 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x4c>

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
        return false;
   dcbfc:	2600      	movs	r6, #0
   dcbfe:	e000      	b.n	dcc02 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_+0x4c>
   dcc00:	4626      	mov	r6, r4
    }
    p->~T();
    move(p, p + 1, data_ + size_);
    --size_;
    return true;
}
   dcc02:	4630      	mov	r0, r6
   dcc04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000dcc08 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_>:
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
   dcc08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   dcc0a:	4604      	mov	r4, r0
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dcc0c:	f851 3b04 	ldr.w	r3, [r1], #4
    return insert(size_, std::move(value));
   dcc10:	6847      	ldr	r7, [r0, #4]
   dcc12:	9300      	str	r3, [sp, #0]
   dcc14:	a801      	add	r0, sp, #4
   dcc16:	f7ff fedf 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   dcc1a:	6866      	ldr	r6, [r4, #4]
   dcc1c:	68a3      	ldr	r3, [r4, #8]
   dcc1e:	429e      	cmp	r6, r3
   dcc20:	db14      	blt.n	dcc4c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x44>
   dcc22:	3601      	adds	r6, #1
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
   dcc24:	2e00      	cmp	r6, #0
   dcc26:	dd0b      	ble.n	dcc40 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x38>

} // particle

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
   dcc28:	00f0      	lsls	r0, r6, #3
   dcc2a:	f7ff f8c5 	bl	dbdb8 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
   dcc2e:	4605      	mov	r5, r0
   dcc30:	b318      	cbz	r0, dcc7a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x72>
                return false;
            }
            move(d, data_, data_ + size_);
   dcc32:	e894 0006 	ldmia.w	r4, {r1, r2}
   dcc36:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   dcc3a:	f7ff ff86 	bl	dcb4a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
   dcc3e:	e000      	b.n	dcc42 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x3a>
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
   dcc40:	2500      	movs	r5, #0
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
   dcc42:	6820      	ldr	r0, [r4, #0]
   dcc44:	f7ff f8c0 	bl	dbdc8 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
   dcc48:	6025      	str	r5, [r4, #0]
        capacity_ = n;
   dcc4a:	60a6      	str	r6, [r4, #8]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
   dcc4c:	6826      	ldr	r6, [r4, #0]
    move(p + 1, p, data_ + size_);
   dcc4e:	6862      	ldr	r2, [r4, #4]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
   dcc50:	eb06 05c7 	add.w	r5, r6, r7, lsl #3
    move(p + 1, p, data_ + size_);
   dcc54:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
   dcc58:	4629      	mov	r1, r5
   dcc5a:	f105 0008 	add.w	r0, r5, #8
   dcc5e:	f7ff ff74 	bl	dcb4a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    new(p) T(std::move(value));
   dcc62:	b135      	cbz	r5, dcc72 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x6a>
   dcc64:	9b00      	ldr	r3, [sp, #0]
   dcc66:	f846 3037 	str.w	r3, [r6, r7, lsl #3]
   dcc6a:	a901      	add	r1, sp, #4
   dcc6c:	1d28      	adds	r0, r5, #4
   dcc6e:	f7ff feb3 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    ++size_;
   dcc72:	6863      	ldr	r3, [r4, #4]
   dcc74:	3301      	adds	r3, #1
   dcc76:	6063      	str	r3, [r4, #4]
   dcc78:	2501      	movs	r5, #1
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dcc7a:	a801      	add	r0, sp, #4
   dcc7c:	f7f8 ffc6 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
}
   dcc80:	4628      	mov	r0, r5
   dcc82:	b003      	add	sp, #12
   dcc84:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000dcc88 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv>:
            }
        }
        return nullptr;
    }

    static void onBleLinkEvents(const hal_ble_link_evt_t* event, void* context) {
   dcc88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   dcc8c:	4604      	mov	r4, r0
   dcc8e:	b08e      	sub	sp, #56	; 0x38
        auto impl = static_cast<BleLocalDeviceImpl*>(context);
        WiringBleLock lk;
   dcc90:	a803      	add	r0, sp, #12
            }
        }
        return nullptr;
    }

    static void onBleLinkEvents(const hal_ble_link_evt_t* event, void* context) {
   dcc92:	460d      	mov	r5, r1
        auto impl = static_cast<BleLocalDeviceImpl*>(context);
        WiringBleLock lk;
   dcc94:	f7ff fdf8 	bl	dc888 <_ZN8particle3ble13WiringBleLockC1Ev>
        switch (event->type) {
   dcc98:	6823      	ldr	r3, [r4, #0]
   dcc9a:	2b03      	cmp	r3, #3
   dcc9c:	d002      	beq.n	dcca4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1c>
   dcc9e:	2b04      	cmp	r3, #4
   dcca0:	d042      	beq.n	dcd28 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xa0>
   dcca2:	e087      	b.n	dcdb4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x12c>
            case BLE_EVT_CONNECTED: {
                BlePeerDevice peer;
   dcca4:	a804      	add	r0, sp, #16
   dcca6:	f7ff fef1 	bl	dca8c <_ZN8particle13BlePeerDeviceC1Ev>
                peer.impl()->connHandle() = event->conn_handle;
   dccaa:	9b04      	ldr	r3, [sp, #16]
   dccac:	8922      	ldrh	r2, [r4, #8]
   dccae:	801a      	strh	r2, [r3, #0]
    }
    return address_.addr[i];
}

BleAddress& BleAddress::operator=(const hal_ble_addr_t& addr) {
    address_ = addr;
   dccb0:	6862      	ldr	r2, [r4, #4]
   dccb2:	9904      	ldr	r1, [sp, #16]
   dccb4:	f852 3f08 	ldr.w	r3, [r2, #8]!
   dccb8:	f8c1 3002 	str.w	r3, [r1, #2]
   dccbc:	6853      	ldr	r3, [r2, #4]
   dccbe:	f8c1 3006 	str.w	r3, [r1, #6]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dccc2:	a807      	add	r0, sp, #28
   dccc4:	9b04      	ldr	r3, [sp, #16]
   dccc6:	9306      	str	r3, [sp, #24]
   dccc8:	a905      	add	r1, sp, #20
   dccca:	f7ff fe85 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
        switch (event->type) {
            case BLE_EVT_CONNECTED: {
                BlePeerDevice peer;
                peer.impl()->connHandle() = event->conn_handle;
                peer.impl()->address() = event->params.connected.info->address;
                if (!impl->peers_.append(peer)) {
   dccce:	a906      	add	r1, sp, #24
   dccd0:	f105 0018 	add.w	r0, r5, #24
   dccd4:	f7ff ff98 	bl	dcc08 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_>
   dccd8:	4604      	mov	r4, r0
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dccda:	a807      	add	r0, sp, #28
   dccdc:	f7f8 ff96 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcce0:	2320      	movs	r3, #32
                    LOG(ERROR, "Failed to append peer Central device.");
   dcce2:	9306      	str	r3, [sp, #24]
        switch (event->type) {
            case BLE_EVT_CONNECTED: {
                BlePeerDevice peer;
                peer.impl()->connHandle() = event->conn_handle;
                peer.impl()->address() = event->params.connected.info->address;
                if (!impl->peers_.append(peer)) {
   dcce4:	b974      	cbnz	r4, dcd04 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x7c>
                    LOG(ERROR, "Failed to append peer Central device.");
   dcce6:	4b36      	ldr	r3, [pc, #216]	; (dcdc0 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x138>)
   dcce8:	9300      	str	r3, [sp, #0]
   dccea:	aa06      	add	r2, sp, #24
   dccec:	4623      	mov	r3, r4
   dccee:	4935      	ldr	r1, [pc, #212]	; (dcdc4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x13c>)
   dccf0:	9407      	str	r4, [sp, #28]
   dccf2:	2032      	movs	r0, #50	; 0x32
   dccf4:	f7fe ff5a 	bl	dbbac <log_message>
                    hal_ble_gap_disconnect(peer.impl()->connHandle(), nullptr);
   dccf8:	9b04      	ldr	r3, [sp, #16]
   dccfa:	4621      	mov	r1, r4
   dccfc:	8818      	ldrh	r0, [r3, #0]
   dccfe:	f7fe fdb9 	bl	db874 <hal_ble_gap_disconnect>
   dcd02:	e00d      	b.n	dcd20 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x98>
                    return;
                }
                LOG(TRACE, "Connected by Central device.");
   dcd04:	4a30      	ldr	r2, [pc, #192]	; (dcdc8 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x140>)
   dcd06:	9200      	str	r2, [sp, #0]
   dcd08:	2300      	movs	r3, #0
   dcd0a:	aa06      	add	r2, sp, #24
   dcd0c:	492d      	ldr	r1, [pc, #180]	; (dcdc4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x13c>)
   dcd0e:	9307      	str	r3, [sp, #28]
   dcd10:	2001      	movs	r0, #1
   dcd12:	f7fe ff4b 	bl	dbbac <log_message>
                if (impl->connectedCb_) {
   dcd16:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   dcd18:	b113      	cbz	r3, dcd20 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x98>
                    impl->connectedCb_(peer, impl->connectedContext_);
   dcd1a:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   dcd1c:	a804      	add	r0, sp, #16
   dcd1e:	4798      	blx	r3
   dcd20:	a805      	add	r0, sp, #20
   dcd22:	f7f8 ff73 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcd26:	e045      	b.n	dcdb4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x12c>
                }
                break;
            }
            case BLE_EVT_DISCONNECTED: {
                BlePeerDevice* peer = impl->findPeerDevice(event->conn_handle);
   dcd28:	8921      	ldrh	r1, [r4, #8]
   dcd2a:	4628      	mov	r0, r5
   dcd2c:	f7ff fdd4 	bl	dc8d8 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>
                if (peer) {
   dcd30:	4607      	mov	r7, r0
   dcd32:	2800      	cmp	r0, #0
   dcd34:	d03e      	beq.n	dcdb4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x12c>
   dcd36:	6804      	ldr	r4, [r0, #0]
   dcd38:	69a3      	ldr	r3, [r4, #24]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
   dcd3a:	69e1      	ldr	r1, [r4, #28]
    Vector<BleCharacteristic>& characteristics() {
        return characteristics_;
    }

    void onDisconnected() {
        connHandle_ = BLE_INVALID_CONN_HANDLE;
   dcd3c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   dcd40:	8022      	strh	r2, [r4, #0]
   dcd42:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
        for (auto& characteristic : characteristics_) {
   dcd46:	4299      	cmp	r1, r3
   dcd48:	d003      	beq.n	dcd52 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xca>
   dcd4a:	f853 0b08 	ldr.w	r0, [r3], #8
            characteristic.impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
   dcd4e:	8042      	strh	r2, [r0, #2]
   dcd50:	e7f9      	b.n	dcd46 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xbe>
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
   dcd52:	68e6      	ldr	r6, [r4, #12]
   dcd54:	6923      	ldr	r3, [r4, #16]
   dcd56:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dcd5a:	45b0      	cmp	r8, r6
   dcd5c:	d004      	beq.n	dcd68 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xe0>
   dcd5e:	1d30      	adds	r0, r6, #4
   dcd60:	f7f8 ff54 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcd64:	3608      	adds	r6, #8
   dcd66:	e7f8      	b.n	dcd5a <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xd2>
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
    size_ = 0;
   dcd68:	2300      	movs	r3, #0
   dcd6a:	6123      	str	r3, [r4, #16]
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
   dcd6c:	69a6      	ldr	r6, [r4, #24]
   dcd6e:	69e3      	ldr	r3, [r4, #28]
   dcd70:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
   dcd74:	45b0      	cmp	r8, r6
   dcd76:	d004      	beq.n	dcd82 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xfa>
   dcd78:	1d30      	adds	r0, r6, #4
   dcd7a:	f7f8 ff47 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dcd7e:	3608      	adds	r6, #8
   dcd80:	e7f8      	b.n	dcd74 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xec>
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
    size_ = 0;
   dcd82:	2300      	movs	r3, #0
   dcd84:	61e3      	str	r3, [r4, #28]
        }
        services_.clear();
        characteristics_.clear();
        servicesDiscovered_ = false;
   dcd86:	72a3      	strb	r3, [r4, #10]
        characteristicsDiscovered_ = false;
   dcd88:	72e3      	strb	r3, [r4, #11]
            }
            case BLE_EVT_DISCONNECTED: {
                BlePeerDevice* peer = impl->findPeerDevice(event->conn_handle);
                if (peer) {
                    peer->impl()->onDisconnected();
                    if (impl->disconnectedCb_) {
   dcd8a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   dcd8c:	b113      	cbz	r3, dcd94 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x10c>
                        impl->disconnectedCb_(*peer, impl->disconnectedContext_);
   dcd8e:	6b29      	ldr	r1, [r5, #48]	; 0x30
   dcd90:	4638      	mov	r0, r7
   dcd92:	4798      	blx	r3
                    }
                    LOG(TRACE, "Disconnected by remote device.");
   dcd94:	2320      	movs	r3, #32
   dcd96:	4a0d      	ldr	r2, [pc, #52]	; (dcdcc <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x144>)
   dcd98:	9306      	str	r3, [sp, #24]
   dcd9a:	9200      	str	r2, [sp, #0]
   dcd9c:	2300      	movs	r3, #0
   dcd9e:	4909      	ldr	r1, [pc, #36]	; (dcdc4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x13c>)
   dcda0:	9307      	str	r3, [sp, #28]
   dcda2:	2001      	movs	r0, #1
   dcda4:	aa06      	add	r2, sp, #24
   dcda6:	f7fe ff01 	bl	dbbac <log_message>
                    impl->peers_.removeOne(*peer);
   dcdaa:	4639      	mov	r1, r7
   dcdac:	f105 0018 	add.w	r0, r5, #24
   dcdb0:	f7ff ff01 	bl	dcbb6 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_>
        return nullptr;
    }

    static void onBleLinkEvents(const hal_ble_link_evt_t* event, void* context) {
        auto impl = static_cast<BleLocalDeviceImpl*>(context);
        WiringBleLock lk;
   dcdb4:	a803      	add	r0, sp, #12
   dcdb6:	f7ff fd75 	bl	dc8a4 <_ZN8particle3ble13WiringBleLockD1Ev>
            }
            default: {
                break;
            }
        }
    }
   dcdba:	b00e      	add	sp, #56	; 0x38
   dcdbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   dcdc0:	000e24be 	.word	0x000e24be
   dcdc4:	000e245c 	.word	0x000e245c
   dcdc8:	000e24e4 	.word	0x000e24e4
   dcdcc:	000e2501 	.word	0x000e2501

000dcdd0 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E>:
BleCharacteristic BleLocalDevice::addCharacteristic(const String& desc, EnumFlags<BleCharacteristicProperty> properties, BleOnDataReceivedCallback callback, void* context) {
    WiringBleLock lk;
    return addCharacteristic(desc.c_str(), properties, callback, context);
}

} /* namespace particle */
   dcdd0:	b510      	push	{r4, lr}
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   dcdd2:	4c06      	ldr	r4, [pc, #24]	; (dcdec <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x1c>)
   dcdd4:	2300      	movs	r3, #0
    {
        os_mutex_recursive_create(&handle_);
   dcdd6:	4620      	mov	r0, r4
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   dcdd8:	6023      	str	r3, [r4, #0]
    {
        os_mutex_recursive_create(&handle_);
   dcdda:	f7fe fd7f 	bl	db8dc <os_mutex_recursive_create>
private:
    bool locked_;
    static RecursiveMutex mutex_;
};

RecursiveMutex WiringBleLock::mutex_;
   dcdde:	4620      	mov	r0, r4
   dcde0:	4a03      	ldr	r2, [pc, #12]	; (dcdf0 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x20>)
   dcde2:	4904      	ldr	r1, [pc, #16]	; (dcdf4 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0x24>)
BleCharacteristic BleLocalDevice::addCharacteristic(const String& desc, EnumFlags<BleCharacteristicProperty> properties, BleOnDataReceivedCallback callback, void* context) {
    WiringBleLock lk;
    return addCharacteristic(desc.c_str(), properties, callback, context);
}

} /* namespace particle */
   dcde4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
private:
    bool locked_;
    static RecursiveMutex mutex_;
};

RecursiveMutex WiringBleLock::mutex_;
   dcde8:	f001 bfa4 	b.w	ded34 <__aeabi_atexit>
   dcdec:	2003e454 	.word	0x2003e454
   dcdf0:	2003daf8 	.word	0x2003daf8
   dcdf4:	000dc865 	.word	0x000dc865

000dcdf8 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
   dcdf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   dcdfa:	4606      	mov	r6, r0
   dcdfc:	460d      	mov	r5, r1
   dcdfe:	188f      	adds	r7, r1, r2
  size_t n = 0;
   dce00:	2400      	movs	r4, #0
  while (size--) {
   dce02:	42bd      	cmp	r5, r7
   dce04:	d00c      	beq.n	dce20 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
   dce06:	6833      	ldr	r3, [r6, #0]
   dce08:	f815 1b01 	ldrb.w	r1, [r5], #1
   dce0c:	689b      	ldr	r3, [r3, #8]
   dce0e:	4630      	mov	r0, r6
   dce10:	4798      	blx	r3
     if (chunk>=0)
   dce12:	2800      	cmp	r0, #0
   dce14:	db01      	blt.n	dce1a <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
   dce16:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
   dce18:	e7f3      	b.n	dce02 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
   dce1a:	2c00      	cmp	r4, #0
   dce1c:	bf08      	it	eq
   dce1e:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
   dce20:	4620      	mov	r0, r4
   dce22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000dce24 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
   dce24:	b570      	push	{r4, r5, r6, lr}
   dce26:	4605      	mov	r5, r0
      if (str == NULL) return 0;
   dce28:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
   dce2a:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
   dce2c:	b149      	cbz	r1, dce42 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
   dce2e:	f003 f91b 	bl	e0068 <strlen>
   dce32:	682b      	ldr	r3, [r5, #0]
   dce34:	4602      	mov	r2, r0
   dce36:	4621      	mov	r1, r4
   dce38:	4628      	mov	r0, r5
   dce3a:	68db      	ldr	r3, [r3, #12]
    }
   dce3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
   dce40:	4718      	bx	r3
    }
   dce42:	bd70      	pop	{r4, r5, r6, pc}

000dce44 <_ZN5Print5printEPKc>:
   dce44:	b508      	push	{r3, lr}
   dce46:	f7ff ffed 	bl	dce24 <_ZN5Print5writeEPKc>
   dce4a:	bd08      	pop	{r3, pc}

000dce4c <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
   dce4c:	6803      	ldr	r3, [r0, #0]
   dce4e:	689b      	ldr	r3, [r3, #8]
   dce50:	4718      	bx	r3

000dce52 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
   dce52:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
   dce54:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
   dce56:	4605      	mov	r5, r0
  size_t n = print('\r');
   dce58:	f7ff fff8 	bl	dce4c <_ZN5Print5printEc>
  n += print('\n');
   dce5c:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
   dce5e:	4604      	mov	r4, r0
  n += print('\n');
   dce60:	4628      	mov	r0, r5
   dce62:	f7ff fff3 	bl	dce4c <_ZN5Print5printEc>
  return n;
}
   dce66:	4420      	add	r0, r4
   dce68:	bd38      	pop	{r3, r4, r5, pc}

000dce6a <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
   dce6a:	b538      	push	{r3, r4, r5, lr}
   dce6c:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
   dce6e:	f7ff ffd9 	bl	dce24 <_ZN5Print5writeEPKc>
   dce72:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
   dce74:	4628      	mov	r0, r5
   dce76:	f7ff ffec 	bl	dce52 <_ZN5Print7printlnEv>
  return n;
}
   dce7a:	4420      	add	r0, r4
   dce7c:	bd38      	pop	{r3, r4, r5, pc}

000dce7e <_ZN5Print11printNumberEmh>:
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
   dce7e:	b530      	push	{r4, r5, lr}
   dce80:	b08b      	sub	sp, #44	; 0x2c
   dce82:	460b      	mov	r3, r1
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
   dce84:	2100      	movs	r1, #0
   dce86:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
   dce8a:	2a01      	cmp	r2, #1
   dce8c:	bf98      	it	ls
   dce8e:	220a      	movls	r2, #10
   dce90:	f10d 0423 	add.w	r4, sp, #35	; 0x23

  do {
   decltype(n) m = n;
   n /= base;
   dce94:	fbb3 f5f2 	udiv	r5, r3, r2
   char c = m - base * n;
   dce98:	fb05 3312 	mls	r3, r5, r2, r3
   dce9c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   dcea0:	2b09      	cmp	r3, #9
   dcea2:	bf94      	ite	ls
   dcea4:	3330      	addls	r3, #48	; 0x30
   dcea6:	3337      	addhi	r3, #55	; 0x37
   dcea8:	b2db      	uxtb	r3, r3
   dceaa:	4621      	mov	r1, r4
   dceac:	f804 3901 	strb.w	r3, [r4], #-1
   dceb0:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
   dceb2:	2d00      	cmp	r5, #0
   dceb4:	d1ee      	bne.n	dce94 <_ZN5Print11printNumberEmh+0x16>
   n /= base;
   char c = m - base * n;
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
   dceb6:	f7ff ffb5 	bl	dce24 <_ZN5Print5writeEPKc>
}
   dceba:	b00b      	add	sp, #44	; 0x2c
   dcebc:	bd30      	pop	{r4, r5, pc}

000dcebe <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
   dcebe:	b40c      	push	{r2, r3}
   dcec0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   dcec4:	b087      	sub	sp, #28
   dcec6:	af00      	add	r7, sp, #0
   dcec8:	f107 0438 	add.w	r4, r7, #56	; 0x38
   dcecc:	4605      	mov	r5, r0
   dcece:	f854 9b04 	ldr.w	r9, [r4], #4
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
   dced2:	603c      	str	r4, [r7, #0]

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
   dced4:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
   dced6:	4623      	mov	r3, r4
   dced8:	464a      	mov	r2, r9
   dceda:	2114      	movs	r1, #20
   dcedc:	1d38      	adds	r0, r7, #4
   dcede:	f7fe ff93 	bl	dbe08 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
   dcee2:	2813      	cmp	r0, #19
   dcee4:	d805      	bhi.n	dcef2 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
   dcee6:	1d39      	adds	r1, r7, #4
   dcee8:	4628      	mov	r0, r5
   dceea:	f7ff ff9b 	bl	dce24 <_ZN5Print5writeEPKc>
   dceee:	4604      	mov	r4, r0
   dcef0:	e013      	b.n	dcf1a <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
   dcef2:	f100 0308 	add.w	r3, r0, #8
   dcef6:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
   dcefa:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
   dcefc:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
   dcf00:	1c41      	adds	r1, r0, #1
   dcf02:	4623      	mov	r3, r4
   dcf04:	464a      	mov	r2, r9
   dcf06:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
   dcf08:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
   dcf0a:	f7fe ff7d 	bl	dbe08 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
   dcf0e:	4669      	mov	r1, sp
   dcf10:	4628      	mov	r0, r5
   dcf12:	f7ff ff87 	bl	dce24 <_ZN5Print5writeEPKc>
   dcf16:	4604      	mov	r4, r0
   dcf18:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
   dcf1a:	b11e      	cbz	r6, dcf24 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
   dcf1c:	4628      	mov	r0, r5
   dcf1e:	f7ff ff98 	bl	dce52 <_ZN5Print7printlnEv>
   dcf22:	4404      	add	r4, r0
    return n;
}
   dcf24:	4620      	mov	r0, r4
   dcf26:	371c      	adds	r7, #28
   dcf28:	46bd      	mov	sp, r7
   dcf2a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   dcf2e:	b002      	add	sp, #8
   dcf30:	4770      	bx	lr

000dcf32 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
   dcf32:	b510      	push	{r4, lr}
   dcf34:	4604      	mov	r4, r0

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   dcf36:	f7fe fc4d 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
   dcf3a:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
   dcf3c:	6823      	ldr	r3, [r4, #0]
   dcf3e:	4620      	mov	r0, r4
   dcf40:	695b      	ldr	r3, [r3, #20]
   dcf42:	4798      	blx	r3
    if (c >= 0) return c;
   dcf44:	2800      	cmp	r0, #0
   dcf46:	da08      	bge.n	dcf5a <_ZN6Stream9timedReadEv+0x28>
   dcf48:	f7fe fc44 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  _startMillis = millis();
  do {
   dcf4c:	68e3      	ldr	r3, [r4, #12]
   dcf4e:	1ac0      	subs	r0, r0, r3
   dcf50:	68a3      	ldr	r3, [r4, #8]
   dcf52:	4298      	cmp	r0, r3
   dcf54:	d3f2      	bcc.n	dcf3c <_ZN6Stream9timedReadEv+0xa>
    c = read();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
   dcf56:	f04f 30ff 	mov.w	r0, #4294967295
}
   dcf5a:	bd10      	pop	{r4, pc}

000dcf5c <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
   dcf5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   dcf60:	4680      	mov	r8, r0
   dcf62:	460d      	mov	r5, r1
   dcf64:	188f      	adds	r7, r1, r2
   dcf66:	460c      	mov	r4, r1
  size_t count = 0;
  while (count < length) {
   dcf68:	42bc      	cmp	r4, r7
   dcf6a:	eba4 0605 	sub.w	r6, r4, r5
   dcf6e:	d007      	beq.n	dcf80 <_ZN6Stream9readBytesEPcj+0x24>
    int c = timedRead();
   dcf70:	4640      	mov	r0, r8
   dcf72:	f7ff ffde 	bl	dcf32 <_ZN6Stream9timedReadEv>
    if (c < 0) break;
   dcf76:	2800      	cmp	r0, #0
   dcf78:	db02      	blt.n	dcf80 <_ZN6Stream9readBytesEPcj+0x24>
    *buffer++ = (char)c;
   dcf7a:	f804 0b01 	strb.w	r0, [r4], #1
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
  size_t count = 0;
  while (count < length) {
   dcf7e:	e7f3      	b.n	dcf68 <_ZN6Stream9readBytesEPcj+0xc>
    if (c < 0) break;
    *buffer++ = (char)c;
    count++;
  }
  return count;
}
   dcf80:	4630      	mov	r0, r6
   dcf82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

000dcf88 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
   dcf88:	4b01      	ldr	r3, [pc, #4]	; (dcf90 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
   dcf8a:	4a02      	ldr	r2, [pc, #8]	; (dcf94 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
   dcf8c:	601a      	str	r2, [r3, #0]
   dcf8e:	4770      	bx	lr
   dcf90:	2003e458 	.word	0x2003e458
   dcf94:	000e2687 	.word	0x000e2687

000dcf98 <_ZL22Refresh_UnixTime_Cachel>:
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
   dcf98:	b5f0      	push	{r4, r5, r6, r7, lr}
    unix_time += time_zone_cache;
   dcf9a:	4b14      	ldr	r3, [pc, #80]	; (dcfec <_ZL22Refresh_UnixTime_Cachel+0x54>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
   dcf9c:	4f14      	ldr	r7, [pc, #80]	; (dcff0 <_ZL22Refresh_UnixTime_Cachel+0x58>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
   dcf9e:	681e      	ldr	r6, [r3, #0]
    unix_time += dst_current_cache;
   dcfa0:	4b14      	ldr	r3, [pc, #80]	; (dcff4 <_ZL22Refresh_UnixTime_Cachel+0x5c>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
   dcfa2:	4406      	add	r6, r0
    unix_time += dst_current_cache;
   dcfa4:	6818      	ldr	r0, [r3, #0]
    if(unix_time != unix_time_cache)
   dcfa6:	683b      	ldr	r3, [r7, #0]

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
   dcfa8:	4406      	add	r6, r0
    if(unix_time != unix_time_cache)
   dcfaa:	429e      	cmp	r6, r3
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
   dcfac:	b08b      	sub	sp, #44	; 0x2c
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
   dcfae:	d01b      	beq.n	dcfe8 <_ZL22Refresh_UnixTime_Cachel+0x50>
   dcfb0:	a80a      	add	r0, sp, #40	; 0x28
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
	return *calendar_time;
   dcfb2:	ad01      	add	r5, sp, #4
   dcfb4:	f840 6d28 	str.w	r6, [r0, #-40]!

/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
   dcfb8:	f002 feb0 	bl	dfd1c <localtime>
	calendar_time->tm_year += 1900;
   dcfbc:	6943      	ldr	r3, [r0, #20]
   dcfbe:	f203 736c 	addw	r3, r3, #1900	; 0x76c
   dcfc2:	6143      	str	r3, [r0, #20]
	return *calendar_time;
   dcfc4:	4604      	mov	r4, r0
   dcfc6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   dcfc8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   dcfca:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   dcfcc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   dcfce:	f8d4 e000 	ldr.w	lr, [r4]
   dcfd2:	f8c5 e000 	str.w	lr, [r5]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   dcfd6:	ad01      	add	r5, sp, #4
   dcfd8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   dcfda:	4c07      	ldr	r4, [pc, #28]	; (dcff8 <_ZL22Refresh_UnixTime_Cachel+0x60>)
   dcfdc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   dcfde:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   dcfe0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
   dcfe2:	603e      	str	r6, [r7, #0]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   dcfe4:	f8c4 e000 	str.w	lr, [r4]
            unix_time_cache = unix_time;
    }
}
   dcfe8:	b00b      	add	sp, #44	; 0x2c
   dcfea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   dcfec:	2003e48c 	.word	0x2003e48c
   dcff0:	2003e488 	.word	0x2003e488
   dcff4:	2003e484 	.word	0x2003e484
   dcff8:	2003e45c 	.word	0x2003e45c

000dcffc <_ZN10CloudClass12syncTimeDoneEv.isra.1>:
    bool syncTimePending(void)
    {
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
   dcffc:	b508      	push	{r3, lr}
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   dcffe:	2000      	movs	r0, #0
   dd000:	f7fe fec2 	bl	dbd88 <spark_sync_time_pending>
   dd004:	b128      	cbz	r0, dd012 <_ZN10CloudClass12syncTimeDoneEv.isra.1+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   dd006:	f7fe fe9f 	bl	dbd48 <spark_cloud_flag_connected>
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   dd00a:	f080 0001 	eor.w	r0, r0, #1
   dd00e:	b2c0      	uxtb	r0, r0
   dd010:	bd08      	pop	{r3, pc}
   dd012:	2001      	movs	r0, #1
    }
   dd014:	bd08      	pop	{r3, pc}
	...

000dd018 <_ZN9TimeClass5monthEl>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
   dd018:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   dd01a:	f7ff ffbd 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
   dd01e:	4b02      	ldr	r3, [pc, #8]	; (dd028 <_ZN9TimeClass5monthEl+0x10>)
   dd020:	6918      	ldr	r0, [r3, #16]
}
   dd022:	3001      	adds	r0, #1
   dd024:	bd08      	pop	{r3, pc}
   dd026:	bf00      	nop
   dd028:	2003e45c 	.word	0x2003e45c

000dd02c <_ZN9TimeClass4zoneEf>:
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
	if(GMT_Offset < -12 || GMT_Offset > 14)
   dd02c:	eefa 7a08 	vmov.f32	s15, #168	; 0xc1400000 -12.0
   dd030:	eeb4 0ae7 	vcmpe.f32	s0, s15
   dd034:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   dd038:	d40f      	bmi.n	dd05a <_ZN9TimeClass4zoneEf+0x2e>
   dd03a:	eef2 7a0c 	vmov.f32	s15, #44	; 0x41600000  14.0
   dd03e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   dd042:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   dd046:	dc08      	bgt.n	dd05a <_ZN9TimeClass4zoneEf+0x2e>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
   dd048:	eddf 7a04 	vldr	s15, [pc, #16]	; dd05c <_ZN9TimeClass4zoneEf+0x30>
   dd04c:	4b04      	ldr	r3, [pc, #16]	; (dd060 <_ZN9TimeClass4zoneEf+0x34>)
   dd04e:	ee20 0a27 	vmul.f32	s0, s0, s15
   dd052:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   dd056:	ed83 0a00 	vstr	s0, [r3]
   dd05a:	4770      	bx	lr
   dd05c:	45610000 	.word	0x45610000
   dd060:	2003e48c 	.word	0x2003e48c

000dd064 <_ZN9TimeClass7isValidEv>:
    strftime(buf, 50, format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
   dd064:	b510      	push	{r4, lr}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
   dd066:	2000      	movs	r0, #0
   dd068:	f7fe fbc4 	bl	db7f4 <HAL_RTC_Time_Is_Valid>
    if (rtcstate)
   dd06c:	4604      	mov	r4, r0
   dd06e:	b968      	cbnz	r0, dd08c <_ZN9TimeClass7isValidEv+0x28>
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
   dd070:	f7fe fda4 	bl	dbbbc <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
   dd074:	2801      	cmp	r0, #1
   dd076:	d10b      	bne.n	dd090 <_ZN9TimeClass7isValidEv+0x2c>
   dd078:	4620      	mov	r0, r4
   dd07a:	f7fe fdcf 	bl	dbc1c <system_thread_get_state>
   dd07e:	b938      	cbnz	r0, dd090 <_ZN9TimeClass7isValidEv+0x2c>
    {
        waitUntil(Particle.syncTimeDone);
   dd080:	f7ff ffbc 	bl	dcffc <_ZN10CloudClass12syncTimeDoneEv.isra.1>


    static uint32_t freeMemory();

    template<typename Condition, typename While> static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
   dd084:	b930      	cbnz	r0, dd094 <_ZN9TimeClass7isValidEv+0x30>
            spark_process();
   dd086:	f7fe fe47 	bl	dbd18 <spark_process>
   dd08a:	e7f9      	b.n	dd080 <_ZN9TimeClass7isValidEv+0x1c>

bool TimeClass::isValid()
{
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
   dd08c:	2001      	movs	r0, #1
   dd08e:	bd10      	pop	{r4, pc}
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
        return HAL_RTC_Time_Is_Valid(nullptr);
    }
    return rtcstate;
   dd090:	2000      	movs	r0, #0
   dd092:	bd10      	pop	{r4, pc}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
   dd094:	f7ff ffb2 	bl	dcffc <_ZN10CloudClass12syncTimeDoneEv.isra.1>
        return HAL_RTC_Time_Is_Valid(nullptr);
   dd098:	2000      	movs	r0, #0
   dd09a:	f7fe fbab 	bl	db7f4 <HAL_RTC_Time_Is_Valid>
   dd09e:	3000      	adds	r0, #0
   dd0a0:	bf18      	it	ne
   dd0a2:	2001      	movne	r0, #1
    }
    return rtcstate;
}
   dd0a4:	bd10      	pop	{r4, pc}

000dd0a6 <_ZN9TimeClass3nowEv>:
	return calendar_time_cache.tm_year;
}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
   dd0a6:	b508      	push	{r3, lr}
    (void)isValid();
   dd0a8:	f7ff ffdc 	bl	dd064 <_ZN9TimeClass7isValidEv>
	return HAL_RTC_Get_UnixTime();
}
   dd0ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
    (void)isValid();
	return HAL_RTC_Get_UnixTime();
   dd0b0:	f7fe bb98 	b.w	db7e4 <HAL_RTC_Get_UnixTime>

000dd0b4 <_ZN9TimeClass4hourEv>:

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;

/* current hour */
int TimeClass::hour()
{
   dd0b4:	b508      	push	{r3, lr}
	return hour(now());
   dd0b6:	f7ff fff6 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}

/* the hour for the given time */
int TimeClass::hour(time_t t)
{
	Refresh_UnixTime_Cache(t);
   dd0ba:	f7ff ff6d 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>

/* current hour */
int TimeClass::hour()
{
	return hour(now());
}
   dd0be:	4b01      	ldr	r3, [pc, #4]	; (dd0c4 <_ZN9TimeClass4hourEv+0x10>)
   dd0c0:	6898      	ldr	r0, [r3, #8]
   dd0c2:	bd08      	pop	{r3, pc}
   dd0c4:	2003e45c 	.word	0x2003e45c

000dd0c8 <_ZN9TimeClass6minuteEv>:
	return (hour(t) >= 12);
}

/* current minute */
int TimeClass::minute()
{
   dd0c8:	b508      	push	{r3, lr}
	return minute(now());
   dd0ca:	f7ff ffec 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}

/* the minute for the given time */
int TimeClass::minute(time_t t)
{
	Refresh_UnixTime_Cache(t);
   dd0ce:	f7ff ff63 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>

/* current minute */
int TimeClass::minute()
{
	return minute(now());
}
   dd0d2:	4b01      	ldr	r3, [pc, #4]	; (dd0d8 <_ZN9TimeClass6minuteEv+0x10>)
   dd0d4:	6858      	ldr	r0, [r3, #4]
   dd0d6:	bd08      	pop	{r3, pc}
   dd0d8:	2003e45c 	.word	0x2003e45c

000dd0dc <_ZN9TimeClass6secondEv>:
	return calendar_time_cache.tm_min;
}

/* current seconds */
int TimeClass::second()
{
   dd0dc:	b508      	push	{r3, lr}
	return second(now());
   dd0de:	f7ff ffe2 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}

/* the second for the given time */
int TimeClass::second(time_t t)
{
	Refresh_UnixTime_Cache(t);
   dd0e2:	f7ff ff59 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>

/* current seconds */
int TimeClass::second()
{
	return second(now());
}
   dd0e6:	4b01      	ldr	r3, [pc, #4]	; (dd0ec <_ZN9TimeClass6secondEv+0x10>)
   dd0e8:	6818      	ldr	r0, [r3, #0]
   dd0ea:	bd08      	pop	{r3, pc}
   dd0ec:	2003e45c 	.word	0x2003e45c

000dd0f0 <_ZN9TimeClass3dayEv>:
	return calendar_time_cache.tm_sec;
}

/* current day */
int TimeClass::day()
{
   dd0f0:	b508      	push	{r3, lr}
	return day(now());
   dd0f2:	f7ff ffd8 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}

/* the day for the given time */
int TimeClass::day(time_t t)
{
	Refresh_UnixTime_Cache(t);
   dd0f6:	f7ff ff4f 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>

/* current day */
int TimeClass::day()
{
	return day(now());
}
   dd0fa:	4b01      	ldr	r3, [pc, #4]	; (dd100 <_ZN9TimeClass3dayEv+0x10>)
   dd0fc:	68d8      	ldr	r0, [r3, #12]
   dd0fe:	bd08      	pop	{r3, pc}
   dd100:	2003e45c 	.word	0x2003e45c

000dd104 <_ZN9TimeClass5monthEv>:
	return (calendar_time_cache.tm_wday + 1);//Arduino's weekday representation
}

/* current month */
int TimeClass::month()
{
   dd104:	b508      	push	{r3, lr}
	return month(now());
   dd106:	f7ff ffce 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}
   dd10a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

/* current month */
int TimeClass::month()
{
	return month(now());
   dd10e:	f7ff bf83 	b.w	dd018 <_ZN9TimeClass5monthEl>
	...

000dd114 <_ZN9TimeClass4yearEv>:
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
}

/* current four digit year */
int TimeClass::year()
{
   dd114:	b508      	push	{r3, lr}
	return year(now());
   dd116:	f7ff ffc6 	bl	dd0a6 <_ZN9TimeClass3nowEv>
}

/* the year for the given time */
int TimeClass::year(time_t t)
{
	Refresh_UnixTime_Cache(t);
   dd11a:	f7ff ff3d 	bl	dcf98 <_ZL22Refresh_UnixTime_Cachel>

/* current four digit year */
int TimeClass::year()
{
	return year(now());
}
   dd11e:	4b01      	ldr	r3, [pc, #4]	; (dd124 <_ZN9TimeClass4yearEv+0x10>)
   dd120:	6958      	ldr	r0, [r3, #20]
   dd122:	bd08      	pop	{r3, pc}
   dd124:	2003e45c 	.word	0x2003e45c

000dd128 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
   dd128:	4b02      	ldr	r3, [pc, #8]	; (dd134 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
   dd12a:	681a      	ldr	r2, [r3, #0]
   dd12c:	4b02      	ldr	r3, [pc, #8]	; (dd138 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
   dd12e:	601a      	str	r2, [r3, #0]
   dd130:	4770      	bx	lr
   dd132:	bf00      	nop
   dd134:	2003da40 	.word	0x2003da40
   dd138:	2003e480 	.word	0x2003e480

000dd13c <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
   dd13c:	2100      	movs	r1, #0
   dd13e:	f7fe bd4d 	b.w	dbbdc <system_delay_ms>

000dd142 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   dd142:	b510      	push	{r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   dd144:	6803      	ldr	r3, [r0, #0]
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   dd146:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   dd148:	689b      	ldr	r3, [r3, #8]
   dd14a:	4798      	blx	r3
          if (--_M_weak_count == 0)
   dd14c:	68a3      	ldr	r3, [r4, #8]
   dd14e:	3b01      	subs	r3, #1
   dd150:	60a3      	str	r3, [r4, #8]
   dd152:	b92b      	cbnz	r3, dd160 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12+0x1e>
            _M_destroy();
   dd154:	6823      	ldr	r3, [r4, #0]
   dd156:	4620      	mov	r0, r4
   dd158:	68db      	ldr	r3, [r3, #12]
        }
    }
   dd15a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
   dd15e:	4718      	bx	r3
   dd160:	bd10      	pop	{r4, pc}
	...

000dd164 <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
   dd164:	b510      	push	{r4, lr}
   dd166:	4b06      	ldr	r3, [pc, #24]	; (dd180 <_ZN9TCPClientD1Ev+0x1c>)
   dd168:	6003      	str	r3, [r0, #0]
   dd16a:	4604      	mov	r4, r0
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   dd16c:	6980      	ldr	r0, [r0, #24]
   dd16e:	b128      	cbz	r0, dd17c <_ZN9TCPClientD1Ev+0x18>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   dd170:	6843      	ldr	r3, [r0, #4]
   dd172:	3b01      	subs	r3, #1
   dd174:	6043      	str	r3, [r0, #4]
   dd176:	b90b      	cbnz	r3, dd17c <_ZN9TCPClientD1Ev+0x18>
   dd178:	f7ff ffe3 	bl	dd142 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.12>
   dd17c:	4620      	mov	r0, r4
   dd17e:	bd10      	pop	{r4, pc}
   dd180:	000e288c 	.word	0x000e288c

000dd184 <_ZN9TCPClientD0Ev>:
   dd184:	b510      	push	{r4, lr}
   dd186:	4604      	mov	r4, r0
   dd188:	f7ff ffec 	bl	dd164 <_ZN9TCPClientD1Ev>
   dd18c:	4620      	mov	r0, r4
   dd18e:	211c      	movs	r1, #28
   dd190:	f001 fdde 	bl	ded50 <_ZdlPvj>
   dd194:	4620      	mov	r0, r4
   dd196:	bd10      	pop	{r4, pc}

000dd198 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
   dd198:	b510      	push	{r4, lr}
   dd19a:	4604      	mov	r4, r0
   dd19c:	f7f7 fd93 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
   dd1a0:	4620      	mov	r0, r4
   dd1a2:	bd10      	pop	{r4, pc}

000dd1a4 <_ZN8RGBClass8mirrorToEtttbb>:
{
    onChange(wiring_rgb_change_handler_t(handler));
}

void RGBClass::mirrorTo(pin_t rpin, pin_t gpin, pin_t bpin, bool invert, bool bootloader)
{
   dd1a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   dd1a8:	f89d 5020 	ldrb.w	r5, [sp, #32]
   dd1ac:	461c      	mov	r4, r3
    HAL_Core_Led_Mirror_Pin(LED_RED + LED_MIRROR_OFFSET, rpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
   dd1ae:	2600      	movs	r6, #0
{
    onChange(wiring_rgb_change_handler_t(handler));
}

void RGBClass::mirrorTo(pin_t rpin, pin_t gpin, pin_t bpin, bool invert, bool bootloader)
{
   dd1b0:	4688      	mov	r8, r1
   dd1b2:	4617      	mov	r7, r2
    HAL_Core_Led_Mirror_Pin(LED_RED + LED_MIRROR_OFFSET, rpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
   dd1b4:	462b      	mov	r3, r5
   dd1b6:	4622      	mov	r2, r4
   dd1b8:	4601      	mov	r1, r0
   dd1ba:	9600      	str	r6, [sp, #0]
   dd1bc:	2005      	movs	r0, #5
   dd1be:	f7fe fb39 	bl	db834 <HAL_Core_Led_Mirror_Pin>
    HAL_Core_Led_Mirror_Pin(LED_GREEN + LED_MIRROR_OFFSET, gpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
   dd1c2:	462b      	mov	r3, r5
   dd1c4:	4622      	mov	r2, r4
   dd1c6:	4641      	mov	r1, r8
   dd1c8:	9600      	str	r6, [sp, #0]
   dd1ca:	2006      	movs	r0, #6
   dd1cc:	f7fe fb32 	bl	db834 <HAL_Core_Led_Mirror_Pin>
    HAL_Core_Led_Mirror_Pin(LED_BLUE + LED_MIRROR_OFFSET, bpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
   dd1d0:	462b      	mov	r3, r5
   dd1d2:	4622      	mov	r2, r4
   dd1d4:	4639      	mov	r1, r7
   dd1d6:	2007      	movs	r0, #7
   dd1d8:	9608      	str	r6, [sp, #32]
}
   dd1da:	b002      	add	sp, #8
   dd1dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

void RGBClass::mirrorTo(pin_t rpin, pin_t gpin, pin_t bpin, bool invert, bool bootloader)
{
    HAL_Core_Led_Mirror_Pin(LED_RED + LED_MIRROR_OFFSET, rpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
    HAL_Core_Led_Mirror_Pin(LED_GREEN + LED_MIRROR_OFFSET, gpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
    HAL_Core_Led_Mirror_Pin(LED_BLUE + LED_MIRROR_OFFSET, bpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
   dd1e0:	f7fe bb28 	b.w	db834 <HAL_Core_Led_Mirror_Pin>

000dd1e4 <_ZN8RGBClass13mirrorDisableEb>:
}

void RGBClass::mirrorDisable(bool bootloader)
{
   dd1e4:	b510      	push	{r4, lr}
    HAL_Core_Led_Mirror_Pin_Disable(LED_RED + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
   dd1e6:	4601      	mov	r1, r0
    HAL_Core_Led_Mirror_Pin(LED_GREEN + LED_MIRROR_OFFSET, gpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
    HAL_Core_Led_Mirror_Pin(LED_BLUE + LED_MIRROR_OFFSET, bpin, (uint32_t)invert, (uint8_t)bootloader, nullptr);
}

void RGBClass::mirrorDisable(bool bootloader)
{
   dd1e8:	4604      	mov	r4, r0
    HAL_Core_Led_Mirror_Pin_Disable(LED_RED + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
   dd1ea:	2200      	movs	r2, #0
   dd1ec:	2005      	movs	r0, #5
   dd1ee:	f7fe fb29 	bl	db844 <HAL_Core_Led_Mirror_Pin_Disable>
    HAL_Core_Led_Mirror_Pin_Disable(LED_GREEN + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
   dd1f2:	4621      	mov	r1, r4
   dd1f4:	2200      	movs	r2, #0
   dd1f6:	2006      	movs	r0, #6
   dd1f8:	f7fe fb24 	bl	db844 <HAL_Core_Led_Mirror_Pin_Disable>
    HAL_Core_Led_Mirror_Pin_Disable(LED_BLUE + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
   dd1fc:	4621      	mov	r1, r4
   dd1fe:	2200      	movs	r2, #0
   dd200:	2007      	movs	r0, #7
}
   dd202:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void RGBClass::mirrorDisable(bool bootloader)
{
    HAL_Core_Led_Mirror_Pin_Disable(LED_RED + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
    HAL_Core_Led_Mirror_Pin_Disable(LED_GREEN + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
    HAL_Core_Led_Mirror_Pin_Disable(LED_BLUE + LED_MIRROR_OFFSET, (uint8_t)bootloader, nullptr);
   dd206:	f7fe bb1d 	b.w	db844 <HAL_Core_Led_Mirror_Pin_Disable>

000dd20a <_ZSt4swapISt9_Any_dataEvRT_S2_>:
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
   dd20a:	b513      	push	{r0, r1, r4, lr}
   dd20c:	460b      	mov	r3, r1
   dd20e:	4604      	mov	r4, r0
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   dd210:	c803      	ldmia	r0, {r0, r1}
   dd212:	e88d 0003 	stmia.w	sp, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
   dd216:	e893 0003 	ldmia.w	r3, {r0, r1}
   dd21a:	e884 0003 	stmia.w	r4, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
   dd21e:	e89d 0003 	ldmia.w	sp, {r0, r1}
   dd222:	e883 0003 	stmia.w	r3, {r0, r1}
    }
   dd226:	b002      	add	sp, #8
   dd228:	bd10      	pop	{r4, pc}
	...

000dd22c <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   dd22c:	4803      	ldr	r0, [pc, #12]	; (dd23c <_GLOBAL__sub_I_RGB+0x10>)
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
   dd22e:	4a04      	ldr	r2, [pc, #16]	; (dd240 <_GLOBAL__sub_I_RGB+0x14>)
   dd230:	4904      	ldr	r1, [pc, #16]	; (dd244 <_GLOBAL__sub_I_RGB+0x18>)
   dd232:	2300      	movs	r3, #0
   dd234:	6083      	str	r3, [r0, #8]
   dd236:	f001 bd7d 	b.w	ded34 <__aeabi_atexit>
   dd23a:	bf00      	nop
   dd23c:	2003e490 	.word	0x2003e490
   dd240:	2003daf8 	.word	0x2003daf8
   dd244:	000dd199 	.word	0x000dd199

000dd248 <_ZN14CellularSignalD1Ev>:
    int rssi = 0;
    int qual = 0;

    CellularSignal() {}
    CellularSignal(const cellular_signal_t& sig);
    virtual ~CellularSignal() {};
   dd248:	4770      	bx	lr

000dd24a <_ZNK14CellularSignal19getAccessTechnologyEv>:
}

hal_net_access_tech_t CellularSignal::getAccessTechnology() const
{
    return static_cast<hal_net_access_tech_t>(sig_.rat);
}
   dd24a:	7d00      	ldrb	r0, [r0, #20]
   dd24c:	4770      	bx	lr
	...

000dd250 <_ZNK14CellularSignal16getStrengthValueEv>:
    return -1.0f;
}

float CellularSignal::getStrengthValue() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.rssi != std::numeric_limits<int32_t>::min()) {
   dd250:	7d03      	ldrb	r3, [r0, #20]
   dd252:	b11b      	cbz	r3, dd25c <_ZNK14CellularSignal16getStrengthValueEv+0xc>
   dd254:	6983      	ldr	r3, [r0, #24]
   dd256:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   dd25a:	d102      	bne.n	dd262 <_ZNK14CellularSignal16getStrengthValueEv+0x12>
        return (float)sig_.rssi / 100.0f;
    }

    return 0.0f;
   dd25c:	ed9f 0a05 	vldr	s0, [pc, #20]	; dd274 <_ZNK14CellularSignal16getStrengthValueEv+0x24>
   dd260:	4770      	bx	lr
}

float CellularSignal::getStrengthValue() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.rssi != std::numeric_limits<int32_t>::min()) {
        return (float)sig_.rssi / 100.0f;
   dd262:	ee07 3a90 	vmov	s15, r3
   dd266:	ed9f 7a04 	vldr	s14, [pc, #16]	; dd278 <_ZNK14CellularSignal16getStrengthValueEv+0x28>
   dd26a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   dd26e:	ee87 0a87 	vdiv.f32	s0, s15, s14
    }

    return 0.0f;
}
   dd272:	4770      	bx	lr
   dd274:	00000000 	.word	0x00000000
   dd278:	42c80000 	.word	0x42c80000

000dd27c <_ZNK14CellularSignal15getQualityValueEv>:
    return -1.0f;
}

float CellularSignal::getQualityValue() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.qual != std::numeric_limits<int32_t>::min()) {
   dd27c:	7d03      	ldrb	r3, [r0, #20]
   dd27e:	b11b      	cbz	r3, dd288 <_ZNK14CellularSignal15getQualityValueEv+0xc>
   dd280:	6a03      	ldr	r3, [r0, #32]
   dd282:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   dd286:	d102      	bne.n	dd28e <_ZNK14CellularSignal15getQualityValueEv+0x12>
        return (float)sig_.qual / 100.0f;
    }

    return 0.0f;
   dd288:	ed9f 0a05 	vldr	s0, [pc, #20]	; dd2a0 <_ZNK14CellularSignal15getQualityValueEv+0x24>
   dd28c:	4770      	bx	lr
}

float CellularSignal::getQualityValue() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.qual != std::numeric_limits<int32_t>::min()) {
        return (float)sig_.qual / 100.0f;
   dd28e:	ee07 3a90 	vmov	s15, r3
   dd292:	ed9f 7a04 	vldr	s14, [pc, #16]	; dd2a4 <_ZNK14CellularSignal15getQualityValueEv+0x28>
   dd296:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   dd29a:	ee87 0a87 	vdiv.f32	s0, s15, s14
    }

    return 0.0f;
}
   dd29e:	4770      	bx	lr
   dd2a0:	00000000 	.word	0x00000000
   dd2a4:	42c80000 	.word	0x42c80000

000dd2a8 <_ZN14CellularSignalD0Ev>:
   dd2a8:	b510      	push	{r4, lr}
   dd2aa:	2128      	movs	r1, #40	; 0x28
   dd2ac:	4604      	mov	r4, r0
   dd2ae:	f001 fd4f 	bl	ded50 <_ZdlPvj>
   dd2b2:	4620      	mov	r0, r4
   dd2b4:	bd10      	pop	{r4, pc}
	...

000dd2b8 <_ZNK14CellularSignal10getQualityEv>:
    return 0.0f;
}

float CellularSignal::getQuality() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.quality >= 0) {
   dd2b8:	7d03      	ldrb	r3, [r0, #20]
   dd2ba:	b17b      	cbz	r3, dd2dc <_ZNK14CellularSignal10getQualityEv+0x24>
   dd2bc:	6a43      	ldr	r3, [r0, #36]	; 0x24
   dd2be:	2b00      	cmp	r3, #0
   dd2c0:	db0c      	blt.n	dd2dc <_ZNK14CellularSignal10getQualityEv+0x24>
        return (float)sig_.quality / 65535.0f * 100.0f;
   dd2c2:	ee07 3a90 	vmov	s15, r3
   dd2c6:	eddf 6a07 	vldr	s13, [pc, #28]	; dd2e4 <_ZNK14CellularSignal10getQualityEv+0x2c>
   dd2ca:	ed9f 0a07 	vldr	s0, [pc, #28]	; dd2e8 <_ZNK14CellularSignal10getQualityEv+0x30>
   dd2ce:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   dd2d2:	eec7 7a26 	vdiv.f32	s15, s14, s13
   dd2d6:	ee27 0a80 	vmul.f32	s0, s15, s0
   dd2da:	4770      	bx	lr
    }

    return -1.0f;
   dd2dc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
}
   dd2e0:	4770      	bx	lr
   dd2e2:	bf00      	nop
   dd2e4:	477fff00 	.word	0x477fff00
   dd2e8:	42c80000 	.word	0x42c80000

000dd2ec <_ZNK14CellularSignal11getStrengthEv>:
    return static_cast<hal_net_access_tech_t>(sig_.rat);
}

float CellularSignal::getStrength() const
{
    if (sig_.rat != NET_ACCESS_TECHNOLOGY_NONE && sig_.strength >= 0) {
   dd2ec:	7d03      	ldrb	r3, [r0, #20]
   dd2ee:	b17b      	cbz	r3, dd310 <_ZNK14CellularSignal11getStrengthEv+0x24>
   dd2f0:	69c3      	ldr	r3, [r0, #28]
   dd2f2:	2b00      	cmp	r3, #0
   dd2f4:	db0c      	blt.n	dd310 <_ZNK14CellularSignal11getStrengthEv+0x24>
        return (float)sig_.strength / 65535.0f * 100.0f;
   dd2f6:	ee07 3a90 	vmov	s15, r3
   dd2fa:	eddf 6a07 	vldr	s13, [pc, #28]	; dd318 <_ZNK14CellularSignal11getStrengthEv+0x2c>
   dd2fe:	ed9f 0a07 	vldr	s0, [pc, #28]	; dd31c <_ZNK14CellularSignal11getStrengthEv+0x30>
   dd302:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   dd306:	eec7 7a26 	vdiv.f32	s15, s14, s13
   dd30a:	ee27 0a80 	vmul.f32	s0, s15, s0
   dd30e:	4770      	bx	lr
    }

    return -1.0f;
   dd310:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
}
   dd314:	4770      	bx	lr
   dd316:	bf00      	nop
   dd318:	477fff00 	.word	0x477fff00
   dd31c:	42c80000 	.word	0x42c80000

000dd320 <_ZN14CellularSignal21fromHalCellularSignalERK17cellular_signal_t>:
    : sig_(sig)
{
}

bool CellularSignal::fromHalCellularSignal(const cellular_signal_t& sig)
{
   dd320:	b530      	push	{r4, r5, lr}
    sig_ = sig;
   dd322:	460d      	mov	r5, r1
   dd324:	f100 0410 	add.w	r4, r0, #16
   dd328:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   dd32a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   dd32c:	e895 0003 	ldmia.w	r5, {r0, r1}
   dd330:	e884 0003 	stmia.w	r4, {r0, r1}
    return true;
}
   dd334:	2001      	movs	r0, #1
   dd336:	bd30      	pop	{r4, r5, pc}

000dd338 <_ZN5Print5printIiLi0EEEjT_i>:

};

template <typename T, std::enable_if_t<std::is_integral<T>::value || std::is_convertible<T, unsigned long long>::value ||
    std::is_convertible<T, long long>::value, int>>
size_t Print::print(T n, int base)
   dd338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   dd33c:	4607      	mov	r7, r0
   dd33e:	460c      	mov	r4, r1
{
    if (base == 0) {
   dd340:	4615      	mov	r5, r2
   dd342:	b92a      	cbnz	r2, dd350 <_ZN5Print5printIiLi0EEEjT_i+0x18>
        return write(n);
   dd344:	6803      	ldr	r3, [r0, #0]
   dd346:	b2c9      	uxtb	r1, r1
   dd348:	689b      	ldr	r3, [r3, #8]
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
    }
}
   dd34a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
template <typename T, std::enable_if_t<std::is_integral<T>::value || std::is_convertible<T, unsigned long long>::value ||
    std::is_convertible<T, long long>::value, int>>
size_t Print::print(T n, int base)
{
    if (base == 0) {
        return write(n);
   dd34e:	4718      	bx	r3
    } else {
        size_t t = 0;
        using PrintNumberType = typename PrintNumberTypeSelector<T>::type;
        PrintNumberType val;
        if (n < 0 && base == 10) {
   dd350:	2900      	cmp	r1, #0
   dd352:	da07      	bge.n	dd364 <_ZN5Print5printIiLi0EEEjT_i+0x2c>
   dd354:	2a0a      	cmp	r2, #10
   dd356:	d105      	bne.n	dd364 <_ZN5Print5printIiLi0EEEjT_i+0x2c>
            t = print('-');
   dd358:	212d      	movs	r1, #45	; 0x2d
   dd35a:	f7ff fd77 	bl	dce4c <_ZN5Print5printEc>
            val = -n;
   dd35e:	4261      	negs	r1, r4
    } else {
        size_t t = 0;
        using PrintNumberType = typename PrintNumberTypeSelector<T>::type;
        PrintNumberType val;
        if (n < 0 && base == 10) {
            t = print('-');
   dd360:	4606      	mov	r6, r0
            val = -n;
   dd362:	e001      	b.n	dd368 <_ZN5Print5printIiLi0EEEjT_i+0x30>
        } else {
            val = n;
   dd364:	4621      	mov	r1, r4
size_t Print::print(T n, int base)
{
    if (base == 0) {
        return write(n);
    } else {
        size_t t = 0;
   dd366:	2600      	movs	r6, #0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
   dd368:	b2ea      	uxtb	r2, r5
   dd36a:	4638      	mov	r0, r7
   dd36c:	f7ff fd87 	bl	dce7e <_ZN5Print11printNumberEmh>
    }
}
   dd370:	4430      	add	r0, r6
   dd372:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000dd376 <_ZNK14CellularSignal7printToER5Print>:

    return 0.0f;
}

size_t CellularSignal::printTo(Print& p) const
{
   dd376:	b570      	push	{r4, r5, r6, lr}
   dd378:	460d      	mov	r5, r1
   dd37a:	4606      	mov	r6, r0
    size_t n = 0;
    n += p.print((*this).rssi, DEC);
   dd37c:	220a      	movs	r2, #10
   dd37e:	6881      	ldr	r1, [r0, #8]
   dd380:	4628      	mov	r0, r5
   dd382:	f7ff ffd9 	bl	dd338 <_ZN5Print5printIiLi0EEEjT_i>
    n += p.print(',');
   dd386:	212c      	movs	r1, #44	; 0x2c
}

size_t CellularSignal::printTo(Print& p) const
{
    size_t n = 0;
    n += p.print((*this).rssi, DEC);
   dd388:	4604      	mov	r4, r0
    n += p.print(',');
   dd38a:	4628      	mov	r0, r5
   dd38c:	f7ff fd5e 	bl	dce4c <_ZN5Print5printEc>
    n += p.print((*this).qual, DEC);
   dd390:	220a      	movs	r2, #10

size_t CellularSignal::printTo(Print& p) const
{
    size_t n = 0;
    n += p.print((*this).rssi, DEC);
    n += p.print(',');
   dd392:	4404      	add	r4, r0
    n += p.print((*this).qual, DEC);
   dd394:	68f1      	ldr	r1, [r6, #12]
   dd396:	4628      	mov	r0, r5
   dd398:	f7ff ffce 	bl	dd338 <_ZN5Print5printIiLi0EEEjT_i>
    return n;
}
   dd39c:	4420      	add	r0, r4
   dd39e:	bd70      	pop	{r4, r5, r6, pc}

000dd3a0 <_ZThn4_NK14CellularSignal7printToER5Print>:
    virtual float getStrength() const;
    virtual float getStrengthValue() const;
    virtual float getQuality() const;
    virtual float getQualityValue() const;

    virtual size_t printTo(Print& p) const;
   dd3a0:	f1a0 0004 	sub.w	r0, r0, #4
   dd3a4:	f7ff bfe7 	b.w	dd376 <_ZNK14CellularSignal7printToER5Print>

000dd3a8 <_ZN9FuelGauge5beginEv>:
        unlock();
    }
}

boolean FuelGauge::begin()
{
   dd3a8:	b510      	push	{r4, lr}
   dd3aa:	4604      	mov	r4, r0
    if (!i2c_.isEnabled()) {
   dd3ac:	6800      	ldr	r0, [r0, #0]
   dd3ae:	f000 ff4a 	bl	de246 <_ZN7TwoWire9isEnabledEv>
   dd3b2:	b910      	cbnz	r0, dd3ba <_ZN9FuelGauge5beginEv+0x12>
		i2c_.begin();
   dd3b4:	6820      	ldr	r0, [r4, #0]
   dd3b6:	f000 ff01 	bl	de1bc <_ZN7TwoWire5beginEv>
    }
    return i2c_.isEnabled();
   dd3ba:	6820      	ldr	r0, [r4, #0]
}
   dd3bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
boolean FuelGauge::begin()
{
    if (!i2c_.isEnabled()) {
		i2c_.begin();
    }
    return i2c_.isEnabled();
   dd3c0:	f000 bf41 	b.w	de246 <_ZN7TwoWire9isEnabledEv>

000dd3c4 <_ZN6detail9_getVCellEhh>:
namespace detail {
	// Converts VCELL_REGISTER reading to Battery Voltage
	float _getVCell(byte MSB, byte LSB) {
		// VCELL = 12-bit value, 1.25mV (1V/800) per bit
		float value = (float)((MSB << 4) | (LSB >> 4));
		return value / 800.0;
   dd3c4:	0909      	lsrs	r1, r1, #4
   dd3c6:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
   dd3ca:	ee07 0a90 	vmov	s15, r0
   dd3ce:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
	}
   dd3d2:	eddf 7a02 	vldr	s15, [pc, #8]	; dd3dc <_ZN6detail9_getVCellEhh+0x18>
   dd3d6:	ee80 0a27 	vdiv.f32	s0, s0, s15
   dd3da:	4770      	bx	lr
   dd3dc:	44480000 	.word	0x44480000

000dd3e0 <_ZN9FuelGauge4lockEv>:
    i2c_.write(LSB);
    i2c_.endTransmission(true);
}

bool FuelGauge::lock() {
    return i2c_.lock();
   dd3e0:	6800      	ldr	r0, [r0, #0]
   dd3e2:	f000 bf34 	b.w	de24e <_ZN7TwoWire4lockEv>

000dd3e6 <_ZN9FuelGaugeC1ER7TwoWireb>:
FuelGauge::FuelGauge(bool _lock)
        : FuelGauge(*fuelWireInstance(), _lock)
{
}

FuelGauge::FuelGauge(TwoWire& i2c, bool _lock)
   dd3e6:	b510      	push	{r4, lr}
   dd3e8:	4604      	mov	r4, r0
    : i2c_(i2c),
      lock_(_lock) {
   dd3ea:	6001      	str	r1, [r0, #0]
   dd3ec:	7102      	strb	r2, [r0, #4]

    if (lock_) {
   dd3ee:	b10a      	cbz	r2, dd3f4 <_ZN9FuelGaugeC1ER7TwoWireb+0xe>
        lock();
   dd3f0:	f7ff fff6 	bl	dd3e0 <_ZN9FuelGauge4lockEv>
    }
}
   dd3f4:	4620      	mov	r0, r4
   dd3f6:	bd10      	pop	{r4, pc}

000dd3f8 <_ZN9FuelGaugeC1Eb>:
    return &Wire;
}

} // anonymous

FuelGauge::FuelGauge(bool _lock)
   dd3f8:	b538      	push	{r3, r4, r5, lr}
   dd3fa:	4604      	mov	r4, r0
   dd3fc:	460d      	mov	r5, r1
        default: {
            return &Wire;
        }
#if Wiring_Wire1
        case HAL_I2C_INTERFACE2: {
            return &Wire1;
   dd3fe:	f001 fc73 	bl	dece8 <_Z20__fetch_global_Wire1v>
}

} // anonymous

FuelGauge::FuelGauge(bool _lock)
        : FuelGauge(*fuelWireInstance(), _lock)
   dd402:	462a      	mov	r2, r5
   dd404:	4601      	mov	r1, r0
   dd406:	4620      	mov	r0, r4
   dd408:	f7ff ffed 	bl	dd3e6 <_ZN9FuelGaugeC1ER7TwoWireb>
{
}
   dd40c:	4620      	mov	r0, r4
   dd40e:	bd38      	pop	{r3, r4, r5, pc}

000dd410 <_ZN9FuelGauge6unlockEv>:
bool FuelGauge::lock() {
    return i2c_.lock();
}

bool FuelGauge::unlock() {
	return i2c_.unlock();
   dd410:	6800      	ldr	r0, [r0, #0]
   dd412:	f000 bf25 	b.w	de260 <_ZN7TwoWire6unlockEv>

000dd416 <_ZN9FuelGaugeD1Ev>:
    if (lock_) {
        lock();
    }
}

FuelGauge::~FuelGauge()
   dd416:	b510      	push	{r4, lr}
{
    if (lock_) {
   dd418:	7903      	ldrb	r3, [r0, #4]
    if (lock_) {
        lock();
    }
}

FuelGauge::~FuelGauge()
   dd41a:	4604      	mov	r4, r0
{
    if (lock_) {
   dd41c:	b10b      	cbz	r3, dd422 <_ZN9FuelGaugeD1Ev+0xc>
        unlock();
   dd41e:	f7ff fff7 	bl	dd410 <_ZN9FuelGauge6unlockEv>
    }
}
   dd422:	4620      	mov	r0, r4
   dd424:	bd10      	pop	{r4, pc}

000dd426 <_ZN9FuelGauge12readRegisterEhRhS0_>:
void FuelGauge::readConfigRegister(byte &MSB, byte &LSB) {
	readRegister(CONFIG_REGISTER, MSB, LSB);
}


void FuelGauge::readRegister(byte startAddress, byte &MSB, byte &LSB) {
   dd426:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   dd428:	4604      	mov	r4, r0
   dd42a:	4616      	mov	r6, r2
   dd42c:	461d      	mov	r5, r3
   dd42e:	460f      	mov	r7, r1
   dd430:	f7ff ffd6 	bl	dd3e0 <_ZN9FuelGauge4lockEv>
    std::lock_guard<FuelGauge> l(*this);
    i2c_.beginTransmission(MAX17043_ADDRESS);
   dd434:	6820      	ldr	r0, [r4, #0]
   dd436:	2136      	movs	r1, #54	; 0x36
   dd438:	f000 fefb 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
    i2c_.write(startAddress);
   dd43c:	6820      	ldr	r0, [r4, #0]
   dd43e:	6803      	ldr	r3, [r0, #0]
   dd440:	4639      	mov	r1, r7
   dd442:	689b      	ldr	r3, [r3, #8]
   dd444:	4798      	blx	r3
    i2c_.endTransmission(true);
   dd446:	2101      	movs	r1, #1
   dd448:	6820      	ldr	r0, [r4, #0]
   dd44a:	f000 fef5 	bl	de238 <_ZN7TwoWire15endTransmissionEh>

    i2c_.requestFrom(MAX17043_ADDRESS, 2, true);
   dd44e:	2202      	movs	r2, #2
   dd450:	2136      	movs	r1, #54	; 0x36
   dd452:	2301      	movs	r3, #1
   dd454:	6820      	ldr	r0, [r4, #0]
   dd456:	f000 fed3 	bl	de200 <_ZN7TwoWire11requestFromEhjh>
    MSB = i2c_.read();
   dd45a:	6820      	ldr	r0, [r4, #0]
   dd45c:	6803      	ldr	r3, [r0, #0]
   dd45e:	695b      	ldr	r3, [r3, #20]
   dd460:	4798      	blx	r3
   dd462:	7030      	strb	r0, [r6, #0]
    LSB = i2c_.read();
   dd464:	6820      	ldr	r0, [r4, #0]
   dd466:	6803      	ldr	r3, [r0, #0]
   dd468:	695b      	ldr	r3, [r3, #20]
   dd46a:	4798      	blx	r3
   dd46c:	7028      	strb	r0, [r5, #0]

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
      { _M_device.unlock(); }
   dd46e:	4620      	mov	r0, r4
}
   dd470:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   dd474:	f7ff bfcc 	b.w	dd410 <_ZN9FuelGauge6unlockEv>

000dd478 <_ZN9FuelGauge8getVCellEv>:
		return MSB + decimal;
	}
} // namespace detail

// Read and return the cell voltage
float FuelGauge::getVCell() {
   dd478:	b507      	push	{r0, r1, r2, lr}

	byte MSB = 0;
	byte LSB = 0;
   dd47a:	ab02      	add	r3, sp, #8
} // namespace detail

// Read and return the cell voltage
float FuelGauge::getVCell() {

	byte MSB = 0;
   dd47c:	2200      	movs	r2, #0
   dd47e:	f88d 2006 	strb.w	r2, [sp, #6]
	byte LSB = 0;
   dd482:	f803 2d01 	strb.w	r2, [r3, #-1]!

	readRegister(VCELL_REGISTER, MSB, LSB);
   dd486:	2102      	movs	r1, #2
   dd488:	f10d 0206 	add.w	r2, sp, #6
   dd48c:	f7ff ffcb 	bl	dd426 <_ZN9FuelGauge12readRegisterEhRhS0_>
	return detail::_getVCell(MSB, LSB);
   dd490:	f89d 1007 	ldrb.w	r1, [sp, #7]
   dd494:	f89d 0006 	ldrb.w	r0, [sp, #6]
}
   dd498:	b003      	add	sp, #12
   dd49a:	f85d eb04 	ldr.w	lr, [sp], #4

	byte MSB = 0;
	byte LSB = 0;

	readRegister(VCELL_REGISTER, MSB, LSB);
	return detail::_getVCell(MSB, LSB);
   dd49e:	f7ff bf91 	b.w	dd3c4 <_ZN6detail9_getVCellEhh>
	...

000dd4a4 <_ZN9FuelGauge6getSoCEv>:
}

// Read and return the state of charge of the cell
float FuelGauge::getSoC() {
   dd4a4:	b507      	push	{r0, r1, r2, lr}

	byte MSB = 0;
	byte LSB = 0;
   dd4a6:	ab02      	add	r3, sp, #8
}

// Read and return the state of charge of the cell
float FuelGauge::getSoC() {

	byte MSB = 0;
   dd4a8:	2200      	movs	r2, #0
	byte LSB = 0;
   dd4aa:	f803 2d01 	strb.w	r2, [r3, #-1]!
}

// Read and return the state of charge of the cell
float FuelGauge::getSoC() {

	byte MSB = 0;
   dd4ae:	f88d 2006 	strb.w	r2, [sp, #6]
	byte LSB = 0;

	readRegister(SOC_REGISTER, MSB, LSB);
   dd4b2:	2104      	movs	r1, #4
   dd4b4:	f10d 0206 	add.w	r2, sp, #6
   dd4b8:	f7ff ffb5 	bl	dd426 <_ZN9FuelGauge12readRegisterEhRhS0_>
	// Converts SOC_REGISTER reading to state of charge of the cell as a percentage
	float _getSoC(byte MSB, byte LSB) {
		// MSB is the whole number
		// LSB is the decimal, resolution in units 1/256%
		float decimal = LSB / 256.0;
		return MSB + decimal;
   dd4bc:	f89d 0007 	ldrb.w	r0, [sp, #7]
   dd4c0:	f001 fef6 	bl	df2b0 <__aeabi_i2d>
   dd4c4:	2200      	movs	r2, #0
   dd4c6:	4b09      	ldr	r3, [pc, #36]	; (dd4ec <_ZN9FuelGauge6getSoCEv+0x48>)
   dd4c8:	f001 ff58 	bl	df37c <__aeabi_dmul>
   dd4cc:	f002 fa10 	bl	df8f0 <__aeabi_d2f>
   dd4d0:	f89d 3006 	ldrb.w	r3, [sp, #6]
   dd4d4:	ee00 3a10 	vmov	s0, r3
	byte MSB = 0;
	byte LSB = 0;

	readRegister(SOC_REGISTER, MSB, LSB);
	return detail::_getSoC(MSB, LSB);
}
   dd4d8:	ee07 0a90 	vmov	s15, r0
	// Converts SOC_REGISTER reading to state of charge of the cell as a percentage
	float _getSoC(byte MSB, byte LSB) {
		// MSB is the whole number
		// LSB is the decimal, resolution in units 1/256%
		float decimal = LSB / 256.0;
		return MSB + decimal;
   dd4dc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
	byte MSB = 0;
	byte LSB = 0;

	readRegister(SOC_REGISTER, MSB, LSB);
	return detail::_getSoC(MSB, LSB);
}
   dd4e0:	ee37 0a80 	vadd.f32	s0, s15, s0
   dd4e4:	b003      	add	sp, #12
   dd4e6:	f85d fb04 	ldr.w	pc, [sp], #4
   dd4ea:	bf00      	nop
   dd4ec:	3f700000 	.word	0x3f700000

000dd4f0 <_ZN9FuelGauge18readConfigRegisterERhS0_>:

}


void FuelGauge::readConfigRegister(byte &MSB, byte &LSB) {
	readRegister(CONFIG_REGISTER, MSB, LSB);
   dd4f0:	4613      	mov	r3, r2
   dd4f2:	460a      	mov	r2, r1
   dd4f4:	210c      	movs	r1, #12
   dd4f6:	f7ff bf96 	b.w	dd426 <_ZN9FuelGauge12readRegisterEhRhS0_>

000dd4fa <_ZN9FuelGauge13writeRegisterEhhh>:
    i2c_.requestFrom(MAX17043_ADDRESS, 2, true);
    MSB = i2c_.read();
    LSB = i2c_.read();
}

void FuelGauge::writeRegister(byte address, byte MSB, byte LSB) {
   dd4fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   dd4fc:	4604      	mov	r4, r0
   dd4fe:	4616      	mov	r6, r2
   dd500:	461d      	mov	r5, r3
   dd502:	460f      	mov	r7, r1
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }
   dd504:	f7ff ff6c 	bl	dd3e0 <_ZN9FuelGauge4lockEv>
    std::lock_guard<FuelGauge> l(*this);
    i2c_.beginTransmission(MAX17043_ADDRESS);
   dd508:	6820      	ldr	r0, [r4, #0]
   dd50a:	2136      	movs	r1, #54	; 0x36
   dd50c:	f000 fe91 	bl	de232 <_ZN7TwoWire17beginTransmissionEi>
    i2c_.write(address);
   dd510:	6820      	ldr	r0, [r4, #0]
   dd512:	6803      	ldr	r3, [r0, #0]
   dd514:	4639      	mov	r1, r7
   dd516:	689b      	ldr	r3, [r3, #8]
   dd518:	4798      	blx	r3
    i2c_.write(MSB);
   dd51a:	6820      	ldr	r0, [r4, #0]
   dd51c:	6803      	ldr	r3, [r0, #0]
   dd51e:	4631      	mov	r1, r6
   dd520:	689b      	ldr	r3, [r3, #8]
   dd522:	4798      	blx	r3
    i2c_.write(LSB);
   dd524:	6820      	ldr	r0, [r4, #0]
   dd526:	6803      	ldr	r3, [r0, #0]
   dd528:	4629      	mov	r1, r5
   dd52a:	689a      	ldr	r2, [r3, #8]
   dd52c:	4790      	blx	r2
    i2c_.endTransmission(true);
   dd52e:	6820      	ldr	r0, [r4, #0]
   dd530:	2101      	movs	r1, #1
   dd532:	f000 fe81 	bl	de238 <_ZN7TwoWire15endTransmissionEh>

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
      { _M_device.unlock(); }
   dd536:	4620      	mov	r0, r4
}
   dd538:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   dd53c:	f7ff bf68 	b.w	dd410 <_ZN9FuelGauge6unlockEv>

000dd540 <_ZN9FuelGauge5sleepEv>:
void FuelGauge::quickStart() {

	writeRegister(MODE_REGISTER, 0x40, 0x00);
}

void FuelGauge::sleep() {
   dd540:	b513      	push	{r0, r1, r4, lr}
   dd542:	4604      	mov	r4, r0
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }
   dd544:	f7ff ff4c 	bl	dd3e0 <_ZN9FuelGauge4lockEv>

    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
	byte LSB = 0;
   dd548:	aa02      	add	r2, sp, #8
}

void FuelGauge::sleep() {

    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
   dd54a:	2300      	movs	r3, #0
	byte LSB = 0;
   dd54c:	f802 3d01 	strb.w	r3, [r2, #-1]!

	readConfigRegister(MSB, LSB);
   dd550:	f10d 0106 	add.w	r1, sp, #6
   dd554:	4620      	mov	r0, r4
}

void FuelGauge::sleep() {

    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
   dd556:	f88d 3006 	strb.w	r3, [sp, #6]
	byte LSB = 0;

	readConfigRegister(MSB, LSB);
   dd55a:	f7ff ffc9 	bl	dd4f0 <_ZN9FuelGauge18readConfigRegisterERhS0_>

	writeRegister(CONFIG_REGISTER, MSB, (LSB | 0b10000000));
   dd55e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   dd562:	f89d 2006 	ldrb.w	r2, [sp, #6]
   dd566:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   dd56a:	210c      	movs	r1, #12
   dd56c:	4620      	mov	r0, r4
   dd56e:	f7ff ffc4 	bl	dd4fa <_ZN9FuelGauge13writeRegisterEhhh>

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
      { _M_device.unlock(); }
   dd572:	4620      	mov	r0, r4
   dd574:	f7ff ff4c 	bl	dd410 <_ZN9FuelGauge6unlockEv>

}
   dd578:	b002      	add	sp, #8
   dd57a:	bd10      	pop	{r4, pc}

000dd57c <_ZN9FuelGauge6wakeupEv>:

void FuelGauge::wakeup() {
   dd57c:	b513      	push	{r0, r1, r4, lr}
   dd57e:	4604      	mov	r4, r0
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }
   dd580:	f7ff ff2e 	bl	dd3e0 <_ZN9FuelGauge4lockEv>
    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
	byte LSB = 0;
   dd584:	aa02      	add	r2, sp, #8

}

void FuelGauge::wakeup() {
    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
   dd586:	2300      	movs	r3, #0
	byte LSB = 0;
   dd588:	f802 3d01 	strb.w	r3, [r2, #-1]!

	readConfigRegister(MSB, LSB);
   dd58c:	f10d 0106 	add.w	r1, sp, #6
   dd590:	4620      	mov	r0, r4

}

void FuelGauge::wakeup() {
    std::lock_guard<FuelGauge> l(*this);
	byte MSB = 0;
   dd592:	f88d 3006 	strb.w	r3, [sp, #6]
	byte LSB = 0;

	readConfigRegister(MSB, LSB);
   dd596:	f7ff ffab 	bl	dd4f0 <_ZN9FuelGauge18readConfigRegisterERhS0_>

	writeRegister(CONFIG_REGISTER, MSB, (LSB & 0b01111111));
   dd59a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   dd59e:	f89d 2006 	ldrb.w	r2, [sp, #6]
   dd5a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   dd5a6:	210c      	movs	r1, #12
   dd5a8:	4620      	mov	r0, r4
   dd5aa:	f7ff ffa6 	bl	dd4fa <_ZN9FuelGauge13writeRegisterEhhh>

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
      { _M_device.unlock(); }
   dd5ae:	4620      	mov	r0, r4
   dd5b0:	f7ff ff2e 	bl	dd410 <_ZN9FuelGauge6unlockEv>

}
   dd5b4:	b002      	add	sp, #8
   dd5b6:	bd10      	pop	{r4, pc}

000dd5b8 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
   dd5b8:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
   dd5ba:	4b0c      	ldr	r3, [pc, #48]	; (dd5ec <serialEventRun+0x34>)
   dd5bc:	b133      	cbz	r3, dd5cc <serialEventRun+0x14>
   dd5be:	f000 fc6f 	bl	ddea0 <_Z16_fetch_usbserialv>
   dd5c2:	6803      	ldr	r3, [r0, #0]
   dd5c4:	691b      	ldr	r3, [r3, #16]
   dd5c6:	4798      	blx	r3
   dd5c8:	2800      	cmp	r0, #0
   dd5ca:	dc09      	bgt.n	dd5e0 <serialEventRun+0x28>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
   dd5cc:	4b08      	ldr	r3, [pc, #32]	; (dd5f0 <serialEventRun+0x38>)
   dd5ce:	b163      	cbz	r3, dd5ea <serialEventRun+0x32>
   dd5d0:	f000 fd5e 	bl	de090 <_Z22__fetch_global_Serial1v>
   dd5d4:	6803      	ldr	r3, [r0, #0]
   dd5d6:	691b      	ldr	r3, [r3, #16]
   dd5d8:	4798      	blx	r3
   dd5da:	2800      	cmp	r0, #0
   dd5dc:	dc03      	bgt.n	dd5e6 <serialEventRun+0x2e>
   dd5de:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
   dd5e0:	f3af 8000 	nop.w
   dd5e4:	e7f2      	b.n	dd5cc <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
   dd5e6:	f3af 8000 	nop.w
   dd5ea:	bd08      	pop	{r3, pc}
	...

000dd5f4 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
   dd5f4:	b508      	push	{r3, lr}
	serialEventRun();
   dd5f6:	f7ff ffdf 	bl	dd5b8 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   dd5fa:	f7fe f8eb 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   dd5fe:	4b01      	ldr	r3, [pc, #4]	; (dd604 <_post_loop+0x10>)
   dd600:	6018      	str	r0, [r3, #0]
   dd602:	bd08      	pop	{r3, pc}
   dd604:	2003e6ec 	.word	0x2003e6ec

000dd608 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   dd608:	4802      	ldr	r0, [pc, #8]	; (dd614 <_Z33system_initialize_user_backup_ramv+0xc>)
   dd60a:	4a03      	ldr	r2, [pc, #12]	; (dd618 <_Z33system_initialize_user_backup_ramv+0x10>)
   dd60c:	4903      	ldr	r1, [pc, #12]	; (dd61c <_Z33system_initialize_user_backup_ramv+0x14>)
   dd60e:	1a12      	subs	r2, r2, r0
   dd610:	f002 bc9f 	b.w	dff52 <memcpy>
   dd614:	2003f400 	.word	0x2003f400
   dd618:	2003f404 	.word	0x2003f404
   dd61c:	000e2b88 	.word	0x000e2b88

000dd620 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
   dd620:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   dd622:	2300      	movs	r3, #0
   dd624:	9300      	str	r3, [sp, #0]
   dd626:	461a      	mov	r2, r3
   dd628:	f06f 0177 	mvn.w	r1, #119	; 0x77
   dd62c:	f7fe fb08 	bl	dbc40 <system_ctrl_set_result>
}
   dd630:	b003      	add	sp, #12
   dd632:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000dd638 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
   dd638:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
   dd63a:	8843      	ldrh	r3, [r0, #2]
   dd63c:	2b0a      	cmp	r3, #10
   dd63e:	d008      	beq.n	dd652 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
   dd640:	2b50      	cmp	r3, #80	; 0x50
   dd642:	d109      	bne.n	dd658 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
   dd644:	4b09      	ldr	r3, [pc, #36]	; (dd66c <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
   dd646:	681b      	ldr	r3, [r3, #0]
   dd648:	b13b      	cbz	r3, dd65a <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
   dd64a:	b003      	add	sp, #12
   dd64c:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
   dd650:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
   dd652:	f7ff ffe5 	bl	dd620 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
   dd656:	e006      	b.n	dd666 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   dd658:	2300      	movs	r3, #0
   dd65a:	9300      	str	r3, [sp, #0]
   dd65c:	461a      	mov	r2, r3
   dd65e:	f06f 0177 	mvn.w	r1, #119	; 0x77
   dd662:	f7fe faed 	bl	dbc40 <system_ctrl_set_result>
        break;
    }
}
   dd666:	b003      	add	sp, #12
   dd668:	f85d fb04 	ldr.w	pc, [sp], #4
   dd66c:	2003e4a0 	.word	0x2003e4a0

000dd670 <module_user_init_hook>:

void module_user_init_hook()
{
   dd670:	b538      	push	{r3, r4, r5, lr}
#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
   dd672:	4c10      	ldr	r4, [pc, #64]	; (dd6b4 <module_user_init_hook+0x44>)
   dd674:	4d10      	ldr	r5, [pc, #64]	; (dd6b8 <module_user_init_hook+0x48>)
   dd676:	6823      	ldr	r3, [r4, #0]
   dd678:	42ab      	cmp	r3, r5
   dd67a:	4b10      	ldr	r3, [pc, #64]	; (dd6bc <module_user_init_hook+0x4c>)
   dd67c:	bf0c      	ite	eq
   dd67e:	2201      	moveq	r2, #1
   dd680:	2200      	movne	r2, #0
   dd682:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
   dd684:	d002      	beq.n	dd68c <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
   dd686:	f7ff ffbf 	bl	dd608 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
   dd68a:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
   dd68c:	f7fe f88a 	bl	db7a4 <HAL_RNG_GetRandomNumber>
   dd690:	4604      	mov	r4, r0
    srand(seed);
   dd692:	f002 fc71 	bl	dff78 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
   dd696:	4b0a      	ldr	r3, [pc, #40]	; (dd6c0 <module_user_init_hook+0x50>)
   dd698:	b113      	cbz	r3, dd6a0 <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
   dd69a:	4620      	mov	r0, r4
   dd69c:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
   dd6a0:	2100      	movs	r1, #0
   dd6a2:	4807      	ldr	r0, [pc, #28]	; (dd6c0 <module_user_init_hook+0x50>)
   dd6a4:	f7fe fb78 	bl	dbd98 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   dd6a8:	2100      	movs	r1, #0
   dd6aa:	4806      	ldr	r0, [pc, #24]	; (dd6c4 <module_user_init_hook+0x54>)
}
   dd6ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   dd6b0:	f7fe babc 	b.w	dbc2c <system_ctrl_set_app_request_handler>
   dd6b4:	2003f400 	.word	0x2003f400
   dd6b8:	9a271c1e 	.word	0x9a271c1e
   dd6bc:	2003e4a4 	.word	0x2003e4a4
   dd6c0:	00000000 	.word	0x00000000
   dd6c4:	000dd639 	.word	0x000dd639

000dd6c8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   dd6c8:	4770      	bx	lr

000dd6ca <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }
   dd6ca:	2000      	movs	r0, #0
   dd6cc:	4770      	bx	lr

000dd6ce <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   dd6ce:	b510      	push	{r4, lr}
   dd6d0:	2110      	movs	r1, #16
   dd6d2:	4604      	mov	r4, r0
   dd6d4:	f001 fb3c 	bl	ded50 <_ZdlPvj>
   dd6d8:	4620      	mov	r0, r4
   dd6da:	bd10      	pop	{r4, pc}

000dd6dc <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
   dd6dc:	b508      	push	{r3, lr}
      { delete this; }
   dd6de:	b108      	cbz	r0, dd6e4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv+0x8>
   dd6e0:	f7ff fff5 	bl	dd6ce <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
   dd6e4:	bd08      	pop	{r3, pc}

000dd6e6 <_ZN8particle5ErrorC1EOS0_>:

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
   dd6e6:	2200      	movs	r2, #0
   dd6e8:	6002      	str	r2, [r0, #0]

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
   dd6ea:	b510      	push	{r4, lr}

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
   dd6ec:	f64f 729c 	movw	r2, #65436	; 0xff9c
   dd6f0:	8082      	strh	r2, [r0, #4]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   dd6f2:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
   dd6f6:	8084      	strh	r4, [r0, #4]
      __b = _GLIBCXX_MOVE(__tmp);
   dd6f8:	808a      	strh	r2, [r1, #4]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   dd6fa:	6802      	ldr	r2, [r0, #0]
      __a = _GLIBCXX_MOVE(__b);
   dd6fc:	680c      	ldr	r4, [r1, #0]
   dd6fe:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
   dd700:	600a      	str	r2, [r1, #0]
}

inline particle::Error::Error(Error&& error) :
        Error() {
    swap(*this, error);
}
   dd702:	bd10      	pop	{r4, pc}

000dd704 <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
   dd704:	b510      	push	{r4, lr}
   dd706:	4604      	mov	r4, r0
    free((void*)msg_);
   dd708:	6800      	ldr	r0, [r0, #0]
   dd70a:	f7fe fb5d 	bl	dbdc8 <free>
}
   dd70e:	4620      	mov	r0, r4
   dd710:	bd10      	pop	{r4, pc}

000dd712 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
   dd712:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
   dd714:	68c4      	ldr	r4, [r0, #12]
   dd716:	b1f4      	cbz	r4, dd756 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { 
        _Tp tmp;
	__atomic_load(&_M_i, &tmp, __m);
   dd718:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
   dd71a:	2b02      	cmp	r3, #2
   dd71c:	d103      	bne.n	dd726 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
   dd71e:	f104 000c 	add.w	r0, r4, #12
   dd722:	f7ff ffef 	bl	dd704 <_ZN8particle5ErrorD1Ev>
      {
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, __m);
   dd726:	6865      	ldr	r5, [r4, #4]
    // Completion callback types
    typedef typename detail::FutureCallbackTypes<ResultT>::OnSuccess OnSuccessCallback;
    typedef typename detail::FutureCallbackTypes<ResultT>::OnError OnErrorCallback;

    ~FutureImplBase() {
        delete onSuccess_.load(std::memory_order_relaxed);
   dd728:	b135      	cbz	r5, dd738 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   dd72a:	4628      	mov	r0, r5
   dd72c:	f7f7 facb 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
   dd730:	2110      	movs	r1, #16
   dd732:	4628      	mov	r0, r5
   dd734:	f001 fb0c 	bl	ded50 <_ZdlPvj>
   dd738:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
   dd73a:	b135      	cbz	r5, dd74a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
   dd73c:	4628      	mov	r0, r5
   dd73e:	f7f7 fac2 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
   dd742:	2110      	movs	r1, #16
   dd744:	4628      	mov	r0, r5
   dd746:	f001 fb03 	bl	ded50 <_ZdlPvj>
   dd74a:	4620      	mov	r0, r4
   dd74c:	2114      	movs	r1, #20
   dd74e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   dd752:	f001 bafd 	b.w	ded50 <_ZdlPvj>
   dd756:	bd38      	pop	{r3, r4, r5, pc}

000dd758 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
}

} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
   dd758:	b510      	push	{r4, lr}
   dd75a:	b088      	sub	sp, #32
   dd75c:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
   dd75e:	4668      	mov	r0, sp
   dd760:	f7fe ff27 	bl	dc5b2 <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
   dd764:	4669      	mov	r1, sp
   dd766:	a804      	add	r0, sp, #16
   dd768:	f7fe ff45 	bl	dc5f6 <_ZN6StringC1ERKS_>
   dd76c:	a804      	add	r0, sp, #16
   dd76e:	47a0      	blx	r4
   dd770:	4604      	mov	r4, r0
   dd772:	a804      	add	r0, sp, #16
   dd774:	f7fe fed6 	bl	dc524 <_ZN6StringD1Ev>
} // namespace

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
   dd778:	4668      	mov	r0, sp
   dd77a:	f7fe fed3 	bl	dc524 <_ZN6StringD1Ev>
    return (*fn)(p);
}
   dd77e:	4620      	mov	r0, r4
   dd780:	b008      	add	sp, #32
   dd782:	bd10      	pop	{r4, pc}

000dd784 <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
   dd784:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
   dd786:	2410      	movs	r4, #16
   dd788:	b085      	sub	sp, #20
   dd78a:	4607      	mov	r7, r0
   dd78c:	460e      	mov	r6, r1
   dd78e:	4615      	mov	r5, r2
   dd790:	2100      	movs	r1, #0
   dd792:	4622      	mov	r2, r4
   dd794:	4668      	mov	r0, sp
   dd796:	f002 fbe7 	bl	dff68 <memset>
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
   dd79a:	2200      	movs	r2, #0
   dd79c:	4669      	mov	r1, sp
   dd79e:	4610      	mov	r0, r2
         size = sizeof(*this);
   dd7a0:	f8ad 4000 	strh.w	r4, [sp]

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
   dd7a4:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
   dd7a6:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
   dd7a8:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
   dd7aa:	f7fe faad 	bl	dbd08 <spark_function>
}
   dd7ae:	b005      	add	sp, #20
   dd7b0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000dd7b2 <_ZN10CloudClass13publishVitalsEm>:
    }

    return p.future();
}

int CloudClass::publishVitals(system_tick_t period_s_) {
   dd7b2:	4608      	mov	r0, r1
    return spark_publish_vitals(period_s_, nullptr);
   dd7b4:	2100      	movs	r1, #0
   dd7b6:	f7fe baf7 	b.w	dbda8 <spark_publish_vitals>

000dd7ba <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>:
};

template<typename ResultT, typename ContextT = detail::FutureContext>
class Future: public FutureBase<ResultT, ContextT> {
public:
    using FutureBase<ResultT, ContextT>::FutureBase;
   dd7ba:	b513      	push	{r0, r1, r4, lr}
   dd7bc:	4604      	mov	r4, r0
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   dd7be:	e891 0005 	ldmia.w	r1, {r0, r2}
	__r._M_pi = _M_pi;
   dd7c2:	2300      	movs	r3, #0
   dd7c4:	604b      	str	r3, [r1, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
   dd7c6:	600b      	str	r3, [r1, #0]
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
   dd7c8:	6020      	str	r0, [r4, #0]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
   dd7ca:	6062      	str	r2, [r4, #4]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dd7cc:	a801      	add	r0, sp, #4

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
   dd7ce:	9301      	str	r3, [sp, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
   dd7d0:	9300      	str	r3, [sp, #0]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dd7d2:	f7f8 fa1b 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dd7d6:	4620      	mov	r0, r4
   dd7d8:	b002      	add	sp, #8
   dd7da:	bd10      	pop	{r4, pc}

000dd7dc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
   dd7dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dd7de:	460c      	mov	r4, r1
   dd7e0:	ad02      	add	r5, sp, #8
   dd7e2:	f854 3b04 	ldr.w	r3, [r4], #4
   dd7e6:	f845 3d08 	str.w	r3, [r5, #-8]!
   dd7ea:	4606      	mov	r6, r0
   dd7ec:	460f      	mov	r7, r1
   dd7ee:	a801      	add	r0, sp, #4
   dd7f0:	4621      	mov	r1, r4
   dd7f2:	f7ff f8f1 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
   dd7f6:	4629      	mov	r1, r5
   dd7f8:	4630      	mov	r0, r6
   dd7fa:	f7ff ffde 	bl	dd7ba <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dd7fe:	a801      	add	r0, sp, #4
   dd800:	f7f8 fa04 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dd804:	4620      	mov	r0, r4
   dd806:	f7f8 fa01 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        delete d;
   dd80a:	4638      	mov	r0, r7
   dd80c:	2108      	movs	r1, #8
   dd80e:	f001 fa9f 	bl	ded50 <_ZdlPvj>
        return p;
    }
   dd812:	4630      	mov	r0, r6
   dd814:	b003      	add	sp, #12
   dd816:	bdf0      	pop	{r4, r5, r6, r7, pc}

000dd818 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
   dd818:	b538      	push	{r3, r4, r5, lr}
   dd81a:	2300      	movs	r3, #0
   dd81c:	4604      	mov	r4, r0
   dd81e:	6003      	str	r3, [r0, #0]
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   dd820:	2010      	movs	r0, #16
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
   dd822:	460d      	mov	r5, r1
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   dd824:	f7f6 fc39 	bl	d409a <_Znwj>
   dd828:	b128      	cbz	r0, dd836 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
   dd82a:	2301      	movs	r3, #1
   dd82c:	6043      	str	r3, [r0, #4]
   dd82e:	6083      	str	r3, [r0, #8]
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }
   dd830:	4b02      	ldr	r3, [pc, #8]	; (dd83c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
   dd832:	6003      	str	r3, [r0, #0]
   dd834:	60c5      	str	r5, [r0, #12]
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   dd836:	6020      	str	r0, [r4, #0]
	  __catch(...)
	    {
	      delete __p;
	      __throw_exception_again;
	    }
	}
   dd838:	4620      	mov	r0, r4
   dd83a:	bd38      	pop	{r3, r4, r5, pc}
   dd83c:	000e2750 	.word	0x000e2750

000dd840 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   dd840:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
   dd842:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   dd844:	b90a      	cbnz	r2, dd84a <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
   dd846:	f001 fa96 	bl	ded76 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   dd84a:	68c3      	ldr	r3, [r0, #12]
    }
   dd84c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   dd850:	4718      	bx	r3

000dd852 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   dd852:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
   dd854:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
   dd856:	f100 0110 	add.w	r1, r0, #16
   dd85a:	f7ff fff1 	bl	dd840 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
   dd85e:	bd08      	pop	{r3, pc}

000dd860 <_ZNKSt8functionIFvRKbEEclES1_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   dd860:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
   dd862:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   dd864:	b90a      	cbnz	r2, dd86a <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
   dd866:	f001 fa86 	bl	ded76 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   dd86a:	68c3      	ldr	r3, [r0, #12]
    }
   dd86c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   dd870:	4718      	bx	r3

000dd872 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   dd872:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
   dd874:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
   dd876:	f100 0110 	add.w	r1, r0, #16
   dd87a:	f7ff fff1 	bl	dd860 <_ZNKSt8functionIFvRKbEEclES1_>
   dd87e:	bd08      	pop	{r3, pc}

000dd880 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
   dd880:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   dd882:	2300      	movs	r3, #0
   dd884:	6083      	str	r3, [r0, #8]
   dd886:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
   dd888:	4604      	mov	r4, r0
   dd88a:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
   dd88c:	b12b      	cbz	r3, dd89a <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   dd88e:	2202      	movs	r2, #2
   dd890:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   dd892:	68eb      	ldr	r3, [r5, #12]
   dd894:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   dd896:	68ab      	ldr	r3, [r5, #8]
   dd898:	60a3      	str	r3, [r4, #8]
	}
    }
   dd89a:	4620      	mov	r0, r4
   dd89c:	bd38      	pop	{r3, r4, r5, pc}
	...

000dd8a0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:

    explicit PromiseBase(detail::FutureImplPtr<ResultT, ContextT> ptr) :
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
   dd8a0:	b5f0      	push	{r4, r5, r6, r7, lr}
   dd8a2:	b089      	sub	sp, #36	; 0x24
   dd8a4:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
   dd8a6:	4668      	mov	r0, sp
   dd8a8:	f7ff ff1d 	bl	dd6e6 <_ZN8particle5ErrorC1EOS0_>
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
   dd8ac:	2300      	movs	r3, #0
   dd8ae:	f88d 3008 	strb.w	r3, [sp, #8]

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
   dd8b2:	f04f 0202 	mov.w	r2, #2
   dd8b6:	e8d4 3f4f 	ldrexb	r3, [r4]
   dd8ba:	2b00      	cmp	r3, #0
   dd8bc:	d103      	bne.n	dd8c6 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x26>
   dd8be:	e8c4 2f41 	strexb	r1, r2, [r4]
   dd8c2:	2900      	cmp	r1, #0
   dd8c4:	d1f7      	bne.n	dd8b6 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x16>
   dd8c6:	d002      	beq.n	dd8ce <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x2e>
   dd8c8:	f88d 3008 	strb.w	r3, [sp, #8]
   dd8cc:	e063      	b.n	dd996 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf6>
        return std::move(defaultValue);
    }

    void setError(Error error) {
        if (this->changeState(State::FAILED)) {
            new(&error_) Error(std::move(error));
   dd8ce:	f114 050c 	adds.w	r5, r4, #12
   dd8d2:	d003      	beq.n	dd8dc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x3c>
   dd8d4:	4669      	mov	r1, sp
   dd8d6:	4628      	mov	r0, r5
   dd8d8:	f7ff ff05 	bl	dd6e6 <_ZN8particle5ErrorC1EOS0_>
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
   dd8dc:	f3bf 8f5f 	dmb	sy
   dd8e0:	2301      	movs	r3, #1
   dd8e2:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
   dd8e4:	2000      	movs	r0, #0
   dd8e6:	f104 0308 	add.w	r3, r4, #8
   dd8ea:	f3bf 8f5f 	dmb	sy
   dd8ee:	e853 6f00 	ldrex	r6, [r3]
   dd8f2:	e843 0200 	strex	r2, r0, [r3]
   dd8f6:	2a00      	cmp	r2, #0
   dd8f8:	d1f9      	bne.n	dd8ee <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x4e>
   dd8fa:	f3bf 8f5f 	dmb	sy

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
   dd8fe:	2e00      	cmp	r6, #0
   dd900:	d049      	beq.n	dd996 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf6>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
   dd902:	f7fe f97b 	bl	dbbfc <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
   dd906:	b120      	cbz	r0, dd912 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x72>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   dd908:	4629      	mov	r1, r5
   dd90a:	4630      	mov	r0, r6
   dd90c:	f7ff ff98 	bl	dd840 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
   dd910:	e03a      	b.n	dd988 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xe8>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   dd912:	4631      	mov	r1, r6
   dd914:	a802      	add	r0, sp, #8
   dd916:	f7ff ffb3 	bl	dd880 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
   dd91a:	68e0      	ldr	r0, [r4, #12]
   dd91c:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
   dd920:	b108      	cbz	r0, dd926 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x86>
   dd922:	f002 fb71 	bl	e0008 <strdup>
   dd926:	9006      	str	r0, [sp, #24]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   dd928:	2010      	movs	r0, #16
   dd92a:	f8ad 501c 	strh.w	r5, [sp, #28]
   dd92e:	f7f6 fbb4 	bl	d409a <_Znwj>
   dd932:	4605      	mov	r5, r0
   dd934:	b1e8      	cbz	r0, dd972 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd2>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   dd936:	2700      	movs	r7, #0
   dd938:	6087      	str	r7, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   dd93a:	2018      	movs	r0, #24
   dd93c:	f7f6 fbad 	bl	d409a <_Znwj>
   dd940:	4604      	mov	r4, r0
   dd942:	b188      	cbz	r0, dd968 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xc8>
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
   dd944:	4601      	mov	r1, r0
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   dd946:	6087      	str	r7, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
   dd948:	a802      	add	r0, sp, #8
   dd94a:	f7ff fc5e 	bl	dd20a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   dd94e:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
   dd950:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   dd952:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   dd954:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
   dd956:	9204      	str	r2, [sp, #16]
   dd958:	a906      	add	r1, sp, #24
   dd95a:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   dd95c:	60e3      	str	r3, [r4, #12]
   dd95e:	f104 0010 	add.w	r0, r4, #16
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   dd962:	9205      	str	r2, [sp, #20]
   dd964:	f7ff febf 	bl	dd6e6 <_ZN8particle5ErrorC1EOS0_>
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
   dd968:	4b0d      	ldr	r3, [pc, #52]	; (dd9a0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x100>)
   dd96a:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   dd96c:	4b0d      	ldr	r3, [pc, #52]	; (dd9a4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x104>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   dd96e:	602c      	str	r4, [r5, #0]

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
   dd970:	60ab      	str	r3, [r5, #8]
      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
   dd972:	a806      	add	r0, sp, #24
   dd974:	f7ff fec6 	bl	dd704 <_ZN8particle5ErrorD1Ev>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   dd978:	a802      	add	r0, sp, #8
   dd97a:	f7f7 f9a4 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
   dd97e:	2200      	movs	r2, #0
   dd980:	4629      	mov	r1, r5
   dd982:	4809      	ldr	r0, [pc, #36]	; (dd9a8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x108>)
   dd984:	f7fe f942 	bl	dbc0c <application_thread_invoke>
   dd988:	4630      	mov	r0, r6
   dd98a:	f7f7 f99c 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
   dd98e:	2110      	movs	r1, #16
   dd990:	4630      	mov	r0, r6
   dd992:	f001 f9dd 	bl	ded50 <_ZdlPvj>
    explicit PromiseBase(detail::FutureImplPtr<ResultT, ContextT> ptr) :
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
        p_->setError(std::move(error));
   dd996:	4668      	mov	r0, sp
   dd998:	f7ff feb4 	bl	dd704 <_ZN8particle5ErrorD1Ev>
    }
   dd99c:	b009      	add	sp, #36	; 0x24
   dd99e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   dd9a0:	000dd853 	.word	0x000dd853
   dd9a4:	000ddac9 	.word	0x000ddac9
   dd9a8:	000de111 	.word	0x000de111

000dd9ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
   dd9ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   dd9b0:	b08b      	sub	sp, #44	; 0x2c
   dd9b2:	4606      	mov	r6, r0
   dd9b4:	460f      	mov	r7, r1
   dd9b6:	4690      	mov	r8, r2
   dd9b8:	4699      	mov	r9, r3
   dd9ba:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   dd9be:	f7fe f9c3 	bl	dbd48 <spark_cloud_flag_connected>
   dd9c2:	ad07      	add	r5, sp, #28
    if (!connected()) {
   dd9c4:	4683      	mov	fp, r0
   dd9c6:	bb30      	cbnz	r0, dda16 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6a>

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
   dd9c8:	f64f 732e 	movw	r3, #65326	; 0xff2e
   dd9cc:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   dd9ce:	a905      	add	r1, sp, #20
   dd9d0:	4628      	mov	r0, r5
   dd9d2:	f8ad 3018 	strh.w	r3, [sp, #24]
   dd9d6:	f7ff fe86 	bl	dd6e6 <_ZN8particle5ErrorC1EOS0_>
   dd9da:	2014      	movs	r0, #20
   dd9dc:	f7f6 fb5d 	bl	d409a <_Znwj>
   dd9e0:	4604      	mov	r4, r0
   dd9e2:	b158      	cbz	r0, dd9fc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x50>
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
   dd9e4:	2302      	movs	r3, #2
   dd9e6:	7003      	strb	r3, [r0, #0]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   dd9e8:	2301      	movs	r3, #1
   dd9ea:	7043      	strb	r3, [r0, #1]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __pointer_type convertible to _M_p.
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   dd9ec:	f8c0 b004 	str.w	fp, [r0, #4]
   dd9f0:	f8c0 b008 	str.w	fp, [r0, #8]
            result_(std::move(result)) {
    }

    explicit FutureImpl(Error error) :
            FutureImplBase<ResultT, ContextT>(State::FAILED),
            error_(std::move(error)) {
   dd9f4:	4629      	mov	r1, r5
   dd9f6:	300c      	adds	r0, #12
   dd9f8:	f7ff fe75 	bl	dd6e6 <_ZN8particle5ErrorC1EOS0_>
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
	explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
   dd9fc:	4630      	mov	r0, r6
   dd9fe:	4621      	mov	r1, r4
   dda00:	f840 4b04 	str.w	r4, [r0], #4
   dda04:	f7ff ff08 	bl	dd818 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   dda08:	4628      	mov	r0, r5
   dda0a:	f7ff fe7b 	bl	dd704 <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
   dda0e:	a805      	add	r0, sp, #20
   dda10:	f7ff fe78 	bl	dd704 <_ZN8particle5ErrorD1Ev>
   dda14:	e052      	b.n	ddabc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x110>
        return Future<bool>(Error::INVALID_STATE);
    }
    spark_send_event_data d = { sizeof(spark_send_event_data) };
   dda16:	2400      	movs	r4, #0
   dda18:	230c      	movs	r3, #12
// can be acquired via Future
template<typename ResultT, typename ContextT>
class PromiseBase {
public:
    PromiseBase() :
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
   dda1a:	2014      	movs	r0, #20
   dda1c:	606c      	str	r4, [r5, #4]
   dda1e:	60ac      	str	r4, [r5, #8]
   dda20:	9307      	str	r3, [sp, #28]
   dda22:	f7f6 fb3a 	bl	d409a <_Znwj>
   dda26:	4601      	mov	r1, r0
   dda28:	b118      	cbz	r0, dda32 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x86>
   dda2a:	7004      	strb	r4, [r0, #0]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   dda2c:	7044      	strb	r4, [r0, #1]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __pointer_type convertible to _M_p.
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   dda2e:	6044      	str	r4, [r0, #4]
   dda30:	6084      	str	r4, [r0, #8]
   dda32:	a804      	add	r0, sp, #16
   dda34:	9103      	str	r1, [sp, #12]
   dda36:	f7ff feef 	bl	dd818 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
   dda3a:	4b22      	ldr	r3, [pc, #136]	; (ddac4 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x118>)
   dda3c:	9308      	str	r3, [sp, #32]
    }

    // Wraps this promise into an object pointer that can be passed to a C function
    void* dataPtr() const {
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
   dda3e:	2008      	movs	r0, #8
   dda40:	f7f6 fb2b 	bl	d409a <_Znwj>
   dda44:	4604      	mov	r4, r0
   dda46:	b128      	cbz	r0, dda54 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xa8>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
   dda48:	9b03      	ldr	r3, [sp, #12]
   dda4a:	f840 3b04 	str.w	r3, [r0], #4
   dda4e:	a904      	add	r1, sp, #16
   dda50:	f7fe ffc2 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    d.handler_data = p.dataPtr();

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   dda54:	9500      	str	r5, [sp, #0]
   dda56:	fa5f f38a 	uxtb.w	r3, sl
   dda5a:	464a      	mov	r2, r9
   dda5c:	4641      	mov	r1, r8
   dda5e:	4638      	mov	r0, r7
    spark_send_event_data d = { sizeof(spark_send_event_data) };

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
    d.handler_data = p.dataPtr();
   dda60:	9409      	str	r4, [sp, #36]	; 0x24

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   dda62:	f7fe f979 	bl	dbd58 <spark_send_event>
   dda66:	b920      	cbnz	r0, dda72 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xc6>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
   dda68:	9b03      	ldr	r3, [sp, #12]
   dda6a:	785b      	ldrb	r3, [r3, #1]
   dda6c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   dda70:	b183      	cbz	r3, dda94 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe8>
   dda72:	9b03      	ldr	r3, [sp, #12]
   dda74:	9305      	str	r3, [sp, #20]
   dda76:	a904      	add	r1, sp, #16
   dda78:	a806      	add	r0, sp, #24
   dda7a:	f7fe ffad 	bl	dc9d8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    bool isDone() const {
        return p_->isDone();
    }

    Future<ResultT, ContextT> future() const {
        return Future<ResultT, ContextT>(p_);
   dda7e:	a905      	add	r1, sp, #20
   dda80:	4630      	mov	r0, r6
   dda82:	f7ff fe9a 	bl	dd7ba <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
   dda86:	a806      	add	r0, sp, #24
   dda88:	f7f8 f8c0 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dda8c:	a804      	add	r0, sp, #16
   dda8e:	f7f8 f8bd 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   dda92:	e013      	b.n	ddabc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x110>
   dda94:	f64f 739c 	movw	r3, #65436	; 0xff9c
        // Set generic error code in case completion callback wasn't invoked for some reason
        p.setError(Error::UNKNOWN);
   dda98:	a905      	add	r1, sp, #20
   dda9a:	a803      	add	r0, sp, #12
   dda9c:	9205      	str	r2, [sp, #20]
   dda9e:	f8ad 3018 	strh.w	r3, [sp, #24]
   ddaa2:	f7ff fefd 	bl	dd8a0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   ddaa6:	a805      	add	r0, sp, #20
   ddaa8:	f7ff fe2c 	bl	dd704 <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
   ddaac:	a805      	add	r0, sp, #20
   ddaae:	9909      	ldr	r1, [sp, #36]	; 0x24
   ddab0:	f7ff fe94 	bl	dd7dc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
   ddab4:	a806      	add	r0, sp, #24
   ddab6:	f7f8 f8a9 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   ddaba:	e7da      	b.n	dda72 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xc6>
    }

    return p.future();
}
   ddabc:	4630      	mov	r0, r6
   ddabe:	b00b      	add	sp, #44	; 0x2c
   ddac0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   ddac4:	000ddc39 	.word	0x000ddc39

000ddac8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
   ddac8:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
   ddaca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   ddacc:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
   ddace:	d006      	beq.n	ddade <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x16>
   ddad0:	2a03      	cmp	r2, #3
   ddad2:	d017      	beq.n	ddb04 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3c>
   ddad4:	2a01      	cmp	r2, #1
   ddad6:	d122      	bne.n	ddb1e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x56>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
   ddad8:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
   ddada:	6003      	str	r3, [r0, #0]
	      break;
   ddadc:	e01f      	b.n	ddb1e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x56>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
   ddade:	2018      	movs	r0, #24
   ddae0:	680e      	ldr	r6, [r1, #0]
   ddae2:	f7f6 fada 	bl	d409a <_Znwj>
   ddae6:	4605      	mov	r5, r0
   ddae8:	b150      	cbz	r0, ddb00 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x38>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
   ddaea:	4631      	mov	r1, r6
   ddaec:	f7ff fec8 	bl	dd880 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
   ddaf0:	6930      	ldr	r0, [r6, #16]
   ddaf2:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
   ddaf6:	b108      	cbz	r0, ddafc <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x34>
   ddaf8:	f002 fa86 	bl	e0008 <strdup>
   ddafc:	6128      	str	r0, [r5, #16]
   ddafe:	82af      	strh	r7, [r5, #20]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
   ddb00:	6025      	str	r5, [r4, #0]
   ddb02:	e00c      	b.n	ddb1e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x56>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
   ddb04:	6804      	ldr	r4, [r0, #0]
   ddb06:	b154      	cbz	r4, ddb1e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x56>
   ddb08:	f104 0010 	add.w	r0, r4, #16
   ddb0c:	f7ff fdfa 	bl	dd704 <_ZN8particle5ErrorD1Ev>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   ddb10:	4620      	mov	r0, r4
   ddb12:	f7f7 f8d8 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
   ddb16:	2118      	movs	r1, #24
   ddb18:	4620      	mov	r0, r4
   ddb1a:	f001 f919 	bl	ded50 <_ZdlPvj>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
   ddb1e:	2000      	movs	r0, #0
   ddb20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000ddb22 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
   ddb22:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   ddb24:	2300      	movs	r3, #0
   ddb26:	6083      	str	r3, [r0, #8]
   ddb28:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
   ddb2a:	4604      	mov	r4, r0
   ddb2c:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
   ddb2e:	b12b      	cbz	r3, ddb3c <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   ddb30:	2202      	movs	r2, #2
   ddb32:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   ddb34:	68eb      	ldr	r3, [r5, #12]
   ddb36:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   ddb38:	68ab      	ldr	r3, [r5, #8]
   ddb3a:	60a3      	str	r3, [r4, #8]
	}
    }
   ddb3c:	4620      	mov	r0, r4
   ddb3e:	bd38      	pop	{r3, r4, r5, pc}

000ddb40 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
   ddb40:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
   ddb42:	b570      	push	{r4, r5, r6, lr}
   ddb44:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
   ddb46:	d006      	beq.n	ddb56 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x16>
   ddb48:	2a03      	cmp	r2, #3
   ddb4a:	d011      	beq.n	ddb70 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x30>
   ddb4c:	2a01      	cmp	r2, #1
   ddb4e:	d118      	bne.n	ddb82 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x42>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
   ddb50:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
   ddb52:	6003      	str	r3, [r0, #0]
	      break;
   ddb54:	e015      	b.n	ddb82 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x42>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
   ddb56:	2014      	movs	r0, #20
   ddb58:	680e      	ldr	r6, [r1, #0]
   ddb5a:	f7f6 fa9e 	bl	d409a <_Znwj>
   ddb5e:	4605      	mov	r5, r0
   ddb60:	b120      	cbz	r0, ddb6c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2c>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
   ddb62:	4631      	mov	r1, r6
   ddb64:	f7ff ffdd 	bl	ddb22 <_ZNSt8functionIFvRKbEEC1ERKS3_>
   ddb68:	7c33      	ldrb	r3, [r6, #16]
   ddb6a:	742b      	strb	r3, [r5, #16]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
   ddb6c:	6025      	str	r5, [r4, #0]
   ddb6e:	e008      	b.n	ddb82 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x42>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
   ddb70:	6804      	ldr	r4, [r0, #0]
   ddb72:	b134      	cbz	r4, ddb82 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x42>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   ddb74:	4620      	mov	r0, r4
   ddb76:	f7f7 f8a6 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
   ddb7a:	2114      	movs	r1, #20
   ddb7c:	4620      	mov	r0, r4
   ddb7e:	f001 f8e7 	bl	ded50 <_ZdlPvj>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
   ddb82:	2000      	movs	r0, #0
   ddb84:	bd70      	pop	{r4, r5, r6, pc}
	...

000ddb88 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>:
        delete callbackPtr; // Delete old callback
    }

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
   ddb88:	b5f0      	push	{r4, r5, r6, r7, lr}

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
   ddb8a:	2300      	movs	r3, #0
   ddb8c:	b087      	sub	sp, #28
   ddb8e:	460c      	mov	r4, r1
   ddb90:	f3bf 8f5f 	dmb	sy
   ddb94:	e850 6f00 	ldrex	r6, [r0]
   ddb98:	e840 3200 	strex	r2, r3, [r0]
   ddb9c:	2a00      	cmp	r2, #0
   ddb9e:	d1f9      	bne.n	ddb94 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xc>
   ddba0:	f3bf 8f5f 	dmb	sy
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
   ddba4:	2e00      	cmp	r6, #0
   ddba6:	d03f      	beq.n	ddc28 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa0>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
   ddba8:	4618      	mov	r0, r3
   ddbaa:	f7fe f827 	bl	dbbfc <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
   ddbae:	4607      	mov	r7, r0
   ddbb0:	b120      	cbz	r0, ddbbc <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x34>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   ddbb2:	4621      	mov	r1, r4
   ddbb4:	4630      	mov	r0, r6
   ddbb6:	f7ff fe53 	bl	dd860 <_ZNKSt8functionIFvRKbEEclES1_>
   ddbba:	e02e      	b.n	ddc1a <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x92>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   ddbbc:	4631      	mov	r1, r6
   ddbbe:	a801      	add	r0, sp, #4
   ddbc0:	f7ff ffaf 	bl	ddb22 <_ZNSt8functionIFvRKbEEC1ERKS3_>
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   ddbc4:	7823      	ldrb	r3, [r4, #0]
   ddbc6:	f88d 3014 	strb.w	r3, [sp, #20]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   ddbca:	2010      	movs	r0, #16
   ddbcc:	f7f6 fa65 	bl	d409a <_Znwj>
   ddbd0:	4605      	mov	r5, r0
   ddbd2:	b1d0      	cbz	r0, ddc0a <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x82>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   ddbd4:	6087      	str	r7, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   ddbd6:	2014      	movs	r0, #20
   ddbd8:	f7f6 fa5f 	bl	d409a <_Znwj>
   ddbdc:	4604      	mov	r4, r0
   ddbde:	b178      	cbz	r0, ddc00 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x78>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   ddbe0:	6087      	str	r7, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
   ddbe2:	4601      	mov	r1, r0
   ddbe4:	a801      	add	r0, sp, #4
   ddbe6:	f7ff fb10 	bl	dd20a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   ddbea:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
   ddbec:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   ddbee:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   ddbf0:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
   ddbf2:	9203      	str	r2, [sp, #12]
   ddbf4:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   ddbf6:	60e3      	str	r3, [r4, #12]
   ddbf8:	f89d 3014 	ldrb.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   ddbfc:	9204      	str	r2, [sp, #16]
   ddbfe:	7423      	strb	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
   ddc00:	4b0a      	ldr	r3, [pc, #40]	; (ddc2c <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa4>)
   ddc02:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   ddc04:	4b0a      	ldr	r3, [pc, #40]	; (ddc30 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa8>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   ddc06:	602c      	str	r4, [r5, #0]

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
   ddc08:	60ab      	str	r3, [r5, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   ddc0a:	a801      	add	r0, sp, #4
   ddc0c:	f7f7 f85b 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
   ddc10:	2200      	movs	r2, #0
   ddc12:	4629      	mov	r1, r5
   ddc14:	4807      	ldr	r0, [pc, #28]	; (ddc34 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xac>)
   ddc16:	f7fd fff9 	bl	dbc0c <application_thread_invoke>
   ddc1a:	4630      	mov	r0, r6
   ddc1c:	f7f7 f853 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
   ddc20:	2110      	movs	r1, #16
   ddc22:	4630      	mov	r0, r6
   ddc24:	f001 f894 	bl	ded50 <_ZdlPvj>
        }
    }
   ddc28:	b007      	add	sp, #28
   ddc2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   ddc2c:	000dd873 	.word	0x000dd873
   ddc30:	000ddb41 	.word	0x000ddb41
   ddc34:	000de111 	.word	0x000de111

000ddc38 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:

namespace {

using namespace particle;

void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
   ddc38:	b530      	push	{r4, r5, lr}
   ddc3a:	b085      	sub	sp, #20
   ddc3c:	4604      	mov	r4, r0
   ddc3e:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
   ddc40:	4668      	mov	r0, sp
   ddc42:	4611      	mov	r1, r2
   ddc44:	f7ff fdca 	bl	dd7dc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
   ddc48:	b17c      	cbz	r4, ddc6a <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        p.setError(Error((Error::Type)error, (const char*)data));
   ddc4a:	b224      	sxth	r4, r4
   ddc4c:	4628      	mov	r0, r5
   ddc4e:	b10d      	cbz	r5, ddc54 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1c>
   ddc50:	f002 f9da 	bl	e0008 <strdup>
   ddc54:	9002      	str	r0, [sp, #8]
   ddc56:	a902      	add	r1, sp, #8
   ddc58:	4668      	mov	r0, sp
   ddc5a:	f8ad 400c 	strh.w	r4, [sp, #12]
   ddc5e:	f7ff fe1f 	bl	dd8a0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   ddc62:	a802      	add	r0, sp, #8
   ddc64:	f7ff fd4e 	bl	dd704 <_ZN8particle5ErrorD1Ev>
   ddc68:	e01d      	b.n	ddca6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>
   ddc6a:	9800      	ldr	r0, [sp, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
   ddc6c:	f88d 4008 	strb.w	r4, [sp, #8]

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
   ddc70:	f04f 0201 	mov.w	r2, #1
   ddc74:	e8d0 3f4f 	ldrexb	r3, [r0]
   ddc78:	42a3      	cmp	r3, r4
   ddc7a:	d103      	bne.n	ddc84 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x4c>
   ddc7c:	e8c0 2f41 	strexb	r1, r2, [r0]
   ddc80:	2900      	cmp	r1, #0
   ddc82:	d1f7      	bne.n	ddc74 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
   ddc84:	d002      	beq.n	ddc8c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x54>
   ddc86:	f88d 3008 	strb.w	r3, [sp, #8]
   ddc8a:	e00c      	b.n	ddca6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>
        }
    }

    void setResult(ResultT result) {
        if (this->changeState(State::SUCCEEDED)) {
            new(&result_) ResultT(std::move(result));
   ddc8c:	f110 010c 	adds.w	r1, r0, #12
   ddc90:	f04f 0301 	mov.w	r3, #1
   ddc94:	bf18      	it	ne
   ddc96:	7303      	strbne	r3, [r0, #12]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
   ddc98:	f3bf 8f5f 	dmb	sy
            this->releaseDone();
            this->invokeCallback(this->onSuccess_, result_);
   ddc9c:	3004      	adds	r0, #4
   ddc9e:	f800 3c03 	strb.w	r3, [r0, #-3]
   ddca2:	f7ff ff71 	bl	ddb88 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>
   ddca6:	a801      	add	r0, sp, #4
   ddca8:	f7f7 ffb0 	bl	d5c0c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    } else {
        p.setResult(true);
    }
}
   ddcac:	b005      	add	sp, #20
   ddcae:	bd30      	pop	{r4, r5, pc}

000ddcb0 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
   ddcb0:	4770      	bx	lr

000ddcb2 <_ZN9IPAddressD0Ev>:
   ddcb2:	b510      	push	{r4, lr}
   ddcb4:	2118      	movs	r1, #24
   ddcb6:	4604      	mov	r4, r0
   ddcb8:	f001 f84a 	bl	ded50 <_ZdlPvj>
   ddcbc:	4620      	mov	r0, r4
   ddcbe:	bd10      	pop	{r4, pc}

000ddcc0 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   ddcc0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   ddcc2:	7d03      	ldrb	r3, [r0, #20]
   ddcc4:	2b06      	cmp	r3, #6
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   ddcc6:	b08d      	sub	sp, #52	; 0x34
   ddcc8:	460e      	mov	r6, r1
   ddcca:	f100 0704 	add.w	r7, r0, #4
   ddcce:	f04f 0400 	mov.w	r4, #0
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   ddcd2:	d002      	beq.n	ddcda <_ZNK9IPAddress7printToER5Print+0x1a>
   ddcd4:	f100 0508 	add.w	r5, r0, #8
   ddcd8:	e018      	b.n	ddd0c <_ZNK9IPAddress7printToER5Print+0x4c>
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
   ddcda:	ad0c      	add	r5, sp, #48	; 0x30
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   ddcdc:	4639      	mov	r1, r7
{
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
   ddcde:	f805 4d30 	strb.w	r4, [r5, #-48]!
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   ddce2:	232f      	movs	r3, #47	; 0x2f
   ddce4:	462a      	mov	r2, r5
   ddce6:	200a      	movs	r0, #10
   ddce8:	f7fd fe20 	bl	db92c <inet_inet_ntop>
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
   ddcec:	4628      	mov	r0, r5
   ddcee:	f002 f9bb 	bl	e0068 <strlen>
   ddcf2:	6833      	ldr	r3, [r6, #0]
   ddcf4:	4602      	mov	r2, r0
   ddcf6:	68db      	ldr	r3, [r3, #12]
   ddcf8:	4629      	mov	r1, r5
   ddcfa:	4630      	mov	r0, r6
   ddcfc:	4798      	blx	r3
   ddcfe:	e00f      	b.n	ddd20 <_ZNK9IPAddress7printToER5Print+0x60>
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
   ddd00:	b124      	cbz	r4, ddd0c <_ZNK9IPAddress7printToER5Print+0x4c>
            n += p.print('.');
   ddd02:	212e      	movs	r1, #46	; 0x2e
   ddd04:	4630      	mov	r0, r6
   ddd06:	f7ff f8a1 	bl	dce4c <_ZN5Print5printEc>
   ddd0a:	4404      	add	r4, r0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
   ddd0c:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
   ddd10:	220a      	movs	r2, #10
   ddd12:	4630      	mov	r0, r6
   ddd14:	f7ff f8b3 	bl	dce7e <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   ddd18:	42bd      	cmp	r5, r7
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   ddd1a:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   ddd1c:	d1f0      	bne.n	ddd00 <_ZNK9IPAddress7printToER5Print+0x40>
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   ddd1e:	4620      	mov	r0, r4
    }
    return n;
}
   ddd20:	b00d      	add	sp, #52	; 0x34
   ddd22:	bdf0      	pop	{r4, r5, r6, r7, pc}

000ddd24 <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
   ddd24:	b510      	push	{r4, lr}
   ddd26:	4b05      	ldr	r3, [pc, #20]	; (ddd3c <_ZN9IPAddressC1Ev+0x18>)
   ddd28:	4604      	mov	r4, r0
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   ddd2a:	2211      	movs	r2, #17
   ddd2c:	f840 3b04 	str.w	r3, [r0], #4
   ddd30:	2100      	movs	r1, #0
   ddd32:	f002 f919 	bl	dff68 <memset>
{
    clear();
}
   ddd36:	4620      	mov	r0, r4
   ddd38:	bd10      	pop	{r4, pc}
   ddd3a:	bf00      	nop
   ddd3c:	000e276c 	.word	0x000e276c

000ddd40 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
   ddd40:	4603      	mov	r3, r0
   ddd42:	4a07      	ldr	r2, [pc, #28]	; (ddd60 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
   ddd44:	b510      	push	{r4, lr}
   ddd46:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
   ddd4a:	f101 0210 	add.w	r2, r1, #16
   ddd4e:	f851 4b04 	ldr.w	r4, [r1], #4
   ddd52:	f843 4b04 	str.w	r4, [r3], #4
   ddd56:	4291      	cmp	r1, r2
   ddd58:	d1f9      	bne.n	ddd4e <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
   ddd5a:	780a      	ldrb	r2, [r1, #0]
   ddd5c:	701a      	strb	r2, [r3, #0]
}
   ddd5e:	bd10      	pop	{r4, pc}
   ddd60:	000e276c 	.word	0x000e276c

000ddd64 <_ZNK9IPAddresscvbEv>:
{
    *this = address;
}

IPAddress::operator bool() const
{
   ddd64:	7d03      	ldrb	r3, [r0, #20]
#if Wiring_IPv6
    if (version() == 4) {
   ddd66:	2b04      	cmp	r3, #4
   ddd68:	d101      	bne.n	ddd6e <_ZNK9IPAddresscvbEv+0xa>
        return address.ipv4 != 0;
   ddd6a:	6840      	ldr	r0, [r0, #4]
   ddd6c:	e008      	b.n	ddd80 <_ZNK9IPAddresscvbEv+0x1c>
    } else if (version() == 6) {
   ddd6e:	2b06      	cmp	r3, #6
   ddd70:	d10a      	bne.n	ddd88 <_ZNK9IPAddresscvbEv+0x24>
        return address.ipv6[0] != 0 || address.ipv6[1] != 0 || address.ipv6[2] != 0 || address.ipv6[3] != 0;
   ddd72:	6843      	ldr	r3, [r0, #4]
   ddd74:	b953      	cbnz	r3, ddd8c <_ZNK9IPAddresscvbEv+0x28>
   ddd76:	6883      	ldr	r3, [r0, #8]
   ddd78:	b943      	cbnz	r3, ddd8c <_ZNK9IPAddresscvbEv+0x28>
   ddd7a:	68c3      	ldr	r3, [r0, #12]
   ddd7c:	b933      	cbnz	r3, ddd8c <_ZNK9IPAddresscvbEv+0x28>
   ddd7e:	6900      	ldr	r0, [r0, #16]
   ddd80:	3000      	adds	r0, #0
   ddd82:	bf18      	it	ne
   ddd84:	2001      	movne	r0, #1
   ddd86:	4770      	bx	lr
    } else {
        return false;
   ddd88:	2000      	movs	r0, #0
   ddd8a:	4770      	bx	lr
{
#if Wiring_IPv6
    if (version() == 4) {
        return address.ipv4 != 0;
    } else if (version() == 6) {
        return address.ipv6[0] != 0 || address.ipv6[1] != 0 || address.ipv6[2] != 0 || address.ipv6[3] != 0;
   ddd8c:	2001      	movs	r0, #1
        return false;
    }
#else
    return address.ipv4!=0;
#endif
}
   ddd8e:	4770      	bx	lr

000ddd90 <_ZN9IPAddress8set_ipv4Ehhhh>:

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
   ddd90:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
   ddd92:	f89d 4008 	ldrb.w	r4, [sp, #8]
   ddd96:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
   ddd9a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   ddd9e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
   ddda2:	2304      	movs	r3, #4
   ddda4:	6041      	str	r1, [r0, #4]
   ddda6:	7503      	strb	r3, [r0, #20]
   ddda8:	bd10      	pop	{r4, pc}
	...

000dddac <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
   dddac:	b537      	push	{r0, r1, r2, r4, r5, lr}
   dddae:	4d04      	ldr	r5, [pc, #16]	; (dddc0 <_ZN9IPAddressC1Ehhhh+0x14>)
   dddb0:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
   dddb2:	f89d 5018 	ldrb.w	r5, [sp, #24]
   dddb6:	9500      	str	r5, [sp, #0]
   dddb8:	f7ff ffea 	bl	ddd90 <_ZN9IPAddress8set_ipv4Ehhhh>
}
   dddbc:	b003      	add	sp, #12
   dddbe:	bd30      	pop	{r4, r5, pc}
   dddc0:	000e276c 	.word	0x000e276c

000dddc4 <_ZN9IPAddressaSEPKh>:
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
    setVersion(4);
}

IPAddress& IPAddress::operator=(const uint8_t* address)
{
   dddc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
   dddc6:	780d      	ldrb	r5, [r1, #0]
   dddc8:	788b      	ldrb	r3, [r1, #2]
   dddca:	784a      	ldrb	r2, [r1, #1]
   dddcc:	78c9      	ldrb	r1, [r1, #3]
   dddce:	9100      	str	r1, [sp, #0]
   dddd0:	4629      	mov	r1, r5
   dddd2:	f7ff ffdd 	bl	ddd90 <_ZN9IPAddress8set_ipv4Ehhhh>
    return *this;
}
   dddd6:	b003      	add	sp, #12
   dddd8:	bd30      	pop	{r4, r5, pc}

000dddda <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   dddda:	7441      	strb	r1, [r0, #17]
   ddddc:	4770      	bx	lr

000dddde <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
   dddde:	4770      	bx	lr

000ddde0 <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
   ddde0:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
   ddde2:	2100      	movs	r1, #0
   ddde4:	7c00      	ldrb	r0, [r0, #16]
   ddde6:	f7fd fec1 	bl	dbb6c <HAL_USB_USART_Receive_Data>
}
   dddea:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   dddee:	bf28      	it	cs
   dddf0:	f04f 30ff 	movcs.w	r0, #4294967295
   dddf4:	bd08      	pop	{r3, pc}

000dddf6 <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
   dddf6:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
   dddf8:	2101      	movs	r1, #1
   dddfa:	7c00      	ldrb	r0, [r0, #16]
   dddfc:	f7fd feb6 	bl	dbb6c <HAL_USB_USART_Receive_Data>
}
   dde00:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   dde04:	bf28      	it	cs
   dde06:	f04f 30ff 	movcs.w	r0, #4294967295
   dde0a:	bd08      	pop	{r3, pc}

000dde0c <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
   dde0c:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
   dde0e:	7c00      	ldrb	r0, [r0, #16]
   dde10:	f7fd fea4 	bl	dbb5c <HAL_USB_USART_Available_Data_For_Write>
}
   dde14:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   dde18:	bd08      	pop	{r3, pc}

000dde1a <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
   dde1a:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
   dde1c:	7c00      	ldrb	r0, [r0, #16]
   dde1e:	f7fd fe95 	bl	dbb4c <HAL_USB_USART_Available_Data>
}
   dde22:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   dde26:	bd08      	pop	{r3, pc}

000dde28 <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
   dde28:	7c00      	ldrb	r0, [r0, #16]
   dde2a:	f7fd beaf 	b.w	dbb8c <HAL_USB_USART_Flush_Data>

000dde2e <_ZN9USBSerialD0Ev>:
   dde2e:	b510      	push	{r4, lr}
   dde30:	2114      	movs	r1, #20
   dde32:	4604      	mov	r4, r0
   dde34:	f000 ff8c 	bl	ded50 <_ZdlPvj>
   dde38:	4620      	mov	r0, r4
   dde3a:	bd10      	pop	{r4, pc}

000dde3c <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
   dde3c:	b538      	push	{r3, r4, r5, lr}
   dde3e:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   dde40:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
   dde42:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   dde44:	f7fd fe8a 	bl	dbb5c <HAL_USB_USART_Available_Data_For_Write>
   dde48:	2800      	cmp	r0, #0
   dde4a:	dc01      	bgt.n	dde50 <_ZN9USBSerial5writeEh+0x14>
   dde4c:	7c60      	ldrb	r0, [r4, #17]
   dde4e:	b128      	cbz	r0, dde5c <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
   dde50:	4629      	mov	r1, r5
   dde52:	7c20      	ldrb	r0, [r4, #16]
   dde54:	f7fd fe92 	bl	dbb7c <HAL_USB_USART_Send_Data>
   dde58:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
   dde5c:	bd38      	pop	{r3, r4, r5, pc}
	...

000dde60 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   dde60:	b510      	push	{r4, lr}
   dde62:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   dde64:	2300      	movs	r3, #0
   dde66:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   dde68:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   dde6c:	60a3      	str	r3, [r4, #8]
   dde6e:	4b05      	ldr	r3, [pc, #20]	; (dde84 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
   dde70:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
   dde72:	2301      	movs	r3, #1

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   dde74:	4608      	mov	r0, r1
{
  _serial = serial;
   dde76:	7421      	strb	r1, [r4, #16]
  _blocking = true;
   dde78:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
   dde7a:	4611      	mov	r1, r2
   dde7c:	f7fd fe56 	bl	dbb2c <HAL_USB_USART_Init>
}
   dde80:	4620      	mov	r0, r4
   dde82:	bd10      	pop	{r4, pc}
   dde84:	000e2780 	.word	0x000e2780

000dde88 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
   dde88:	2200      	movs	r2, #0
   dde8a:	7c00      	ldrb	r0, [r0, #16]
   dde8c:	f7fd be56 	b.w	dbb3c <HAL_USB_USART_Begin>

000dde90 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
   dde90:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = {0};
   dde92:	2214      	movs	r2, #20

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
   dde94:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
   dde96:	2100      	movs	r1, #0
   dde98:	f002 f866 	bl	dff68 <memset>
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
   dde9c:	4620      	mov	r0, r4
   dde9e:	bd10      	pop	{r4, pc}

000ddea0 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
   ddea0:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   ddea2:	4d0e      	ldr	r5, [pc, #56]	; (ddedc <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
   ddea4:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
   ddea6:	a801      	add	r0, sp, #4
   ddea8:	f7ff fff2 	bl	dde90 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   ddeac:	6829      	ldr	r1, [r5, #0]
   ddeae:	f011 0401 	ands.w	r4, r1, #1
   ddeb2:	d110      	bne.n	dded6 <_Z16_fetch_usbserialv+0x36>
   ddeb4:	4628      	mov	r0, r5
   ddeb6:	f7f6 f901 	bl	d40bc <__cxa_guard_acquire>
   ddeba:	b160      	cbz	r0, dded6 <_Z16_fetch_usbserialv+0x36>
   ddebc:	aa01      	add	r2, sp, #4
   ddebe:	4621      	mov	r1, r4
   ddec0:	4807      	ldr	r0, [pc, #28]	; (ddee0 <_Z16_fetch_usbserialv+0x40>)
   ddec2:	f7ff ffcd 	bl	dde60 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
   ddec6:	4628      	mov	r0, r5
   ddec8:	f7f6 f8fd 	bl	d40c6 <__cxa_guard_release>
   ddecc:	4a05      	ldr	r2, [pc, #20]	; (ddee4 <_Z16_fetch_usbserialv+0x44>)
   ddece:	4906      	ldr	r1, [pc, #24]	; (ddee8 <_Z16_fetch_usbserialv+0x48>)
   dded0:	4803      	ldr	r0, [pc, #12]	; (ddee0 <_Z16_fetch_usbserialv+0x40>)
   dded2:	f000 ff2f 	bl	ded34 <__aeabi_atexit>
	return _usbserial;
}
   dded6:	4802      	ldr	r0, [pc, #8]	; (ddee0 <_Z16_fetch_usbserialv+0x40>)
   dded8:	b007      	add	sp, #28
   ddeda:	bd30      	pop	{r4, r5, pc}
   ddedc:	2003e4a8 	.word	0x2003e4a8
   ddee0:	2003e4ac 	.word	0x2003e4ac
   ddee4:	2003daf8 	.word	0x2003daf8
   ddee8:	000ddddf 	.word	0x000ddddf

000ddeec <_ZN5spark13CellularClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   ddeec:	2200      	movs	r2, #0
   ddeee:	4611      	mov	r1, r2
   ddef0:	6840      	ldr	r0, [r0, #4]
   ddef2:	f7fd bef1 	b.w	dbcd8 <network_listening>

000ddef6 <_ZN5spark13CellularClass16getListenTimeoutEv>:
    }

    inline void setListenTimeout(std::chrono::seconds s) { setListenTimeout(s.count()); }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   ddef6:	2200      	movs	r2, #0
   ddef8:	4611      	mov	r1, r2
   ddefa:	6840      	ldr	r0, [r0, #4]
   ddefc:	f7fd befc 	b.w	dbcf8 <network_get_listen_timeout>

000ddf00 <_ZN5spark13CellularClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    inline void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   ddf00:	2200      	movs	r2, #0
   ddf02:	6840      	ldr	r0, [r0, #4]
   ddf04:	f7fd bef0 	b.w	dbce8 <network_set_listen_timeout>

000ddf08 <_ZN5spark13CellularClass6listenEb>:
        cellular_credentials_clear(nullptr);
    }
#endif // HAL_PLATFORM_MESH

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   ddf08:	2200      	movs	r2, #0
   ddf0a:	f081 0101 	eor.w	r1, r1, #1
   ddf0e:	6840      	ldr	r0, [r0, #4]
   ddf10:	f7fd beda 	b.w	dbcc8 <network_listen>

000ddf14 <_ZN5spark13CellularClass10connectingEv>:
    }
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   ddf14:	2200      	movs	r2, #0
   ddf16:	4611      	mov	r1, r2
   ddf18:	6840      	ldr	r0, [r0, #4]
   ddf1a:	f7fd bead 	b.w	dbc78 <network_connecting>

000ddf1e <_ZN5spark13CellularClass10disconnectEv>:
    }

    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   ddf1e:	2200      	movs	r2, #0
   ddf20:	2102      	movs	r1, #2
   ddf22:	6840      	ldr	r0, [r0, #4]
   ddf24:	f7fd beb0 	b.w	dbc88 <network_disconnect>

000ddf28 <_ZN5spark13CellularClass7connectEj>:
    }
    void off() {
        network_off(*this, 0, 0, NULL);
    }
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   ddf28:	2300      	movs	r3, #0
   ddf2a:	461a      	mov	r2, r3
   ddf2c:	6840      	ldr	r0, [r0, #4]
   ddf2e:	f7fd be9b 	b.w	dbc68 <network_connect>
	...

000ddf34 <_ZN5spark13CellularClass4RSSIEv>:

// #include "cellular_internal.h"

namespace spark {

    CellularSignal CellularClass::RSSI() {
   ddf34:	b5f0      	push	{r4, r5, r6, r7, lr}
class CellularSignal : public particle::Signal, public Printable {
public:
    int rssi = 0;
    int qual = 0;

    CellularSignal() {}
   ddf36:	4b1b      	ldr	r3, [pc, #108]	; (ddfa4 <_ZN5spark13CellularClass4RSSIEv+0x70>)
   ddf38:	6003      	str	r3, [r0, #0]
   ddf3a:	2500      	movs	r5, #0
   ddf3c:	460f      	mov	r7, r1
   ddf3e:	3328      	adds	r3, #40	; 0x28
   ddf40:	2618      	movs	r6, #24
   ddf42:	b089      	sub	sp, #36	; 0x24
   ddf44:	6043      	str	r3, [r0, #4]
   ddf46:	6085      	str	r5, [r0, #8]
   ddf48:	60c5      	str	r5, [r0, #12]
   ddf4a:	4632      	mov	r2, r6
   ddf4c:	4629      	mov	r1, r5
   ddf4e:	4604      	mov	r4, r0
   ddf50:	3010      	adds	r0, #16
   ddf52:	f002 f809 	bl	dff68 <memset>
        CellularSignal sig;
        if (!network_ready(*this, 0, NULL)) {
   ddf56:	462a      	mov	r2, r5
   ddf58:	4629      	mov	r1, r5
   ddf5a:	6878      	ldr	r0, [r7, #4]
   ddf5c:	f7fd fe9c 	bl	dbc98 <network_ready>
   ddf60:	b908      	cbnz	r0, ddf66 <_ZN5spark13CellularClass4RSSIEv+0x32>
            sig.rssi = 0;
   ddf62:	60a0      	str	r0, [r4, #8]
            return sig;
   ddf64:	e01b      	b.n	ddf9e <_ZN5spark13CellularClass4RSSIEv+0x6a>
        }

        CellularSignalHal sig_hal = {0};
        cellular_signal_t sigext = {0};
   ddf66:	4629      	mov	r1, r5
   ddf68:	4632      	mov	r2, r6
   ddf6a:	a802      	add	r0, sp, #8
        if (!network_ready(*this, 0, NULL)) {
            sig.rssi = 0;
            return sig;
        }

        CellularSignalHal sig_hal = {0};
   ddf6c:	9500      	str	r5, [sp, #0]
   ddf6e:	9501      	str	r5, [sp, #4]
        cellular_signal_t sigext = {0};
   ddf70:	f001 fffa 	bl	dff68 <memset>
        sigext.size = sizeof(sigext);
        if (cellular_signal(&sig_hal, &sigext) != 0) {
   ddf74:	a902      	add	r1, sp, #8
   ddf76:	4668      	mov	r0, sp
            return sig;
        }

        CellularSignalHal sig_hal = {0};
        cellular_signal_t sigext = {0};
        sigext.size = sizeof(sigext);
   ddf78:	f8ad 6008 	strh.w	r6, [sp, #8]
        if (cellular_signal(&sig_hal, &sigext) != 0) {
   ddf7c:	f7fd fdce 	bl	dbb1c <cellular_signal>
   ddf80:	b110      	cbz	r0, ddf88 <_ZN5spark13CellularClass4RSSIEv+0x54>
            sig.rssi = 1;
   ddf82:	2301      	movs	r3, #1
   ddf84:	60a3      	str	r3, [r4, #8]
            return sig;
   ddf86:	e00a      	b.n	ddf9e <_ZN5spark13CellularClass4RSSIEv+0x6a>
        }
        sig.rssi = sig_hal.rssi;
   ddf88:	9b00      	ldr	r3, [sp, #0]
        sig.qual = sig_hal.qual;
   ddf8a:	9a01      	ldr	r2, [sp, #4]
        sigext.size = sizeof(sigext);
        if (cellular_signal(&sig_hal, &sigext) != 0) {
            sig.rssi = 1;
            return sig;
        }
        sig.rssi = sig_hal.rssi;
   ddf8c:	60a3      	str	r3, [r4, #8]
        sig.qual = sig_hal.qual;
   ddf8e:	60e2      	str	r2, [r4, #12]
        if (sig.rssi == 0) {
   ddf90:	b90b      	cbnz	r3, ddf96 <_ZN5spark13CellularClass4RSSIEv+0x62>
            sig.rssi = 2;
   ddf92:	2302      	movs	r3, #2
   ddf94:	60a3      	str	r3, [r4, #8]
        }
        sig.fromHalCellularSignal(sigext);
   ddf96:	a902      	add	r1, sp, #8
   ddf98:	4620      	mov	r0, r4
   ddf9a:	f7ff f9c1 	bl	dd320 <_ZN14CellularSignal21fromHalCellularSignalERK17cellular_signal_t>
        return sig;
    }
   ddf9e:	4620      	mov	r0, r4
   ddfa0:	b009      	add	sp, #36	; 0x24
   ddfa2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   ddfa4:	000e271c 	.word	0x000e271c

000ddfa8 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv>:
        return (band_get.ok = true);
    }

    CellularClass Cellular;
    // NetworkClass& Network = Cellular;
}
   ddfa8:	b538      	push	{r3, r4, r5, lr}
    int tx_total;
    int rx_total;

    CellularDataHal()
    {
        memset(this, 0, sizeof(*this));
   ddfaa:	4c08      	ldr	r4, [pc, #32]	; (ddfcc <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x24>)
   ddfac:	2528      	movs	r5, #40	; 0x28
   ddfae:	462a      	mov	r2, r5
   ddfb0:	2100      	movs	r1, #0
   ddfb2:	4620      	mov	r0, r4
   ddfb4:	f001 ffd8 	bl	dff68 <memset>
        cid = -1;
   ddfb8:	f04f 33ff 	mov.w	r3, #4294967295
   ddfbc:	6063      	str	r3, [r4, #4]
   ddfbe:	4b04      	ldr	r3, [pc, #16]	; (ddfd0 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x28>)
        size = sizeof(*this);
   ddfc0:	8025      	strh	r5, [r4, #0]
   ddfc2:	2204      	movs	r2, #4
   ddfc4:	605a      	str	r2, [r3, #4]

class CellularClass : public NetworkClass
{
public:
    CellularClass() :
            NetworkClass(NETWORK_INTERFACE_CELLULAR) {
   ddfc6:	4a03      	ldr	r2, [pc, #12]	; (ddfd4 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x2c>)
   ddfc8:	601a      	str	r2, [r3, #0]
   ddfca:	bd38      	pop	{r3, r4, r5, pc}
   ddfcc:	2003e4c8 	.word	0x2003e4c8
   ddfd0:	2003e4c0 	.word	0x2003e4c0
   ddfd4:	000e27b0 	.word	0x000e27b0

000ddfd8 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
   ddfd8:	4770      	bx	lr

000ddfda <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   ddfda:	7441      	strb	r1, [r0, #17]
   ddfdc:	4770      	bx	lr

000ddfde <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
   ddfde:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
   ddfe0:	7c00      	ldrb	r0, [r0, #16]
   ddfe2:	f7fd fcf3 	bl	db9cc <HAL_USART_Available_Data_For_Write>
}
   ddfe6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   ddfea:	bd08      	pop	{r3, pc}

000ddfec <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
   ddfec:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
   ddfee:	7c00      	ldrb	r0, [r0, #16]
   ddff0:	f7fd fcc4 	bl	db97c <HAL_USART_Available_Data>
}
   ddff4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   ddff8:	bd08      	pop	{r3, pc}

000ddffa <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
   ddffa:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
   ddffc:	7c00      	ldrb	r0, [r0, #16]
   ddffe:	f7fd fccd 	bl	db99c <HAL_USART_Peek_Data>
}
   de002:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   de006:	bf28      	it	cs
   de008:	f04f 30ff 	movcs.w	r0, #4294967295
   de00c:	bd08      	pop	{r3, pc}

000de00e <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
   de00e:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
   de010:	7c00      	ldrb	r0, [r0, #16]
   de012:	f7fd fcbb 	bl	db98c <HAL_USART_Read_Data>
}
   de016:	ea30 0020 	bics.w	r0, r0, r0, asr #32
   de01a:	bf28      	it	cs
   de01c:	f04f 30ff 	movcs.w	r0, #4294967295
   de020:	bd08      	pop	{r3, pc}

000de022 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
   de022:	7c00      	ldrb	r0, [r0, #16]
   de024:	f7fd bcc2 	b.w	db9ac <HAL_USART_Flush_Data>

000de028 <_ZN11USARTSerialD0Ev>:
   de028:	b510      	push	{r4, lr}
   de02a:	2114      	movs	r1, #20
   de02c:	4604      	mov	r4, r0
   de02e:	f000 fe8f 	bl	ded50 <_ZdlPvj>
   de032:	4620      	mov	r0, r4
   de034:	bd10      	pop	{r4, pc}

000de036 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
   de036:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
   de038:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
   de03a:	4604      	mov	r4, r0
   de03c:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
   de03e:	b925      	cbnz	r5, de04a <_ZN11USARTSerial5writeEh+0x14>
   de040:	7c00      	ldrb	r0, [r0, #16]
   de042:	f7fd fcc3 	bl	db9cc <HAL_USART_Available_Data_For_Write>
   de046:	2800      	cmp	r0, #0
   de048:	dd05      	ble.n	de056 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
   de04a:	4631      	mov	r1, r6
   de04c:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
   de04e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
   de052:	f7fd bc8b 	b.w	db96c <HAL_USART_Write_Data>
  }
  return 0;
}
   de056:	4628      	mov	r0, r5
   de058:	bd70      	pop	{r4, r5, r6, pc}
	...

000de05c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
   de05c:	b510      	push	{r4, lr}
   de05e:	4604      	mov	r4, r0
   de060:	4608      	mov	r0, r1
   de062:	4611      	mov	r1, r2
   de064:	2200      	movs	r2, #0
   de066:	6062      	str	r2, [r4, #4]
   de068:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   de06c:	60a2      	str	r2, [r4, #8]
   de06e:	4a05      	ldr	r2, [pc, #20]	; (de084 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
   de070:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
   de072:	2201      	movs	r2, #1

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
{
  _serial = serial;
   de074:	7420      	strb	r0, [r4, #16]
  // Default is blocking mode
  _blocking = true;
   de076:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
   de078:	461a      	mov	r2, r3
   de07a:	f7fd fc6f 	bl	db95c <HAL_USART_Init>
}
   de07e:	4620      	mov	r0, r4
   de080:	bd10      	pop	{r4, pc}
   de082:	bf00      	nop
   de084:	000e27e4 	.word	0x000e27e4

000de088 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
   de088:	7c00      	ldrb	r0, [r0, #16]
   de08a:	f7fd bc97 	b.w	db9bc <HAL_USART_Is_Enabled>
	...

000de090 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
   de090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
#else
  if (!serial1_rx_buffer) {
   de092:	4c19      	ldr	r4, [pc, #100]	; (de0f8 <_Z22__fetch_global_Serial1v+0x68>)
   de094:	6825      	ldr	r5, [r4, #0]
   de096:	b94d      	cbnz	r5, de0ac <_Z22__fetch_global_Serial1v+0x1c>
    serial1_rx_buffer = new Ring_Buffer();
   de098:	2084      	movs	r0, #132	; 0x84
   de09a:	f7f5 fffe 	bl	d409a <_Znwj>
   de09e:	4606      	mov	r6, r0
   de0a0:	b118      	cbz	r0, de0aa <_Z22__fetch_global_Serial1v+0x1a>
   de0a2:	2284      	movs	r2, #132	; 0x84
   de0a4:	4629      	mov	r1, r5
   de0a6:	f001 ff5f 	bl	dff68 <memset>
   de0aa:	6026      	str	r6, [r4, #0]
  }
  if (!serial1_tx_buffer) {
   de0ac:	4d13      	ldr	r5, [pc, #76]	; (de0fc <_Z22__fetch_global_Serial1v+0x6c>)
   de0ae:	682e      	ldr	r6, [r5, #0]
   de0b0:	b94e      	cbnz	r6, de0c6 <_Z22__fetch_global_Serial1v+0x36>
    serial1_tx_buffer = new Ring_Buffer();
   de0b2:	2084      	movs	r0, #132	; 0x84
   de0b4:	f7f5 fff1 	bl	d409a <_Znwj>
   de0b8:	4607      	mov	r7, r0
   de0ba:	b118      	cbz	r0, de0c4 <_Z22__fetch_global_Serial1v+0x34>
   de0bc:	2284      	movs	r2, #132	; 0x84
   de0be:	4631      	mov	r1, r6
   de0c0:	f001 ff52 	bl	dff68 <memset>
   de0c4:	602f      	str	r7, [r5, #0]
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
   de0c6:	4f0e      	ldr	r7, [pc, #56]	; (de100 <_Z22__fetch_global_Serial1v+0x70>)
   de0c8:	6839      	ldr	r1, [r7, #0]
   de0ca:	f011 0601 	ands.w	r6, r1, #1
   de0ce:	d111      	bne.n	de0f4 <_Z22__fetch_global_Serial1v+0x64>
   de0d0:	4638      	mov	r0, r7
   de0d2:	f7f5 fff3 	bl	d40bc <__cxa_guard_acquire>
   de0d6:	b168      	cbz	r0, de0f4 <_Z22__fetch_global_Serial1v+0x64>
   de0d8:	6822      	ldr	r2, [r4, #0]
   de0da:	682b      	ldr	r3, [r5, #0]
   de0dc:	4809      	ldr	r0, [pc, #36]	; (de104 <_Z22__fetch_global_Serial1v+0x74>)
   de0de:	4631      	mov	r1, r6
   de0e0:	f7ff ffbc 	bl	de05c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
   de0e4:	4638      	mov	r0, r7
   de0e6:	f7f5 ffee 	bl	d40c6 <__cxa_guard_release>
   de0ea:	4a07      	ldr	r2, [pc, #28]	; (de108 <_Z22__fetch_global_Serial1v+0x78>)
   de0ec:	4907      	ldr	r1, [pc, #28]	; (de10c <_Z22__fetch_global_Serial1v+0x7c>)
   de0ee:	4805      	ldr	r0, [pc, #20]	; (de104 <_Z22__fetch_global_Serial1v+0x74>)
   de0f0:	f000 fe20 	bl	ded34 <__aeabi_atexit>
#endif
	return serial1;
}
   de0f4:	4803      	ldr	r0, [pc, #12]	; (de104 <_Z22__fetch_global_Serial1v+0x74>)
   de0f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   de0f8:	2003e50c 	.word	0x2003e50c
   de0fc:	2003e504 	.word	0x2003e504
   de100:	2003e508 	.word	0x2003e508
   de104:	2003e4f0 	.word	0x2003e4f0
   de108:	2003daf8 	.word	0x2003daf8
   de10c:	000ddfd9 	.word	0x000ddfd9

000de110 <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
   de110:	b510      	push	{r4, lr}
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
   de112:	6883      	ldr	r3, [r0, #8]
   de114:	4604      	mov	r4, r0
   de116:	b90b      	cbnz	r3, de11c <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
   de118:	f000 fe2d 	bl	ded76 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   de11c:	68c3      	ldr	r3, [r0, #12]
   de11e:	4798      	blx	r3

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
   de120:	68a3      	ldr	r3, [r4, #8]
   de122:	b11b      	cbz	r3, de12c <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   de124:	2203      	movs	r2, #3
   de126:	4621      	mov	r1, r4
   de128:	4620      	mov	r0, r4
   de12a:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
   de12c:	4620      	mov	r0, r4
   de12e:	2110      	movs	r1, #16
}
   de130:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
   de134:	f000 be0c 	b.w	ded50 <_ZdlPvj>

000de138 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
   de138:	4770      	bx	lr

000de13a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
   de13a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   de13c:	4606      	mov	r6, r0
   de13e:	4615      	mov	r5, r2
   de140:	460c      	mov	r4, r1
   de142:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   de144:	42bc      	cmp	r4, r7
   de146:	d006      	beq.n	de156 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
   de148:	6833      	ldr	r3, [r6, #0]
   de14a:	f814 1b01 	ldrb.w	r1, [r4], #1
   de14e:	689b      	ldr	r3, [r3, #8]
   de150:	4630      	mov	r0, r6
   de152:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   de154:	e7f6      	b.n	de144 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
   de156:	4628      	mov	r0, r5
   de158:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000de15a <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
   de15a:	2200      	movs	r2, #0
   de15c:	7c00      	ldrb	r0, [r0, #16]
   de15e:	f7fd bc5d 	b.w	dba1c <HAL_I2C_Write_Data>

000de162 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
   de162:	2100      	movs	r1, #0
   de164:	7c00      	ldrb	r0, [r0, #16]
   de166:	f7fd bc61 	b.w	dba2c <HAL_I2C_Available_Data>

000de16a <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
   de16a:	2100      	movs	r1, #0
   de16c:	7c00      	ldrb	r0, [r0, #16]
   de16e:	f7fd bc65 	b.w	dba3c <HAL_I2C_Read_Data>

000de172 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
   de172:	2100      	movs	r1, #0
   de174:	7c00      	ldrb	r0, [r0, #16]
   de176:	f7fd bc69 	b.w	dba4c <HAL_I2C_Peek_Data>

000de17a <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
   de17a:	2100      	movs	r1, #0
   de17c:	7c00      	ldrb	r0, [r0, #16]
   de17e:	f7fd bc6d 	b.w	dba5c <HAL_I2C_Flush_Data>

000de182 <_ZN7TwoWireD0Ev>:
   de182:	b510      	push	{r4, lr}
   de184:	2114      	movs	r1, #20
   de186:	4604      	mov	r4, r0
   de188:	f000 fde2 	bl	ded50 <_ZdlPvj>
   de18c:	4620      	mov	r0, r4
   de18e:	bd10      	pop	{r4, pc}

000de190 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
   de190:	b510      	push	{r4, lr}
   de192:	4604      	mov	r4, r0
   de194:	2300      	movs	r3, #0
   de196:	6063      	str	r3, [r4, #4]
   de198:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   de19c:	60a3      	str	r3, [r4, #8]
   de19e:	4b04      	ldr	r3, [pc, #16]	; (de1b0 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config+0x20>)
{
  _i2c = i2c;
   de1a0:	7421      	strb	r1, [r4, #16]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
   de1a2:	4608      	mov	r0, r1
   de1a4:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, &conf);
   de1a6:	4611      	mov	r1, r2
   de1a8:	f7fd fc68 	bl	dba7c <HAL_I2C_Init>
}
   de1ac:	4620      	mov	r0, r4
   de1ae:	bd10      	pop	{r4, pc}
   de1b0:	000e2814 	.word	0x000e2814

000de1b4 <_ZN7TwoWire8setSpeedEm>:
// Public Methods //////////////////////////////////////////////////////////////

//setSpeed() should be called before begin() else default to 100KHz
void TwoWire::setSpeed(uint32_t clockSpeed)
{
  HAL_I2C_Set_Speed(_i2c, clockSpeed, NULL);
   de1b4:	2200      	movs	r2, #0
   de1b6:	7c00      	ldrb	r0, [r0, #16]
   de1b8:	f7fd bc10 	b.w	db9dc <HAL_I2C_Set_Speed>

000de1bc <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
   de1bc:	2300      	movs	r3, #0
   de1be:	461a      	mov	r2, r3
   de1c0:	4619      	mov	r1, r3
   de1c2:	7c00      	ldrb	r0, [r0, #16]
   de1c4:	f7fd bc12 	b.w	db9ec <HAL_I2C_Begin>

000de1c8 <_ZN7TwoWire11requestFromERK16WireTransmission>:
size_t TwoWire::requestFrom(uint8_t address, size_t quantity)
{
  return requestFrom(address, quantity, (uint8_t)true);
}

size_t TwoWire::requestFrom(const WireTransmission& transfer) {
   de1c8:	b570      	push	{r4, r5, r6, lr}
   de1ca:	460c      	mov	r4, r1
   de1cc:	b086      	sub	sp, #24
      .address = address_,
      .reserved = {0},
      .quantity = (uint32_t)size_,
      .timeout_ms = timeout_,
      .flags = (uint32_t)(stop_ ? HAL_I2C_TRANSMISSION_FLAG_STOP : 0)
    };
   de1ce:	2514      	movs	r5, #20
   de1d0:	4606      	mov	r6, r0
   de1d2:	462a      	mov	r2, r5
   de1d4:	2100      	movs	r1, #0
   de1d6:	a801      	add	r0, sp, #4
   de1d8:	f001 fec6 	bl	dff68 <memset>
   de1dc:	7823      	ldrb	r3, [r4, #0]
   de1de:	f88d 3008 	strb.w	r3, [sp, #8]
   de1e2:	6863      	ldr	r3, [r4, #4]
   de1e4:	9303      	str	r3, [sp, #12]
   de1e6:	68e3      	ldr	r3, [r4, #12]
   de1e8:	9304      	str	r3, [sp, #16]
  auto conf = transfer.halConfig();
  return HAL_I2C_Request_Data_Ex(_i2c, &conf, nullptr);
   de1ea:	2200      	movs	r2, #0
   de1ec:	7a23      	ldrb	r3, [r4, #8]
   de1ee:	7c30      	ldrb	r0, [r6, #16]
   de1f0:	f8ad 5004 	strh.w	r5, [sp, #4]
   de1f4:	a901      	add	r1, sp, #4
   de1f6:	9305      	str	r3, [sp, #20]
   de1f8:	f7fd fc58 	bl	dbaac <HAL_I2C_Request_Data_Ex>
}
   de1fc:	b006      	add	sp, #24
   de1fe:	bd70      	pop	{r4, r5, r6, pc}

000de200 <_ZN7TwoWire11requestFromEhjh>:
{
	HAL_I2C_End(_i2c, NULL);
}

size_t TwoWire::requestFrom(uint8_t address, size_t quantity, uint8_t sendStop)
{
   de200:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
   de202:	3300      	adds	r3, #0
public:
  WireTransmission(uint8_t address)
      : address_{address},
        size_{0},
        stop_{true},
        timeout_{HAL_I2C_DEFAULT_TIMEOUT_MS} {
   de204:	f88d 1000 	strb.w	r1, [sp]
   de208:	f04f 0164 	mov.w	r1, #100	; 0x64
   de20c:	9103      	str	r1, [sp, #12]
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
   de20e:	bf18      	it	ne
   de210:	2301      	movne	r3, #1
  return requestFrom(WireTransmission(address).quantity(quantity).stop(sendStop));
   de212:	4669      	mov	r1, sp
  }

  WireTransmission() = delete;

  WireTransmission& quantity(size_t size) {
    size_ = size;
   de214:	9201      	str	r2, [sp, #4]
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
   de216:	f88d 3008 	strb.w	r3, [sp, #8]
   de21a:	f7ff ffd5 	bl	de1c8 <_ZN7TwoWire11requestFromERK16WireTransmission>
}
   de21e:	b005      	add	sp, #20
   de220:	f85d fb04 	ldr.w	pc, [sp], #4

000de224 <_ZN7TwoWire11requestFromEhj>:

size_t TwoWire::requestFrom(uint8_t address, size_t quantity)
{
  return requestFrom(address, quantity, (uint8_t)true);
   de224:	2301      	movs	r3, #1
   de226:	f7ff bfeb 	b.w	de200 <_ZN7TwoWire11requestFromEhjh>

000de22a <_ZN7TwoWire17beginTransmissionEh>:
  return HAL_I2C_Request_Data_Ex(_i2c, &conf, nullptr);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
   de22a:	2200      	movs	r2, #0
   de22c:	7c00      	ldrb	r0, [r0, #16]
   de22e:	f7fd bbe5 	b.w	db9fc <HAL_I2C_Begin_Transmission>

000de232 <_ZN7TwoWire17beginTransmissionEi>:
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
   de232:	b2c9      	uxtb	r1, r1
   de234:	f7ff bff9 	b.w	de22a <_ZN7TwoWire17beginTransmissionEh>

000de238 <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
   de238:	2200      	movs	r2, #0
   de23a:	7c00      	ldrb	r0, [r0, #16]
   de23c:	f7fd bbe6 	b.w	dba0c <HAL_I2C_End_Transmission>

000de240 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
   de240:	2101      	movs	r1, #1
   de242:	f7ff bff9 	b.w	de238 <_ZN7TwoWire15endTransmissionEh>

000de246 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
   de246:	2100      	movs	r1, #0
   de248:	7c00      	ldrb	r0, [r0, #16]
   de24a:	f7fd bc0f 	b.w	dba6c <HAL_I2C_Is_Enabled>

000de24e <_ZN7TwoWire4lockEv>:
{
  HAL_I2C_Reset(_i2c, 0, NULL);
}

bool TwoWire::lock()
{
   de24e:	b508      	push	{r3, lr}
  return HAL_I2C_Acquire(_i2c, NULL) == 0;
   de250:	2100      	movs	r1, #0
   de252:	7c00      	ldrb	r0, [r0, #16]
   de254:	f7fd fc1a 	bl	dba8c <HAL_I2C_Acquire>
}
   de258:	fab0 f080 	clz	r0, r0
   de25c:	0940      	lsrs	r0, r0, #5
   de25e:	bd08      	pop	{r3, pc}

000de260 <_ZN7TwoWire6unlockEv>:

bool TwoWire::unlock()
{
   de260:	b508      	push	{r3, lr}
  return HAL_I2C_Release(_i2c, NULL) == 0;
   de262:	2100      	movs	r1, #0
   de264:	7c00      	ldrb	r0, [r0, #16]
   de266:	f7fd fc19 	bl	dba9c <HAL_I2C_Release>
}
   de26a:	fab0 f080 	clz	r0, r0
   de26e:	0940      	lsrs	r0, r0, #5
   de270:	bd08      	pop	{r3, pc}

000de272 <_ZN5spark9MeshClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   de272:	2200      	movs	r2, #0
   de274:	4611      	mov	r1, r2
   de276:	6840      	ldr	r0, [r0, #4]
   de278:	f7fd bd2e 	b.w	dbcd8 <network_listening>

000de27c <_ZN5spark9MeshClass16getListenTimeoutEv>:
    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
    }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
   de27c:	2200      	movs	r2, #0
   de27e:	4611      	mov	r1, r2
   de280:	6840      	ldr	r0, [r0, #4]
   de282:	f7fd bd39 	b.w	dbcf8 <network_get_listen_timeout>

000de286 <_ZN5spark9MeshClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
   de286:	2200      	movs	r2, #0
   de288:	6840      	ldr	r0, [r0, #4]
   de28a:	f7fd bd2d 	b.w	dbce8 <network_set_listen_timeout>

000de28e <_ZN5spark9MeshClass6listenEb>:
    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
   de28e:	2200      	movs	r2, #0
   de290:	f081 0101 	eor.w	r1, r1, #1
   de294:	6840      	ldr	r0, [r0, #4]
   de296:	f7fd bd17 	b.w	dbcc8 <network_listen>

000de29a <_ZN5spark9MeshClass3offEv>:
    void on() {
        network_on(*this, 0, 0, NULL);
    }

    void off() {
        network_off(*this, 1, 0, NULL);
   de29a:	2300      	movs	r3, #0
   de29c:	461a      	mov	r2, r3
   de29e:	2101      	movs	r1, #1
   de2a0:	6840      	ldr	r0, [r0, #4]
   de2a2:	f7fd bd09 	b.w	dbcb8 <network_off>

000de2a6 <_ZN5spark9MeshClass2onEv>:
    MeshClass() :
            NetworkClass(NETWORK_INTERFACE_MESH) {
    }

    void on() {
        network_on(*this, 0, 0, NULL);
   de2a6:	2300      	movs	r3, #0
   de2a8:	461a      	mov	r2, r3
   de2aa:	4619      	mov	r1, r3
   de2ac:	6840      	ldr	r0, [r0, #4]
   de2ae:	f7fd bcfb 	b.w	dbca8 <network_on>

000de2b2 <_ZN5spark9MeshClass5readyEv>:
    bool listening(void) {
        return network_listening(*this, 0, NULL);
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   de2b2:	2200      	movs	r2, #0
   de2b4:	4611      	mov	r1, r2
   de2b6:	6840      	ldr	r0, [r0, #4]
   de2b8:	f7fd bcee 	b.w	dbc98 <network_ready>

000de2bc <_ZN5spark9MeshClass10connectingEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
   de2bc:	2200      	movs	r2, #0
   de2be:	4611      	mov	r1, r2
   de2c0:	6840      	ldr	r0, [r0, #4]
   de2c2:	f7fd bcd9 	b.w	dbc78 <network_connecting>

000de2c6 <_ZN5spark9MeshClass10disconnectEv>:
    }

    void disconnect() {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   de2c6:	2200      	movs	r2, #0
   de2c8:	2102      	movs	r1, #2
   de2ca:	6840      	ldr	r0, [r0, #4]
   de2cc:	f7fd bcdc 	b.w	dbc88 <network_disconnect>

000de2d0 <_ZN5spark9MeshClass7connectEj>:
    void off() {
        network_off(*this, 1, 0, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
   de2d0:	2300      	movs	r3, #0
   de2d2:	461a      	mov	r2, r3
   de2d4:	6840      	ldr	r0, [r0, #4]
   de2d6:	f7fd bcc7 	b.w	dbc68 <network_connect>

000de2da <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>:
	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      /// Calls @c delete @p __ptr
      void
      operator()(_Tp* __ptr) const
   de2da:	b538      	push	{r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   de2dc:	4605      	mov	r5, r0
   de2de:	b188      	cbz	r0, de304 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x2a>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   de2e0:	6804      	ldr	r4, [r0, #0]
   de2e2:	b14c      	cbz	r4, de2f8 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x1e>

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
   de2e4:	68a3      	ldr	r3, [r4, #8]
   de2e6:	b11b      	cbz	r3, de2f0 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6+0x16>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   de2e8:	2203      	movs	r2, #3
   de2ea:	4621      	mov	r1, r4
   de2ec:	4620      	mov	r0, r4
   de2ee:	4798      	blx	r3
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   de2f0:	2110      	movs	r1, #16
   de2f2:	4620      	mov	r0, r4
   de2f4:	f000 fd2c 	bl	ded50 <_ZdlPvj>
   de2f8:	4628      	mov	r0, r5
   de2fa:	2114      	movs	r1, #20
      }
   de2fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   de300:	f000 bd26 	b.w	ded50 <_ZdlPvj>
   de304:	bd38      	pop	{r3, r4, r5, pc}

000de306 <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13>:
   de306:	b110      	cbz	r0, de30e <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13+0x8>
   de308:	6803      	ldr	r3, [r0, #0]
   de30a:	685b      	ldr	r3, [r3, #4]
   de30c:	4718      	bx	r3
   de30e:	4770      	bx	lr

000de310 <_ZN6ThreadD1Ev>:
    Thread(Thread&& thread)
        : d_(std::move(thread.d_))
    {
    }

    ~Thread()
   de310:	b510      	push	{r4, lr}
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
   de312:	6803      	ldr	r3, [r0, #0]
   de314:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (!isValid())
   de316:	b1bb      	cbz	r3, de348 <_ZN6ThreadD1Ev+0x38>
        return isCurrent();
    }

    bool isCurrent() const
    {
        return isValid() && os_thread_is_current(d_->handle);
   de318:	6858      	ldr	r0, [r3, #4]
   de31a:	f7fd fac7 	bl	db8ac <os_thread_is_current>
   de31e:	b978      	cbnz	r0, de340 <_ZN6ThreadD1Ev+0x30>
   de320:	6823      	ldr	r3, [r4, #0]

        // We shouldn't dispose of current thread
        if (isCurrent())
            return;

        if (!d_->exited) {
   de322:	7c5a      	ldrb	r2, [r3, #17]
   de324:	b912      	cbnz	r2, de32c <_ZN6ThreadD1Ev+0x1c>
        d_.reset();
    }

    bool join()
    {
        return isValid() && os_thread_join(d_->handle)==0;
   de326:	6858      	ldr	r0, [r3, #4]
   de328:	f7fd fac8 	bl	db8bc <os_thread_join>

        if (!d_->exited) {
            join();
        }

        os_thread_cleanup(d_->handle);
   de32c:	6823      	ldr	r3, [r4, #0]
   de32e:	6858      	ldr	r0, [r3, #4]
   de330:	f7fd facc 	bl	db8cc <os_thread_cleanup>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   de334:	6820      	ldr	r0, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
   de336:	2300      	movs	r3, #0
   de338:	6023      	str	r3, [r4, #0]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
   de33a:	b128      	cbz	r0, de348 <_ZN6ThreadD1Ev+0x38>
	  get_deleter()(__p);
   de33c:	f7ff ffcd 	bl	de2da <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   de340:	6820      	ldr	r0, [r4, #0]
   de342:	b108      	cbz	r0, de348 <_ZN6ThreadD1Ev+0x38>
	  get_deleter()(__ptr);
   de344:	f7ff ffc9 	bl	de2da <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.6>
    }

    ~Thread()
    {
        dispose();
    }
   de348:	4620      	mov	r0, r4
   de34a:	bd10      	pop	{r4, pc}

000de34c <_ZN5spark11MeshPublishD1Ev>:
    virtual float getQualityValue() const {
        return 0.0f;
    }
};

class MeshPublish {
   de34c:	b538      	push	{r3, r4, r5, lr}
   de34e:	4604      	mov	r4, r0

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr()
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   de350:	f8d0 01c4 	ldr.w	r0, [r0, #452]	; 0x1c4
   de354:	b108      	cbz	r0, de35a <_ZN5spark11MeshPublishD1Ev+0xe>
      void
      operator()(_Tp* __ptr) const
      {
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete [] __ptr;
   de356:	f7f5 fea4 	bl	d40a2 <_ZdaPv>
        dispose();
    }

    void dispose()
    {
        if (handle_) {
   de35a:	f8d4 01c0 	ldr.w	r0, [r4, #448]	; 0x1c0
   de35e:	b108      	cbz	r0, de364 <_ZN5spark11MeshPublishD1Ev+0x18>
            os_mutex_recursive_destroy(handle_);
   de360:	f7fd fac4 	bl	db8ec <os_mutex_recursive_destroy>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   de364:	f8d4 51bc 	ldr.w	r5, [r4, #444]	; 0x1bc
   de368:	b135      	cbz	r5, de378 <_ZN5spark11MeshPublishD1Ev+0x2c>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
   de36a:	4628      	mov	r0, r5
   de36c:	f7ff ffd0 	bl	de310 <_ZN6ThreadD1Ev>
   de370:	2104      	movs	r1, #4
   de372:	4628      	mov	r0, r5
   de374:	f000 fcec 	bl	ded50 <_ZdlPvj>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
   de378:	6820      	ldr	r0, [r4, #0]
   de37a:	b108      	cbz	r0, de380 <_ZN5spark11MeshPublishD1Ev+0x34>
	  get_deleter()(__ptr);
   de37c:	f7ff ffc3 	bl	de306 <_ZNKSt14default_deleteI3UDPEclEPS0_.isra.8.constprop.13>
   de380:	4620      	mov	r0, r4
   de382:	bd38      	pop	{r3, r4, r5, pc}

000de384 <_ZN5spark9MeshClassD1Ev>:
    RecursiveMutex mutex_;
    std::unique_ptr<uint8_t[]> buffer_;
    std::atomic_bool exit_;
};

class MeshClass : public NetworkClass, public MeshPublish {
   de384:	b510      	push	{r4, lr}
   de386:	4b04      	ldr	r3, [pc, #16]	; (de398 <_ZN5spark9MeshClassD1Ev+0x14>)
   de388:	4604      	mov	r4, r0
   de38a:	f840 3b08 	str.w	r3, [r0], #8
   de38e:	f7ff ffdd 	bl	de34c <_ZN5spark11MeshPublishD1Ev>
   de392:	4620      	mov	r0, r4
   de394:	bd10      	pop	{r4, pc}
   de396:	bf00      	nop
   de398:	000e283c 	.word	0x000e283c

000de39c <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_>:

    return addr;
}

MeshClass Mesh;
} // namespace spark
   de39c:	b538      	push	{r3, r4, r5, lr}
   de39e:	4c0e      	ldr	r4, [pc, #56]	; (de3d8 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x3c>)
   de3a0:	4b0e      	ldr	r3, [pc, #56]	; (de3dc <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x40>)
   de3a2:	6023      	str	r3, [r4, #0]

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }
   de3a4:	2500      	movs	r5, #0
   de3a6:	2302      	movs	r3, #2
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
    {
        os_mutex_recursive_create(&handle_);
   de3a8:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
   de3ac:	6063      	str	r3, [r4, #4]
   de3ae:	60a5      	str	r5, [r4, #8]
   de3b0:	f8c4 51c4 	str.w	r5, [r4, #452]	; 0x1c4
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
   de3b4:	f8c4 51c8 	str.w	r5, [r4, #456]	; 0x1c8
    {
        os_mutex_recursive_create(&handle_);
   de3b8:	f7fd fa90 	bl	db8dc <os_mutex_recursive_create>
public:
    MeshClass() :
            NetworkClass(NETWORK_INTERFACE_MESH) {
   de3bc:	4b08      	ldr	r3, [pc, #32]	; (de3e0 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x44>)
   de3be:	f8c4 51cc 	str.w	r5, [r4, #460]	; 0x1cc
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   de3c2:	f884 51d0 	strb.w	r5, [r4, #464]	; 0x1d0
   de3c6:	6023      	str	r3, [r4, #0]
    }

    return addr;
}

MeshClass Mesh;
   de3c8:	4620      	mov	r0, r4
   de3ca:	4a06      	ldr	r2, [pc, #24]	; (de3e4 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x48>)
   de3cc:	4906      	ldr	r1, [pc, #24]	; (de3e8 <_GLOBAL__sub_I__ZN5spark11MeshPublish13Subscriptions20event_handler_existsEPKcPFvS3_S3_EPvN17SubscriptionScope4EnumES3_+0x4c>)
} // namespace spark
   de3ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    }

    return addr;
}

MeshClass Mesh;
   de3d2:	f000 bcaf 	b.w	ded34 <__aeabi_atexit>
   de3d6:	bf00      	nop
   de3d8:	2003e510 	.word	0x2003e510
   de3dc:	000e28f0 	.word	0x000e28f0
   de3e0:	000e283c 	.word	0x000e283c
   de3e4:	2003daf8 	.word	0x2003daf8
   de3e8:	000de385 	.word	0x000de385

000de3ec <_ZN9TCPClient5writeEh>:
    done.dismiss();

    return 1; // success
}

size_t TCPClient::write(uint8_t b) {
   de3ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
   de3ee:	ac02      	add	r4, sp, #8
    return write(&b, 1, SOCKET_WAIT_FOREVER);
   de3f0:	6803      	ldr	r3, [r0, #0]
    done.dismiss();

    return 1; // success
}

size_t TCPClient::write(uint8_t b) {
   de3f2:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SOCKET_WAIT_FOREVER);
   de3f6:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   de3f8:	2201      	movs	r2, #1
   de3fa:	f04f 33ff 	mov.w	r3, #4294967295
   de3fe:	4621      	mov	r1, r4
   de400:	47a8      	blx	r5
}
   de402:	b003      	add	sp, #12
   de404:	bd30      	pop	{r4, r5, pc}

000de406 <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
   de406:	b410      	push	{r4}
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   de408:	6803      	ldr	r3, [r0, #0]
   de40a:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   de40c:	f04f 33ff 	mov.w	r3, #4294967295
   de410:	46a4      	mov	ip, r4
}
   de412:	f85d 4b04 	ldr.w	r4, [sp], #4
size_t TCPClient::write(uint8_t b) {
    return write(&b, 1, SOCKET_WAIT_FOREVER);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
    return write(buffer, size, SOCKET_WAIT_FOREVER);
   de416:	4760      	bx	ip

000de418 <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
   de418:	b537      	push	{r0, r1, r2, r4, r5, lr}
   de41a:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
   de41c:	6803      	ldr	r3, [r0, #0]

size_t TCPClient::write(const uint8_t *buffer, size_t size) {
    return write(buffer, size, SOCKET_WAIT_FOREVER);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
   de41e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
   de422:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   de424:	4621      	mov	r1, r4
   de426:	4613      	mov	r3, r2
   de428:	2201      	movs	r2, #1
   de42a:	47a8      	blx	r5
}
   de42c:	b003      	add	sp, #12
   de42e:	bd30      	pop	{r4, r5, pc}

000de430 <_ZN9TCPClient5flushEv>:
void TCPClient::flush_buffer() {
    d_->offset = 0;
    d_->total = 0;
}

void TCPClient::flush() {
   de430:	4770      	bx	lr

000de432 <_ZN9TCPClient9connectedEv>:
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
}

uint8_t TCPClient::connected() {
   de432:	b538      	push	{r3, r4, r5, lr}
   de434:	6943      	ldr	r3, [r0, #20]
    bool rv = (status() || bufferCount());
   de436:	681a      	ldr	r2, [r3, #0]
   de438:	2a00      	cmp	r2, #0
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
}

uint8_t TCPClient::connected() {
   de43a:	4604      	mov	r4, r0
    bool rv = (status() || bufferCount());
   de43c:	da05      	bge.n	de44a <_ZN9TCPClient9connectedEv+0x18>
   de43e:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   de442:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   de446:	429a      	cmp	r2, r3
   de448:	d001      	beq.n	de44e <_ZN9TCPClient9connectedEv+0x1c>
   de44a:	2501      	movs	r5, #1
   de44c:	e00b      	b.n	de466 <_ZN9TCPClient9connectedEv+0x34>
    if (!rv) {
        rv = available();
   de44e:	6803      	ldr	r3, [r0, #0]
   de450:	691b      	ldr	r3, [r3, #16]
   de452:	4798      	blx	r3
   de454:	2800      	cmp	r0, #0
   de456:	bf14      	ite	ne
   de458:	2501      	movne	r5, #1
   de45a:	2500      	moveq	r5, #0
        if (!rv) {
   de45c:	d103      	bne.n	de466 <_ZN9TCPClient9connectedEv+0x34>
            stop();
   de45e:	6823      	ldr	r3, [r4, #0]
   de460:	4620      	mov	r0, r4
   de462:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   de464:	4798      	blx	r3
        }
    }
    return rv;
}
   de466:	4628      	mov	r0, r5
   de468:	bd38      	pop	{r3, r4, r5, pc}

000de46a <_ZN9TCPClientcvbEv>:

uint8_t TCPClient::status() {
    return (isOpen(d_->sock));
   de46a:	6943      	ldr	r3, [r0, #20]
}

TCPClient::operator bool() {
   return (status() != 0);
   de46c:	6818      	ldr	r0, [r3, #0]
}
   de46e:	43c0      	mvns	r0, r0
   de470:	0fc0      	lsrs	r0, r0, #31
   de472:	4770      	bx	lr

000de474 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   de474:	4770      	bx	lr

000de476 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
   de476:	2000      	movs	r0, #0
   de478:	4770      	bx	lr

000de47a <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
   de47a:	b510      	push	{r4, lr}
   de47c:	2114      	movs	r1, #20
   de47e:	4604      	mov	r4, r0
   de480:	f000 fc66 	bl	ded50 <_ZdlPvj>
   de484:	4620      	mov	r0, r4
   de486:	bd10      	pop	{r4, pc}

000de488 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   de488:	f7f5 be09 	b.w	d409e <_ZdlPv>

000de48c <_ZN9TCPClient5writeEPKhjm>:

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout) {
   de48c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   de48e:	4616      	mov	r6, r2

    size_t printNumber(unsigned long, uint8_t);
    size_t printNumber(unsigned long long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   de490:	2200      	movs	r2, #0
   de492:	6042      	str	r2, [r0, #4]
    clearWriteError();
    struct timeval tv = {};
   de494:	9202      	str	r2, [sp, #8]
   de496:	9203      	str	r2, [sp, #12]
    if (timeout != SOCKET_WAIT_FOREVER) {
   de498:	1c5a      	adds	r2, r3, #1

size_t TCPClient::write(uint8_t b, system_tick_t timeout) {
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout) {
   de49a:	4604      	mov	r4, r0
   de49c:	460d      	mov	r5, r1
    clearWriteError();
    struct timeval tv = {};
    if (timeout != SOCKET_WAIT_FOREVER) {
   de49e:	d008      	beq.n	de4b2 <_ZN9TCPClient5writeEPKhjm+0x26>
        tv.tv_sec = timeout / 1000;
   de4a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   de4a4:	fbb3 f1f2 	udiv	r1, r3, r2
   de4a8:	9102      	str	r1, [sp, #8]
        tv.tv_usec = (timeout % 1000) * 1000;
   de4aa:	fb02 3111 	mls	r1, r2, r1, r3
   de4ae:	434a      	muls	r2, r1
   de4b0:	9203      	str	r2, [sp, #12]
    }
    int ret = sock_setsockopt(d_->sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
   de4b2:	6960      	ldr	r0, [r4, #20]
   de4b4:	2308      	movs	r3, #8
   de4b6:	9300      	str	r3, [sp, #0]
   de4b8:	f241 0205 	movw	r2, #4101	; 0x1005
   de4bc:	446b      	add	r3, sp
   de4be:	f640 71ff 	movw	r1, #4095	; 0xfff
   de4c2:	6800      	ldr	r0, [r0, #0]
   de4c4:	f7fd fafa 	bl	dbabc <sock_setsockopt>
    if (ret < 0) {
   de4c8:	2800      	cmp	r0, #0
   de4ca:	db08      	blt.n	de4de <_ZN9TCPClient5writeEPKhjm+0x52>
        setWriteError(errno);
        return 0;
    }

    ret = sock_send(d_->sock, buffer, size, 0);
   de4cc:	6960      	ldr	r0, [r4, #20]
   de4ce:	2300      	movs	r3, #0
   de4d0:	4632      	mov	r2, r6
   de4d2:	4629      	mov	r1, r5
   de4d4:	6800      	ldr	r0, [r0, #0]
   de4d6:	f7fd fb11 	bl	dbafc <sock_send>
    if (ret < 0) {
   de4da:	2800      	cmp	r0, #0
   de4dc:	da04      	bge.n	de4e8 <_ZN9TCPClient5writeEPKhjm+0x5c>
        setWriteError(errno);
   de4de:	f7fd fcab 	bl	dbe38 <__errno>
   de4e2:	6803      	ldr	r3, [r0, #0]
   de4e4:	6063      	str	r3, [r4, #4]
   de4e6:	2000      	movs	r0, #0
        return 0;
    }

    return ret;
}
   de4e8:	b004      	add	sp, #16
   de4ea:	bd70      	pop	{r4, r5, r6, pc}

000de4ec <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   de4ec:	b510      	push	{r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   de4ee:	6803      	ldr	r3, [r0, #0]
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
   de4f0:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
   de4f2:	689b      	ldr	r3, [r3, #8]
   de4f4:	4798      	blx	r3
          if (--_M_weak_count == 0)
   de4f6:	68a3      	ldr	r3, [r4, #8]
   de4f8:	3b01      	subs	r3, #1
   de4fa:	60a3      	str	r3, [r4, #8]
   de4fc:	b92b      	cbnz	r3, de50a <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31+0x1e>
            _M_destroy();
   de4fe:	6823      	ldr	r3, [r4, #0]
   de500:	4620      	mov	r0, r4
   de502:	68db      	ldr	r3, [r3, #12]
        }
    }
   de504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
   de508:	4718      	bx	r3
   de50a:	bd10      	pop	{r4, pc}

000de50c <_ZN9TCPClient8remoteIPEv>:

TCPClient::operator bool() {
   return (status() != 0);
}

IPAddress TCPClient::remoteIP() {
   de50c:	b570      	push	{r4, r5, r6, lr}

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   de50e:	4604      	mov	r4, r0
   de510:	694d      	ldr	r5, [r1, #20]
   de512:	4b05      	ldr	r3, [pc, #20]	; (de528 <_ZN9TCPClient8remoteIPEv+0x1c>)
   de514:	f844 3b04 	str.w	r3, [r4], #4
   de518:	358c      	adds	r5, #140	; 0x8c
   de51a:	4606      	mov	r6, r0
   de51c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   de51e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   de520:	682b      	ldr	r3, [r5, #0]
   de522:	7023      	strb	r3, [r4, #0]
    return d_->remoteIP;
}
   de524:	4630      	mov	r0, r6
   de526:	bd70      	pop	{r4, r5, r6, pc}
   de528:	000e276c 	.word	0x000e276c

000de52c <_ZN9TCPClient4peekEv>:
        d_->offset += read;
    }
    return read;
}

int TCPClient::peek() {
   de52c:	b510      	push	{r4, lr}
   de52e:	6943      	ldr	r3, [r0, #20]
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
   de530:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   de534:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   de538:	429a      	cmp	r2, r3
        d_->offset += read;
    }
    return read;
}

int TCPClient::peek() {
   de53a:	4604      	mov	r4, r0
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
   de53c:	d005      	beq.n	de54a <_ZN9TCPClient4peekEv+0x1e>
   de53e:	6962      	ldr	r2, [r4, #20]
   de540:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   de544:	4413      	add	r3, r2
   de546:	7918      	ldrb	r0, [r3, #4]
   de548:	bd10      	pop	{r4, pc}
   de54a:	6803      	ldr	r3, [r0, #0]
   de54c:	691b      	ldr	r3, [r3, #16]
   de54e:	4798      	blx	r3
   de550:	2800      	cmp	r0, #0
   de552:	d1f4      	bne.n	de53e <_ZN9TCPClient4peekEv+0x12>
   de554:	f04f 30ff 	mov.w	r0, #4294967295
}
   de558:	bd10      	pop	{r4, pc}

000de55a <_ZN9TCPClient4readEv>:
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
}

int TCPClient::read() {
   de55a:	b510      	push	{r4, lr}
   de55c:	6943      	ldr	r3, [r0, #20]
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
   de55e:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   de562:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   de566:	429a      	cmp	r2, r3
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
}

int TCPClient::read() {
   de568:	4604      	mov	r4, r0
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
   de56a:	d008      	beq.n	de57e <_ZN9TCPClient4readEv+0x24>
   de56c:	6962      	ldr	r2, [r4, #20]
   de56e:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   de572:	1c59      	adds	r1, r3, #1
   de574:	4413      	add	r3, r2
   de576:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
   de57a:	7918      	ldrb	r0, [r3, #4]
   de57c:	bd10      	pop	{r4, pc}
   de57e:	6803      	ldr	r3, [r0, #0]
   de580:	691b      	ldr	r3, [r3, #16]
   de582:	4798      	blx	r3
   de584:	2800      	cmp	r0, #0
   de586:	d1f1      	bne.n	de56c <_ZN9TCPClient4readEv+0x12>
   de588:	f04f 30ff 	mov.w	r0, #4294967295
}
   de58c:	bd10      	pop	{r4, pc}

000de58e <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size) {
   de58e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   de590:	6943      	ldr	r3, [r0, #20]
   de592:	4617      	mov	r7, r2
    int read = -1;
    if (bufferCount() || available()) {
   de594:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   de598:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
   de59c:	429a      	cmp	r2, r3

int TCPClient::read() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size) {
   de59e:	4605      	mov	r5, r0
   de5a0:	460e      	mov	r6, r1
    int read = -1;
    if (bufferCount() || available()) {
   de5a2:	d106      	bne.n	de5b2 <_ZN9TCPClient4readEPhj+0x24>
   de5a4:	6803      	ldr	r3, [r0, #0]
   de5a6:	691b      	ldr	r3, [r3, #16]
   de5a8:	4798      	blx	r3
   de5aa:	b910      	cbnz	r0, de5b2 <_ZN9TCPClient4readEPhj+0x24>
int TCPClient::read() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size) {
    int read = -1;
   de5ac:	f04f 34ff 	mov.w	r4, #4294967295
   de5b0:	e014      	b.n	de5dc <_ZN9TCPClient4readEPhj+0x4e>
   de5b2:	6969      	ldr	r1, [r5, #20]

    return ret;
}

int TCPClient::bufferCount() {
    return d_->total - d_->offset;
   de5b4:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
   de5b8:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
   de5bc:	1ae4      	subs	r4, r4, r3
}

int TCPClient::read(uint8_t *buffer, size_t size) {
    int read = -1;
    if (bufferCount() || available()) {
        read = (size > (size_t) bufferCount()) ? bufferCount() : size;
   de5be:	42bc      	cmp	r4, r7
   de5c0:	bf28      	it	cs
   de5c2:	463c      	movcs	r4, r7
        memcpy(buffer, &d_->buffer[d_->offset], read);
   de5c4:	4419      	add	r1, r3
   de5c6:	4622      	mov	r2, r4
   de5c8:	3104      	adds	r1, #4
   de5ca:	4630      	mov	r0, r6
   de5cc:	f001 fcc1 	bl	dff52 <memcpy>
   de5d0:	696a      	ldr	r2, [r5, #20]
        d_->offset += read;
   de5d2:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
   de5d6:	4423      	add	r3, r4
   de5d8:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
    }
    return read;
}
   de5dc:	4620      	mov	r0, r4
   de5de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000de5e0 <_ZN9TCPClient7connectEPKctm>:
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   de5e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   de5e4:	4698      	mov	r8, r3
    stop();
   de5e6:	6803      	ldr	r3, [r0, #0]
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   de5e8:	b093      	sub	sp, #76	; 0x4c
    stop();
   de5ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
   de5ec:	460d      	mov	r5, r1
   de5ee:	4606      	mov	r6, r0
   de5f0:	4617      	mov	r7, r2
    stop();
   de5f2:	4798      	blx	r3

    struct addrinfo* ais = nullptr;
   de5f4:	ab12      	add	r3, sp, #72	; 0x48
   de5f6:	2400      	movs	r4, #0
   de5f8:	f843 4d48 	str.w	r4, [r3, #-72]!
    SCOPE_GUARD({
        netdb_freeaddrinfo(ais);
    });
    CHECK_TRUE(netdb_getaddrinfo(host, nullptr, nullptr, &ais) == 0, 0); // return 0
   de5fc:	4622      	mov	r2, r4
   de5fe:	4621      	mov	r1, r4
   de600:	4628      	mov	r0, r5
   de602:	f7fd f84f 	bl	db6a4 <netdb_getaddrinfo>
   de606:	4681      	mov	r9, r0
   de608:	2800      	cmp	r0, #0
   de60a:	d13d      	bne.n	de688 <_ZN9TCPClient7connectEPKctm+0xa8>

    // FIXME: for now using only the first entry
    if (ais && ais->ai_addr) {
   de60c:	9b00      	ldr	r3, [sp, #0]
   de60e:	2b00      	cmp	r3, #0
   de610:	d056      	beq.n	de6c0 <_ZN9TCPClient7connectEPKctm+0xe0>
   de612:	695b      	ldr	r3, [r3, #20]
   de614:	2b00      	cmp	r3, #0
   de616:	d053      	beq.n	de6c0 <_ZN9TCPClient7connectEPKctm+0xe0>
        IPAddress addr;
   de618:	a806      	add	r0, sp, #24
   de61a:	f7ff fb83 	bl	ddd24 <_ZN9IPAddressC1Ev>
        detail::sockaddrToIpAddressPort(ais->ai_addr, addr, nullptr);
   de61e:	9b00      	ldr	r3, [sp, #0]
   de620:	695c      	ldr	r4, [r3, #20]
namespace spark {

namespace detail {

inline void sockaddrToIpAddressPort(const struct sockaddr* saddr, IPAddress& addr, uint16_t* port) {
    if (saddr->sa_family == AF_INET) {
   de622:	7863      	ldrb	r3, [r4, #1]
   de624:	2b02      	cmp	r3, #2
   de626:	d101      	bne.n	de62c <_ZN9TCPClient7connectEPKctm+0x4c>
        const struct sockaddr_in* inaddr = (const struct sockaddr_in*)saddr;
        addr = (const uint8_t*)(&inaddr->sin_addr.s_addr);
   de628:	1d21      	adds	r1, r4, #4
   de62a:	e013      	b.n	de654 <_ZN9TCPClient7connectEPKctm+0x74>
        if (port) {
            *port = ntohs(inaddr->sin_port);
        }
    }
#if HAL_IPv6
    else if (saddr->sa_family == AF_INET6) {
   de62c:	2b0a      	cmp	r3, #10
   de62e:	d114      	bne.n	de65a <_ZN9TCPClient7connectEPKctm+0x7a>
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
   de630:	2211      	movs	r2, #17
   de632:	4649      	mov	r1, r9
   de634:	a801      	add	r0, sp, #4
   de636:	f001 fc97 	bl	dff68 <memset>
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
   de63a:	68a3      	ldr	r3, [r4, #8]
   de63c:	bb33      	cbnz	r3, de68c <_ZN9TCPClient7connectEPKctm+0xac>
   de63e:	68e3      	ldr	r3, [r4, #12]
   de640:	bb23      	cbnz	r3, de68c <_ZN9TCPClient7connectEPKctm+0xac>
   de642:	f64f 70ff 	movw	r0, #65535	; 0xffff
   de646:	6925      	ldr	r5, [r4, #16]
   de648:	f7fd f978 	bl	db93c <inet_htonl>
   de64c:	4285      	cmp	r5, r0
   de64e:	d11d      	bne.n	de68c <_ZN9TCPClient7connectEPKctm+0xac>
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
            a.v = 6;
            addr = IPAddress(a);
        } else {
            auto ptr = (const uint32_t*)(in6addr->sin6_addr.s6_addr);
            addr = (const uint8_t*)(&ptr[3]);
   de650:	f104 0114 	add.w	r1, r4, #20
   de654:	a806      	add	r0, sp, #24
   de656:	f7ff fbb5 	bl	dddc4 <_ZN9IPAddressaSEPKh>
    operator bool() const;

    // For some reason, without this non-const overload GCC struggles to pick right operator
    // for bool conversion of a non-const object
    operator bool() {
        return static_cast<const IPAddress*>(this)->operator bool();
   de65a:	a806      	add	r0, sp, #24
   de65c:	f7ff fb82 	bl	ddd64 <_ZNK9IPAddresscvbEv>
        if (addr) {
   de660:	2800      	cmp	r0, #0
   de662:	d02d      	beq.n	de6c0 <_ZN9TCPClient7connectEPKctm+0xe0>
            return connect(addr, port, nif);
   de664:	6833      	ldr	r3, [r6, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   de666:	ad07      	add	r5, sp, #28
   de668:	f8d3 9020 	ldr.w	r9, [r3, #32]
   de66c:	4b18      	ldr	r3, [pc, #96]	; (de6d0 <_ZN9TCPClient7connectEPKctm+0xf0>)
   de66e:	930c      	str	r3, [sp, #48]	; 0x30
   de670:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   de672:	ac0d      	add	r4, sp, #52	; 0x34
   de674:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   de676:	682b      	ldr	r3, [r5, #0]
   de678:	7023      	strb	r3, [r4, #0]
   de67a:	463a      	mov	r2, r7
   de67c:	4643      	mov	r3, r8
   de67e:	a90c      	add	r1, sp, #48	; 0x30
   de680:	4630      	mov	r0, r6
   de682:	47c8      	blx	r9
   de684:	4681      	mov	r9, r0
   de686:	e01b      	b.n	de6c0 <_ZN9TCPClient7connectEPKctm+0xe0>

    struct addrinfo* ais = nullptr;
    SCOPE_GUARD({
        netdb_freeaddrinfo(ais);
    });
    CHECK_TRUE(netdb_getaddrinfo(host, nullptr, nullptr, &ais) == 0, 0); // return 0
   de688:	46a1      	mov	r9, r4
   de68a:	e019      	b.n	de6c0 <_ZN9TCPClient7connectEPKctm+0xe0>
#if HAL_IPv6
    else if (saddr->sa_family == AF_INET6) {
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
   de68c:	f104 0308 	add.w	r3, r4, #8
   de690:	ad01      	add	r5, sp, #4
   de692:	3418      	adds	r4, #24
   de694:	6818      	ldr	r0, [r3, #0]
   de696:	6859      	ldr	r1, [r3, #4]
   de698:	462a      	mov	r2, r5
   de69a:	c203      	stmia	r2!, {r0, r1}
   de69c:	3308      	adds	r3, #8
   de69e:	42a3      	cmp	r3, r4
   de6a0:	4615      	mov	r5, r2
   de6a2:	d1f7      	bne.n	de694 <_ZN9TCPClient7connectEPKctm+0xb4>
            a.v = 6;
   de6a4:	2306      	movs	r3, #6
            addr = IPAddress(a);
   de6a6:	a901      	add	r1, sp, #4
   de6a8:	a80c      	add	r0, sp, #48	; 0x30
   de6aa:	ad0d      	add	r5, sp, #52	; 0x34
    else if (saddr->sa_family == AF_INET6) {
        const struct sockaddr_in6* in6addr = (const struct sockaddr_in6*)saddr;
        HAL_IPAddress a = {};
        if (!IN6_IS_ADDR_V4MAPPED(&in6addr->sin6_addr)) {
            memcpy(a.ipv6, in6addr->sin6_addr.s6_addr, sizeof(a.ipv6));
            a.v = 6;
   de6ac:	f88d 3014 	strb.w	r3, [sp, #20]
            addr = IPAddress(a);
   de6b0:	f7ff fb46 	bl	ddd40 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   de6b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   de6b6:	ac07      	add	r4, sp, #28
   de6b8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   de6ba:	682b      	ldr	r3, [r5, #0]
   de6bc:	7023      	strb	r3, [r4, #0]
   de6be:	e7cc      	b.n	de65a <_ZN9TCPClient7connectEPKctm+0x7a>
// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif) {
    stop();

    struct addrinfo* ais = nullptr;
    SCOPE_GUARD({
   de6c0:	9800      	ldr	r0, [sp, #0]
   de6c2:	f7fc ffe7 	bl	db694 <netdb_freeaddrinfo>
            return connect(addr, port, nif);
        }
    }

    return 0; // error, could not connect
}
   de6c6:	4648      	mov	r0, r9
   de6c8:	b013      	add	sp, #76	; 0x4c
   de6ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   de6ce:	bf00      	nop
   de6d0:	000e276c 	.word	0x000e276c

000de6d4 <_ZN9TCPClient12flush_bufferEv>:

int TCPClient::peek() {
    return (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer() {
   de6d4:	6942      	ldr	r2, [r0, #20]
    d_->offset = 0;
   de6d6:	2300      	movs	r3, #0
   de6d8:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
   de6dc:	6942      	ldr	r2, [r0, #20]
    d_->total = 0;
   de6de:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
   de6e2:	4770      	bx	lr

000de6e4 <_ZN9TCPClient7connectE9IPAddresstm>:

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   de6e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   de6e8:	461e      	mov	r6, r3
    stop();
   de6ea:	6803      	ldr	r3, [r0, #0]

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   de6ec:	460c      	mov	r4, r1
   de6ee:	b08a      	sub	sp, #40	; 0x28
    stop();
   de6f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c

    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
   de6f2:	4605      	mov	r5, r0
   de6f4:	4617      	mov	r7, r2
    stop();
   de6f6:	4798      	blx	r3

    NAMED_SCOPE_GUARD(done, {
        stop();
    });

    d_->sock = sock_socket(ip.version() == 4 ? AF_INET : AF_INET6, SOCK_STREAM, IPPROTO_TCP);
   de6f8:	7d23      	ldrb	r3, [r4, #20]
   de6fa:	f8d5 8014 	ldr.w	r8, [r5, #20]
   de6fe:	2b04      	cmp	r3, #4
   de700:	bf0c      	ite	eq
   de702:	2002      	moveq	r0, #2
   de704:	200a      	movne	r0, #10
   de706:	2206      	movs	r2, #6
   de708:	2101      	movs	r1, #1
   de70a:	f7fd f9ff 	bl	dbb0c <sock_socket>
   de70e:	f8c8 0000 	str.w	r0, [r8]
    CHECK_TRUE(d_->sock >= 0, 0); // return 0
   de712:	696b      	ldr	r3, [r5, #20]
   de714:	681b      	ldr	r3, [r3, #0]
   de716:	2b00      	cmp	r3, #0
   de718:	db18      	blt.n	de74c <_ZN9TCPClient7connectE9IPAddresstm+0x68>

    flush_buffer();
   de71a:	4628      	mov	r0, r5
   de71c:	f7ff ffda 	bl	de6d4 <_ZN9TCPClient12flush_bufferEv>

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
   de720:	b1d6      	cbz	r6, de758 <_ZN9TCPClient7connectE9IPAddresstm+0x74>
        struct ifreq ifr = {};
   de722:	2300      	movs	r3, #0
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   de724:	a903      	add	r1, sp, #12
   de726:	b2f0      	uxtb	r0, r6
    flush_buffer();

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
        struct ifreq ifr = {};
   de728:	9303      	str	r3, [sp, #12]
   de72a:	f8ad 3010 	strh.w	r3, [sp, #16]
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   de72e:	f7fd f831 	bl	db794 <if_index_to_name>
   de732:	b958      	cbnz	r0, de74c <_ZN9TCPClient7connectE9IPAddresstm+0x68>
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
   de734:	6968      	ldr	r0, [r5, #20]
   de736:	2306      	movs	r3, #6
   de738:	9300      	str	r3, [sp, #0]
   de73a:	f241 020b 	movw	r2, #4107	; 0x100b
   de73e:	ab03      	add	r3, sp, #12
   de740:	f640 71ff 	movw	r1, #4095	; 0xfff
   de744:	6800      	ldr	r0, [r0, #0]
   de746:	f7fd f9b9 	bl	dbabc <sock_setsockopt>
   de74a:	b128      	cbz	r0, de758 <_ZN9TCPClient7connectE9IPAddresstm+0x74>

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
    stop();

    NAMED_SCOPE_GUARD(done, {
   de74c:	682b      	ldr	r3, [r5, #0]
   de74e:	4628      	mov	r0, r5
   de750:	6adb      	ldr	r3, [r3, #44]	; 0x2c

#if HAL_PLATFORM_IFAPI
    // TODO: provide compatibility headers and use if_indextoname()
    if (nif != 0) {
        struct ifreq ifr = {};
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
   de752:	2400      	movs	r4, #0

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif) {
    stop();

    NAMED_SCOPE_GUARD(done, {
   de754:	4798      	blx	r3
   de756:	e03b      	b.n	de7d0 <_ZN9TCPClient7connectE9IPAddresstm+0xec>
        CHECK_TRUE(if_index_to_name(nif, ifr.ifr_name) == 0, 0); // return 0
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
    }
#endif // HAL_PLATFORM_IFAPI

    sockaddr_storage saddr = {};
   de758:	261c      	movs	r6, #28
   de75a:	4632      	mov	r2, r6
   de75c:	2100      	movs	r1, #0
   de75e:	a803      	add	r0, sp, #12
   de760:	f001 fc02 	bl	dff68 <memset>
    if (ip.version() == 4) {
   de764:	7d23      	ldrb	r3, [r4, #20]
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
   de766:	f88d 600c 	strb.w	r6, [sp, #12]
        CHECK_TRUE(sock_setsockopt(d_->sock, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0, 0); // return 0
    }
#endif // HAL_PLATFORM_IFAPI

    sockaddr_storage saddr = {};
    if (ip.version() == 4) {
   de76a:	2b04      	cmp	r3, #4
   de76c:	d10c      	bne.n	de788 <_ZN9TCPClient7connectE9IPAddresstm+0xa4>
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
        s->sin_family = AF_INET;
   de76e:	2302      	movs	r3, #2
        s->sin_port = htons(port);
   de770:	4638      	mov	r0, r7

    sockaddr_storage saddr = {};
    if (ip.version() == 4) {
        auto s = (sockaddr_in*)&saddr;
        s->sin_len = sizeof(saddr);
        s->sin_family = AF_INET;
   de772:	f88d 300d 	strb.w	r3, [sp, #13]
        s->sin_port = htons(port);
   de776:	f7fd f8e9 	bl	db94c <inet_htons>
   de77a:	f8ad 000e 	strh.w	r0, [sp, #14]
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
   de77e:	6860      	ldr	r0, [r4, #4]
   de780:	f7fd f8dc 	bl	db93c <inet_htonl>
   de784:	9004      	str	r0, [sp, #16]
   de786:	e013      	b.n	de7b0 <_ZN9TCPClient7connectE9IPAddresstm+0xcc>
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
   de788:	230a      	movs	r3, #10
        s->sin6_port = htons(port);
   de78a:	4638      	mov	r0, r7
        s->sin_port = htons(port);
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
   de78c:	f88d 300d 	strb.w	r3, [sp, #13]
        s->sin6_port = htons(port);
   de790:	f7fd f8dc 	bl	db94c <inet_htons>
        memcpy(s->sin6_addr.s6_addr, ip.raw().ipv6, sizeof(s->sin6_addr.s6_addr));
   de794:	ae05      	add	r6, sp, #20
        s->sin_addr.s_addr = htonl(ip.raw().ipv4);
    } else {
        auto s = (sockaddr_in6*)&saddr;
        s->sin6_len = sizeof(saddr);
        s->sin6_family = AF_INET6;
        s->sin6_port = htons(port);
   de796:	f8ad 000e 	strh.w	r0, [sp, #14]
        memcpy(s->sin6_addr.s6_addr, ip.raw().ipv6, sizeof(s->sin6_addr.s6_addr));
   de79a:	1d23      	adds	r3, r4, #4
   de79c:	f104 0714 	add.w	r7, r4, #20
   de7a0:	6818      	ldr	r0, [r3, #0]
   de7a2:	6859      	ldr	r1, [r3, #4]
   de7a4:	4632      	mov	r2, r6
   de7a6:	c203      	stmia	r2!, {r0, r1}
   de7a8:	3308      	adds	r3, #8
   de7aa:	42bb      	cmp	r3, r7
   de7ac:	4616      	mov	r6, r2
   de7ae:	d1f7      	bne.n	de7a0 <_ZN9TCPClient7connectE9IPAddresstm+0xbc>
    }

    // FIXME: timeout?
    CHECK_TRUE(sock_connect(d_->sock, (const sockaddr*)&saddr, sizeof(saddr)) == 0, 0); // return 0
   de7b0:	696b      	ldr	r3, [r5, #20]
   de7b2:	221c      	movs	r2, #28
   de7b4:	a903      	add	r1, sp, #12
   de7b6:	6818      	ldr	r0, [r3, #0]
   de7b8:	f7fd f990 	bl	dbadc <sock_connect>
   de7bc:	2800      	cmp	r0, #0
   de7be:	d1c5      	bne.n	de74c <_ZN9TCPClient7connectE9IPAddresstm+0x68>
   de7c0:	3404      	adds	r4, #4
   de7c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   de7c4:	696d      	ldr	r5, [r5, #20]
   de7c6:	358c      	adds	r5, #140	; 0x8c
   de7c8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   de7ca:	6823      	ldr	r3, [r4, #0]
   de7cc:	702b      	strb	r3, [r5, #0]

    d_->remoteIP = ip;

    done.dismiss();

    return 1; // success
   de7ce:	2401      	movs	r4, #1
}
   de7d0:	4620      	mov	r0, r4
   de7d2:	b00a      	add	sp, #40	; 0x28
   de7d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000de7d8 <_ZN9TCPClient4stopEv>:
}

void TCPClient::flush() {
}

void TCPClient::stop() {
   de7d8:	b510      	push	{r4, lr}
    if (isOpen(d_->sock)) {
   de7da:	6943      	ldr	r3, [r0, #20]
}

void TCPClient::flush() {
}

void TCPClient::stop() {
   de7dc:	4604      	mov	r4, r0
    if (isOpen(d_->sock)) {
   de7de:	6818      	ldr	r0, [r3, #0]
   de7e0:	2800      	cmp	r0, #0
   de7e2:	db01      	blt.n	de7e8 <_ZN9TCPClient4stopEv+0x10>
        sock_close(d_->sock);
   de7e4:	f7fd f972 	bl	dbacc <sock_close>
   de7e8:	6963      	ldr	r3, [r4, #20]
    }
    d_->sock = -1;
   de7ea:	f04f 32ff 	mov.w	r2, #4294967295
   de7ee:	601a      	str	r2, [r3, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   de7f0:	6960      	ldr	r0, [r4, #20]
   de7f2:	2211      	movs	r2, #17
   de7f4:	2100      	movs	r1, #0
   de7f6:	308c      	adds	r0, #140	; 0x8c
   de7f8:	f001 fbb6 	bl	dff68 <memset>
    d_->remoteIP.clear();
    flush_buffer();
   de7fc:	4620      	mov	r0, r4
}
   de7fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (isOpen(d_->sock)) {
        sock_close(d_->sock);
    }
    d_->sock = -1;
    d_->remoteIP.clear();
    flush_buffer();
   de802:	f7ff bf67 	b.w	de6d4 <_ZN9TCPClient12flush_bufferEv>
	...

000de808 <_ZN9TCPClient9availableEv>:
int TCPClient::bufferCount() {
    return d_->total - d_->offset;
}

int TCPClient::available()
{
   de808:	b530      	push	{r4, r5, lr}
   de80a:	6942      	ldr	r2, [r0, #20]
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
   de80c:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
int TCPClient::bufferCount() {
    return d_->total - d_->offset;
}

int TCPClient::available()
{
   de810:	b08b      	sub	sp, #44	; 0x2c
   de812:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
   de814:	b11b      	cbz	r3, de81e <_ZN9TCPClient9availableEv+0x16>
   de816:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
   de81a:	429a      	cmp	r2, r3
   de81c:	d040      	beq.n	de8a0 <_ZN9TCPClient9availableEv+0x98>
   de81e:	6963      	ldr	r3, [r4, #20]
        flush_buffer();
    }

    if (isOpen(d_->sock)) {
   de820:	6818      	ldr	r0, [r3, #0]
   de822:	2800      	cmp	r0, #0
   de824:	db3f      	blt.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
        // Have room
        if (d_->total < arraySize(d_->buffer)) {
   de826:	f8b3 5086 	ldrh.w	r5, [r3, #134]	; 0x86
   de82a:	2d7f      	cmp	r5, #127	; 0x7f
   de82c:	d83b      	bhi.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
            int ret = sock_recv(d_->sock, d_->buffer + d_->total, arraySize(d_->buffer) - d_->total, MSG_DONTWAIT);
   de82e:	1d19      	adds	r1, r3, #4
   de830:	f1c5 0280 	rsb	r2, r5, #128	; 0x80
   de834:	2308      	movs	r3, #8
   de836:	4429      	add	r1, r5
   de838:	f7fd f958 	bl	dbaec <sock_recv>
            if (ret > 0) {
   de83c:	2800      	cmp	r0, #0
   de83e:	dd0c      	ble.n	de85a <_ZN9TCPClient9availableEv+0x52>
   de840:	6963      	ldr	r3, [r4, #20]
                if (d_->total == 0) {
   de842:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
   de846:	b90a      	cbnz	r2, de84c <_ZN9TCPClient9availableEv+0x44>
                    d_->offset = 0;
   de848:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
   de84c:	6962      	ldr	r2, [r4, #20]
                }
                d_->total += ret;
   de84e:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
   de852:	4418      	add	r0, r3
   de854:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
   de858:	e025      	b.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
            } else {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
   de85a:	f7fd faed 	bl	dbe38 <__errno>
   de85e:	6803      	ldr	r3, [r0, #0]
   de860:	2b0b      	cmp	r3, #11
   de862:	d020      	beq.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
   de864:	f7fd fae8 	bl	dbe38 <__errno>
   de868:	6803      	ldr	r3, [r0, #0]
   de86a:	2b0b      	cmp	r3, #11
   de86c:	d01b      	beq.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
                    LOG(ERROR, "recv error = %d", errno);
   de86e:	2320      	movs	r3, #32
   de870:	2500      	movs	r5, #0
   de872:	9302      	str	r3, [sp, #8]
   de874:	9503      	str	r5, [sp, #12]
   de876:	f7fd fadf 	bl	dbe38 <__errno>
   de87a:	6803      	ldr	r3, [r0, #0]
   de87c:	9301      	str	r3, [sp, #4]
   de87e:	4b0e      	ldr	r3, [pc, #56]	; (de8b8 <_ZN9TCPClient9availableEv+0xb0>)
   de880:	9300      	str	r3, [sp, #0]
   de882:	aa02      	add	r2, sp, #8
   de884:	462b      	mov	r3, r5
   de886:	490d      	ldr	r1, [pc, #52]	; (de8bc <_ZN9TCPClient9availableEv+0xb4>)
   de888:	2032      	movs	r0, #50	; 0x32
   de88a:	f7fd f98f 	bl	dbbac <log_message>
                    sock_close(d_->sock);
   de88e:	6963      	ldr	r3, [r4, #20]
   de890:	6818      	ldr	r0, [r3, #0]
   de892:	f7fd f91b 	bl	dbacc <sock_close>
   de896:	6963      	ldr	r3, [r4, #20]
                    d_->sock = -1;
   de898:	f04f 32ff 	mov.w	r2, #4294967295
   de89c:	601a      	str	r2, [r3, #0]
   de89e:	e002      	b.n	de8a6 <_ZN9TCPClient9availableEv+0x9e>
{
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total)) {
        flush_buffer();
   de8a0:	f7ff ff18 	bl	de6d4 <_ZN9TCPClient12flush_bufferEv>
   de8a4:	e7bb      	b.n	de81e <_ZN9TCPClient9availableEv+0x16>
   de8a6:	6962      	ldr	r2, [r4, #20]
                }
            }
        } // Have Space
    } // isOpen(d_->sock)
    avail = bufferCount();
    return avail;
   de8a8:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
   de8ac:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
   de8b0:	1a18      	subs	r0, r3, r0
}
   de8b2:	b00b      	add	sp, #44	; 0x2c
   de8b4:	bd30      	pop	{r4, r5, pc}
   de8b6:	bf00      	nop
   de8b8:	000e28d7 	.word	0x000e28d7
   de8bc:	000e28d0 	.word	0x000e28d0

000de8c0 <_ZN9TCPClient4DataC1Ei>:

IPAddress TCPClient::remoteIP() {
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
   de8c0:	b510      	push	{r4, lr}
        : sock(sock),
          offset(0),
          total(0) {
   de8c2:	2300      	movs	r3, #0

IPAddress TCPClient::remoteIP() {
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
   de8c4:	4604      	mov	r4, r0
        : sock(sock),
          offset(0),
          total(0) {
   de8c6:	6001      	str	r1, [r0, #0]
   de8c8:	f8a0 3084 	strh.w	r3, [r0, #132]	; 0x84
   de8cc:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
   de8d0:	3088      	adds	r0, #136	; 0x88
   de8d2:	f7ff fa27 	bl	ddd24 <_ZN9IPAddressC1Ev>
}
   de8d6:	4620      	mov	r0, r4
   de8d8:	bd10      	pop	{r4, pc}
	...

000de8dc <_ZN9TCPClientC1Ei>:
   de8dc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8

TCPClient::TCPClient()
        : TCPClient(-1) {
}

TCPClient::TCPClient(sock_handle_t sock)
   de8e0:	b570      	push	{r4, r5, r6, lr}
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
   de8e2:	2300      	movs	r3, #0
   de8e4:	6082      	str	r2, [r0, #8]
        : d_(std::make_shared<Data>(sock)) {
   de8e6:	4a14      	ldr	r2, [pc, #80]	; (de938 <_ZN9TCPClientC1Ei+0x5c>)
   de8e8:	6043      	str	r3, [r0, #4]
   de8ea:	6002      	str	r2, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
   de8ec:	6143      	str	r3, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
   de8ee:	6183      	str	r3, [r0, #24]

TCPClient::TCPClient()
        : TCPClient(-1) {
}

TCPClient::TCPClient(sock_handle_t sock)
   de8f0:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   de8f2:	20a0      	movs	r0, #160	; 0xa0
   de8f4:	460e      	mov	r6, r1
   de8f6:	f7f5 fbd0 	bl	d409a <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   de8fa:	4605      	mov	r5, r0
   de8fc:	b110      	cbz	r0, de904 <_ZN9TCPClientC1Ei+0x28>
   de8fe:	4631      	mov	r1, r6
   de900:	f7ff ffde 	bl	de8c0 <_ZN9TCPClient4DataC1Ei>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   de904:	2014      	movs	r0, #20
   de906:	f7f5 fbc8 	bl	d409a <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
   de90a:	4603      	mov	r3, r0
   de90c:	b128      	cbz	r0, de91a <_ZN9TCPClientC1Ei+0x3e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
   de90e:	2201      	movs	r2, #1
   de910:	6042      	str	r2, [r0, #4]
   de912:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
   de914:	4a09      	ldr	r2, [pc, #36]	; (de93c <_ZN9TCPClientC1Ei+0x60>)
   de916:	6002      	str	r2, [r0, #0]
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
   de918:	6105      	str	r5, [r0, #16]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
   de91a:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
   de91c:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
   de91e:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   de920:	b128      	cbz	r0, de92e <_ZN9TCPClientC1Ei+0x52>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
   de922:	6843      	ldr	r3, [r0, #4]
   de924:	3b01      	subs	r3, #1
   de926:	6043      	str	r3, [r0, #4]
   de928:	b90b      	cbnz	r3, de92e <_ZN9TCPClientC1Ei+0x52>
   de92a:	f7ff fddf 	bl	de4ec <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.4.constprop.31>
        : d_(std::make_shared<Data>(sock)) {
    flush_buffer();
   de92e:	4620      	mov	r0, r4
   de930:	f7ff fed0 	bl	de6d4 <_ZN9TCPClient12flush_bufferEv>
}
   de934:	4620      	mov	r0, r4
   de936:	bd70      	pop	{r4, r5, r6, pc}
   de938:	000e288c 	.word	0x000e288c
   de93c:	000e2870 	.word	0x000e2870

000de940 <_ZN9TCPClientC1Ev>:

static bool inline isOpen(sock_handle_t sd) {
    return socket_handle_valid(sd);
}

TCPClient::TCPClient()
   de940:	b510      	push	{r4, lr}
        : TCPClient(-1) {
   de942:	f04f 31ff 	mov.w	r1, #4294967295

static bool inline isOpen(sock_handle_t sd) {
    return socket_handle_valid(sd);
}

TCPClient::TCPClient()
   de946:	4604      	mov	r4, r0
        : TCPClient(-1) {
   de948:	f7ff ffc8 	bl	de8dc <_ZN9TCPClientC1Ei>
}
   de94c:	4620      	mov	r0, r4
   de94e:	bd10      	pop	{r4, pc}

000de950 <_ZN9TCPClient4DataD1Ev>:
        : sock(sock),
          offset(0),
          total(0) {
}

TCPClient::Data::~Data() {
   de950:	b510      	push	{r4, lr}
   de952:	4604      	mov	r4, r0
    if (socket_handle_valid(sock)) {
   de954:	6800      	ldr	r0, [r0, #0]
   de956:	2800      	cmp	r0, #0
   de958:	db01      	blt.n	de95e <_ZN9TCPClient4DataD1Ev+0xe>
        sock_close(sock);
   de95a:	f7fd f8b7 	bl	dbacc <sock_close>
    }
}
   de95e:	4620      	mov	r0, r4
   de960:	bd10      	pop	{r4, pc}

000de962 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
   de962:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
   de964:	6904      	ldr	r4, [r0, #16]
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
   de966:	4620      	mov	r0, r4
   de968:	f7ff fff2 	bl	de950 <_ZN9TCPClient4DataD1Ev>
      { __gd._M_ptr = nullptr; }

      /// Deallocate the owned pointer
      ~__allocated_ptr()
      {
	if (_M_ptr != nullptr)
   de96c:	b124      	cbz	r4, de978 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x16>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
   de96e:	4620      	mov	r0, r4
   de970:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   de974:	f7f5 bb93 	b.w	d409e <_ZdlPv>
   de978:	bd10      	pop	{r4, pc}

000de97a <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
   de97a:	2300      	movs	r3, #0
   de97c:	461a      	mov	r2, r3
   de97e:	6840      	ldr	r0, [r0, #4]
   de980:	f7fd b972 	b.w	dbc68 <network_connect>

000de984 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
   de984:	2200      	movs	r2, #0
   de986:	2102      	movs	r1, #2
   de988:	6840      	ldr	r0, [r0, #4]
   de98a:	f7fd b97d 	b.w	dbc88 <network_disconnect>

000de98e <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
   de98e:	2200      	movs	r2, #0
   de990:	4611      	mov	r1, r2
   de992:	6840      	ldr	r0, [r0, #4]
   de994:	f7fd b970 	b.w	dbc78 <network_connecting>

000de998 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
   de998:	2200      	movs	r2, #0
   de99a:	4611      	mov	r1, r2
   de99c:	6840      	ldr	r0, [r0, #4]
   de99e:	f7fd b97b 	b.w	dbc98 <network_ready>

000de9a2 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
   de9a2:	2300      	movs	r3, #0
   de9a4:	461a      	mov	r2, r3
   de9a6:	4619      	mov	r1, r3
   de9a8:	6840      	ldr	r0, [r0, #4]
   de9aa:	f7fd b97d 	b.w	dbca8 <network_on>

000de9ae <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
   de9ae:	2300      	movs	r3, #0
   de9b0:	461a      	mov	r2, r3
   de9b2:	4619      	mov	r1, r3
   de9b4:	6840      	ldr	r0, [r0, #4]
   de9b6:	f7fd b97f 	b.w	dbcb8 <network_off>

000de9ba <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
   de9ba:	2200      	movs	r2, #0
   de9bc:	f081 0101 	eor.w	r1, r1, #1
   de9c0:	6840      	ldr	r0, [r0, #4]
   de9c2:	f7fd b981 	b.w	dbcc8 <network_listen>

000de9c6 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
   de9c6:	2200      	movs	r2, #0
   de9c8:	6840      	ldr	r0, [r0, #4]
   de9ca:	f7fd b98d 	b.w	dbce8 <network_set_listen_timeout>

000de9ce <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
   de9ce:	2200      	movs	r2, #0
   de9d0:	4611      	mov	r1, r2
   de9d2:	6840      	ldr	r0, [r0, #4]
   de9d4:	f7fd b990 	b.w	dbcf8 <network_get_listen_timeout>

000de9d8 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
   de9d8:	2200      	movs	r2, #0
   de9da:	4611      	mov	r1, r2
   de9dc:	6840      	ldr	r0, [r0, #4]
   de9de:	f7fd b97b 	b.w	dbcd8 <network_listening>

000de9e2 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
   de9e2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    IPAddress addr;
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   de9e6:	2400      	movs	r4, #0

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
}

IPAddress NetworkClass::resolve(const char* name) {
   de9e8:	b095      	sub	sp, #84	; 0x54
   de9ea:	4616      	mov	r6, r2
   de9ec:	460d      	mov	r5, r1
   de9ee:	4607      	mov	r7, r0
    IPAddress addr;
   de9f0:	f7ff f998 	bl	ddd24 <_ZN9IPAddressC1Ev>
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
    struct addrinfo hints = {};
   de9f4:	4621      	mov	r1, r4
   de9f6:	2220      	movs	r2, #32
   de9f8:	a80c      	add	r0, sp, #48	; 0x30
}

IPAddress NetworkClass::resolve(const char* name) {
    IPAddress addr;
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   de9fa:	9400      	str	r4, [sp, #0]
    struct addrinfo hints = {};
   de9fc:	f001 fab4 	bl	dff68 <memset>
    hints.ai_flags = AI_ADDRCONFIG;
   dea00:	2340      	movs	r3, #64	; 0x40
   dea02:	930c      	str	r3, [sp, #48]	; 0x30
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
   dea04:	4621      	mov	r1, r4
   dea06:	466b      	mov	r3, sp
   dea08:	aa0c      	add	r2, sp, #48	; 0x30
   dea0a:	4630      	mov	r0, r6
   dea0c:	f7fc fe4a 	bl	db6a4 <netdb_getaddrinfo>
    if (!r) {
   dea10:	4604      	mov	r4, r0
   dea12:	2800      	cmp	r0, #0
   dea14:	d144      	bne.n	deaa0 <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   dea16:	4602      	mov	r2, r0
   dea18:	2101      	movs	r1, #1
   dea1a:	6868      	ldr	r0, [r5, #4]
   dea1c:	f7fd f93c 	bl	dbc98 <network_ready>
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   dea20:	2102      	movs	r1, #2
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   dea22:	4680      	mov	r8, r0
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   dea24:	4622      	mov	r2, r4
   dea26:	6868      	ldr	r0, [r5, #4]
   dea28:	f7fd f936 	bl	dbc98 <network_ready>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   dea2c:	9e00      	ldr	r6, [sp, #0]
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   dea2e:	4681      	mov	r9, r0
    struct addrinfo hints = {};
    hints.ai_flags = AI_ADDRCONFIG;
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
    if (!r) {
        bool ok = false;
   dea30:	4621      	mov	r1, r4
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   dea32:	2e00      	cmp	r6, #0
   dea34:	d034      	beq.n	deaa0 <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
   dea36:	2900      	cmp	r1, #0
   dea38:	d132      	bne.n	deaa0 <_ZN5spark12NetworkClass7resolveEPKc+0xbe>
            // NOTE: using only the first entry that matches the current state of IPv4/IPv6 connectivity
            switch (cur->ai_family) {
   dea3a:	6873      	ldr	r3, [r6, #4]
   dea3c:	2b02      	cmp	r3, #2
   dea3e:	d002      	beq.n	dea46 <_ZN5spark12NetworkClass7resolveEPKc+0x64>
   dea40:	2b0a      	cmp	r3, #10
   dea42:	d009      	beq.n	dea58 <_ZN5spark12NetworkClass7resolveEPKc+0x76>
   dea44:	e02a      	b.n	dea9c <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                case AF_INET: {
                    if (!ipv4) {
   dea46:	f1b8 0f00 	cmp.w	r8, #0
   dea4a:	d027      	beq.n	dea9c <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                        continue;
                    }
                    // NOTE: HAL_IPAddress is little-endian
                    auto in = (struct sockaddr_in*)cur->ai_addr;
                    addr = (const uint8_t*)(&in->sin_addr.s_addr);
   dea4c:	6971      	ldr	r1, [r6, #20]
   dea4e:	4638      	mov	r0, r7
   dea50:	3104      	adds	r1, #4
   dea52:	f7ff f9b7 	bl	dddc4 <_ZN9IPAddressaSEPKh>
   dea56:	e020      	b.n	dea9a <_ZN5spark12NetworkClass7resolveEPKc+0xb8>
                    ok = true;
                    break;
                }
                case AF_INET6: {
                    if (!ipv6) {
   dea58:	f1b9 0f00 	cmp.w	r9, #0
   dea5c:	d01e      	beq.n	dea9c <_ZN5spark12NetworkClass7resolveEPKc+0xba>
                        continue;
                    }
                    auto in6 = (struct sockaddr_in6*)cur->ai_addr;
   dea5e:	6974      	ldr	r4, [r6, #20]
                    HAL_IPAddress a = {};
   dea60:	2211      	movs	r2, #17
   dea62:	a801      	add	r0, sp, #4
   dea64:	f001 fa80 	bl	dff68 <memset>
                    a.v = 6;
   dea68:	2306      	movs	r3, #6
   dea6a:	f88d 3014 	strb.w	r3, [sp, #20]
                    memcpy(a.ipv6, in6->sin6_addr.s6_addr, sizeof(a.ipv6));
   dea6e:	ad01      	add	r5, sp, #4
   dea70:	f104 0308 	add.w	r3, r4, #8
   dea74:	3418      	adds	r4, #24
   dea76:	6818      	ldr	r0, [r3, #0]
   dea78:	6859      	ldr	r1, [r3, #4]
   dea7a:	462a      	mov	r2, r5
   dea7c:	c203      	stmia	r2!, {r0, r1}
   dea7e:	3308      	adds	r3, #8
   dea80:	42a3      	cmp	r3, r4
   dea82:	4615      	mov	r5, r2
   dea84:	d1f7      	bne.n	dea76 <_ZN5spark12NetworkClass7resolveEPKc+0x94>
                    addr = IPAddress(a);
   dea86:	a901      	add	r1, sp, #4
   dea88:	a806      	add	r0, sp, #24

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
   dea8a:	ad07      	add	r5, sp, #28
   dea8c:	f7ff f958 	bl	ddd40 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   dea90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   dea92:	1d3c      	adds	r4, r7, #4
   dea94:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   dea96:	682b      	ldr	r3, [r5, #0]
   dea98:	7023      	strb	r3, [r4, #0]
                    ok = true;
   dea9a:	2101      	movs	r1, #1
    if (!r) {
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   dea9c:	69f6      	ldr	r6, [r6, #28]
   dea9e:	e7c8      	b.n	dea32 <_ZN5spark12NetworkClass7resolveEPKc+0x50>
                    break;
                }
            }
        }
    }
    freeaddrinfo(ai);
   deaa0:	9800      	ldr	r0, [sp, #0]
   deaa2:	f7fc fdf7 	bl	db694 <netdb_freeaddrinfo>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
   deaa6:	4638      	mov	r0, r7
   deaa8:	b015      	add	sp, #84	; 0x54
   deaaa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

000deab0 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
   deab0:	4b02      	ldr	r3, [pc, #8]	; (deabc <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
   deab2:	4a03      	ldr	r2, [pc, #12]	; (deac0 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
   deab4:	601a      	str	r2, [r3, #0]
   deab6:	2200      	movs	r2, #0
   deab8:	605a      	str	r2, [r3, #4]
   deaba:	4770      	bx	lr
   deabc:	2003e6e4 	.word	0x2003e6e4
   deac0:	000e28f0 	.word	0x000e28f0

000deac4 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
   deac4:	b570      	push	{r4, r5, r6, lr}

template <HAL_SPI_Interface Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   deac6:	4e18      	ldr	r6, [pc, #96]	; (deb28 <pinAvailable+0x64>)
   deac8:	6831      	ldr	r1, [r6, #0]
   deaca:	f011 0501 	ands.w	r5, r1, #1
   deace:	4604      	mov	r4, r0
   dead0:	d10a      	bne.n	deae8 <pinAvailable+0x24>
   dead2:	4630      	mov	r0, r6
   dead4:	f7f5 faf2 	bl	d40bc <__cxa_guard_acquire>
   dead8:	b130      	cbz	r0, deae8 <pinAvailable+0x24>
   deada:	4629      	mov	r1, r5
   deadc:	4813      	ldr	r0, [pc, #76]	; (deb2c <pinAvailable+0x68>)
   deade:	f7fd fa99 	bl	dc014 <_ZN8SPIClassC1E17HAL_SPI_Interface>
   deae2:	4630      	mov	r0, r6
   deae4:	f7f5 faef 	bl	d40c6 <__cxa_guard_release>
    }
    void detachInterrupt() {
        instance().detachInterrupt();
    }
    bool isEnabled(void) {
        return instance().isEnabled();
   deae8:	4810      	ldr	r0, [pc, #64]	; (deb2c <pinAvailable+0x68>)
   deaea:	f7fd fb51 	bl	dc190 <_ZN8SPIClass9isEnabledEv>

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
   deaee:	b128      	cbz	r0, deafc <pinAvailable+0x38>
   deaf0:	f1a4 030b 	sub.w	r3, r4, #11
   deaf4:	2b02      	cmp	r3, #2
   deaf6:	d801      	bhi.n	deafc <pinAvailable+0x38>
  {
    return 0; // 'pin' is used
   deaf8:	2000      	movs	r0, #0
   deafa:	bd70      	pop	{r4, r5, r6, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
   deafc:	f000 f8ce 	bl	dec9c <_Z19__fetch_global_Wirev>
   deb00:	f7ff fba1 	bl	de246 <_ZN7TwoWire9isEnabledEv>
   deb04:	b108      	cbz	r0, deb0a <pinAvailable+0x46>
   deb06:	2c01      	cmp	r4, #1
   deb08:	d9f6      	bls.n	deaf8 <pinAvailable+0x34>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
   deb0a:	f7ff fac1 	bl	de090 <_Z22__fetch_global_Serial1v>
   deb0e:	f7ff fabb 	bl	de088 <_ZN11USARTSerial9isEnabledEv>
   deb12:	b118      	cbz	r0, deb1c <pinAvailable+0x58>
   deb14:	f1a4 0309 	sub.w	r3, r4, #9
   deb18:	2b01      	cmp	r3, #1
   deb1a:	d9ed      	bls.n	deaf8 <pinAvailable+0x34>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
   deb1c:	2c23      	cmp	r4, #35	; 0x23
   deb1e:	bf8c      	ite	hi
   deb20:	2000      	movhi	r0, #0
   deb22:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
   deb24:	bd70      	pop	{r4, r5, r6, pc}
   deb26:	bf00      	nop
   deb28:	2003e3b4 	.word	0x2003e3b4
   deb2c:	2003e3b8 	.word	0x2003e3b8

000deb30 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   deb30:	2823      	cmp	r0, #35	; 0x23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
   deb32:	b538      	push	{r3, r4, r5, lr}
   deb34:	4604      	mov	r4, r0
   deb36:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   deb38:	d80a      	bhi.n	deb50 <pinMode+0x20>
   deb3a:	29ff      	cmp	r1, #255	; 0xff
   deb3c:	d008      	beq.n	deb50 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
   deb3e:	f7ff ffc1 	bl	deac4 <pinAvailable>
   deb42:	b128      	cbz	r0, deb50 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
   deb44:	4629      	mov	r1, r5
   deb46:	4620      	mov	r0, r4
}
   deb48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
   deb4c:	f7fc bdba 	b.w	db6c4 <HAL_Pin_Mode>
   deb50:	bd38      	pop	{r3, r4, r5, pc}

000deb52 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
   deb52:	b538      	push	{r3, r4, r5, lr}
   deb54:	4604      	mov	r4, r0
   deb56:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
   deb58:	f7fc fdbc 	bl	db6d4 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
   deb5c:	28ff      	cmp	r0, #255	; 0xff
   deb5e:	d010      	beq.n	deb82 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
   deb60:	2806      	cmp	r0, #6
   deb62:	d804      	bhi.n	deb6e <digitalWrite+0x1c>
   deb64:	234d      	movs	r3, #77	; 0x4d
   deb66:	fa23 f000 	lsr.w	r0, r3, r0
   deb6a:	07c3      	lsls	r3, r0, #31
   deb6c:	d409      	bmi.n	deb82 <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
   deb6e:	4620      	mov	r0, r4
   deb70:	f7ff ffa8 	bl	deac4 <pinAvailable>
   deb74:	b128      	cbz	r0, deb82 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
   deb76:	4629      	mov	r1, r5
   deb78:	4620      	mov	r0, r4
}
   deb7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
   deb7e:	f7fc bdb1 	b.w	db6e4 <HAL_GPIO_Write>
   deb82:	bd38      	pop	{r3, r4, r5, pc}

000deb84 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
   deb84:	b510      	push	{r4, lr}
   deb86:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
   deb88:	f7fc fda4 	bl	db6d4 <HAL_Get_Pin_Mode>
    if (is_af_output_mode(mode))
   deb8c:	3804      	subs	r0, #4
   deb8e:	b2c0      	uxtb	r0, r0
   deb90:	2801      	cmp	r0, #1
   deb92:	d908      	bls.n	deba6 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
   deb94:	4620      	mov	r0, r4
   deb96:	f7ff ff95 	bl	deac4 <pinAvailable>
   deb9a:	b120      	cbz	r0, deba6 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
   deb9c:	4620      	mov	r0, r4
}
   deb9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
   deba2:	f7fc bda7 	b.w	db6f4 <HAL_GPIO_Read>
}
   deba6:	2000      	movs	r0, #0
   deba8:	bd10      	pop	{r4, pc}
	...

000debac <_ZN19ApplicationWatchdog4loopEv>:
	wd.loop();
	os_thread_cleanup(nullptr);
}

void ApplicationWatchdog::loop()
{
   debac:	b530      	push	{r4, r5, lr}
	bool done = false;
	system_tick_t now;
	while (!done) {
		HAL_Delay_Milliseconds(timeout);
		now = current_time();
		done = (now-last_checkin)>=timeout;
   debae:	4d1c      	ldr	r5, [pc, #112]	; (dec20 <_ZN19ApplicationWatchdog4loopEv+0x74>)
	wd.loop();
	os_thread_cleanup(nullptr);
}

void ApplicationWatchdog::loop()
{
   debb0:	b089      	sub	sp, #36	; 0x24
   debb2:	4604      	mov	r4, r0
	bool done = false;
	system_tick_t now;
	while (!done) {
		HAL_Delay_Milliseconds(timeout);
   debb4:	6820      	ldr	r0, [r4, #0]
   debb6:	f7fc fdfd 	bl	db7b4 <HAL_Delay_Milliseconds>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   debba:	f7fc fe0b 	bl	db7d4 <HAL_Timer_Get_Milli_Seconds>
		now = current_time();
		done = (now-last_checkin)>=timeout;
   debbe:	682b      	ldr	r3, [r5, #0]
   debc0:	6822      	ldr	r2, [r4, #0]

void ApplicationWatchdog::loop()
{
	bool done = false;
	system_tick_t now;
	while (!done) {
   debc2:	1ac0      	subs	r0, r0, r3
   debc4:	4290      	cmp	r0, r2
   debc6:	d3f5      	bcc.n	debb4 <_ZN19ApplicationWatchdog4loopEv+0x8>
		HAL_Delay_Milliseconds(timeout);
		now = current_time();
		done = (now-last_checkin)>=timeout;
	}

	if (timeout>0 && timeout_fn) {
   debc8:	6823      	ldr	r3, [r4, #0]
   debca:	b333      	cbz	r3, dec1a <_ZN19ApplicationWatchdog4loopEv+0x6e>
   debcc:	68e3      	ldr	r3, [r4, #12]
   debce:	b323      	cbz	r3, dec1a <_ZN19ApplicationWatchdog4loopEv+0x6e>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   debd0:	1d25      	adds	r5, r4, #4
   debd2:	6923      	ldr	r3, [r4, #16]
   debd4:	4628      	mov	r0, r5
   debd6:	4798      	blx	r3
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   debd8:	2300      	movs	r3, #0
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
   debda:	a904      	add	r1, sp, #16
   debdc:	4668      	mov	r0, sp
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
   debde:	9302      	str	r3, [sp, #8]
   debe0:	9306      	str	r3, [sp, #24]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
   debe2:	f7fe fb12 	bl	dd20a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   debe6:	9b02      	ldr	r3, [sp, #8]
      __a = _GLIBCXX_MOVE(__b);
   debe8:	9a06      	ldr	r2, [sp, #24]
   debea:	9202      	str	r2, [sp, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   debec:	9306      	str	r3, [sp, #24]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   debee:	9a07      	ldr	r2, [sp, #28]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   debf0:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
   debf2:	9307      	str	r3, [sp, #28]
   debf4:	4629      	mov	r1, r5
   debf6:	a804      	add	r0, sp, #16
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   debf8:	9203      	str	r2, [sp, #12]
   debfa:	f7fe fb06 	bl	dd20a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   debfe:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
   dec00:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   dec02:	60e3      	str	r3, [r4, #12]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
   dec04:	9b07      	ldr	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
   dec06:	9206      	str	r2, [sp, #24]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
   dec08:	a804      	add	r0, sp, #16
   dec0a:	6922      	ldr	r2, [r4, #16]
      __b = _GLIBCXX_MOVE(__tmp);
   dec0c:	6123      	str	r3, [r4, #16]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
   dec0e:	9207      	str	r2, [sp, #28]
   dec10:	f7f6 f859 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
   dec14:	4668      	mov	r0, sp
   dec16:	f7f6 f856 	bl	d4cc6 <_ZNSt14_Function_baseD1Ev>
		timeout_fn();
		timeout_fn = std::function<void(void)>();
	}
}
   dec1a:	b009      	add	sp, #36	; 0x24
   dec1c:	bd30      	pop	{r4, r5, pc}
   dec1e:	bf00      	nop
   dec20:	2003e6ec 	.word	0x2003e6ec

000dec24 <_ZN19ApplicationWatchdog5startEPv>:
#if PLATFORM_THREADING

volatile system_tick_t ApplicationWatchdog::last_checkin;

os_thread_return_t ApplicationWatchdog::start(void* pointer)
{
   dec24:	b508      	push	{r3, lr}
	ApplicationWatchdog& wd = *(ApplicationWatchdog*)pointer;
	wd.loop();
   dec26:	f7ff ffc1 	bl	debac <_ZN19ApplicationWatchdog4loopEv>
	os_thread_cleanup(nullptr);
   dec2a:	2000      	movs	r0, #0
}
   dec2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

os_thread_return_t ApplicationWatchdog::start(void* pointer)
{
	ApplicationWatchdog& wd = *(ApplicationWatchdog*)pointer;
	wd.loop();
	os_thread_cleanup(nullptr);
   dec30:	f7fc be4c 	b.w	db8cc <os_thread_cleanup>

000dec34 <_Z17acquireWireBufferv>:
   dec34:	b570      	push	{r4, r5, r6, lr}
   dec36:	4604      	mov	r4, r0
   dec38:	2514      	movs	r5, #20
   dec3a:	462a      	mov	r2, r5
   dec3c:	4e09      	ldr	r6, [pc, #36]	; (dec64 <_Z17acquireWireBufferv+0x30>)
   dec3e:	2100      	movs	r1, #0
   dec40:	f001 f992 	bl	dff68 <memset>
   dec44:	8025      	strh	r5, [r4, #0]
   dec46:	2520      	movs	r5, #32
   dec48:	4631      	mov	r1, r6
   dec4a:	60a5      	str	r5, [r4, #8]
   dec4c:	6125      	str	r5, [r4, #16]
   dec4e:	4628      	mov	r0, r5
   dec50:	f000 f880 	bl	ded54 <_ZnajRKSt9nothrow_t>
   dec54:	4631      	mov	r1, r6
   dec56:	6060      	str	r0, [r4, #4]
   dec58:	4628      	mov	r0, r5
   dec5a:	f000 f87b 	bl	ded54 <_ZnajRKSt9nothrow_t>
   dec5e:	60e0      	str	r0, [r4, #12]
   dec60:	4620      	mov	r0, r4
   dec62:	bd70      	pop	{r4, r5, r6, pc}
   dec64:	000e291c 	.word	0x000e291c

000dec68 <_Z18acquireWire1Bufferv>:
	return defaultWireConfig();
}

#if Wiring_Wire1
HAL_I2C_Config __attribute__((weak)) acquireWire1Buffer()
{
   dec68:	b570      	push	{r4, r5, r6, lr}
   dec6a:	4604      	mov	r4, r0
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
   dec6c:	2514      	movs	r5, #20
   dec6e:	462a      	mov	r2, r5

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   dec70:	4e09      	ldr	r6, [pc, #36]	; (dec98 <_Z18acquireWire1Bufferv+0x30>)
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
   dec72:	2100      	movs	r1, #0
   dec74:	f001 f978 	bl	dff68 <memset>
   dec78:	8025      	strh	r5, [r4, #0]
   dec7a:	2520      	movs	r5, #32

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   dec7c:	4631      	mov	r1, r6
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
   dec7e:	60a5      	str	r5, [r4, #8]
   dec80:	6125      	str	r5, [r4, #16]

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   dec82:	4628      	mov	r0, r5
   dec84:	f000 f866 	bl	ded54 <_ZnajRKSt9nothrow_t>
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   dec88:	4631      	mov	r1, r6
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
   dec8a:	6060      	str	r0, [r4, #4]
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   dec8c:	4628      	mov	r0, r5
   dec8e:	f000 f861 	bl	ded54 <_ZnajRKSt9nothrow_t>
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
   dec92:	60e0      	str	r0, [r4, #12]

#if Wiring_Wire1
HAL_I2C_Config __attribute__((weak)) acquireWire1Buffer()
{
	return defaultWireConfig();
}
   dec94:	4620      	mov	r0, r4
   dec96:	bd70      	pop	{r4, r5, r6, pc}
   dec98:	000e291c 	.word	0x000e291c

000dec9c <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
   dec9c:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   dec9e:	4d0e      	ldr	r5, [pc, #56]	; (decd8 <_Z19__fetch_global_Wirev+0x3c>)
   deca0:	6829      	ldr	r1, [r5, #0]
   deca2:	f011 0401 	ands.w	r4, r1, #1
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
   deca6:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   deca8:	d113      	bne.n	decd2 <_Z19__fetch_global_Wirev+0x36>
   decaa:	4628      	mov	r0, r5
   decac:	f7f5 fa06 	bl	d40bc <__cxa_guard_acquire>
   decb0:	b178      	cbz	r0, decd2 <_Z19__fetch_global_Wirev+0x36>
   decb2:	a801      	add	r0, sp, #4
   decb4:	f7ff ffbe 	bl	dec34 <_Z17acquireWireBufferv>
   decb8:	aa01      	add	r2, sp, #4
   decba:	4621      	mov	r1, r4
   decbc:	4807      	ldr	r0, [pc, #28]	; (decdc <_Z19__fetch_global_Wirev+0x40>)
   decbe:	f7ff fa67 	bl	de190 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
   decc2:	4628      	mov	r0, r5
   decc4:	f7f5 f9ff 	bl	d40c6 <__cxa_guard_release>
   decc8:	4a05      	ldr	r2, [pc, #20]	; (dece0 <_Z19__fetch_global_Wirev+0x44>)
   decca:	4906      	ldr	r1, [pc, #24]	; (dece4 <_Z19__fetch_global_Wirev+0x48>)
   deccc:	4803      	ldr	r0, [pc, #12]	; (decdc <_Z19__fetch_global_Wirev+0x40>)
   decce:	f000 f831 	bl	ded34 <__aeabi_atexit>
	return wire;
}
   decd2:	4802      	ldr	r0, [pc, #8]	; (decdc <_Z19__fetch_global_Wirev+0x40>)
   decd4:	b007      	add	sp, #28
   decd6:	bd30      	pop	{r4, r5, pc}
   decd8:	2003e6f4 	.word	0x2003e6f4
   decdc:	2003e70c 	.word	0x2003e70c
   dece0:	2003daf8 	.word	0x2003daf8
   dece4:	000de139 	.word	0x000de139

000dece8 <_Z20__fetch_global_Wire1v>:

#if Wiring_Wire1
TwoWire& __fetch_global_Wire1()
{
   dece8:	b510      	push	{r4, lr}
	static TwoWire wire(HAL_I2C_INTERFACE2, acquireWire1Buffer());
   decea:	4c0e      	ldr	r4, [pc, #56]	; (ded24 <_Z20__fetch_global_Wire1v+0x3c>)
   decec:	6823      	ldr	r3, [r4, #0]
   decee:	07db      	lsls	r3, r3, #31
	return wire;
}

#if Wiring_Wire1
TwoWire& __fetch_global_Wire1()
{
   decf0:	b086      	sub	sp, #24
	static TwoWire wire(HAL_I2C_INTERFACE2, acquireWire1Buffer());
   decf2:	d413      	bmi.n	ded1c <_Z20__fetch_global_Wire1v+0x34>
   decf4:	4620      	mov	r0, r4
   decf6:	f7f5 f9e1 	bl	d40bc <__cxa_guard_acquire>
   decfa:	b178      	cbz	r0, ded1c <_Z20__fetch_global_Wire1v+0x34>
   decfc:	a801      	add	r0, sp, #4
   decfe:	f7ff ffb3 	bl	dec68 <_Z18acquireWire1Bufferv>
   ded02:	aa01      	add	r2, sp, #4
   ded04:	2101      	movs	r1, #1
   ded06:	4808      	ldr	r0, [pc, #32]	; (ded28 <_Z20__fetch_global_Wire1v+0x40>)
   ded08:	f7ff fa42 	bl	de190 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
   ded0c:	4620      	mov	r0, r4
   ded0e:	f7f5 f9da 	bl	d40c6 <__cxa_guard_release>
   ded12:	4a06      	ldr	r2, [pc, #24]	; (ded2c <_Z20__fetch_global_Wire1v+0x44>)
   ded14:	4906      	ldr	r1, [pc, #24]	; (ded30 <_Z20__fetch_global_Wire1v+0x48>)
   ded16:	4804      	ldr	r0, [pc, #16]	; (ded28 <_Z20__fetch_global_Wire1v+0x40>)
   ded18:	f000 f80c 	bl	ded34 <__aeabi_atexit>
	return wire;
}
   ded1c:	4802      	ldr	r0, [pc, #8]	; (ded28 <_Z20__fetch_global_Wire1v+0x40>)
   ded1e:	b006      	add	sp, #24
   ded20:	bd10      	pop	{r4, pc}
   ded22:	bf00      	nop
   ded24:	2003e720 	.word	0x2003e720
   ded28:	2003e6f8 	.word	0x2003e6f8
   ded2c:	2003daf8 	.word	0x2003daf8
   ded30:	000de139 	.word	0x000de139

000ded34 <__aeabi_atexit>:
   ded34:	460b      	mov	r3, r1
   ded36:	4601      	mov	r1, r0
   ded38:	4618      	mov	r0, r3
   ded3a:	f000 bfe1 	b.w	dfd00 <__cxa_atexit>
	...

000ded40 <_ZSt15get_new_handlerv>:
   ded40:	4b02      	ldr	r3, [pc, #8]	; (ded4c <_ZSt15get_new_handlerv+0xc>)
   ded42:	6818      	ldr	r0, [r3, #0]
   ded44:	f3bf 8f5f 	dmb	sy
   ded48:	4770      	bx	lr
   ded4a:	bf00      	nop
   ded4c:	2003e724 	.word	0x2003e724

000ded50 <_ZdlPvj>:
   ded50:	f7f5 b9a5 	b.w	d409e <_ZdlPv>

000ded54 <_ZnajRKSt9nothrow_t>:
   ded54:	f000 b800 	b.w	ded58 <_ZnwjRKSt9nothrow_t>

000ded58 <_ZnwjRKSt9nothrow_t>:
   ded58:	b510      	push	{r4, lr}
   ded5a:	2800      	cmp	r0, #0
   ded5c:	bf14      	ite	ne
   ded5e:	4604      	movne	r4, r0
   ded60:	2401      	moveq	r4, #1
   ded62:	4620      	mov	r0, r4
   ded64:	f7fd f828 	bl	dbdb8 <malloc>
   ded68:	b920      	cbnz	r0, ded74 <_ZnwjRKSt9nothrow_t+0x1c>
   ded6a:	f7ff ffe9 	bl	ded40 <_ZSt15get_new_handlerv>
   ded6e:	b108      	cbz	r0, ded74 <_ZnwjRKSt9nothrow_t+0x1c>
   ded70:	4780      	blx	r0
   ded72:	e7f6      	b.n	ded62 <_ZnwjRKSt9nothrow_t+0xa>
   ded74:	bd10      	pop	{r4, pc}

000ded76 <_ZSt25__throw_bad_function_callv>:
   ded76:	b508      	push	{r3, lr}
   ded78:	f7fd f84e 	bl	dbe18 <abort>

000ded7c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
   ded7c:	4b18      	ldr	r3, [pc, #96]	; (dede0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
   ded7e:	681a      	ldr	r2, [r3, #0]
   ded80:	07d1      	lsls	r1, r2, #31
   ded82:	bf5c      	itt	pl
   ded84:	2201      	movpl	r2, #1
   ded86:	601a      	strpl	r2, [r3, #0]
   ded88:	4b16      	ldr	r3, [pc, #88]	; (dede4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
   ded8a:	681a      	ldr	r2, [r3, #0]
   ded8c:	07d2      	lsls	r2, r2, #31
   ded8e:	bf5c      	itt	pl
   ded90:	2201      	movpl	r2, #1
   ded92:	601a      	strpl	r2, [r3, #0]
   ded94:	4b14      	ldr	r3, [pc, #80]	; (dede8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
   ded96:	681a      	ldr	r2, [r3, #0]
   ded98:	07d0      	lsls	r0, r2, #31
   ded9a:	bf5c      	itt	pl
   ded9c:	2201      	movpl	r2, #1
   ded9e:	601a      	strpl	r2, [r3, #0]
   deda0:	4b12      	ldr	r3, [pc, #72]	; (dedec <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
   deda2:	681a      	ldr	r2, [r3, #0]
   deda4:	07d1      	lsls	r1, r2, #31
   deda6:	bf5c      	itt	pl
   deda8:	2201      	movpl	r2, #1
   dedaa:	601a      	strpl	r2, [r3, #0]
   dedac:	4b10      	ldr	r3, [pc, #64]	; (dedf0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
   dedae:	681a      	ldr	r2, [r3, #0]
   dedb0:	07d2      	lsls	r2, r2, #31
   dedb2:	bf5c      	itt	pl
   dedb4:	2201      	movpl	r2, #1
   dedb6:	601a      	strpl	r2, [r3, #0]
   dedb8:	4b0e      	ldr	r3, [pc, #56]	; (dedf4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
   dedba:	681a      	ldr	r2, [r3, #0]
   dedbc:	07d0      	lsls	r0, r2, #31
   dedbe:	bf5c      	itt	pl
   dedc0:	2201      	movpl	r2, #1
   dedc2:	601a      	strpl	r2, [r3, #0]
   dedc4:	4b0c      	ldr	r3, [pc, #48]	; (dedf8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
   dedc6:	681a      	ldr	r2, [r3, #0]
   dedc8:	07d1      	lsls	r1, r2, #31
   dedca:	bf5c      	itt	pl
   dedcc:	2201      	movpl	r2, #1
   dedce:	601a      	strpl	r2, [r3, #0]
   dedd0:	4b0a      	ldr	r3, [pc, #40]	; (dedfc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
   dedd2:	681a      	ldr	r2, [r3, #0]
   dedd4:	07d2      	lsls	r2, r2, #31
   dedd6:	bf5c      	itt	pl
   dedd8:	2201      	movpl	r2, #1
   dedda:	601a      	strpl	r2, [r3, #0]
   deddc:	4770      	bx	lr
   dedde:	bf00      	nop
   dede0:	2003e744 	.word	0x2003e744
   dede4:	2003e740 	.word	0x2003e740
   dede8:	2003e73c 	.word	0x2003e73c
   dedec:	2003e738 	.word	0x2003e738
   dedf0:	2003e734 	.word	0x2003e734
   dedf4:	2003e730 	.word	0x2003e730
   dedf8:	2003e72c 	.word	0x2003e72c
   dedfc:	2003e728 	.word	0x2003e728

000dee00 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
   dee00:	4b24      	ldr	r3, [pc, #144]	; (dee94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
   dee02:	681a      	ldr	r2, [r3, #0]
   dee04:	07d0      	lsls	r0, r2, #31
   dee06:	bf5c      	itt	pl
   dee08:	2201      	movpl	r2, #1
   dee0a:	601a      	strpl	r2, [r3, #0]
   dee0c:	4b22      	ldr	r3, [pc, #136]	; (dee98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
   dee0e:	681a      	ldr	r2, [r3, #0]
   dee10:	07d1      	lsls	r1, r2, #31
   dee12:	bf5c      	itt	pl
   dee14:	2201      	movpl	r2, #1
   dee16:	601a      	strpl	r2, [r3, #0]
   dee18:	4b20      	ldr	r3, [pc, #128]	; (dee9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
   dee1a:	681a      	ldr	r2, [r3, #0]
   dee1c:	07d2      	lsls	r2, r2, #31
   dee1e:	bf5c      	itt	pl
   dee20:	2201      	movpl	r2, #1
   dee22:	601a      	strpl	r2, [r3, #0]
   dee24:	4b1e      	ldr	r3, [pc, #120]	; (deea0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
   dee26:	681a      	ldr	r2, [r3, #0]
   dee28:	07d0      	lsls	r0, r2, #31
   dee2a:	bf5c      	itt	pl
   dee2c:	2201      	movpl	r2, #1
   dee2e:	601a      	strpl	r2, [r3, #0]
   dee30:	4b1c      	ldr	r3, [pc, #112]	; (deea4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
   dee32:	681a      	ldr	r2, [r3, #0]
   dee34:	07d1      	lsls	r1, r2, #31
   dee36:	bf5c      	itt	pl
   dee38:	2201      	movpl	r2, #1
   dee3a:	601a      	strpl	r2, [r3, #0]
   dee3c:	4b1a      	ldr	r3, [pc, #104]	; (deea8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
   dee3e:	681a      	ldr	r2, [r3, #0]
   dee40:	07d2      	lsls	r2, r2, #31
   dee42:	bf5c      	itt	pl
   dee44:	2201      	movpl	r2, #1
   dee46:	601a      	strpl	r2, [r3, #0]
   dee48:	4b18      	ldr	r3, [pc, #96]	; (deeac <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
   dee4a:	681a      	ldr	r2, [r3, #0]
   dee4c:	07d0      	lsls	r0, r2, #31
   dee4e:	bf5c      	itt	pl
   dee50:	2201      	movpl	r2, #1
   dee52:	601a      	strpl	r2, [r3, #0]
   dee54:	4b16      	ldr	r3, [pc, #88]	; (deeb0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
   dee56:	681a      	ldr	r2, [r3, #0]
   dee58:	07d1      	lsls	r1, r2, #31
   dee5a:	bf5c      	itt	pl
   dee5c:	2201      	movpl	r2, #1
   dee5e:	601a      	strpl	r2, [r3, #0]
   dee60:	4b14      	ldr	r3, [pc, #80]	; (deeb4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
   dee62:	681a      	ldr	r2, [r3, #0]
   dee64:	07d2      	lsls	r2, r2, #31
   dee66:	bf5c      	itt	pl
   dee68:	2201      	movpl	r2, #1
   dee6a:	601a      	strpl	r2, [r3, #0]
   dee6c:	4b12      	ldr	r3, [pc, #72]	; (deeb8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
   dee6e:	681a      	ldr	r2, [r3, #0]
   dee70:	07d0      	lsls	r0, r2, #31
   dee72:	bf5c      	itt	pl
   dee74:	2201      	movpl	r2, #1
   dee76:	601a      	strpl	r2, [r3, #0]
   dee78:	4b10      	ldr	r3, [pc, #64]	; (deebc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
   dee7a:	681a      	ldr	r2, [r3, #0]
   dee7c:	07d1      	lsls	r1, r2, #31
   dee7e:	bf5c      	itt	pl
   dee80:	2201      	movpl	r2, #1
   dee82:	601a      	strpl	r2, [r3, #0]
   dee84:	4b0e      	ldr	r3, [pc, #56]	; (deec0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
   dee86:	681a      	ldr	r2, [r3, #0]
   dee88:	07d2      	lsls	r2, r2, #31
   dee8a:	bf5c      	itt	pl
   dee8c:	2201      	movpl	r2, #1
   dee8e:	601a      	strpl	r2, [r3, #0]
   dee90:	4770      	bx	lr
   dee92:	bf00      	nop
   dee94:	2003e774 	.word	0x2003e774
   dee98:	2003e770 	.word	0x2003e770
   dee9c:	2003e76c 	.word	0x2003e76c
   deea0:	2003e768 	.word	0x2003e768
   deea4:	2003e764 	.word	0x2003e764
   deea8:	2003e760 	.word	0x2003e760
   deeac:	2003e75c 	.word	0x2003e75c
   deeb0:	2003e758 	.word	0x2003e758
   deeb4:	2003e754 	.word	0x2003e754
   deeb8:	2003e750 	.word	0x2003e750
   deebc:	2003e74c 	.word	0x2003e74c
   deec0:	2003e748 	.word	0x2003e748

000deec4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
   deec4:	4b24      	ldr	r3, [pc, #144]	; (def58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
   deec6:	681a      	ldr	r2, [r3, #0]
   deec8:	07d0      	lsls	r0, r2, #31
   deeca:	bf5c      	itt	pl
   deecc:	2201      	movpl	r2, #1
   deece:	601a      	strpl	r2, [r3, #0]
   deed0:	4b22      	ldr	r3, [pc, #136]	; (def5c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
   deed2:	681a      	ldr	r2, [r3, #0]
   deed4:	07d1      	lsls	r1, r2, #31
   deed6:	bf5c      	itt	pl
   deed8:	2201      	movpl	r2, #1
   deeda:	601a      	strpl	r2, [r3, #0]
   deedc:	4b20      	ldr	r3, [pc, #128]	; (def60 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
   deede:	681a      	ldr	r2, [r3, #0]
   deee0:	07d2      	lsls	r2, r2, #31
   deee2:	bf5c      	itt	pl
   deee4:	2201      	movpl	r2, #1
   deee6:	601a      	strpl	r2, [r3, #0]
   deee8:	4b1e      	ldr	r3, [pc, #120]	; (def64 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
   deeea:	681a      	ldr	r2, [r3, #0]
   deeec:	07d0      	lsls	r0, r2, #31
   deeee:	bf5c      	itt	pl
   deef0:	2201      	movpl	r2, #1
   deef2:	601a      	strpl	r2, [r3, #0]
   deef4:	4b1c      	ldr	r3, [pc, #112]	; (def68 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
   deef6:	681a      	ldr	r2, [r3, #0]
   deef8:	07d1      	lsls	r1, r2, #31
   deefa:	bf5c      	itt	pl
   deefc:	2201      	movpl	r2, #1
   deefe:	601a      	strpl	r2, [r3, #0]
   def00:	4b1a      	ldr	r3, [pc, #104]	; (def6c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
   def02:	681a      	ldr	r2, [r3, #0]
   def04:	07d2      	lsls	r2, r2, #31
   def06:	bf5c      	itt	pl
   def08:	2201      	movpl	r2, #1
   def0a:	601a      	strpl	r2, [r3, #0]
   def0c:	4b18      	ldr	r3, [pc, #96]	; (def70 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
   def0e:	681a      	ldr	r2, [r3, #0]
   def10:	07d0      	lsls	r0, r2, #31
   def12:	bf5c      	itt	pl
   def14:	2201      	movpl	r2, #1
   def16:	601a      	strpl	r2, [r3, #0]
   def18:	4b16      	ldr	r3, [pc, #88]	; (def74 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
   def1a:	681a      	ldr	r2, [r3, #0]
   def1c:	07d1      	lsls	r1, r2, #31
   def1e:	bf5c      	itt	pl
   def20:	2201      	movpl	r2, #1
   def22:	601a      	strpl	r2, [r3, #0]
   def24:	4b14      	ldr	r3, [pc, #80]	; (def78 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
   def26:	681a      	ldr	r2, [r3, #0]
   def28:	07d2      	lsls	r2, r2, #31
   def2a:	bf5c      	itt	pl
   def2c:	2201      	movpl	r2, #1
   def2e:	601a      	strpl	r2, [r3, #0]
   def30:	4b12      	ldr	r3, [pc, #72]	; (def7c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
   def32:	681a      	ldr	r2, [r3, #0]
   def34:	07d0      	lsls	r0, r2, #31
   def36:	bf5c      	itt	pl
   def38:	2201      	movpl	r2, #1
   def3a:	601a      	strpl	r2, [r3, #0]
   def3c:	4b10      	ldr	r3, [pc, #64]	; (def80 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
   def3e:	681a      	ldr	r2, [r3, #0]
   def40:	07d1      	lsls	r1, r2, #31
   def42:	bf5c      	itt	pl
   def44:	2201      	movpl	r2, #1
   def46:	601a      	strpl	r2, [r3, #0]
   def48:	4b0e      	ldr	r3, [pc, #56]	; (def84 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
   def4a:	681a      	ldr	r2, [r3, #0]
   def4c:	07d2      	lsls	r2, r2, #31
   def4e:	bf5c      	itt	pl
   def50:	2201      	movpl	r2, #1
   def52:	601a      	strpl	r2, [r3, #0]
   def54:	4770      	bx	lr
   def56:	bf00      	nop
   def58:	2003e7a4 	.word	0x2003e7a4
   def5c:	2003e7a0 	.word	0x2003e7a0
   def60:	2003e79c 	.word	0x2003e79c
   def64:	2003e798 	.word	0x2003e798
   def68:	2003e794 	.word	0x2003e794
   def6c:	2003e790 	.word	0x2003e790
   def70:	2003e78c 	.word	0x2003e78c
   def74:	2003e788 	.word	0x2003e788
   def78:	2003e784 	.word	0x2003e784
   def7c:	2003e780 	.word	0x2003e780
   def80:	2003e77c 	.word	0x2003e77c
   def84:	2003e778 	.word	0x2003e778

000def88 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
   def88:	4b18      	ldr	r3, [pc, #96]	; (defec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
   def8a:	681a      	ldr	r2, [r3, #0]
   def8c:	07d1      	lsls	r1, r2, #31
   def8e:	bf5c      	itt	pl
   def90:	2201      	movpl	r2, #1
   def92:	601a      	strpl	r2, [r3, #0]
   def94:	4b16      	ldr	r3, [pc, #88]	; (deff0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
   def96:	681a      	ldr	r2, [r3, #0]
   def98:	07d2      	lsls	r2, r2, #31
   def9a:	bf5c      	itt	pl
   def9c:	2201      	movpl	r2, #1
   def9e:	601a      	strpl	r2, [r3, #0]
   defa0:	4b14      	ldr	r3, [pc, #80]	; (deff4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
   defa2:	681a      	ldr	r2, [r3, #0]
   defa4:	07d0      	lsls	r0, r2, #31
   defa6:	bf5c      	itt	pl
   defa8:	2201      	movpl	r2, #1
   defaa:	601a      	strpl	r2, [r3, #0]
   defac:	4b12      	ldr	r3, [pc, #72]	; (deff8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
   defae:	681a      	ldr	r2, [r3, #0]
   defb0:	07d1      	lsls	r1, r2, #31
   defb2:	bf5c      	itt	pl
   defb4:	2201      	movpl	r2, #1
   defb6:	601a      	strpl	r2, [r3, #0]
   defb8:	4b10      	ldr	r3, [pc, #64]	; (deffc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
   defba:	681a      	ldr	r2, [r3, #0]
   defbc:	07d2      	lsls	r2, r2, #31
   defbe:	bf5c      	itt	pl
   defc0:	2201      	movpl	r2, #1
   defc2:	601a      	strpl	r2, [r3, #0]
   defc4:	4b0e      	ldr	r3, [pc, #56]	; (df000 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
   defc6:	681a      	ldr	r2, [r3, #0]
   defc8:	07d0      	lsls	r0, r2, #31
   defca:	bf5c      	itt	pl
   defcc:	2201      	movpl	r2, #1
   defce:	601a      	strpl	r2, [r3, #0]
   defd0:	4b0c      	ldr	r3, [pc, #48]	; (df004 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
   defd2:	681a      	ldr	r2, [r3, #0]
   defd4:	07d1      	lsls	r1, r2, #31
   defd6:	bf5c      	itt	pl
   defd8:	2201      	movpl	r2, #1
   defda:	601a      	strpl	r2, [r3, #0]
   defdc:	4b0a      	ldr	r3, [pc, #40]	; (df008 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
   defde:	681a      	ldr	r2, [r3, #0]
   defe0:	07d2      	lsls	r2, r2, #31
   defe2:	bf5c      	itt	pl
   defe4:	2201      	movpl	r2, #1
   defe6:	601a      	strpl	r2, [r3, #0]
   defe8:	4770      	bx	lr
   defea:	bf00      	nop
   defec:	2003e7c4 	.word	0x2003e7c4
   deff0:	2003e7c0 	.word	0x2003e7c0
   deff4:	2003e7bc 	.word	0x2003e7bc
   deff8:	2003e7b8 	.word	0x2003e7b8
   deffc:	2003e7b4 	.word	0x2003e7b4
   df000:	2003e7b0 	.word	0x2003e7b0
   df004:	2003e7ac 	.word	0x2003e7ac
   df008:	2003e7a8 	.word	0x2003e7a8

000df00c <__aeabi_drsub>:
   df00c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   df010:	e002      	b.n	df018 <__adddf3>
   df012:	bf00      	nop

000df014 <__aeabi_dsub>:
   df014:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000df018 <__adddf3>:
   df018:	b530      	push	{r4, r5, lr}
   df01a:	ea4f 0441 	mov.w	r4, r1, lsl #1
   df01e:	ea4f 0543 	mov.w	r5, r3, lsl #1
   df022:	ea94 0f05 	teq	r4, r5
   df026:	bf08      	it	eq
   df028:	ea90 0f02 	teqeq	r0, r2
   df02c:	bf1f      	itttt	ne
   df02e:	ea54 0c00 	orrsne.w	ip, r4, r0
   df032:	ea55 0c02 	orrsne.w	ip, r5, r2
   df036:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   df03a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   df03e:	f000 80e2 	beq.w	df206 <__adddf3+0x1ee>
   df042:	ea4f 5454 	mov.w	r4, r4, lsr #21
   df046:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   df04a:	bfb8      	it	lt
   df04c:	426d      	neglt	r5, r5
   df04e:	dd0c      	ble.n	df06a <__adddf3+0x52>
   df050:	442c      	add	r4, r5
   df052:	ea80 0202 	eor.w	r2, r0, r2
   df056:	ea81 0303 	eor.w	r3, r1, r3
   df05a:	ea82 0000 	eor.w	r0, r2, r0
   df05e:	ea83 0101 	eor.w	r1, r3, r1
   df062:	ea80 0202 	eor.w	r2, r0, r2
   df066:	ea81 0303 	eor.w	r3, r1, r3
   df06a:	2d36      	cmp	r5, #54	; 0x36
   df06c:	bf88      	it	hi
   df06e:	bd30      	pophi	{r4, r5, pc}
   df070:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   df074:	ea4f 3101 	mov.w	r1, r1, lsl #12
   df078:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   df07c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   df080:	d002      	beq.n	df088 <__adddf3+0x70>
   df082:	4240      	negs	r0, r0
   df084:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   df088:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   df08c:	ea4f 3303 	mov.w	r3, r3, lsl #12
   df090:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   df094:	d002      	beq.n	df09c <__adddf3+0x84>
   df096:	4252      	negs	r2, r2
   df098:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   df09c:	ea94 0f05 	teq	r4, r5
   df0a0:	f000 80a7 	beq.w	df1f2 <__adddf3+0x1da>
   df0a4:	f1a4 0401 	sub.w	r4, r4, #1
   df0a8:	f1d5 0e20 	rsbs	lr, r5, #32
   df0ac:	db0d      	blt.n	df0ca <__adddf3+0xb2>
   df0ae:	fa02 fc0e 	lsl.w	ip, r2, lr
   df0b2:	fa22 f205 	lsr.w	r2, r2, r5
   df0b6:	1880      	adds	r0, r0, r2
   df0b8:	f141 0100 	adc.w	r1, r1, #0
   df0bc:	fa03 f20e 	lsl.w	r2, r3, lr
   df0c0:	1880      	adds	r0, r0, r2
   df0c2:	fa43 f305 	asr.w	r3, r3, r5
   df0c6:	4159      	adcs	r1, r3
   df0c8:	e00e      	b.n	df0e8 <__adddf3+0xd0>
   df0ca:	f1a5 0520 	sub.w	r5, r5, #32
   df0ce:	f10e 0e20 	add.w	lr, lr, #32
   df0d2:	2a01      	cmp	r2, #1
   df0d4:	fa03 fc0e 	lsl.w	ip, r3, lr
   df0d8:	bf28      	it	cs
   df0da:	f04c 0c02 	orrcs.w	ip, ip, #2
   df0de:	fa43 f305 	asr.w	r3, r3, r5
   df0e2:	18c0      	adds	r0, r0, r3
   df0e4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   df0e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   df0ec:	d507      	bpl.n	df0fe <__adddf3+0xe6>
   df0ee:	f04f 0e00 	mov.w	lr, #0
   df0f2:	f1dc 0c00 	rsbs	ip, ip, #0
   df0f6:	eb7e 0000 	sbcs.w	r0, lr, r0
   df0fa:	eb6e 0101 	sbc.w	r1, lr, r1
   df0fe:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   df102:	d31b      	bcc.n	df13c <__adddf3+0x124>
   df104:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   df108:	d30c      	bcc.n	df124 <__adddf3+0x10c>
   df10a:	0849      	lsrs	r1, r1, #1
   df10c:	ea5f 0030 	movs.w	r0, r0, rrx
   df110:	ea4f 0c3c 	mov.w	ip, ip, rrx
   df114:	f104 0401 	add.w	r4, r4, #1
   df118:	ea4f 5244 	mov.w	r2, r4, lsl #21
   df11c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   df120:	f080 809a 	bcs.w	df258 <__adddf3+0x240>
   df124:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   df128:	bf08      	it	eq
   df12a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   df12e:	f150 0000 	adcs.w	r0, r0, #0
   df132:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   df136:	ea41 0105 	orr.w	r1, r1, r5
   df13a:	bd30      	pop	{r4, r5, pc}
   df13c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   df140:	4140      	adcs	r0, r0
   df142:	eb41 0101 	adc.w	r1, r1, r1
   df146:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   df14a:	f1a4 0401 	sub.w	r4, r4, #1
   df14e:	d1e9      	bne.n	df124 <__adddf3+0x10c>
   df150:	f091 0f00 	teq	r1, #0
   df154:	bf04      	itt	eq
   df156:	4601      	moveq	r1, r0
   df158:	2000      	moveq	r0, #0
   df15a:	fab1 f381 	clz	r3, r1
   df15e:	bf08      	it	eq
   df160:	3320      	addeq	r3, #32
   df162:	f1a3 030b 	sub.w	r3, r3, #11
   df166:	f1b3 0220 	subs.w	r2, r3, #32
   df16a:	da0c      	bge.n	df186 <__adddf3+0x16e>
   df16c:	320c      	adds	r2, #12
   df16e:	dd08      	ble.n	df182 <__adddf3+0x16a>
   df170:	f102 0c14 	add.w	ip, r2, #20
   df174:	f1c2 020c 	rsb	r2, r2, #12
   df178:	fa01 f00c 	lsl.w	r0, r1, ip
   df17c:	fa21 f102 	lsr.w	r1, r1, r2
   df180:	e00c      	b.n	df19c <__adddf3+0x184>
   df182:	f102 0214 	add.w	r2, r2, #20
   df186:	bfd8      	it	le
   df188:	f1c2 0c20 	rsble	ip, r2, #32
   df18c:	fa01 f102 	lsl.w	r1, r1, r2
   df190:	fa20 fc0c 	lsr.w	ip, r0, ip
   df194:	bfdc      	itt	le
   df196:	ea41 010c 	orrle.w	r1, r1, ip
   df19a:	4090      	lslle	r0, r2
   df19c:	1ae4      	subs	r4, r4, r3
   df19e:	bfa2      	ittt	ge
   df1a0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   df1a4:	4329      	orrge	r1, r5
   df1a6:	bd30      	popge	{r4, r5, pc}
   df1a8:	ea6f 0404 	mvn.w	r4, r4
   df1ac:	3c1f      	subs	r4, #31
   df1ae:	da1c      	bge.n	df1ea <__adddf3+0x1d2>
   df1b0:	340c      	adds	r4, #12
   df1b2:	dc0e      	bgt.n	df1d2 <__adddf3+0x1ba>
   df1b4:	f104 0414 	add.w	r4, r4, #20
   df1b8:	f1c4 0220 	rsb	r2, r4, #32
   df1bc:	fa20 f004 	lsr.w	r0, r0, r4
   df1c0:	fa01 f302 	lsl.w	r3, r1, r2
   df1c4:	ea40 0003 	orr.w	r0, r0, r3
   df1c8:	fa21 f304 	lsr.w	r3, r1, r4
   df1cc:	ea45 0103 	orr.w	r1, r5, r3
   df1d0:	bd30      	pop	{r4, r5, pc}
   df1d2:	f1c4 040c 	rsb	r4, r4, #12
   df1d6:	f1c4 0220 	rsb	r2, r4, #32
   df1da:	fa20 f002 	lsr.w	r0, r0, r2
   df1de:	fa01 f304 	lsl.w	r3, r1, r4
   df1e2:	ea40 0003 	orr.w	r0, r0, r3
   df1e6:	4629      	mov	r1, r5
   df1e8:	bd30      	pop	{r4, r5, pc}
   df1ea:	fa21 f004 	lsr.w	r0, r1, r4
   df1ee:	4629      	mov	r1, r5
   df1f0:	bd30      	pop	{r4, r5, pc}
   df1f2:	f094 0f00 	teq	r4, #0
   df1f6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   df1fa:	bf06      	itte	eq
   df1fc:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   df200:	3401      	addeq	r4, #1
   df202:	3d01      	subne	r5, #1
   df204:	e74e      	b.n	df0a4 <__adddf3+0x8c>
   df206:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   df20a:	bf18      	it	ne
   df20c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   df210:	d029      	beq.n	df266 <__adddf3+0x24e>
   df212:	ea94 0f05 	teq	r4, r5
   df216:	bf08      	it	eq
   df218:	ea90 0f02 	teqeq	r0, r2
   df21c:	d005      	beq.n	df22a <__adddf3+0x212>
   df21e:	ea54 0c00 	orrs.w	ip, r4, r0
   df222:	bf04      	itt	eq
   df224:	4619      	moveq	r1, r3
   df226:	4610      	moveq	r0, r2
   df228:	bd30      	pop	{r4, r5, pc}
   df22a:	ea91 0f03 	teq	r1, r3
   df22e:	bf1e      	ittt	ne
   df230:	2100      	movne	r1, #0
   df232:	2000      	movne	r0, #0
   df234:	bd30      	popne	{r4, r5, pc}
   df236:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   df23a:	d105      	bne.n	df248 <__adddf3+0x230>
   df23c:	0040      	lsls	r0, r0, #1
   df23e:	4149      	adcs	r1, r1
   df240:	bf28      	it	cs
   df242:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   df246:	bd30      	pop	{r4, r5, pc}
   df248:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   df24c:	bf3c      	itt	cc
   df24e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   df252:	bd30      	popcc	{r4, r5, pc}
   df254:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   df258:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   df25c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   df260:	f04f 0000 	mov.w	r0, #0
   df264:	bd30      	pop	{r4, r5, pc}
   df266:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   df26a:	bf1a      	itte	ne
   df26c:	4619      	movne	r1, r3
   df26e:	4610      	movne	r0, r2
   df270:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   df274:	bf1c      	itt	ne
   df276:	460b      	movne	r3, r1
   df278:	4602      	movne	r2, r0
   df27a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   df27e:	bf06      	itte	eq
   df280:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   df284:	ea91 0f03 	teqeq	r1, r3
   df288:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   df28c:	bd30      	pop	{r4, r5, pc}
   df28e:	bf00      	nop

000df290 <__aeabi_ui2d>:
   df290:	f090 0f00 	teq	r0, #0
   df294:	bf04      	itt	eq
   df296:	2100      	moveq	r1, #0
   df298:	4770      	bxeq	lr
   df29a:	b530      	push	{r4, r5, lr}
   df29c:	f44f 6480 	mov.w	r4, #1024	; 0x400
   df2a0:	f104 0432 	add.w	r4, r4, #50	; 0x32
   df2a4:	f04f 0500 	mov.w	r5, #0
   df2a8:	f04f 0100 	mov.w	r1, #0
   df2ac:	e750      	b.n	df150 <__adddf3+0x138>
   df2ae:	bf00      	nop

000df2b0 <__aeabi_i2d>:
   df2b0:	f090 0f00 	teq	r0, #0
   df2b4:	bf04      	itt	eq
   df2b6:	2100      	moveq	r1, #0
   df2b8:	4770      	bxeq	lr
   df2ba:	b530      	push	{r4, r5, lr}
   df2bc:	f44f 6480 	mov.w	r4, #1024	; 0x400
   df2c0:	f104 0432 	add.w	r4, r4, #50	; 0x32
   df2c4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   df2c8:	bf48      	it	mi
   df2ca:	4240      	negmi	r0, r0
   df2cc:	f04f 0100 	mov.w	r1, #0
   df2d0:	e73e      	b.n	df150 <__adddf3+0x138>
   df2d2:	bf00      	nop

000df2d4 <__aeabi_f2d>:
   df2d4:	0042      	lsls	r2, r0, #1
   df2d6:	ea4f 01e2 	mov.w	r1, r2, asr #3
   df2da:	ea4f 0131 	mov.w	r1, r1, rrx
   df2de:	ea4f 7002 	mov.w	r0, r2, lsl #28
   df2e2:	bf1f      	itttt	ne
   df2e4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   df2e8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   df2ec:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   df2f0:	4770      	bxne	lr
   df2f2:	f092 0f00 	teq	r2, #0
   df2f6:	bf14      	ite	ne
   df2f8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   df2fc:	4770      	bxeq	lr
   df2fe:	b530      	push	{r4, r5, lr}
   df300:	f44f 7460 	mov.w	r4, #896	; 0x380
   df304:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   df308:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   df30c:	e720      	b.n	df150 <__adddf3+0x138>
   df30e:	bf00      	nop

000df310 <__aeabi_ul2d>:
   df310:	ea50 0201 	orrs.w	r2, r0, r1
   df314:	bf08      	it	eq
   df316:	4770      	bxeq	lr
   df318:	b530      	push	{r4, r5, lr}
   df31a:	f04f 0500 	mov.w	r5, #0
   df31e:	e00a      	b.n	df336 <__aeabi_l2d+0x16>

000df320 <__aeabi_l2d>:
   df320:	ea50 0201 	orrs.w	r2, r0, r1
   df324:	bf08      	it	eq
   df326:	4770      	bxeq	lr
   df328:	b530      	push	{r4, r5, lr}
   df32a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   df32e:	d502      	bpl.n	df336 <__aeabi_l2d+0x16>
   df330:	4240      	negs	r0, r0
   df332:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   df336:	f44f 6480 	mov.w	r4, #1024	; 0x400
   df33a:	f104 0432 	add.w	r4, r4, #50	; 0x32
   df33e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   df342:	f43f aedc 	beq.w	df0fe <__adddf3+0xe6>
   df346:	f04f 0203 	mov.w	r2, #3
   df34a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   df34e:	bf18      	it	ne
   df350:	3203      	addne	r2, #3
   df352:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   df356:	bf18      	it	ne
   df358:	3203      	addne	r2, #3
   df35a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   df35e:	f1c2 0320 	rsb	r3, r2, #32
   df362:	fa00 fc03 	lsl.w	ip, r0, r3
   df366:	fa20 f002 	lsr.w	r0, r0, r2
   df36a:	fa01 fe03 	lsl.w	lr, r1, r3
   df36e:	ea40 000e 	orr.w	r0, r0, lr
   df372:	fa21 f102 	lsr.w	r1, r1, r2
   df376:	4414      	add	r4, r2
   df378:	e6c1      	b.n	df0fe <__adddf3+0xe6>
   df37a:	bf00      	nop

000df37c <__aeabi_dmul>:
   df37c:	b570      	push	{r4, r5, r6, lr}
   df37e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   df382:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   df386:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   df38a:	bf1d      	ittte	ne
   df38c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   df390:	ea94 0f0c 	teqne	r4, ip
   df394:	ea95 0f0c 	teqne	r5, ip
   df398:	f000 f8de 	bleq	df558 <__aeabi_dmul+0x1dc>
   df39c:	442c      	add	r4, r5
   df39e:	ea81 0603 	eor.w	r6, r1, r3
   df3a2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   df3a6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   df3aa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   df3ae:	bf18      	it	ne
   df3b0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   df3b4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   df3b8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   df3bc:	d038      	beq.n	df430 <__aeabi_dmul+0xb4>
   df3be:	fba0 ce02 	umull	ip, lr, r0, r2
   df3c2:	f04f 0500 	mov.w	r5, #0
   df3c6:	fbe1 e502 	umlal	lr, r5, r1, r2
   df3ca:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   df3ce:	fbe0 e503 	umlal	lr, r5, r0, r3
   df3d2:	f04f 0600 	mov.w	r6, #0
   df3d6:	fbe1 5603 	umlal	r5, r6, r1, r3
   df3da:	f09c 0f00 	teq	ip, #0
   df3de:	bf18      	it	ne
   df3e0:	f04e 0e01 	orrne.w	lr, lr, #1
   df3e4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   df3e8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   df3ec:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   df3f0:	d204      	bcs.n	df3fc <__aeabi_dmul+0x80>
   df3f2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   df3f6:	416d      	adcs	r5, r5
   df3f8:	eb46 0606 	adc.w	r6, r6, r6
   df3fc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   df400:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   df404:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   df408:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   df40c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   df410:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   df414:	bf88      	it	hi
   df416:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   df41a:	d81e      	bhi.n	df45a <__aeabi_dmul+0xde>
   df41c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   df420:	bf08      	it	eq
   df422:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   df426:	f150 0000 	adcs.w	r0, r0, #0
   df42a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   df42e:	bd70      	pop	{r4, r5, r6, pc}
   df430:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   df434:	ea46 0101 	orr.w	r1, r6, r1
   df438:	ea40 0002 	orr.w	r0, r0, r2
   df43c:	ea81 0103 	eor.w	r1, r1, r3
   df440:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   df444:	bfc2      	ittt	gt
   df446:	ebd4 050c 	rsbsgt	r5, r4, ip
   df44a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   df44e:	bd70      	popgt	{r4, r5, r6, pc}
   df450:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   df454:	f04f 0e00 	mov.w	lr, #0
   df458:	3c01      	subs	r4, #1
   df45a:	f300 80ab 	bgt.w	df5b4 <__aeabi_dmul+0x238>
   df45e:	f114 0f36 	cmn.w	r4, #54	; 0x36
   df462:	bfde      	ittt	le
   df464:	2000      	movle	r0, #0
   df466:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   df46a:	bd70      	pople	{r4, r5, r6, pc}
   df46c:	f1c4 0400 	rsb	r4, r4, #0
   df470:	3c20      	subs	r4, #32
   df472:	da35      	bge.n	df4e0 <__aeabi_dmul+0x164>
   df474:	340c      	adds	r4, #12
   df476:	dc1b      	bgt.n	df4b0 <__aeabi_dmul+0x134>
   df478:	f104 0414 	add.w	r4, r4, #20
   df47c:	f1c4 0520 	rsb	r5, r4, #32
   df480:	fa00 f305 	lsl.w	r3, r0, r5
   df484:	fa20 f004 	lsr.w	r0, r0, r4
   df488:	fa01 f205 	lsl.w	r2, r1, r5
   df48c:	ea40 0002 	orr.w	r0, r0, r2
   df490:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   df494:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   df498:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   df49c:	fa21 f604 	lsr.w	r6, r1, r4
   df4a0:	eb42 0106 	adc.w	r1, r2, r6
   df4a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   df4a8:	bf08      	it	eq
   df4aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   df4ae:	bd70      	pop	{r4, r5, r6, pc}
   df4b0:	f1c4 040c 	rsb	r4, r4, #12
   df4b4:	f1c4 0520 	rsb	r5, r4, #32
   df4b8:	fa00 f304 	lsl.w	r3, r0, r4
   df4bc:	fa20 f005 	lsr.w	r0, r0, r5
   df4c0:	fa01 f204 	lsl.w	r2, r1, r4
   df4c4:	ea40 0002 	orr.w	r0, r0, r2
   df4c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   df4cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   df4d0:	f141 0100 	adc.w	r1, r1, #0
   df4d4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   df4d8:	bf08      	it	eq
   df4da:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   df4de:	bd70      	pop	{r4, r5, r6, pc}
   df4e0:	f1c4 0520 	rsb	r5, r4, #32
   df4e4:	fa00 f205 	lsl.w	r2, r0, r5
   df4e8:	ea4e 0e02 	orr.w	lr, lr, r2
   df4ec:	fa20 f304 	lsr.w	r3, r0, r4
   df4f0:	fa01 f205 	lsl.w	r2, r1, r5
   df4f4:	ea43 0302 	orr.w	r3, r3, r2
   df4f8:	fa21 f004 	lsr.w	r0, r1, r4
   df4fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   df500:	fa21 f204 	lsr.w	r2, r1, r4
   df504:	ea20 0002 	bic.w	r0, r0, r2
   df508:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   df50c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   df510:	bf08      	it	eq
   df512:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   df516:	bd70      	pop	{r4, r5, r6, pc}
   df518:	f094 0f00 	teq	r4, #0
   df51c:	d10f      	bne.n	df53e <__aeabi_dmul+0x1c2>
   df51e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   df522:	0040      	lsls	r0, r0, #1
   df524:	eb41 0101 	adc.w	r1, r1, r1
   df528:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   df52c:	bf08      	it	eq
   df52e:	3c01      	subeq	r4, #1
   df530:	d0f7      	beq.n	df522 <__aeabi_dmul+0x1a6>
   df532:	ea41 0106 	orr.w	r1, r1, r6
   df536:	f095 0f00 	teq	r5, #0
   df53a:	bf18      	it	ne
   df53c:	4770      	bxne	lr
   df53e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   df542:	0052      	lsls	r2, r2, #1
   df544:	eb43 0303 	adc.w	r3, r3, r3
   df548:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   df54c:	bf08      	it	eq
   df54e:	3d01      	subeq	r5, #1
   df550:	d0f7      	beq.n	df542 <__aeabi_dmul+0x1c6>
   df552:	ea43 0306 	orr.w	r3, r3, r6
   df556:	4770      	bx	lr
   df558:	ea94 0f0c 	teq	r4, ip
   df55c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   df560:	bf18      	it	ne
   df562:	ea95 0f0c 	teqne	r5, ip
   df566:	d00c      	beq.n	df582 <__aeabi_dmul+0x206>
   df568:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   df56c:	bf18      	it	ne
   df56e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   df572:	d1d1      	bne.n	df518 <__aeabi_dmul+0x19c>
   df574:	ea81 0103 	eor.w	r1, r1, r3
   df578:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   df57c:	f04f 0000 	mov.w	r0, #0
   df580:	bd70      	pop	{r4, r5, r6, pc}
   df582:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   df586:	bf06      	itte	eq
   df588:	4610      	moveq	r0, r2
   df58a:	4619      	moveq	r1, r3
   df58c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   df590:	d019      	beq.n	df5c6 <__aeabi_dmul+0x24a>
   df592:	ea94 0f0c 	teq	r4, ip
   df596:	d102      	bne.n	df59e <__aeabi_dmul+0x222>
   df598:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   df59c:	d113      	bne.n	df5c6 <__aeabi_dmul+0x24a>
   df59e:	ea95 0f0c 	teq	r5, ip
   df5a2:	d105      	bne.n	df5b0 <__aeabi_dmul+0x234>
   df5a4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   df5a8:	bf1c      	itt	ne
   df5aa:	4610      	movne	r0, r2
   df5ac:	4619      	movne	r1, r3
   df5ae:	d10a      	bne.n	df5c6 <__aeabi_dmul+0x24a>
   df5b0:	ea81 0103 	eor.w	r1, r1, r3
   df5b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   df5b8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   df5bc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   df5c0:	f04f 0000 	mov.w	r0, #0
   df5c4:	bd70      	pop	{r4, r5, r6, pc}
   df5c6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   df5ca:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   df5ce:	bd70      	pop	{r4, r5, r6, pc}

000df5d0 <__aeabi_ddiv>:
   df5d0:	b570      	push	{r4, r5, r6, lr}
   df5d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
   df5d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   df5da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   df5de:	bf1d      	ittte	ne
   df5e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   df5e4:	ea94 0f0c 	teqne	r4, ip
   df5e8:	ea95 0f0c 	teqne	r5, ip
   df5ec:	f000 f8a7 	bleq	df73e <__aeabi_ddiv+0x16e>
   df5f0:	eba4 0405 	sub.w	r4, r4, r5
   df5f4:	ea81 0e03 	eor.w	lr, r1, r3
   df5f8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   df5fc:	ea4f 3101 	mov.w	r1, r1, lsl #12
   df600:	f000 8088 	beq.w	df714 <__aeabi_ddiv+0x144>
   df604:	ea4f 3303 	mov.w	r3, r3, lsl #12
   df608:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   df60c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   df610:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   df614:	ea4f 2202 	mov.w	r2, r2, lsl #8
   df618:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   df61c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   df620:	ea4f 2600 	mov.w	r6, r0, lsl #8
   df624:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   df628:	429d      	cmp	r5, r3
   df62a:	bf08      	it	eq
   df62c:	4296      	cmpeq	r6, r2
   df62e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   df632:	f504 7440 	add.w	r4, r4, #768	; 0x300
   df636:	d202      	bcs.n	df63e <__aeabi_ddiv+0x6e>
   df638:	085b      	lsrs	r3, r3, #1
   df63a:	ea4f 0232 	mov.w	r2, r2, rrx
   df63e:	1ab6      	subs	r6, r6, r2
   df640:	eb65 0503 	sbc.w	r5, r5, r3
   df644:	085b      	lsrs	r3, r3, #1
   df646:	ea4f 0232 	mov.w	r2, r2, rrx
   df64a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   df64e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   df652:	ebb6 0e02 	subs.w	lr, r6, r2
   df656:	eb75 0e03 	sbcs.w	lr, r5, r3
   df65a:	bf22      	ittt	cs
   df65c:	1ab6      	subcs	r6, r6, r2
   df65e:	4675      	movcs	r5, lr
   df660:	ea40 000c 	orrcs.w	r0, r0, ip
   df664:	085b      	lsrs	r3, r3, #1
   df666:	ea4f 0232 	mov.w	r2, r2, rrx
   df66a:	ebb6 0e02 	subs.w	lr, r6, r2
   df66e:	eb75 0e03 	sbcs.w	lr, r5, r3
   df672:	bf22      	ittt	cs
   df674:	1ab6      	subcs	r6, r6, r2
   df676:	4675      	movcs	r5, lr
   df678:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   df67c:	085b      	lsrs	r3, r3, #1
   df67e:	ea4f 0232 	mov.w	r2, r2, rrx
   df682:	ebb6 0e02 	subs.w	lr, r6, r2
   df686:	eb75 0e03 	sbcs.w	lr, r5, r3
   df68a:	bf22      	ittt	cs
   df68c:	1ab6      	subcs	r6, r6, r2
   df68e:	4675      	movcs	r5, lr
   df690:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   df694:	085b      	lsrs	r3, r3, #1
   df696:	ea4f 0232 	mov.w	r2, r2, rrx
   df69a:	ebb6 0e02 	subs.w	lr, r6, r2
   df69e:	eb75 0e03 	sbcs.w	lr, r5, r3
   df6a2:	bf22      	ittt	cs
   df6a4:	1ab6      	subcs	r6, r6, r2
   df6a6:	4675      	movcs	r5, lr
   df6a8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   df6ac:	ea55 0e06 	orrs.w	lr, r5, r6
   df6b0:	d018      	beq.n	df6e4 <__aeabi_ddiv+0x114>
   df6b2:	ea4f 1505 	mov.w	r5, r5, lsl #4
   df6b6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   df6ba:	ea4f 1606 	mov.w	r6, r6, lsl #4
   df6be:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   df6c2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   df6c6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   df6ca:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   df6ce:	d1c0      	bne.n	df652 <__aeabi_ddiv+0x82>
   df6d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   df6d4:	d10b      	bne.n	df6ee <__aeabi_ddiv+0x11e>
   df6d6:	ea41 0100 	orr.w	r1, r1, r0
   df6da:	f04f 0000 	mov.w	r0, #0
   df6de:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   df6e2:	e7b6      	b.n	df652 <__aeabi_ddiv+0x82>
   df6e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   df6e8:	bf04      	itt	eq
   df6ea:	4301      	orreq	r1, r0
   df6ec:	2000      	moveq	r0, #0
   df6ee:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   df6f2:	bf88      	it	hi
   df6f4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   df6f8:	f63f aeaf 	bhi.w	df45a <__aeabi_dmul+0xde>
   df6fc:	ebb5 0c03 	subs.w	ip, r5, r3
   df700:	bf04      	itt	eq
   df702:	ebb6 0c02 	subseq.w	ip, r6, r2
   df706:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   df70a:	f150 0000 	adcs.w	r0, r0, #0
   df70e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   df712:	bd70      	pop	{r4, r5, r6, pc}
   df714:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   df718:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   df71c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   df720:	bfc2      	ittt	gt
   df722:	ebd4 050c 	rsbsgt	r5, r4, ip
   df726:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   df72a:	bd70      	popgt	{r4, r5, r6, pc}
   df72c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   df730:	f04f 0e00 	mov.w	lr, #0
   df734:	3c01      	subs	r4, #1
   df736:	e690      	b.n	df45a <__aeabi_dmul+0xde>
   df738:	ea45 0e06 	orr.w	lr, r5, r6
   df73c:	e68d      	b.n	df45a <__aeabi_dmul+0xde>
   df73e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   df742:	ea94 0f0c 	teq	r4, ip
   df746:	bf08      	it	eq
   df748:	ea95 0f0c 	teqeq	r5, ip
   df74c:	f43f af3b 	beq.w	df5c6 <__aeabi_dmul+0x24a>
   df750:	ea94 0f0c 	teq	r4, ip
   df754:	d10a      	bne.n	df76c <__aeabi_ddiv+0x19c>
   df756:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   df75a:	f47f af34 	bne.w	df5c6 <__aeabi_dmul+0x24a>
   df75e:	ea95 0f0c 	teq	r5, ip
   df762:	f47f af25 	bne.w	df5b0 <__aeabi_dmul+0x234>
   df766:	4610      	mov	r0, r2
   df768:	4619      	mov	r1, r3
   df76a:	e72c      	b.n	df5c6 <__aeabi_dmul+0x24a>
   df76c:	ea95 0f0c 	teq	r5, ip
   df770:	d106      	bne.n	df780 <__aeabi_ddiv+0x1b0>
   df772:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   df776:	f43f aefd 	beq.w	df574 <__aeabi_dmul+0x1f8>
   df77a:	4610      	mov	r0, r2
   df77c:	4619      	mov	r1, r3
   df77e:	e722      	b.n	df5c6 <__aeabi_dmul+0x24a>
   df780:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   df784:	bf18      	it	ne
   df786:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   df78a:	f47f aec5 	bne.w	df518 <__aeabi_dmul+0x19c>
   df78e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   df792:	f47f af0d 	bne.w	df5b0 <__aeabi_dmul+0x234>
   df796:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   df79a:	f47f aeeb 	bne.w	df574 <__aeabi_dmul+0x1f8>
   df79e:	e712      	b.n	df5c6 <__aeabi_dmul+0x24a>

000df7a0 <__gedf2>:
   df7a0:	f04f 3cff 	mov.w	ip, #4294967295
   df7a4:	e006      	b.n	df7b4 <__cmpdf2+0x4>
   df7a6:	bf00      	nop

000df7a8 <__ledf2>:
   df7a8:	f04f 0c01 	mov.w	ip, #1
   df7ac:	e002      	b.n	df7b4 <__cmpdf2+0x4>
   df7ae:	bf00      	nop

000df7b0 <__cmpdf2>:
   df7b0:	f04f 0c01 	mov.w	ip, #1
   df7b4:	f84d cd04 	str.w	ip, [sp, #-4]!
   df7b8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   df7bc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   df7c0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   df7c4:	bf18      	it	ne
   df7c6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   df7ca:	d01b      	beq.n	df804 <__cmpdf2+0x54>
   df7cc:	b001      	add	sp, #4
   df7ce:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   df7d2:	bf0c      	ite	eq
   df7d4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   df7d8:	ea91 0f03 	teqne	r1, r3
   df7dc:	bf02      	ittt	eq
   df7de:	ea90 0f02 	teqeq	r0, r2
   df7e2:	2000      	moveq	r0, #0
   df7e4:	4770      	bxeq	lr
   df7e6:	f110 0f00 	cmn.w	r0, #0
   df7ea:	ea91 0f03 	teq	r1, r3
   df7ee:	bf58      	it	pl
   df7f0:	4299      	cmppl	r1, r3
   df7f2:	bf08      	it	eq
   df7f4:	4290      	cmpeq	r0, r2
   df7f6:	bf2c      	ite	cs
   df7f8:	17d8      	asrcs	r0, r3, #31
   df7fa:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   df7fe:	f040 0001 	orr.w	r0, r0, #1
   df802:	4770      	bx	lr
   df804:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   df808:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   df80c:	d102      	bne.n	df814 <__cmpdf2+0x64>
   df80e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   df812:	d107      	bne.n	df824 <__cmpdf2+0x74>
   df814:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   df818:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   df81c:	d1d6      	bne.n	df7cc <__cmpdf2+0x1c>
   df81e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   df822:	d0d3      	beq.n	df7cc <__cmpdf2+0x1c>
   df824:	f85d 0b04 	ldr.w	r0, [sp], #4
   df828:	4770      	bx	lr
   df82a:	bf00      	nop

000df82c <__aeabi_cdrcmple>:
   df82c:	4684      	mov	ip, r0
   df82e:	4610      	mov	r0, r2
   df830:	4662      	mov	r2, ip
   df832:	468c      	mov	ip, r1
   df834:	4619      	mov	r1, r3
   df836:	4663      	mov	r3, ip
   df838:	e000      	b.n	df83c <__aeabi_cdcmpeq>
   df83a:	bf00      	nop

000df83c <__aeabi_cdcmpeq>:
   df83c:	b501      	push	{r0, lr}
   df83e:	f7ff ffb7 	bl	df7b0 <__cmpdf2>
   df842:	2800      	cmp	r0, #0
   df844:	bf48      	it	mi
   df846:	f110 0f00 	cmnmi.w	r0, #0
   df84a:	bd01      	pop	{r0, pc}

000df84c <__aeabi_dcmpeq>:
   df84c:	f84d ed08 	str.w	lr, [sp, #-8]!
   df850:	f7ff fff4 	bl	df83c <__aeabi_cdcmpeq>
   df854:	bf0c      	ite	eq
   df856:	2001      	moveq	r0, #1
   df858:	2000      	movne	r0, #0
   df85a:	f85d fb08 	ldr.w	pc, [sp], #8
   df85e:	bf00      	nop

000df860 <__aeabi_dcmplt>:
   df860:	f84d ed08 	str.w	lr, [sp, #-8]!
   df864:	f7ff ffea 	bl	df83c <__aeabi_cdcmpeq>
   df868:	bf34      	ite	cc
   df86a:	2001      	movcc	r0, #1
   df86c:	2000      	movcs	r0, #0
   df86e:	f85d fb08 	ldr.w	pc, [sp], #8
   df872:	bf00      	nop

000df874 <__aeabi_dcmple>:
   df874:	f84d ed08 	str.w	lr, [sp, #-8]!
   df878:	f7ff ffe0 	bl	df83c <__aeabi_cdcmpeq>
   df87c:	bf94      	ite	ls
   df87e:	2001      	movls	r0, #1
   df880:	2000      	movhi	r0, #0
   df882:	f85d fb08 	ldr.w	pc, [sp], #8
   df886:	bf00      	nop

000df888 <__aeabi_dcmpge>:
   df888:	f84d ed08 	str.w	lr, [sp, #-8]!
   df88c:	f7ff ffce 	bl	df82c <__aeabi_cdrcmple>
   df890:	bf94      	ite	ls
   df892:	2001      	movls	r0, #1
   df894:	2000      	movhi	r0, #0
   df896:	f85d fb08 	ldr.w	pc, [sp], #8
   df89a:	bf00      	nop

000df89c <__aeabi_dcmpgt>:
   df89c:	f84d ed08 	str.w	lr, [sp, #-8]!
   df8a0:	f7ff ffc4 	bl	df82c <__aeabi_cdrcmple>
   df8a4:	bf34      	ite	cc
   df8a6:	2001      	movcc	r0, #1
   df8a8:	2000      	movcs	r0, #0
   df8aa:	f85d fb08 	ldr.w	pc, [sp], #8
   df8ae:	bf00      	nop

000df8b0 <__aeabi_d2uiz>:
   df8b0:	004a      	lsls	r2, r1, #1
   df8b2:	d211      	bcs.n	df8d8 <__aeabi_d2uiz+0x28>
   df8b4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   df8b8:	d211      	bcs.n	df8de <__aeabi_d2uiz+0x2e>
   df8ba:	d50d      	bpl.n	df8d8 <__aeabi_d2uiz+0x28>
   df8bc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   df8c0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   df8c4:	d40e      	bmi.n	df8e4 <__aeabi_d2uiz+0x34>
   df8c6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   df8ca:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   df8ce:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   df8d2:	fa23 f002 	lsr.w	r0, r3, r2
   df8d6:	4770      	bx	lr
   df8d8:	f04f 0000 	mov.w	r0, #0
   df8dc:	4770      	bx	lr
   df8de:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   df8e2:	d102      	bne.n	df8ea <__aeabi_d2uiz+0x3a>
   df8e4:	f04f 30ff 	mov.w	r0, #4294967295
   df8e8:	4770      	bx	lr
   df8ea:	f04f 0000 	mov.w	r0, #0
   df8ee:	4770      	bx	lr

000df8f0 <__aeabi_d2f>:
   df8f0:	ea4f 0241 	mov.w	r2, r1, lsl #1
   df8f4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   df8f8:	bf24      	itt	cs
   df8fa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   df8fe:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   df902:	d90d      	bls.n	df920 <__aeabi_d2f+0x30>
   df904:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   df908:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   df90c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   df910:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   df914:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   df918:	bf08      	it	eq
   df91a:	f020 0001 	biceq.w	r0, r0, #1
   df91e:	4770      	bx	lr
   df920:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   df924:	d121      	bne.n	df96a <__aeabi_d2f+0x7a>
   df926:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   df92a:	bfbc      	itt	lt
   df92c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   df930:	4770      	bxlt	lr
   df932:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   df936:	ea4f 5252 	mov.w	r2, r2, lsr #21
   df93a:	f1c2 0218 	rsb	r2, r2, #24
   df93e:	f1c2 0c20 	rsb	ip, r2, #32
   df942:	fa10 f30c 	lsls.w	r3, r0, ip
   df946:	fa20 f002 	lsr.w	r0, r0, r2
   df94a:	bf18      	it	ne
   df94c:	f040 0001 	orrne.w	r0, r0, #1
   df950:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   df954:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   df958:	fa03 fc0c 	lsl.w	ip, r3, ip
   df95c:	ea40 000c 	orr.w	r0, r0, ip
   df960:	fa23 f302 	lsr.w	r3, r3, r2
   df964:	ea4f 0343 	mov.w	r3, r3, lsl #1
   df968:	e7cc      	b.n	df904 <__aeabi_d2f+0x14>
   df96a:	ea7f 5362 	mvns.w	r3, r2, asr #21
   df96e:	d107      	bne.n	df980 <__aeabi_d2f+0x90>
   df970:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   df974:	bf1e      	ittt	ne
   df976:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   df97a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   df97e:	4770      	bxne	lr
   df980:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   df984:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   df988:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   df98c:	4770      	bx	lr
   df98e:	bf00      	nop

000df990 <__aeabi_uldivmod>:
   df990:	b953      	cbnz	r3, df9a8 <__aeabi_uldivmod+0x18>
   df992:	b94a      	cbnz	r2, df9a8 <__aeabi_uldivmod+0x18>
   df994:	2900      	cmp	r1, #0
   df996:	bf08      	it	eq
   df998:	2800      	cmpeq	r0, #0
   df99a:	bf1c      	itt	ne
   df99c:	f04f 31ff 	movne.w	r1, #4294967295
   df9a0:	f04f 30ff 	movne.w	r0, #4294967295
   df9a4:	f000 b9a2 	b.w	dfcec <__aeabi_idiv0>
   df9a8:	f1ad 0c08 	sub.w	ip, sp, #8
   df9ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   df9b0:	f000 f82a 	bl	dfa08 <__udivmoddi4>
   df9b4:	f8dd e004 	ldr.w	lr, [sp, #4]
   df9b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   df9bc:	b004      	add	sp, #16
   df9be:	4770      	bx	lr

000df9c0 <__aeabi_d2ulz>:
   df9c0:	b5d0      	push	{r4, r6, r7, lr}
   df9c2:	2200      	movs	r2, #0
   df9c4:	4b0e      	ldr	r3, [pc, #56]	; (dfa00 <__aeabi_d2ulz+0x40>)
   df9c6:	4606      	mov	r6, r0
   df9c8:	460f      	mov	r7, r1
   df9ca:	f7ff fcd7 	bl	df37c <__aeabi_dmul>
   df9ce:	f7ff ff6f 	bl	df8b0 <__aeabi_d2uiz>
   df9d2:	4604      	mov	r4, r0
   df9d4:	f7ff fc5c 	bl	df290 <__aeabi_ui2d>
   df9d8:	2200      	movs	r2, #0
   df9da:	4b0a      	ldr	r3, [pc, #40]	; (dfa04 <__aeabi_d2ulz+0x44>)
   df9dc:	f7ff fcce 	bl	df37c <__aeabi_dmul>
   df9e0:	4602      	mov	r2, r0
   df9e2:	460b      	mov	r3, r1
   df9e4:	4630      	mov	r0, r6
   df9e6:	4639      	mov	r1, r7
   df9e8:	f7ff fb14 	bl	df014 <__aeabi_dsub>
   df9ec:	f7ff ff60 	bl	df8b0 <__aeabi_d2uiz>
   df9f0:	4623      	mov	r3, r4
   df9f2:	2200      	movs	r2, #0
   df9f4:	ea42 0200 	orr.w	r2, r2, r0
   df9f8:	4610      	mov	r0, r2
   df9fa:	4619      	mov	r1, r3
   df9fc:	bdd0      	pop	{r4, r6, r7, pc}
   df9fe:	bf00      	nop
   dfa00:	3df00000 	.word	0x3df00000
   dfa04:	41f00000 	.word	0x41f00000

000dfa08 <__udivmoddi4>:
   dfa08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   dfa0c:	468c      	mov	ip, r1
   dfa0e:	460e      	mov	r6, r1
   dfa10:	4604      	mov	r4, r0
   dfa12:	9d08      	ldr	r5, [sp, #32]
   dfa14:	2b00      	cmp	r3, #0
   dfa16:	d150      	bne.n	dfaba <__udivmoddi4+0xb2>
   dfa18:	428a      	cmp	r2, r1
   dfa1a:	4617      	mov	r7, r2
   dfa1c:	d96c      	bls.n	dfaf8 <__udivmoddi4+0xf0>
   dfa1e:	fab2 fe82 	clz	lr, r2
   dfa22:	f1be 0f00 	cmp.w	lr, #0
   dfa26:	d00b      	beq.n	dfa40 <__udivmoddi4+0x38>
   dfa28:	f1ce 0420 	rsb	r4, lr, #32
   dfa2c:	fa20 f404 	lsr.w	r4, r0, r4
   dfa30:	fa01 f60e 	lsl.w	r6, r1, lr
   dfa34:	ea44 0c06 	orr.w	ip, r4, r6
   dfa38:	fa02 f70e 	lsl.w	r7, r2, lr
   dfa3c:	fa00 f40e 	lsl.w	r4, r0, lr
   dfa40:	ea4f 4917 	mov.w	r9, r7, lsr #16
   dfa44:	0c22      	lsrs	r2, r4, #16
   dfa46:	fbbc f0f9 	udiv	r0, ip, r9
   dfa4a:	fa1f f887 	uxth.w	r8, r7
   dfa4e:	fb09 c610 	mls	r6, r9, r0, ip
   dfa52:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
   dfa56:	fb00 f308 	mul.w	r3, r0, r8
   dfa5a:	42b3      	cmp	r3, r6
   dfa5c:	d909      	bls.n	dfa72 <__udivmoddi4+0x6a>
   dfa5e:	19f6      	adds	r6, r6, r7
   dfa60:	f100 32ff 	add.w	r2, r0, #4294967295
   dfa64:	f080 8122 	bcs.w	dfcac <__udivmoddi4+0x2a4>
   dfa68:	42b3      	cmp	r3, r6
   dfa6a:	f240 811f 	bls.w	dfcac <__udivmoddi4+0x2a4>
   dfa6e:	3802      	subs	r0, #2
   dfa70:	443e      	add	r6, r7
   dfa72:	1af6      	subs	r6, r6, r3
   dfa74:	b2a2      	uxth	r2, r4
   dfa76:	fbb6 f3f9 	udiv	r3, r6, r9
   dfa7a:	fb09 6613 	mls	r6, r9, r3, r6
   dfa7e:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
   dfa82:	fb03 f808 	mul.w	r8, r3, r8
   dfa86:	45a0      	cmp	r8, r4
   dfa88:	d909      	bls.n	dfa9e <__udivmoddi4+0x96>
   dfa8a:	19e4      	adds	r4, r4, r7
   dfa8c:	f103 32ff 	add.w	r2, r3, #4294967295
   dfa90:	f080 810a 	bcs.w	dfca8 <__udivmoddi4+0x2a0>
   dfa94:	45a0      	cmp	r8, r4
   dfa96:	f240 8107 	bls.w	dfca8 <__udivmoddi4+0x2a0>
   dfa9a:	3b02      	subs	r3, #2
   dfa9c:	443c      	add	r4, r7
   dfa9e:	ebc8 0404 	rsb	r4, r8, r4
   dfaa2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   dfaa6:	2100      	movs	r1, #0
   dfaa8:	2d00      	cmp	r5, #0
   dfaaa:	d062      	beq.n	dfb72 <__udivmoddi4+0x16a>
   dfaac:	fa24 f40e 	lsr.w	r4, r4, lr
   dfab0:	2300      	movs	r3, #0
   dfab2:	602c      	str	r4, [r5, #0]
   dfab4:	606b      	str	r3, [r5, #4]
   dfab6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dfaba:	428b      	cmp	r3, r1
   dfabc:	d907      	bls.n	dface <__udivmoddi4+0xc6>
   dfabe:	2d00      	cmp	r5, #0
   dfac0:	d055      	beq.n	dfb6e <__udivmoddi4+0x166>
   dfac2:	2100      	movs	r1, #0
   dfac4:	e885 0041 	stmia.w	r5, {r0, r6}
   dfac8:	4608      	mov	r0, r1
   dfaca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dface:	fab3 f183 	clz	r1, r3
   dfad2:	2900      	cmp	r1, #0
   dfad4:	f040 8090 	bne.w	dfbf8 <__udivmoddi4+0x1f0>
   dfad8:	42b3      	cmp	r3, r6
   dfada:	d302      	bcc.n	dfae2 <__udivmoddi4+0xda>
   dfadc:	4282      	cmp	r2, r0
   dfade:	f200 80f8 	bhi.w	dfcd2 <__udivmoddi4+0x2ca>
   dfae2:	1a84      	subs	r4, r0, r2
   dfae4:	eb66 0603 	sbc.w	r6, r6, r3
   dfae8:	2001      	movs	r0, #1
   dfaea:	46b4      	mov	ip, r6
   dfaec:	2d00      	cmp	r5, #0
   dfaee:	d040      	beq.n	dfb72 <__udivmoddi4+0x16a>
   dfaf0:	e885 1010 	stmia.w	r5, {r4, ip}
   dfaf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dfaf8:	b912      	cbnz	r2, dfb00 <__udivmoddi4+0xf8>
   dfafa:	2701      	movs	r7, #1
   dfafc:	fbb7 f7f2 	udiv	r7, r7, r2
   dfb00:	fab7 fe87 	clz	lr, r7
   dfb04:	f1be 0f00 	cmp.w	lr, #0
   dfb08:	d135      	bne.n	dfb76 <__udivmoddi4+0x16e>
   dfb0a:	1bf3      	subs	r3, r6, r7
   dfb0c:	ea4f 4817 	mov.w	r8, r7, lsr #16
   dfb10:	fa1f fc87 	uxth.w	ip, r7
   dfb14:	2101      	movs	r1, #1
   dfb16:	fbb3 f0f8 	udiv	r0, r3, r8
   dfb1a:	0c22      	lsrs	r2, r4, #16
   dfb1c:	fb08 3610 	mls	r6, r8, r0, r3
   dfb20:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
   dfb24:	fb0c f300 	mul.w	r3, ip, r0
   dfb28:	42b3      	cmp	r3, r6
   dfb2a:	d907      	bls.n	dfb3c <__udivmoddi4+0x134>
   dfb2c:	19f6      	adds	r6, r6, r7
   dfb2e:	f100 32ff 	add.w	r2, r0, #4294967295
   dfb32:	d202      	bcs.n	dfb3a <__udivmoddi4+0x132>
   dfb34:	42b3      	cmp	r3, r6
   dfb36:	f200 80ce 	bhi.w	dfcd6 <__udivmoddi4+0x2ce>
   dfb3a:	4610      	mov	r0, r2
   dfb3c:	1af6      	subs	r6, r6, r3
   dfb3e:	b2a2      	uxth	r2, r4
   dfb40:	fbb6 f3f8 	udiv	r3, r6, r8
   dfb44:	fb08 6613 	mls	r6, r8, r3, r6
   dfb48:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
   dfb4c:	fb0c fc03 	mul.w	ip, ip, r3
   dfb50:	45a4      	cmp	ip, r4
   dfb52:	d907      	bls.n	dfb64 <__udivmoddi4+0x15c>
   dfb54:	19e4      	adds	r4, r4, r7
   dfb56:	f103 32ff 	add.w	r2, r3, #4294967295
   dfb5a:	d202      	bcs.n	dfb62 <__udivmoddi4+0x15a>
   dfb5c:	45a4      	cmp	ip, r4
   dfb5e:	f200 80b5 	bhi.w	dfccc <__udivmoddi4+0x2c4>
   dfb62:	4613      	mov	r3, r2
   dfb64:	ebcc 0404 	rsb	r4, ip, r4
   dfb68:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   dfb6c:	e79c      	b.n	dfaa8 <__udivmoddi4+0xa0>
   dfb6e:	4629      	mov	r1, r5
   dfb70:	4628      	mov	r0, r5
   dfb72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dfb76:	f1ce 0120 	rsb	r1, lr, #32
   dfb7a:	fa06 f30e 	lsl.w	r3, r6, lr
   dfb7e:	fa07 f70e 	lsl.w	r7, r7, lr
   dfb82:	fa20 f901 	lsr.w	r9, r0, r1
   dfb86:	ea4f 4817 	mov.w	r8, r7, lsr #16
   dfb8a:	40ce      	lsrs	r6, r1
   dfb8c:	ea49 0903 	orr.w	r9, r9, r3
   dfb90:	fbb6 faf8 	udiv	sl, r6, r8
   dfb94:	ea4f 4419 	mov.w	r4, r9, lsr #16
   dfb98:	fb08 661a 	mls	r6, r8, sl, r6
   dfb9c:	fa1f fc87 	uxth.w	ip, r7
   dfba0:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
   dfba4:	fb0a f20c 	mul.w	r2, sl, ip
   dfba8:	429a      	cmp	r2, r3
   dfbaa:	fa00 f40e 	lsl.w	r4, r0, lr
   dfbae:	d90a      	bls.n	dfbc6 <__udivmoddi4+0x1be>
   dfbb0:	19db      	adds	r3, r3, r7
   dfbb2:	f10a 31ff 	add.w	r1, sl, #4294967295
   dfbb6:	f080 8087 	bcs.w	dfcc8 <__udivmoddi4+0x2c0>
   dfbba:	429a      	cmp	r2, r3
   dfbbc:	f240 8084 	bls.w	dfcc8 <__udivmoddi4+0x2c0>
   dfbc0:	f1aa 0a02 	sub.w	sl, sl, #2
   dfbc4:	443b      	add	r3, r7
   dfbc6:	1a9b      	subs	r3, r3, r2
   dfbc8:	fa1f f989 	uxth.w	r9, r9
   dfbcc:	fbb3 f1f8 	udiv	r1, r3, r8
   dfbd0:	fb08 3311 	mls	r3, r8, r1, r3
   dfbd4:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
   dfbd8:	fb01 f60c 	mul.w	r6, r1, ip
   dfbdc:	429e      	cmp	r6, r3
   dfbde:	d907      	bls.n	dfbf0 <__udivmoddi4+0x1e8>
   dfbe0:	19db      	adds	r3, r3, r7
   dfbe2:	f101 32ff 	add.w	r2, r1, #4294967295
   dfbe6:	d26b      	bcs.n	dfcc0 <__udivmoddi4+0x2b8>
   dfbe8:	429e      	cmp	r6, r3
   dfbea:	d969      	bls.n	dfcc0 <__udivmoddi4+0x2b8>
   dfbec:	3902      	subs	r1, #2
   dfbee:	443b      	add	r3, r7
   dfbf0:	1b9b      	subs	r3, r3, r6
   dfbf2:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
   dfbf6:	e78e      	b.n	dfb16 <__udivmoddi4+0x10e>
   dfbf8:	f1c1 0e20 	rsb	lr, r1, #32
   dfbfc:	fa22 f40e 	lsr.w	r4, r2, lr
   dfc00:	408b      	lsls	r3, r1
   dfc02:	4323      	orrs	r3, r4
   dfc04:	fa20 f70e 	lsr.w	r7, r0, lr
   dfc08:	fa06 f401 	lsl.w	r4, r6, r1
   dfc0c:	ea4f 4c13 	mov.w	ip, r3, lsr #16
   dfc10:	fa26 f60e 	lsr.w	r6, r6, lr
   dfc14:	433c      	orrs	r4, r7
   dfc16:	fbb6 f9fc 	udiv	r9, r6, ip
   dfc1a:	0c27      	lsrs	r7, r4, #16
   dfc1c:	fb0c 6619 	mls	r6, ip, r9, r6
   dfc20:	fa1f f883 	uxth.w	r8, r3
   dfc24:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
   dfc28:	fb09 f708 	mul.w	r7, r9, r8
   dfc2c:	42b7      	cmp	r7, r6
   dfc2e:	fa02 f201 	lsl.w	r2, r2, r1
   dfc32:	fa00 fa01 	lsl.w	sl, r0, r1
   dfc36:	d908      	bls.n	dfc4a <__udivmoddi4+0x242>
   dfc38:	18f6      	adds	r6, r6, r3
   dfc3a:	f109 30ff 	add.w	r0, r9, #4294967295
   dfc3e:	d241      	bcs.n	dfcc4 <__udivmoddi4+0x2bc>
   dfc40:	42b7      	cmp	r7, r6
   dfc42:	d93f      	bls.n	dfcc4 <__udivmoddi4+0x2bc>
   dfc44:	f1a9 0902 	sub.w	r9, r9, #2
   dfc48:	441e      	add	r6, r3
   dfc4a:	1bf6      	subs	r6, r6, r7
   dfc4c:	b2a0      	uxth	r0, r4
   dfc4e:	fbb6 f4fc 	udiv	r4, r6, ip
   dfc52:	fb0c 6614 	mls	r6, ip, r4, r6
   dfc56:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
   dfc5a:	fb04 f808 	mul.w	r8, r4, r8
   dfc5e:	45b8      	cmp	r8, r7
   dfc60:	d907      	bls.n	dfc72 <__udivmoddi4+0x26a>
   dfc62:	18ff      	adds	r7, r7, r3
   dfc64:	f104 30ff 	add.w	r0, r4, #4294967295
   dfc68:	d228      	bcs.n	dfcbc <__udivmoddi4+0x2b4>
   dfc6a:	45b8      	cmp	r8, r7
   dfc6c:	d926      	bls.n	dfcbc <__udivmoddi4+0x2b4>
   dfc6e:	3c02      	subs	r4, #2
   dfc70:	441f      	add	r7, r3
   dfc72:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
   dfc76:	ebc8 0707 	rsb	r7, r8, r7
   dfc7a:	fba0 8902 	umull	r8, r9, r0, r2
   dfc7e:	454f      	cmp	r7, r9
   dfc80:	4644      	mov	r4, r8
   dfc82:	464e      	mov	r6, r9
   dfc84:	d314      	bcc.n	dfcb0 <__udivmoddi4+0x2a8>
   dfc86:	d029      	beq.n	dfcdc <__udivmoddi4+0x2d4>
   dfc88:	b365      	cbz	r5, dfce4 <__udivmoddi4+0x2dc>
   dfc8a:	ebba 0304 	subs.w	r3, sl, r4
   dfc8e:	eb67 0706 	sbc.w	r7, r7, r6
   dfc92:	fa07 fe0e 	lsl.w	lr, r7, lr
   dfc96:	40cb      	lsrs	r3, r1
   dfc98:	40cf      	lsrs	r7, r1
   dfc9a:	ea4e 0303 	orr.w	r3, lr, r3
   dfc9e:	e885 0088 	stmia.w	r5, {r3, r7}
   dfca2:	2100      	movs	r1, #0
   dfca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dfca8:	4613      	mov	r3, r2
   dfcaa:	e6f8      	b.n	dfa9e <__udivmoddi4+0x96>
   dfcac:	4610      	mov	r0, r2
   dfcae:	e6e0      	b.n	dfa72 <__udivmoddi4+0x6a>
   dfcb0:	ebb8 0402 	subs.w	r4, r8, r2
   dfcb4:	eb69 0603 	sbc.w	r6, r9, r3
   dfcb8:	3801      	subs	r0, #1
   dfcba:	e7e5      	b.n	dfc88 <__udivmoddi4+0x280>
   dfcbc:	4604      	mov	r4, r0
   dfcbe:	e7d8      	b.n	dfc72 <__udivmoddi4+0x26a>
   dfcc0:	4611      	mov	r1, r2
   dfcc2:	e795      	b.n	dfbf0 <__udivmoddi4+0x1e8>
   dfcc4:	4681      	mov	r9, r0
   dfcc6:	e7c0      	b.n	dfc4a <__udivmoddi4+0x242>
   dfcc8:	468a      	mov	sl, r1
   dfcca:	e77c      	b.n	dfbc6 <__udivmoddi4+0x1be>
   dfccc:	3b02      	subs	r3, #2
   dfcce:	443c      	add	r4, r7
   dfcd0:	e748      	b.n	dfb64 <__udivmoddi4+0x15c>
   dfcd2:	4608      	mov	r0, r1
   dfcd4:	e70a      	b.n	dfaec <__udivmoddi4+0xe4>
   dfcd6:	3802      	subs	r0, #2
   dfcd8:	443e      	add	r6, r7
   dfcda:	e72f      	b.n	dfb3c <__udivmoddi4+0x134>
   dfcdc:	45c2      	cmp	sl, r8
   dfcde:	d3e7      	bcc.n	dfcb0 <__udivmoddi4+0x2a8>
   dfce0:	463e      	mov	r6, r7
   dfce2:	e7d1      	b.n	dfc88 <__udivmoddi4+0x280>
   dfce4:	4629      	mov	r1, r5
   dfce6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   dfcea:	bf00      	nop

000dfcec <__aeabi_idiv0>:
   dfcec:	4770      	bx	lr
   dfcee:	bf00      	nop

000dfcf0 <atoi>:
   dfcf0:	220a      	movs	r2, #10
   dfcf2:	2100      	movs	r1, #0
   dfcf4:	f000 bacc 	b.w	e0290 <strtol>

000dfcf8 <atol>:
   dfcf8:	220a      	movs	r2, #10
   dfcfa:	2100      	movs	r1, #0
   dfcfc:	f000 bac8 	b.w	e0290 <strtol>

000dfd00 <__cxa_atexit>:
   dfd00:	b510      	push	{r4, lr}
   dfd02:	4c05      	ldr	r4, [pc, #20]	; (dfd18 <__cxa_atexit+0x18>)
   dfd04:	4613      	mov	r3, r2
   dfd06:	b12c      	cbz	r4, dfd14 <__cxa_atexit+0x14>
   dfd08:	460a      	mov	r2, r1
   dfd0a:	4601      	mov	r1, r0
   dfd0c:	2002      	movs	r0, #2
   dfd0e:	f3af 8000 	nop.w
   dfd12:	bd10      	pop	{r4, pc}
   dfd14:	4620      	mov	r0, r4
   dfd16:	bd10      	pop	{r4, pc}
   dfd18:	00000000 	.word	0x00000000

000dfd1c <localtime>:
   dfd1c:	b538      	push	{r3, r4, r5, lr}
   dfd1e:	4b07      	ldr	r3, [pc, #28]	; (dfd3c <localtime+0x20>)
   dfd20:	681c      	ldr	r4, [r3, #0]
   dfd22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   dfd24:	4605      	mov	r5, r0
   dfd26:	b91b      	cbnz	r3, dfd30 <localtime+0x14>
   dfd28:	2024      	movs	r0, #36	; 0x24
   dfd2a:	f7fc f845 	bl	dbdb8 <malloc>
   dfd2e:	63e0      	str	r0, [r4, #60]	; 0x3c
   dfd30:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   dfd32:	4628      	mov	r0, r5
   dfd34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   dfd38:	f000 b802 	b.w	dfd40 <localtime_r>
   dfd3c:	2003daa8 	.word	0x2003daa8

000dfd40 <localtime_r>:
   dfd40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   dfd44:	460c      	mov	r4, r1
   dfd46:	4680      	mov	r8, r0
   dfd48:	f000 fda8 	bl	e089c <__gettzinfo>
   dfd4c:	4621      	mov	r1, r4
   dfd4e:	4607      	mov	r7, r0
   dfd50:	4640      	mov	r0, r8
   dfd52:	f000 fda7 	bl	e08a4 <gmtime_r>
   dfd56:	6946      	ldr	r6, [r0, #20]
   dfd58:	f206 766c 	addw	r6, r6, #1900	; 0x76c
   dfd5c:	07b3      	lsls	r3, r6, #30
   dfd5e:	4604      	mov	r4, r0
   dfd60:	d105      	bne.n	dfd6e <localtime_r+0x2e>
   dfd62:	2264      	movs	r2, #100	; 0x64
   dfd64:	fb96 f3f2 	sdiv	r3, r6, r2
   dfd68:	fb02 6313 	mls	r3, r2, r3, r6
   dfd6c:	b94b      	cbnz	r3, dfd82 <localtime_r+0x42>
   dfd6e:	f44f 75c8 	mov.w	r5, #400	; 0x190
   dfd72:	fb96 f3f5 	sdiv	r3, r6, r5
   dfd76:	fb05 6513 	mls	r5, r5, r3, r6
   dfd7a:	fab5 f385 	clz	r3, r5
   dfd7e:	095b      	lsrs	r3, r3, #5
   dfd80:	e000      	b.n	dfd84 <localtime_r+0x44>
   dfd82:	2301      	movs	r3, #1
   dfd84:	4a5f      	ldr	r2, [pc, #380]	; (dff04 <localtime_r+0x1c4>)
   dfd86:	2530      	movs	r5, #48	; 0x30
   dfd88:	fb05 2503 	mla	r5, r5, r3, r2
   dfd8c:	f000 fbba 	bl	e0504 <__tz_lock>
   dfd90:	f000 fbba 	bl	e0508 <_tzset_unlocked>
   dfd94:	4b5c      	ldr	r3, [pc, #368]	; (dff08 <localtime_r+0x1c8>)
   dfd96:	681b      	ldr	r3, [r3, #0]
   dfd98:	b1f3      	cbz	r3, dfdd8 <localtime_r+0x98>
   dfd9a:	687b      	ldr	r3, [r7, #4]
   dfd9c:	429e      	cmp	r6, r3
   dfd9e:	d105      	bne.n	dfdac <localtime_r+0x6c>
   dfda0:	6839      	ldr	r1, [r7, #0]
   dfda2:	f8d8 3000 	ldr.w	r3, [r8]
   dfda6:	69fa      	ldr	r2, [r7, #28]
   dfda8:	b941      	cbnz	r1, dfdbc <localtime_r+0x7c>
   dfdaa:	e00a      	b.n	dfdc2 <localtime_r+0x82>
   dfdac:	4630      	mov	r0, r6
   dfdae:	f000 fb01 	bl	e03b4 <__tzcalc_limits>
   dfdb2:	2800      	cmp	r0, #0
   dfdb4:	d1f4      	bne.n	dfda0 <localtime_r+0x60>
   dfdb6:	f04f 33ff 	mov.w	r3, #4294967295
   dfdba:	e00d      	b.n	dfdd8 <localtime_r+0x98>
   dfdbc:	4293      	cmp	r3, r2
   dfdbe:	db08      	blt.n	dfdd2 <localtime_r+0x92>
   dfdc0:	e001      	b.n	dfdc6 <localtime_r+0x86>
   dfdc2:	4293      	cmp	r3, r2
   dfdc4:	da07      	bge.n	dfdd6 <localtime_r+0x96>
   dfdc6:	6bba      	ldr	r2, [r7, #56]	; 0x38
   dfdc8:	4293      	cmp	r3, r2
   dfdca:	bfac      	ite	ge
   dfdcc:	2300      	movge	r3, #0
   dfdce:	2301      	movlt	r3, #1
   dfdd0:	e002      	b.n	dfdd8 <localtime_r+0x98>
   dfdd2:	2300      	movs	r3, #0
   dfdd4:	e000      	b.n	dfdd8 <localtime_r+0x98>
   dfdd6:	2301      	movs	r3, #1
   dfdd8:	6223      	str	r3, [r4, #32]
   dfdda:	6a23      	ldr	r3, [r4, #32]
   dfddc:	2b01      	cmp	r3, #1
   dfdde:	bf0c      	ite	eq
   dfde0:	6bf9      	ldreq	r1, [r7, #60]	; 0x3c
   dfde2:	6a39      	ldrne	r1, [r7, #32]
   dfde4:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   dfde8:	203c      	movs	r0, #60	; 0x3c
   dfdea:	fb91 f6f3 	sdiv	r6, r1, r3
   dfdee:	fb03 1316 	mls	r3, r3, r6, r1
   dfdf2:	6861      	ldr	r1, [r4, #4]
   dfdf4:	fb93 f2f0 	sdiv	r2, r3, r0
   dfdf8:	fb00 3012 	mls	r0, r0, r2, r3
   dfdfc:	6823      	ldr	r3, [r4, #0]
   dfdfe:	1a89      	subs	r1, r1, r2
   dfe00:	68a2      	ldr	r2, [r4, #8]
   dfe02:	6061      	str	r1, [r4, #4]
   dfe04:	1a1b      	subs	r3, r3, r0
   dfe06:	1b92      	subs	r2, r2, r6
   dfe08:	2b3b      	cmp	r3, #59	; 0x3b
   dfe0a:	6023      	str	r3, [r4, #0]
   dfe0c:	60a2      	str	r2, [r4, #8]
   dfe0e:	dd03      	ble.n	dfe18 <localtime_r+0xd8>
   dfe10:	3101      	adds	r1, #1
   dfe12:	6061      	str	r1, [r4, #4]
   dfe14:	3b3c      	subs	r3, #60	; 0x3c
   dfe16:	e004      	b.n	dfe22 <localtime_r+0xe2>
   dfe18:	2b00      	cmp	r3, #0
   dfe1a:	da03      	bge.n	dfe24 <localtime_r+0xe4>
   dfe1c:	3901      	subs	r1, #1
   dfe1e:	6061      	str	r1, [r4, #4]
   dfe20:	333c      	adds	r3, #60	; 0x3c
   dfe22:	6023      	str	r3, [r4, #0]
   dfe24:	6863      	ldr	r3, [r4, #4]
   dfe26:	2b3b      	cmp	r3, #59	; 0x3b
   dfe28:	dd03      	ble.n	dfe32 <localtime_r+0xf2>
   dfe2a:	3201      	adds	r2, #1
   dfe2c:	60a2      	str	r2, [r4, #8]
   dfe2e:	3b3c      	subs	r3, #60	; 0x3c
   dfe30:	e004      	b.n	dfe3c <localtime_r+0xfc>
   dfe32:	2b00      	cmp	r3, #0
   dfe34:	da03      	bge.n	dfe3e <localtime_r+0xfe>
   dfe36:	3a01      	subs	r2, #1
   dfe38:	60a2      	str	r2, [r4, #8]
   dfe3a:	333c      	adds	r3, #60	; 0x3c
   dfe3c:	6063      	str	r3, [r4, #4]
   dfe3e:	68a3      	ldr	r3, [r4, #8]
   dfe40:	2b17      	cmp	r3, #23
   dfe42:	dd22      	ble.n	dfe8a <localtime_r+0x14a>
   dfe44:	69e2      	ldr	r2, [r4, #28]
   dfe46:	3201      	adds	r2, #1
   dfe48:	61e2      	str	r2, [r4, #28]
   dfe4a:	69a2      	ldr	r2, [r4, #24]
   dfe4c:	3201      	adds	r2, #1
   dfe4e:	2a06      	cmp	r2, #6
   dfe50:	bfc8      	it	gt
   dfe52:	2200      	movgt	r2, #0
   dfe54:	61a2      	str	r2, [r4, #24]
   dfe56:	68e2      	ldr	r2, [r4, #12]
   dfe58:	3b18      	subs	r3, #24
   dfe5a:	3201      	adds	r2, #1
   dfe5c:	60a3      	str	r3, [r4, #8]
   dfe5e:	6923      	ldr	r3, [r4, #16]
   dfe60:	60e2      	str	r2, [r4, #12]
   dfe62:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
   dfe66:	428a      	cmp	r2, r1
   dfe68:	dd46      	ble.n	dfef8 <localtime_r+0x1b8>
   dfe6a:	3301      	adds	r3, #1
   dfe6c:	2b0c      	cmp	r3, #12
   dfe6e:	bf0c      	ite	eq
   dfe70:	6963      	ldreq	r3, [r4, #20]
   dfe72:	6123      	strne	r3, [r4, #16]
   dfe74:	eba2 0201 	sub.w	r2, r2, r1
   dfe78:	60e2      	str	r2, [r4, #12]
   dfe7a:	bf01      	itttt	eq
   dfe7c:	3301      	addeq	r3, #1
   dfe7e:	2200      	moveq	r2, #0
   dfe80:	6122      	streq	r2, [r4, #16]
   dfe82:	6163      	streq	r3, [r4, #20]
   dfe84:	bf08      	it	eq
   dfe86:	61e2      	streq	r2, [r4, #28]
   dfe88:	e036      	b.n	dfef8 <localtime_r+0x1b8>
   dfe8a:	2b00      	cmp	r3, #0
   dfe8c:	da34      	bge.n	dfef8 <localtime_r+0x1b8>
   dfe8e:	69e2      	ldr	r2, [r4, #28]
   dfe90:	3a01      	subs	r2, #1
   dfe92:	61e2      	str	r2, [r4, #28]
   dfe94:	69a2      	ldr	r2, [r4, #24]
   dfe96:	3a01      	subs	r2, #1
   dfe98:	bf48      	it	mi
   dfe9a:	2206      	movmi	r2, #6
   dfe9c:	61a2      	str	r2, [r4, #24]
   dfe9e:	68e2      	ldr	r2, [r4, #12]
   dfea0:	3318      	adds	r3, #24
   dfea2:	3a01      	subs	r2, #1
   dfea4:	60e2      	str	r2, [r4, #12]
   dfea6:	60a3      	str	r3, [r4, #8]
   dfea8:	bb32      	cbnz	r2, dfef8 <localtime_r+0x1b8>
   dfeaa:	6923      	ldr	r3, [r4, #16]
   dfeac:	3b01      	subs	r3, #1
   dfeae:	d401      	bmi.n	dfeb4 <localtime_r+0x174>
   dfeb0:	6123      	str	r3, [r4, #16]
   dfeb2:	e01d      	b.n	dfef0 <localtime_r+0x1b0>
   dfeb4:	230b      	movs	r3, #11
   dfeb6:	6123      	str	r3, [r4, #16]
   dfeb8:	6963      	ldr	r3, [r4, #20]
   dfeba:	1e5a      	subs	r2, r3, #1
   dfebc:	f012 0f03 	tst.w	r2, #3
   dfec0:	6162      	str	r2, [r4, #20]
   dfec2:	f203 736b 	addw	r3, r3, #1899	; 0x76b
   dfec6:	d105      	bne.n	dfed4 <localtime_r+0x194>
   dfec8:	2164      	movs	r1, #100	; 0x64
   dfeca:	fb93 f2f1 	sdiv	r2, r3, r1
   dfece:	fb01 3212 	mls	r2, r1, r2, r3
   dfed2:	b94a      	cbnz	r2, dfee8 <localtime_r+0x1a8>
   dfed4:	f44f 71c8 	mov.w	r1, #400	; 0x190
   dfed8:	fb93 f2f1 	sdiv	r2, r3, r1
   dfedc:	fb01 3312 	mls	r3, r1, r2, r3
   dfee0:	fab3 f383 	clz	r3, r3
   dfee4:	095b      	lsrs	r3, r3, #5
   dfee6:	e000      	b.n	dfeea <localtime_r+0x1aa>
   dfee8:	2301      	movs	r3, #1
   dfeea:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
   dfeee:	61e3      	str	r3, [r4, #28]
   dfef0:	6923      	ldr	r3, [r4, #16]
   dfef2:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
   dfef6:	60e3      	str	r3, [r4, #12]
   dfef8:	f000 fb05 	bl	e0506 <__tz_unlock>
   dfefc:	4620      	mov	r0, r4
   dfefe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   dff02:	bf00      	nop
   dff04:	000e2a80 	.word	0x000e2a80
   dff08:	2003e7e4 	.word	0x2003e7e4

000dff0c <ldiv>:
   dff0c:	2900      	cmp	r1, #0
   dff0e:	b510      	push	{r4, lr}
   dff10:	fb91 f4f2 	sdiv	r4, r1, r2
   dff14:	fb02 1314 	mls	r3, r2, r4, r1
   dff18:	db04      	blt.n	dff24 <ldiv+0x18>
   dff1a:	2b00      	cmp	r3, #0
   dff1c:	da07      	bge.n	dff2e <ldiv+0x22>
   dff1e:	3401      	adds	r4, #1
   dff20:	1a9b      	subs	r3, r3, r2
   dff22:	e004      	b.n	dff2e <ldiv+0x22>
   dff24:	2b00      	cmp	r3, #0
   dff26:	bfc4      	itt	gt
   dff28:	f104 34ff 	addgt.w	r4, r4, #4294967295
   dff2c:	189b      	addgt	r3, r3, r2
   dff2e:	6004      	str	r4, [r0, #0]
   dff30:	6043      	str	r3, [r0, #4]
   dff32:	bd10      	pop	{r4, pc}

000dff34 <memcmp>:
   dff34:	b510      	push	{r4, lr}
   dff36:	3901      	subs	r1, #1
   dff38:	4402      	add	r2, r0
   dff3a:	4290      	cmp	r0, r2
   dff3c:	d007      	beq.n	dff4e <memcmp+0x1a>
   dff3e:	f810 3b01 	ldrb.w	r3, [r0], #1
   dff42:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   dff46:	42a3      	cmp	r3, r4
   dff48:	d0f7      	beq.n	dff3a <memcmp+0x6>
   dff4a:	1b18      	subs	r0, r3, r4
   dff4c:	bd10      	pop	{r4, pc}
   dff4e:	2000      	movs	r0, #0
   dff50:	bd10      	pop	{r4, pc}

000dff52 <memcpy>:
   dff52:	b510      	push	{r4, lr}
   dff54:	1e43      	subs	r3, r0, #1
   dff56:	440a      	add	r2, r1
   dff58:	4291      	cmp	r1, r2
   dff5a:	d004      	beq.n	dff66 <memcpy+0x14>
   dff5c:	f811 4b01 	ldrb.w	r4, [r1], #1
   dff60:	f803 4f01 	strb.w	r4, [r3, #1]!
   dff64:	e7f8      	b.n	dff58 <memcpy+0x6>
   dff66:	bd10      	pop	{r4, pc}

000dff68 <memset>:
   dff68:	4402      	add	r2, r0
   dff6a:	4603      	mov	r3, r0
   dff6c:	4293      	cmp	r3, r2
   dff6e:	d002      	beq.n	dff76 <memset+0xe>
   dff70:	f803 1b01 	strb.w	r1, [r3], #1
   dff74:	e7fa      	b.n	dff6c <memset+0x4>
   dff76:	4770      	bx	lr

000dff78 <srand>:
   dff78:	b538      	push	{r3, r4, r5, lr}
   dff7a:	4b12      	ldr	r3, [pc, #72]	; (dffc4 <srand+0x4c>)
   dff7c:	681c      	ldr	r4, [r3, #0]
   dff7e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   dff80:	4605      	mov	r5, r0
   dff82:	b9d3      	cbnz	r3, dffba <srand+0x42>
   dff84:	2018      	movs	r0, #24
   dff86:	f7fb ff17 	bl	dbdb8 <malloc>
   dff8a:	f243 330e 	movw	r3, #13070	; 0x330e
   dff8e:	63a0      	str	r0, [r4, #56]	; 0x38
   dff90:	8003      	strh	r3, [r0, #0]
   dff92:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   dff96:	8043      	strh	r3, [r0, #2]
   dff98:	f241 2334 	movw	r3, #4660	; 0x1234
   dff9c:	8083      	strh	r3, [r0, #4]
   dff9e:	f24e 636d 	movw	r3, #58989	; 0xe66d
   dffa2:	80c3      	strh	r3, [r0, #6]
   dffa4:	f64d 63ec 	movw	r3, #57068	; 0xdeec
   dffa8:	8103      	strh	r3, [r0, #8]
   dffaa:	2305      	movs	r3, #5
   dffac:	8143      	strh	r3, [r0, #10]
   dffae:	230b      	movs	r3, #11
   dffb0:	8183      	strh	r3, [r0, #12]
   dffb2:	2201      	movs	r2, #1
   dffb4:	2300      	movs	r3, #0
   dffb6:	e9c0 2304 	strd	r2, r3, [r0, #16]
   dffba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   dffbc:	2200      	movs	r2, #0
   dffbe:	611d      	str	r5, [r3, #16]
   dffc0:	615a      	str	r2, [r3, #20]
   dffc2:	bd38      	pop	{r3, r4, r5, pc}
   dffc4:	2003daa8 	.word	0x2003daa8

000dffc8 <strchr>:
   dffc8:	b2c9      	uxtb	r1, r1
   dffca:	4603      	mov	r3, r0
   dffcc:	f810 2b01 	ldrb.w	r2, [r0], #1
   dffd0:	b11a      	cbz	r2, dffda <strchr+0x12>
   dffd2:	4291      	cmp	r1, r2
   dffd4:	d1f9      	bne.n	dffca <strchr+0x2>
   dffd6:	4618      	mov	r0, r3
   dffd8:	4770      	bx	lr
   dffda:	2900      	cmp	r1, #0
   dffdc:	bf0c      	ite	eq
   dffde:	4618      	moveq	r0, r3
   dffe0:	2000      	movne	r0, #0
   dffe2:	4770      	bx	lr

000dffe4 <strcmp>:
   dffe4:	f810 2b01 	ldrb.w	r2, [r0], #1
   dffe8:	f811 3b01 	ldrb.w	r3, [r1], #1
   dffec:	2a01      	cmp	r2, #1
   dffee:	bf28      	it	cs
   dfff0:	429a      	cmpcs	r2, r3
   dfff2:	d0f7      	beq.n	dffe4 <strcmp>
   dfff4:	1ad0      	subs	r0, r2, r3
   dfff6:	4770      	bx	lr

000dfff8 <strcpy>:
   dfff8:	4603      	mov	r3, r0
   dfffa:	f811 2b01 	ldrb.w	r2, [r1], #1
   dfffe:	f803 2b01 	strb.w	r2, [r3], #1
   e0002:	2a00      	cmp	r2, #0
   e0004:	d1f9      	bne.n	dfffa <strcpy+0x2>
   e0006:	4770      	bx	lr

000e0008 <strdup>:
   e0008:	4b02      	ldr	r3, [pc, #8]	; (e0014 <strdup+0xc>)
   e000a:	4601      	mov	r1, r0
   e000c:	6818      	ldr	r0, [r3, #0]
   e000e:	f000 b803 	b.w	e0018 <_strdup_r>
   e0012:	bf00      	nop
   e0014:	2003daa8 	.word	0x2003daa8

000e0018 <_strdup_r>:
   e0018:	b570      	push	{r4, r5, r6, lr}
   e001a:	4606      	mov	r6, r0
   e001c:	4608      	mov	r0, r1
   e001e:	460c      	mov	r4, r1
   e0020:	f000 f822 	bl	e0068 <strlen>
   e0024:	1c45      	adds	r5, r0, #1
   e0026:	4629      	mov	r1, r5
   e0028:	4630      	mov	r0, r6
   e002a:	f7fb fefd 	bl	dbe28 <_malloc_r>
   e002e:	4606      	mov	r6, r0
   e0030:	b118      	cbz	r0, e003a <_strdup_r+0x22>
   e0032:	462a      	mov	r2, r5
   e0034:	4621      	mov	r1, r4
   e0036:	f7ff ff8c 	bl	dff52 <memcpy>
   e003a:	4630      	mov	r0, r6
   e003c:	bd70      	pop	{r4, r5, r6, pc}

000e003e <strlcpy>:
   e003e:	b510      	push	{r4, lr}
   e0040:	460b      	mov	r3, r1
   e0042:	b152      	cbz	r2, e005a <strlcpy+0x1c>
   e0044:	3a01      	subs	r2, #1
   e0046:	d006      	beq.n	e0056 <strlcpy+0x18>
   e0048:	f813 4b01 	ldrb.w	r4, [r3], #1
   e004c:	f800 4b01 	strb.w	r4, [r0], #1
   e0050:	2c00      	cmp	r4, #0
   e0052:	d1f7      	bne.n	e0044 <strlcpy+0x6>
   e0054:	e005      	b.n	e0062 <strlcpy+0x24>
   e0056:	2200      	movs	r2, #0
   e0058:	7002      	strb	r2, [r0, #0]
   e005a:	f813 2b01 	ldrb.w	r2, [r3], #1
   e005e:	2a00      	cmp	r2, #0
   e0060:	d1fb      	bne.n	e005a <strlcpy+0x1c>
   e0062:	1a58      	subs	r0, r3, r1
   e0064:	3801      	subs	r0, #1
   e0066:	bd10      	pop	{r4, pc}

000e0068 <strlen>:
   e0068:	4603      	mov	r3, r0
   e006a:	f813 2b01 	ldrb.w	r2, [r3], #1
   e006e:	2a00      	cmp	r2, #0
   e0070:	d1fb      	bne.n	e006a <strlen+0x2>
   e0072:	1a18      	subs	r0, r3, r0
   e0074:	3801      	subs	r0, #1
   e0076:	4770      	bx	lr

000e0078 <strncmp>:
   e0078:	b530      	push	{r4, r5, lr}
   e007a:	b182      	cbz	r2, e009e <strncmp+0x26>
   e007c:	1e45      	subs	r5, r0, #1
   e007e:	3901      	subs	r1, #1
   e0080:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   e0084:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   e0088:	42a3      	cmp	r3, r4
   e008a:	d106      	bne.n	e009a <strncmp+0x22>
   e008c:	43ec      	mvns	r4, r5
   e008e:	4414      	add	r4, r2
   e0090:	42e0      	cmn	r0, r4
   e0092:	d001      	beq.n	e0098 <strncmp+0x20>
   e0094:	2b00      	cmp	r3, #0
   e0096:	d1f3      	bne.n	e0080 <strncmp+0x8>
   e0098:	461c      	mov	r4, r3
   e009a:	1b18      	subs	r0, r3, r4
   e009c:	bd30      	pop	{r4, r5, pc}
   e009e:	4610      	mov	r0, r2
   e00a0:	bd30      	pop	{r4, r5, pc}

000e00a2 <strncpy>:
   e00a2:	b510      	push	{r4, lr}
   e00a4:	4603      	mov	r3, r0
   e00a6:	b142      	cbz	r2, e00ba <strncpy+0x18>
   e00a8:	f811 4b01 	ldrb.w	r4, [r1], #1
   e00ac:	f803 4b01 	strb.w	r4, [r3], #1
   e00b0:	3a01      	subs	r2, #1
   e00b2:	2c00      	cmp	r4, #0
   e00b4:	d1f7      	bne.n	e00a6 <strncpy+0x4>
   e00b6:	441a      	add	r2, r3
   e00b8:	e000      	b.n	e00bc <strncpy+0x1a>
   e00ba:	bd10      	pop	{r4, pc}
   e00bc:	4293      	cmp	r3, r2
   e00be:	d002      	beq.n	e00c6 <strncpy+0x24>
   e00c0:	f803 4b01 	strb.w	r4, [r3], #1
   e00c4:	e7fa      	b.n	e00bc <strncpy+0x1a>
   e00c6:	bd10      	pop	{r4, pc}

000e00c8 <strtok>:
   e00c8:	4b17      	ldr	r3, [pc, #92]	; (e0128 <strtok+0x60>)
   e00ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   e00ce:	681d      	ldr	r5, [r3, #0]
   e00d0:	6dac      	ldr	r4, [r5, #88]	; 0x58
   e00d2:	4606      	mov	r6, r0
   e00d4:	460f      	mov	r7, r1
   e00d6:	b9fc      	cbnz	r4, e0118 <strtok+0x50>
   e00d8:	2050      	movs	r0, #80	; 0x50
   e00da:	f7fb fe6d 	bl	dbdb8 <malloc>
   e00de:	65a8      	str	r0, [r5, #88]	; 0x58
   e00e0:	6084      	str	r4, [r0, #8]
   e00e2:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e00e4:	6004      	str	r4, [r0, #0]
   e00e6:	6044      	str	r4, [r0, #4]
   e00e8:	611c      	str	r4, [r3, #16]
   e00ea:	60dc      	str	r4, [r3, #12]
   e00ec:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e00ee:	619c      	str	r4, [r3, #24]
   e00f0:	615c      	str	r4, [r3, #20]
   e00f2:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e00f4:	62dc      	str	r4, [r3, #44]	; 0x2c
   e00f6:	629c      	str	r4, [r3, #40]	; 0x28
   e00f8:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e00fa:	635c      	str	r4, [r3, #52]	; 0x34
   e00fc:	631c      	str	r4, [r3, #48]	; 0x30
   e00fe:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e0100:	63dc      	str	r4, [r3, #60]	; 0x3c
   e0102:	639c      	str	r4, [r3, #56]	; 0x38
   e0104:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e0106:	645c      	str	r4, [r3, #68]	; 0x44
   e0108:	641c      	str	r4, [r3, #64]	; 0x40
   e010a:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e010c:	64dc      	str	r4, [r3, #76]	; 0x4c
   e010e:	649c      	str	r4, [r3, #72]	; 0x48
   e0110:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e0112:	771c      	strb	r4, [r3, #28]
   e0114:	6dab      	ldr	r3, [r5, #88]	; 0x58
   e0116:	625c      	str	r4, [r3, #36]	; 0x24
   e0118:	6daa      	ldr	r2, [r5, #88]	; 0x58
   e011a:	4639      	mov	r1, r7
   e011c:	4630      	mov	r0, r6
   e011e:	2301      	movs	r3, #1
   e0120:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   e0124:	f000 b802 	b.w	e012c <__strtok_r>
   e0128:	2003daa8 	.word	0x2003daa8

000e012c <__strtok_r>:
   e012c:	b5f0      	push	{r4, r5, r6, r7, lr}
   e012e:	b948      	cbnz	r0, e0144 <__strtok_r+0x18>
   e0130:	6810      	ldr	r0, [r2, #0]
   e0132:	b938      	cbnz	r0, e0144 <__strtok_r+0x18>
   e0134:	bdf0      	pop	{r4, r5, r6, r7, pc}
   e0136:	f817 6b01 	ldrb.w	r6, [r7], #1
   e013a:	b15e      	cbz	r6, e0154 <__strtok_r+0x28>
   e013c:	42b5      	cmp	r5, r6
   e013e:	d1fa      	bne.n	e0136 <__strtok_r+0xa>
   e0140:	b12b      	cbz	r3, e014e <__strtok_r+0x22>
   e0142:	4620      	mov	r0, r4
   e0144:	4604      	mov	r4, r0
   e0146:	460f      	mov	r7, r1
   e0148:	f814 5b01 	ldrb.w	r5, [r4], #1
   e014c:	e7f3      	b.n	e0136 <__strtok_r+0xa>
   e014e:	6014      	str	r4, [r2, #0]
   e0150:	7003      	strb	r3, [r0, #0]
   e0152:	bdf0      	pop	{r4, r5, r6, r7, pc}
   e0154:	b94d      	cbnz	r5, e016a <__strtok_r+0x3e>
   e0156:	6015      	str	r5, [r2, #0]
   e0158:	4628      	mov	r0, r5
   e015a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   e015c:	f817 6b01 	ldrb.w	r6, [r7], #1
   e0160:	42b5      	cmp	r5, r6
   e0162:	d007      	beq.n	e0174 <__strtok_r+0x48>
   e0164:	2e00      	cmp	r6, #0
   e0166:	d1f9      	bne.n	e015c <__strtok_r+0x30>
   e0168:	461c      	mov	r4, r3
   e016a:	4623      	mov	r3, r4
   e016c:	460f      	mov	r7, r1
   e016e:	f813 5b01 	ldrb.w	r5, [r3], #1
   e0172:	e7f3      	b.n	e015c <__strtok_r+0x30>
   e0174:	b115      	cbz	r5, e017c <__strtok_r+0x50>
   e0176:	2100      	movs	r1, #0
   e0178:	7021      	strb	r1, [r4, #0]
   e017a:	e000      	b.n	e017e <__strtok_r+0x52>
   e017c:	462b      	mov	r3, r5
   e017e:	6013      	str	r3, [r2, #0]
   e0180:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000e0184 <_strtol_r>:
   e0184:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   e0188:	4680      	mov	r8, r0
   e018a:	4840      	ldr	r0, [pc, #256]	; (e028c <_strtol_r+0x108>)
   e018c:	f8d0 9000 	ldr.w	r9, [r0]
   e0190:	460f      	mov	r7, r1
   e0192:	463d      	mov	r5, r7
   e0194:	f815 4b01 	ldrb.w	r4, [r5], #1
   e0198:	eb09 0004 	add.w	r0, r9, r4
   e019c:	7840      	ldrb	r0, [r0, #1]
   e019e:	f000 0008 	and.w	r0, r0, #8
   e01a2:	f000 06ff 	and.w	r6, r0, #255	; 0xff
   e01a6:	b108      	cbz	r0, e01ac <_strtol_r+0x28>
   e01a8:	462f      	mov	r7, r5
   e01aa:	e7f2      	b.n	e0192 <_strtol_r+0xe>
   e01ac:	2c2d      	cmp	r4, #45	; 0x2d
   e01ae:	d103      	bne.n	e01b8 <_strtol_r+0x34>
   e01b0:	1cbd      	adds	r5, r7, #2
   e01b2:	787c      	ldrb	r4, [r7, #1]
   e01b4:	2601      	movs	r6, #1
   e01b6:	e003      	b.n	e01c0 <_strtol_r+0x3c>
   e01b8:	2c2b      	cmp	r4, #43	; 0x2b
   e01ba:	bf04      	itt	eq
   e01bc:	787c      	ldrbeq	r4, [r7, #1]
   e01be:	1cbd      	addeq	r5, r7, #2
   e01c0:	b113      	cbz	r3, e01c8 <_strtol_r+0x44>
   e01c2:	2b10      	cmp	r3, #16
   e01c4:	d10a      	bne.n	e01dc <_strtol_r+0x58>
   e01c6:	e05b      	b.n	e0280 <_strtol_r+0xfc>
   e01c8:	2c30      	cmp	r4, #48	; 0x30
   e01ca:	d157      	bne.n	e027c <_strtol_r+0xf8>
   e01cc:	7828      	ldrb	r0, [r5, #0]
   e01ce:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   e01d2:	2858      	cmp	r0, #88	; 0x58
   e01d4:	d14d      	bne.n	e0272 <_strtol_r+0xee>
   e01d6:	786c      	ldrb	r4, [r5, #1]
   e01d8:	2310      	movs	r3, #16
   e01da:	3502      	adds	r5, #2
   e01dc:	2e00      	cmp	r6, #0
   e01de:	bf14      	ite	ne
   e01e0:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   e01e4:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   e01e8:	2700      	movs	r7, #0
   e01ea:	fbbc faf3 	udiv	sl, ip, r3
   e01ee:	4638      	mov	r0, r7
   e01f0:	fb03 cc1a 	mls	ip, r3, sl, ip
   e01f4:	eb09 0e04 	add.w	lr, r9, r4
   e01f8:	f89e e001 	ldrb.w	lr, [lr, #1]
   e01fc:	f01e 0f04 	tst.w	lr, #4
   e0200:	d001      	beq.n	e0206 <_strtol_r+0x82>
   e0202:	3c30      	subs	r4, #48	; 0x30
   e0204:	e00b      	b.n	e021e <_strtol_r+0x9a>
   e0206:	f01e 0e03 	ands.w	lr, lr, #3
   e020a:	d01b      	beq.n	e0244 <_strtol_r+0xc0>
   e020c:	f1be 0f01 	cmp.w	lr, #1
   e0210:	bf0c      	ite	eq
   e0212:	f04f 0e37 	moveq.w	lr, #55	; 0x37
   e0216:	f04f 0e57 	movne.w	lr, #87	; 0x57
   e021a:	ebce 0404 	rsb	r4, lr, r4
   e021e:	42a3      	cmp	r3, r4
   e0220:	dd10      	ble.n	e0244 <_strtol_r+0xc0>
   e0222:	f1b7 3fff 	cmp.w	r7, #4294967295
   e0226:	d00a      	beq.n	e023e <_strtol_r+0xba>
   e0228:	4550      	cmp	r0, sl
   e022a:	d806      	bhi.n	e023a <_strtol_r+0xb6>
   e022c:	d101      	bne.n	e0232 <_strtol_r+0xae>
   e022e:	4564      	cmp	r4, ip
   e0230:	dc03      	bgt.n	e023a <_strtol_r+0xb6>
   e0232:	fb03 4000 	mla	r0, r3, r0, r4
   e0236:	2701      	movs	r7, #1
   e0238:	e001      	b.n	e023e <_strtol_r+0xba>
   e023a:	f04f 37ff 	mov.w	r7, #4294967295
   e023e:	f815 4b01 	ldrb.w	r4, [r5], #1
   e0242:	e7d7      	b.n	e01f4 <_strtol_r+0x70>
   e0244:	1c7b      	adds	r3, r7, #1
   e0246:	d10c      	bne.n	e0262 <_strtol_r+0xde>
   e0248:	2e00      	cmp	r6, #0
   e024a:	f04f 0322 	mov.w	r3, #34	; 0x22
   e024e:	bf14      	ite	ne
   e0250:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
   e0254:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   e0258:	f8c8 3000 	str.w	r3, [r8]
   e025c:	b92a      	cbnz	r2, e026a <_strtol_r+0xe6>
   e025e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e0262:	b106      	cbz	r6, e0266 <_strtol_r+0xe2>
   e0264:	4240      	negs	r0, r0
   e0266:	b172      	cbz	r2, e0286 <_strtol_r+0x102>
   e0268:	b107      	cbz	r7, e026c <_strtol_r+0xe8>
   e026a:	1e69      	subs	r1, r5, #1
   e026c:	6011      	str	r1, [r2, #0]
   e026e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e0272:	2430      	movs	r4, #48	; 0x30
   e0274:	2b00      	cmp	r3, #0
   e0276:	d1b1      	bne.n	e01dc <_strtol_r+0x58>
   e0278:	2308      	movs	r3, #8
   e027a:	e7af      	b.n	e01dc <_strtol_r+0x58>
   e027c:	230a      	movs	r3, #10
   e027e:	e7ad      	b.n	e01dc <_strtol_r+0x58>
   e0280:	2c30      	cmp	r4, #48	; 0x30
   e0282:	d0a3      	beq.n	e01cc <_strtol_r+0x48>
   e0284:	e7aa      	b.n	e01dc <_strtol_r+0x58>
   e0286:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e028a:	bf00      	nop
   e028c:	2003da44 	.word	0x2003da44

000e0290 <strtol>:
   e0290:	4613      	mov	r3, r2
   e0292:	460a      	mov	r2, r1
   e0294:	4601      	mov	r1, r0
   e0296:	4802      	ldr	r0, [pc, #8]	; (e02a0 <strtol+0x10>)
   e0298:	6800      	ldr	r0, [r0, #0]
   e029a:	f7ff bf73 	b.w	e0184 <_strtol_r>
   e029e:	bf00      	nop
   e02a0:	2003daa8 	.word	0x2003daa8

000e02a4 <_strtoul_r>:
   e02a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   e02a8:	4680      	mov	r8, r0
   e02aa:	483c      	ldr	r0, [pc, #240]	; (e039c <_strtoul_r+0xf8>)
   e02ac:	f8d0 9000 	ldr.w	r9, [r0]
   e02b0:	460e      	mov	r6, r1
   e02b2:	4635      	mov	r5, r6
   e02b4:	f815 4b01 	ldrb.w	r4, [r5], #1
   e02b8:	eb09 0004 	add.w	r0, r9, r4
   e02bc:	7840      	ldrb	r0, [r0, #1]
   e02be:	f000 0008 	and.w	r0, r0, #8
   e02c2:	f000 07ff 	and.w	r7, r0, #255	; 0xff
   e02c6:	b108      	cbz	r0, e02cc <_strtoul_r+0x28>
   e02c8:	462e      	mov	r6, r5
   e02ca:	e7f2      	b.n	e02b2 <_strtoul_r+0xe>
   e02cc:	2c2d      	cmp	r4, #45	; 0x2d
   e02ce:	d103      	bne.n	e02d8 <_strtoul_r+0x34>
   e02d0:	1cb5      	adds	r5, r6, #2
   e02d2:	7874      	ldrb	r4, [r6, #1]
   e02d4:	2701      	movs	r7, #1
   e02d6:	e003      	b.n	e02e0 <_strtoul_r+0x3c>
   e02d8:	2c2b      	cmp	r4, #43	; 0x2b
   e02da:	bf04      	itt	eq
   e02dc:	7874      	ldrbeq	r4, [r6, #1]
   e02de:	1cb5      	addeq	r5, r6, #2
   e02e0:	b113      	cbz	r3, e02e8 <_strtoul_r+0x44>
   e02e2:	2b10      	cmp	r3, #16
   e02e4:	d10a      	bne.n	e02fc <_strtoul_r+0x58>
   e02e6:	e053      	b.n	e0390 <_strtoul_r+0xec>
   e02e8:	2c30      	cmp	r4, #48	; 0x30
   e02ea:	d14f      	bne.n	e038c <_strtoul_r+0xe8>
   e02ec:	7828      	ldrb	r0, [r5, #0]
   e02ee:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   e02f2:	2858      	cmp	r0, #88	; 0x58
   e02f4:	d145      	bne.n	e0382 <_strtoul_r+0xde>
   e02f6:	786c      	ldrb	r4, [r5, #1]
   e02f8:	2310      	movs	r3, #16
   e02fa:	3502      	adds	r5, #2
   e02fc:	f04f 3cff 	mov.w	ip, #4294967295
   e0300:	2600      	movs	r6, #0
   e0302:	fbbc fcf3 	udiv	ip, ip, r3
   e0306:	fb03 fa0c 	mul.w	sl, r3, ip
   e030a:	ea6f 0a0a 	mvn.w	sl, sl
   e030e:	4630      	mov	r0, r6
   e0310:	eb09 0e04 	add.w	lr, r9, r4
   e0314:	f89e e001 	ldrb.w	lr, [lr, #1]
   e0318:	f01e 0f04 	tst.w	lr, #4
   e031c:	d001      	beq.n	e0322 <_strtoul_r+0x7e>
   e031e:	3c30      	subs	r4, #48	; 0x30
   e0320:	e00b      	b.n	e033a <_strtoul_r+0x96>
   e0322:	f01e 0e03 	ands.w	lr, lr, #3
   e0326:	d01a      	beq.n	e035e <_strtoul_r+0xba>
   e0328:	f1be 0f01 	cmp.w	lr, #1
   e032c:	bf0c      	ite	eq
   e032e:	f04f 0e37 	moveq.w	lr, #55	; 0x37
   e0332:	f04f 0e57 	movne.w	lr, #87	; 0x57
   e0336:	ebce 0404 	rsb	r4, lr, r4
   e033a:	42a3      	cmp	r3, r4
   e033c:	dd0f      	ble.n	e035e <_strtoul_r+0xba>
   e033e:	2e00      	cmp	r6, #0
   e0340:	db08      	blt.n	e0354 <_strtoul_r+0xb0>
   e0342:	4560      	cmp	r0, ip
   e0344:	d806      	bhi.n	e0354 <_strtoul_r+0xb0>
   e0346:	d101      	bne.n	e034c <_strtoul_r+0xa8>
   e0348:	4554      	cmp	r4, sl
   e034a:	dc03      	bgt.n	e0354 <_strtoul_r+0xb0>
   e034c:	fb03 4000 	mla	r0, r3, r0, r4
   e0350:	2601      	movs	r6, #1
   e0352:	e001      	b.n	e0358 <_strtoul_r+0xb4>
   e0354:	f04f 36ff 	mov.w	r6, #4294967295
   e0358:	f815 4b01 	ldrb.w	r4, [r5], #1
   e035c:	e7d8      	b.n	e0310 <_strtoul_r+0x6c>
   e035e:	2e00      	cmp	r6, #0
   e0360:	da07      	bge.n	e0372 <_strtoul_r+0xce>
   e0362:	2322      	movs	r3, #34	; 0x22
   e0364:	f8c8 3000 	str.w	r3, [r8]
   e0368:	f04f 30ff 	mov.w	r0, #4294967295
   e036c:	b92a      	cbnz	r2, e037a <_strtoul_r+0xd6>
   e036e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e0372:	b107      	cbz	r7, e0376 <_strtoul_r+0xd2>
   e0374:	4240      	negs	r0, r0
   e0376:	b172      	cbz	r2, e0396 <_strtoul_r+0xf2>
   e0378:	b106      	cbz	r6, e037c <_strtoul_r+0xd8>
   e037a:	1e69      	subs	r1, r5, #1
   e037c:	6011      	str	r1, [r2, #0]
   e037e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e0382:	2430      	movs	r4, #48	; 0x30
   e0384:	2b00      	cmp	r3, #0
   e0386:	d1b9      	bne.n	e02fc <_strtoul_r+0x58>
   e0388:	2308      	movs	r3, #8
   e038a:	e7b7      	b.n	e02fc <_strtoul_r+0x58>
   e038c:	230a      	movs	r3, #10
   e038e:	e7b5      	b.n	e02fc <_strtoul_r+0x58>
   e0390:	2c30      	cmp	r4, #48	; 0x30
   e0392:	d0ab      	beq.n	e02ec <_strtoul_r+0x48>
   e0394:	e7b2      	b.n	e02fc <_strtoul_r+0x58>
   e0396:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   e039a:	bf00      	nop
   e039c:	2003da44 	.word	0x2003da44

000e03a0 <strtoul>:
   e03a0:	4613      	mov	r3, r2
   e03a2:	460a      	mov	r2, r1
   e03a4:	4601      	mov	r1, r0
   e03a6:	4802      	ldr	r0, [pc, #8]	; (e03b0 <strtoul+0x10>)
   e03a8:	6800      	ldr	r0, [r0, #0]
   e03aa:	f7ff bf7b 	b.w	e02a4 <_strtoul_r>
   e03ae:	bf00      	nop
   e03b0:	2003daa8 	.word	0x2003daa8

000e03b4 <__tzcalc_limits>:
   e03b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   e03b8:	4604      	mov	r4, r0
   e03ba:	f000 fa6f 	bl	e089c <__gettzinfo>
   e03be:	f240 73b1 	movw	r3, #1969	; 0x7b1
   e03c2:	429c      	cmp	r4, r3
   e03c4:	f340 8096 	ble.w	e04f4 <__tzcalc_limits+0x140>
   e03c8:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
   e03cc:	18e3      	adds	r3, r4, r3
   e03ce:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
   e03d2:	109b      	asrs	r3, r3, #2
   e03d4:	f240 156d 	movw	r5, #365	; 0x16d
   e03d8:	fb05 3502 	mla	r5, r5, r2, r3
   e03dc:	f2a4 726d 	subw	r2, r4, #1901	; 0x76d
   e03e0:	f06f 0363 	mvn.w	r3, #99	; 0x63
   e03e4:	fb92 f3f3 	sdiv	r3, r2, r3
   e03e8:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
   e03ec:	442b      	add	r3, r5
   e03ee:	18a5      	adds	r5, r4, r2
   e03f0:	f44f 72c8 	mov.w	r2, #400	; 0x190
   e03f4:	fb95 f5f2 	sdiv	r5, r5, r2
   e03f8:	441d      	add	r5, r3
   e03fa:	2364      	movs	r3, #100	; 0x64
   e03fc:	fb94 f7f2 	sdiv	r7, r4, r2
   e0400:	fb94 f6f3 	sdiv	r6, r4, r3
   e0404:	fb02 4717 	mls	r7, r2, r7, r4
   e0408:	fb03 4616 	mls	r6, r3, r6, r4
   e040c:	f100 0338 	add.w	r3, r0, #56	; 0x38
   e0410:	fab7 fe87 	clz	lr, r7
   e0414:	9301      	str	r3, [sp, #4]
   e0416:	f004 0303 	and.w	r3, r4, #3
   e041a:	6044      	str	r4, [r0, #4]
   e041c:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
   e0420:	4601      	mov	r1, r0
   e0422:	9300      	str	r3, [sp, #0]
   e0424:	f04f 0c07 	mov.w	ip, #7
   e0428:	7a0b      	ldrb	r3, [r1, #8]
   e042a:	2b4a      	cmp	r3, #74	; 0x4a
   e042c:	d10e      	bne.n	e044c <__tzcalc_limits+0x98>
   e042e:	694b      	ldr	r3, [r1, #20]
   e0430:	9a00      	ldr	r2, [sp, #0]
   e0432:	18ec      	adds	r4, r5, r3
   e0434:	b902      	cbnz	r2, e0438 <__tzcalc_limits+0x84>
   e0436:	b906      	cbnz	r6, e043a <__tzcalc_limits+0x86>
   e0438:	b927      	cbnz	r7, e0444 <__tzcalc_limits+0x90>
   e043a:	2b3b      	cmp	r3, #59	; 0x3b
   e043c:	bfd4      	ite	le
   e043e:	2300      	movle	r3, #0
   e0440:	2301      	movgt	r3, #1
   e0442:	e000      	b.n	e0446 <__tzcalc_limits+0x92>
   e0444:	2300      	movs	r3, #0
   e0446:	4423      	add	r3, r4
   e0448:	3b01      	subs	r3, #1
   e044a:	e03f      	b.n	e04cc <__tzcalc_limits+0x118>
   e044c:	2b44      	cmp	r3, #68	; 0x44
   e044e:	d102      	bne.n	e0456 <__tzcalc_limits+0xa2>
   e0450:	694b      	ldr	r3, [r1, #20]
   e0452:	442b      	add	r3, r5
   e0454:	e03a      	b.n	e04cc <__tzcalc_limits+0x118>
   e0456:	9b00      	ldr	r3, [sp, #0]
   e0458:	b92b      	cbnz	r3, e0466 <__tzcalc_limits+0xb2>
   e045a:	2e00      	cmp	r6, #0
   e045c:	bf0c      	ite	eq
   e045e:	46f0      	moveq	r8, lr
   e0460:	f04f 0801 	movne.w	r8, #1
   e0464:	e000      	b.n	e0468 <__tzcalc_limits+0xb4>
   e0466:	46f0      	mov	r8, lr
   e0468:	4b24      	ldr	r3, [pc, #144]	; (e04fc <__tzcalc_limits+0x148>)
   e046a:	68cc      	ldr	r4, [r1, #12]
   e046c:	2230      	movs	r2, #48	; 0x30
   e046e:	fb02 3808 	mla	r8, r2, r8, r3
   e0472:	f1a8 0a04 	sub.w	sl, r8, #4
   e0476:	46a9      	mov	r9, r5
   e0478:	2301      	movs	r3, #1
   e047a:	42a3      	cmp	r3, r4
   e047c:	da04      	bge.n	e0488 <__tzcalc_limits+0xd4>
   e047e:	f85a bf04 	ldr.w	fp, [sl, #4]!
   e0482:	3301      	adds	r3, #1
   e0484:	44d9      	add	r9, fp
   e0486:	e7f8      	b.n	e047a <__tzcalc_limits+0xc6>
   e0488:	f109 0304 	add.w	r3, r9, #4
   e048c:	fb93 fbfc 	sdiv	fp, r3, ip
   e0490:	ebcb 0acb 	rsb	sl, fp, fp, lsl #3
   e0494:	2c01      	cmp	r4, #1
   e0496:	ebca 0a03 	rsb	sl, sl, r3
   e049a:	694b      	ldr	r3, [r1, #20]
   e049c:	bfb8      	it	lt
   e049e:	2401      	movlt	r4, #1
   e04a0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   e04a4:	ebb3 0a0a 	subs.w	sl, r3, sl
   e04a8:	690b      	ldr	r3, [r1, #16]
   e04aa:	f104 34ff 	add.w	r4, r4, #4294967295
   e04ae:	f103 33ff 	add.w	r3, r3, #4294967295
   e04b2:	bf48      	it	mi
   e04b4:	f10a 0a07 	addmi.w	sl, sl, #7
   e04b8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   e04bc:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
   e04c0:	4453      	add	r3, sl
   e04c2:	42a3      	cmp	r3, r4
   e04c4:	db01      	blt.n	e04ca <__tzcalc_limits+0x116>
   e04c6:	3b07      	subs	r3, #7
   e04c8:	e7fb      	b.n	e04c2 <__tzcalc_limits+0x10e>
   e04ca:	444b      	add	r3, r9
   e04cc:	698c      	ldr	r4, [r1, #24]
   e04ce:	4a0c      	ldr	r2, [pc, #48]	; (e0500 <__tzcalc_limits+0x14c>)
   e04d0:	fb02 4303 	mla	r3, r2, r3, r4
   e04d4:	6a0c      	ldr	r4, [r1, #32]
   e04d6:	4423      	add	r3, r4
   e04d8:	f841 3f1c 	str.w	r3, [r1, #28]!
   e04dc:	9b01      	ldr	r3, [sp, #4]
   e04de:	4299      	cmp	r1, r3
   e04e0:	d1a2      	bne.n	e0428 <__tzcalc_limits+0x74>
   e04e2:	69c3      	ldr	r3, [r0, #28]
   e04e4:	6b82      	ldr	r2, [r0, #56]	; 0x38
   e04e6:	4293      	cmp	r3, r2
   e04e8:	bfac      	ite	ge
   e04ea:	2300      	movge	r3, #0
   e04ec:	2301      	movlt	r3, #1
   e04ee:	6003      	str	r3, [r0, #0]
   e04f0:	2001      	movs	r0, #1
   e04f2:	e000      	b.n	e04f6 <__tzcalc_limits+0x142>
   e04f4:	2000      	movs	r0, #0
   e04f6:	b003      	add	sp, #12
   e04f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   e04fc:	000e2a80 	.word	0x000e2a80
   e0500:	00015180 	.word	0x00015180

000e0504 <__tz_lock>:
   e0504:	4770      	bx	lr

000e0506 <__tz_unlock>:
   e0506:	4770      	bx	lr

000e0508 <_tzset_unlocked>:
   e0508:	4b01      	ldr	r3, [pc, #4]	; (e0510 <_tzset_unlocked+0x8>)
   e050a:	6818      	ldr	r0, [r3, #0]
   e050c:	f000 b802 	b.w	e0514 <_tzset_unlocked_r>
   e0510:	2003daa8 	.word	0x2003daa8

000e0514 <_tzset_unlocked_r>:
   e0514:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   e0518:	b08d      	sub	sp, #52	; 0x34
   e051a:	4607      	mov	r7, r0
   e051c:	f000 f9be 	bl	e089c <__gettzinfo>
   e0520:	49b0      	ldr	r1, [pc, #704]	; (e07e4 <_tzset_unlocked_r+0x2d0>)
   e0522:	4eb1      	ldr	r6, [pc, #708]	; (e07e8 <_tzset_unlocked_r+0x2d4>)
   e0524:	4604      	mov	r4, r0
   e0526:	4638      	mov	r0, r7
   e0528:	f000 f9b0 	bl	e088c <_getenv_r>
   e052c:	4605      	mov	r5, r0
   e052e:	b960      	cbnz	r0, e054a <_tzset_unlocked_r+0x36>
   e0530:	4bae      	ldr	r3, [pc, #696]	; (e07ec <_tzset_unlocked_r+0x2d8>)
   e0532:	4aaf      	ldr	r2, [pc, #700]	; (e07f0 <_tzset_unlocked_r+0x2dc>)
   e0534:	6018      	str	r0, [r3, #0]
   e0536:	4baf      	ldr	r3, [pc, #700]	; (e07f4 <_tzset_unlocked_r+0x2e0>)
   e0538:	6018      	str	r0, [r3, #0]
   e053a:	4baf      	ldr	r3, [pc, #700]	; (e07f8 <_tzset_unlocked_r+0x2e4>)
   e053c:	6830      	ldr	r0, [r6, #0]
   e053e:	601a      	str	r2, [r3, #0]
   e0540:	605a      	str	r2, [r3, #4]
   e0542:	f7fb fc41 	bl	dbdc8 <free>
   e0546:	6035      	str	r5, [r6, #0]
   e0548:	e148      	b.n	e07dc <_tzset_unlocked_r+0x2c8>
   e054a:	6831      	ldr	r1, [r6, #0]
   e054c:	b979      	cbnz	r1, e056e <_tzset_unlocked_r+0x5a>
   e054e:	6830      	ldr	r0, [r6, #0]
   e0550:	f7fb fc3a 	bl	dbdc8 <free>
   e0554:	4628      	mov	r0, r5
   e0556:	f7ff fd87 	bl	e0068 <strlen>
   e055a:	1c41      	adds	r1, r0, #1
   e055c:	4638      	mov	r0, r7
   e055e:	f7fb fc63 	bl	dbe28 <_malloc_r>
   e0562:	6030      	str	r0, [r6, #0]
   e0564:	b148      	cbz	r0, e057a <_tzset_unlocked_r+0x66>
   e0566:	4629      	mov	r1, r5
   e0568:	f7ff fd46 	bl	dfff8 <strcpy>
   e056c:	e005      	b.n	e057a <_tzset_unlocked_r+0x66>
   e056e:	f7ff fd39 	bl	dffe4 <strcmp>
   e0572:	2800      	cmp	r0, #0
   e0574:	f000 8132 	beq.w	e07dc <_tzset_unlocked_r+0x2c8>
   e0578:	e7e9      	b.n	e054e <_tzset_unlocked_r+0x3a>
   e057a:	782b      	ldrb	r3, [r5, #0]
   e057c:	4a9f      	ldr	r2, [pc, #636]	; (e07fc <_tzset_unlocked_r+0x2e8>)
   e057e:	49a0      	ldr	r1, [pc, #640]	; (e0800 <_tzset_unlocked_r+0x2ec>)
   e0580:	2b3a      	cmp	r3, #58	; 0x3a
   e0582:	bf08      	it	eq
   e0584:	3501      	addeq	r5, #1
   e0586:	ae0a      	add	r6, sp, #40	; 0x28
   e0588:	4633      	mov	r3, r6
   e058a:	4628      	mov	r0, r5
   e058c:	f7fb fc34 	bl	dbdf8 <siscanf>
   e0590:	2800      	cmp	r0, #0
   e0592:	f340 8123 	ble.w	e07dc <_tzset_unlocked_r+0x2c8>
   e0596:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   e0598:	18ef      	adds	r7, r5, r3
   e059a:	5ceb      	ldrb	r3, [r5, r3]
   e059c:	2b2d      	cmp	r3, #45	; 0x2d
   e059e:	d103      	bne.n	e05a8 <_tzset_unlocked_r+0x94>
   e05a0:	3701      	adds	r7, #1
   e05a2:	f04f 35ff 	mov.w	r5, #4294967295
   e05a6:	e003      	b.n	e05b0 <_tzset_unlocked_r+0x9c>
   e05a8:	2b2b      	cmp	r3, #43	; 0x2b
   e05aa:	bf08      	it	eq
   e05ac:	3701      	addeq	r7, #1
   e05ae:	2501      	movs	r5, #1
   e05b0:	f10d 0a20 	add.w	sl, sp, #32
   e05b4:	f10d 0b1e 	add.w	fp, sp, #30
   e05b8:	f04f 0800 	mov.w	r8, #0
   e05bc:	9603      	str	r6, [sp, #12]
   e05be:	f8cd a008 	str.w	sl, [sp, #8]
   e05c2:	9601      	str	r6, [sp, #4]
   e05c4:	f8cd b000 	str.w	fp, [sp]
   e05c8:	4633      	mov	r3, r6
   e05ca:	aa07      	add	r2, sp, #28
   e05cc:	498d      	ldr	r1, [pc, #564]	; (e0804 <_tzset_unlocked_r+0x2f0>)
   e05ce:	f8ad 801e 	strh.w	r8, [sp, #30]
   e05d2:	4638      	mov	r0, r7
   e05d4:	f8ad 8020 	strh.w	r8, [sp, #32]
   e05d8:	f7fb fc0e 	bl	dbdf8 <siscanf>
   e05dc:	4540      	cmp	r0, r8
   e05de:	f340 80fd 	ble.w	e07dc <_tzset_unlocked_r+0x2c8>
   e05e2:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   e05e6:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   e05ea:	f8df 9224 	ldr.w	r9, [pc, #548]	; e0810 <_tzset_unlocked_r+0x2fc>
   e05ee:	213c      	movs	r1, #60	; 0x3c
   e05f0:	fb01 3302 	mla	r3, r1, r2, r3
   e05f4:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   e05f8:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   e05fc:	fb01 3302 	mla	r3, r1, r2, r3
   e0600:	435d      	muls	r5, r3
   e0602:	6225      	str	r5, [r4, #32]
   e0604:	4d7c      	ldr	r5, [pc, #496]	; (e07f8 <_tzset_unlocked_r+0x2e4>)
   e0606:	4b7d      	ldr	r3, [pc, #500]	; (e07fc <_tzset_unlocked_r+0x2e8>)
   e0608:	602b      	str	r3, [r5, #0]
   e060a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   e060c:	497c      	ldr	r1, [pc, #496]	; (e0800 <_tzset_unlocked_r+0x2ec>)
   e060e:	441f      	add	r7, r3
   e0610:	464a      	mov	r2, r9
   e0612:	4633      	mov	r3, r6
   e0614:	4638      	mov	r0, r7
   e0616:	f7fb fbef 	bl	dbdf8 <siscanf>
   e061a:	4540      	cmp	r0, r8
   e061c:	dc08      	bgt.n	e0630 <_tzset_unlocked_r+0x11c>
   e061e:	682b      	ldr	r3, [r5, #0]
   e0620:	606b      	str	r3, [r5, #4]
   e0622:	4b72      	ldr	r3, [pc, #456]	; (e07ec <_tzset_unlocked_r+0x2d8>)
   e0624:	6a22      	ldr	r2, [r4, #32]
   e0626:	601a      	str	r2, [r3, #0]
   e0628:	4b72      	ldr	r3, [pc, #456]	; (e07f4 <_tzset_unlocked_r+0x2e0>)
   e062a:	f8c3 8000 	str.w	r8, [r3]
   e062e:	e0d5      	b.n	e07dc <_tzset_unlocked_r+0x2c8>
   e0630:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   e0632:	f8c5 9004 	str.w	r9, [r5, #4]
   e0636:	18fd      	adds	r5, r7, r3
   e0638:	5cfb      	ldrb	r3, [r7, r3]
   e063a:	2b2d      	cmp	r3, #45	; 0x2d
   e063c:	d103      	bne.n	e0646 <_tzset_unlocked_r+0x132>
   e063e:	3501      	adds	r5, #1
   e0640:	f04f 37ff 	mov.w	r7, #4294967295
   e0644:	e003      	b.n	e064e <_tzset_unlocked_r+0x13a>
   e0646:	2b2b      	cmp	r3, #43	; 0x2b
   e0648:	bf08      	it	eq
   e064a:	3501      	addeq	r5, #1
   e064c:	2701      	movs	r7, #1
   e064e:	2300      	movs	r3, #0
   e0650:	f8ad 301c 	strh.w	r3, [sp, #28]
   e0654:	f8ad 301e 	strh.w	r3, [sp, #30]
   e0658:	f8ad 3020 	strh.w	r3, [sp, #32]
   e065c:	930a      	str	r3, [sp, #40]	; 0x28
   e065e:	9603      	str	r6, [sp, #12]
   e0660:	f8cd a008 	str.w	sl, [sp, #8]
   e0664:	9601      	str	r6, [sp, #4]
   e0666:	f8cd b000 	str.w	fp, [sp]
   e066a:	4633      	mov	r3, r6
   e066c:	aa07      	add	r2, sp, #28
   e066e:	4965      	ldr	r1, [pc, #404]	; (e0804 <_tzset_unlocked_r+0x2f0>)
   e0670:	4628      	mov	r0, r5
   e0672:	f7fb fbc1 	bl	dbdf8 <siscanf>
   e0676:	2800      	cmp	r0, #0
   e0678:	dc04      	bgt.n	e0684 <_tzset_unlocked_r+0x170>
   e067a:	6a23      	ldr	r3, [r4, #32]
   e067c:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
   e0680:	63e3      	str	r3, [r4, #60]	; 0x3c
   e0682:	e00e      	b.n	e06a2 <_tzset_unlocked_r+0x18e>
   e0684:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   e0688:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   e068c:	213c      	movs	r1, #60	; 0x3c
   e068e:	fb01 3302 	mla	r3, r1, r2, r3
   e0692:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   e0696:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   e069a:	fb01 3302 	mla	r3, r1, r2, r3
   e069e:	435f      	muls	r7, r3
   e06a0:	63e7      	str	r7, [r4, #60]	; 0x3c
   e06a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   e06a4:	4627      	mov	r7, r4
   e06a6:	441d      	add	r5, r3
   e06a8:	f04f 0900 	mov.w	r9, #0
   e06ac:	782b      	ldrb	r3, [r5, #0]
   e06ae:	2b2c      	cmp	r3, #44	; 0x2c
   e06b0:	bf08      	it	eq
   e06b2:	3501      	addeq	r5, #1
   e06b4:	f895 8000 	ldrb.w	r8, [r5]
   e06b8:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
   e06bc:	d126      	bne.n	e070c <_tzset_unlocked_r+0x1f8>
   e06be:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   e06c2:	9302      	str	r3, [sp, #8]
   e06c4:	ab09      	add	r3, sp, #36	; 0x24
   e06c6:	9300      	str	r3, [sp, #0]
   e06c8:	9603      	str	r6, [sp, #12]
   e06ca:	9601      	str	r6, [sp, #4]
   e06cc:	4633      	mov	r3, r6
   e06ce:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   e06d2:	494d      	ldr	r1, [pc, #308]	; (e0808 <_tzset_unlocked_r+0x2f4>)
   e06d4:	4628      	mov	r0, r5
   e06d6:	f7fb fb8f 	bl	dbdf8 <siscanf>
   e06da:	2803      	cmp	r0, #3
   e06dc:	d17e      	bne.n	e07dc <_tzset_unlocked_r+0x2c8>
   e06de:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
   e06e2:	1e4b      	subs	r3, r1, #1
   e06e4:	2b0b      	cmp	r3, #11
   e06e6:	d879      	bhi.n	e07dc <_tzset_unlocked_r+0x2c8>
   e06e8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   e06ec:	1e53      	subs	r3, r2, #1
   e06ee:	2b04      	cmp	r3, #4
   e06f0:	d874      	bhi.n	e07dc <_tzset_unlocked_r+0x2c8>
   e06f2:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
   e06f6:	2b06      	cmp	r3, #6
   e06f8:	d870      	bhi.n	e07dc <_tzset_unlocked_r+0x2c8>
   e06fa:	f887 8008 	strb.w	r8, [r7, #8]
   e06fe:	60f9      	str	r1, [r7, #12]
   e0700:	613a      	str	r2, [r7, #16]
   e0702:	617b      	str	r3, [r7, #20]
   e0704:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   e0706:	eb05 0803 	add.w	r8, r5, r3
   e070a:	e02a      	b.n	e0762 <_tzset_unlocked_r+0x24e>
   e070c:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
   e0710:	bf06      	itte	eq
   e0712:	3501      	addeq	r5, #1
   e0714:	4643      	moveq	r3, r8
   e0716:	2344      	movne	r3, #68	; 0x44
   e0718:	220a      	movs	r2, #10
   e071a:	a90b      	add	r1, sp, #44	; 0x2c
   e071c:	4628      	mov	r0, r5
   e071e:	9305      	str	r3, [sp, #20]
   e0720:	f7ff fe3e 	bl	e03a0 <strtoul>
   e0724:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   e0728:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
   e072c:	4545      	cmp	r5, r8
   e072e:	9b05      	ldr	r3, [sp, #20]
   e0730:	d114      	bne.n	e075c <_tzset_unlocked_r+0x248>
   e0732:	234d      	movs	r3, #77	; 0x4d
   e0734:	f1b9 0f00 	cmp.w	r9, #0
   e0738:	d107      	bne.n	e074a <_tzset_unlocked_r+0x236>
   e073a:	7223      	strb	r3, [r4, #8]
   e073c:	2303      	movs	r3, #3
   e073e:	60e3      	str	r3, [r4, #12]
   e0740:	2302      	movs	r3, #2
   e0742:	6123      	str	r3, [r4, #16]
   e0744:	f8c4 9014 	str.w	r9, [r4, #20]
   e0748:	e00b      	b.n	e0762 <_tzset_unlocked_r+0x24e>
   e074a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
   e074e:	230b      	movs	r3, #11
   e0750:	62a3      	str	r3, [r4, #40]	; 0x28
   e0752:	2301      	movs	r3, #1
   e0754:	62e3      	str	r3, [r4, #44]	; 0x2c
   e0756:	2300      	movs	r3, #0
   e0758:	6323      	str	r3, [r4, #48]	; 0x30
   e075a:	e002      	b.n	e0762 <_tzset_unlocked_r+0x24e>
   e075c:	b280      	uxth	r0, r0
   e075e:	723b      	strb	r3, [r7, #8]
   e0760:	6178      	str	r0, [r7, #20]
   e0762:	2302      	movs	r3, #2
   e0764:	f8ad 301c 	strh.w	r3, [sp, #28]
   e0768:	2300      	movs	r3, #0
   e076a:	f8ad 301e 	strh.w	r3, [sp, #30]
   e076e:	f8ad 3020 	strh.w	r3, [sp, #32]
   e0772:	930a      	str	r3, [sp, #40]	; 0x28
   e0774:	f898 3000 	ldrb.w	r3, [r8]
   e0778:	2b2f      	cmp	r3, #47	; 0x2f
   e077a:	d10b      	bne.n	e0794 <_tzset_unlocked_r+0x280>
   e077c:	9603      	str	r6, [sp, #12]
   e077e:	f8cd a008 	str.w	sl, [sp, #8]
   e0782:	9601      	str	r6, [sp, #4]
   e0784:	f8cd b000 	str.w	fp, [sp]
   e0788:	4633      	mov	r3, r6
   e078a:	aa07      	add	r2, sp, #28
   e078c:	491f      	ldr	r1, [pc, #124]	; (e080c <_tzset_unlocked_r+0x2f8>)
   e078e:	4640      	mov	r0, r8
   e0790:	f7fb fb32 	bl	dbdf8 <siscanf>
   e0794:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   e0798:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   e079c:	213c      	movs	r1, #60	; 0x3c
   e079e:	fb01 3302 	mla	r3, r1, r2, r3
   e07a2:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   e07a6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   e07aa:	fb01 3302 	mla	r3, r1, r2, r3
   e07ae:	61bb      	str	r3, [r7, #24]
   e07b0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   e07b2:	f109 0901 	add.w	r9, r9, #1
   e07b6:	f1b9 0f02 	cmp.w	r9, #2
   e07ba:	4445      	add	r5, r8
   e07bc:	f107 071c 	add.w	r7, r7, #28
   e07c0:	f47f af74 	bne.w	e06ac <_tzset_unlocked_r+0x198>
   e07c4:	6860      	ldr	r0, [r4, #4]
   e07c6:	f7ff fdf5 	bl	e03b4 <__tzcalc_limits>
   e07ca:	4b08      	ldr	r3, [pc, #32]	; (e07ec <_tzset_unlocked_r+0x2d8>)
   e07cc:	6a22      	ldr	r2, [r4, #32]
   e07ce:	601a      	str	r2, [r3, #0]
   e07d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   e07d2:	1a9b      	subs	r3, r3, r2
   e07d4:	4a07      	ldr	r2, [pc, #28]	; (e07f4 <_tzset_unlocked_r+0x2e0>)
   e07d6:	bf18      	it	ne
   e07d8:	2301      	movne	r3, #1
   e07da:	6013      	str	r3, [r2, #0]
   e07dc:	b00d      	add	sp, #52	; 0x34
   e07de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   e07e2:	bf00      	nop
   e07e4:	000e2ae0 	.word	0x000e2ae0
   e07e8:	2003e7e0 	.word	0x2003e7e0
   e07ec:	2003e7e8 	.word	0x2003e7e8
   e07f0:	000e2ae3 	.word	0x000e2ae3
   e07f4:	2003e7e4 	.word	0x2003e7e4
   e07f8:	2003daac 	.word	0x2003daac
   e07fc:	2003e7d3 	.word	0x2003e7d3
   e0800:	000e2ae7 	.word	0x000e2ae7
   e0804:	000e2b0a 	.word	0x000e2b0a
   e0808:	000e2af6 	.word	0x000e2af6
   e080c:	000e2b09 	.word	0x000e2b09
   e0810:	2003e7c8 	.word	0x2003e7c8

000e0814 <_findenv_r>:
   e0814:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   e0818:	4607      	mov	r7, r0
   e081a:	468b      	mov	fp, r1
   e081c:	4690      	mov	r8, r2
   e081e:	f000 f8d9 	bl	e09d4 <__env_lock>
   e0822:	4b19      	ldr	r3, [pc, #100]	; (e0888 <_findenv_r+0x74>)
   e0824:	681d      	ldr	r5, [r3, #0]
   e0826:	469a      	mov	sl, r3
   e0828:	b13d      	cbz	r5, e083a <_findenv_r+0x26>
   e082a:	465c      	mov	r4, fp
   e082c:	4623      	mov	r3, r4
   e082e:	f813 2b01 	ldrb.w	r2, [r3], #1
   e0832:	b142      	cbz	r2, e0846 <_findenv_r+0x32>
   e0834:	2a3d      	cmp	r2, #61	; 0x3d
   e0836:	461c      	mov	r4, r3
   e0838:	d1f8      	bne.n	e082c <_findenv_r+0x18>
   e083a:	4638      	mov	r0, r7
   e083c:	f000 f8cb 	bl	e09d6 <__env_unlock>
   e0840:	2000      	movs	r0, #0
   e0842:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   e0846:	ebcb 0404 	rsb	r4, fp, r4
   e084a:	46a9      	mov	r9, r5
   e084c:	f859 0b04 	ldr.w	r0, [r9], #4
   e0850:	2800      	cmp	r0, #0
   e0852:	d0f2      	beq.n	e083a <_findenv_r+0x26>
   e0854:	4622      	mov	r2, r4
   e0856:	4659      	mov	r1, fp
   e0858:	f7ff fc0e 	bl	e0078 <strncmp>
   e085c:	b988      	cbnz	r0, e0882 <_findenv_r+0x6e>
   e085e:	f859 3c04 	ldr.w	r3, [r9, #-4]
   e0862:	191e      	adds	r6, r3, r4
   e0864:	5d1b      	ldrb	r3, [r3, r4]
   e0866:	2b3d      	cmp	r3, #61	; 0x3d
   e0868:	d10b      	bne.n	e0882 <_findenv_r+0x6e>
   e086a:	f8da 3000 	ldr.w	r3, [sl]
   e086e:	1aed      	subs	r5, r5, r3
   e0870:	10ad      	asrs	r5, r5, #2
   e0872:	4638      	mov	r0, r7
   e0874:	f8c8 5000 	str.w	r5, [r8]
   e0878:	f000 f8ad 	bl	e09d6 <__env_unlock>
   e087c:	1c70      	adds	r0, r6, #1
   e087e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   e0882:	464d      	mov	r5, r9
   e0884:	e7e1      	b.n	e084a <_findenv_r+0x36>
   e0886:	bf00      	nop
   e0888:	2003daf4 	.word	0x2003daf4

000e088c <_getenv_r>:
   e088c:	b507      	push	{r0, r1, r2, lr}
   e088e:	aa01      	add	r2, sp, #4
   e0890:	f7ff ffc0 	bl	e0814 <_findenv_r>
   e0894:	b003      	add	sp, #12
   e0896:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000e089c <__gettzinfo>:
   e089c:	4800      	ldr	r0, [pc, #0]	; (e08a0 <__gettzinfo+0x4>)
   e089e:	4770      	bx	lr
   e08a0:	2003dab4 	.word	0x2003dab4

000e08a4 <gmtime_r>:
   e08a4:	6802      	ldr	r2, [r0, #0]
   e08a6:	4b47      	ldr	r3, [pc, #284]	; (e09c4 <gmtime_r+0x120>)
   e08a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   e08aa:	fb92 f4f3 	sdiv	r4, r2, r3
   e08ae:	fb03 2214 	mls	r2, r3, r4, r2
   e08b2:	2a00      	cmp	r2, #0
   e08b4:	bfbc      	itt	lt
   e08b6:	f502 32a8 	addlt.w	r2, r2, #86016	; 0x15000
   e08ba:	f502 72c0 	addlt.w	r2, r2, #384	; 0x180
   e08be:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   e08c2:	f504 242f 	add.w	r4, r4, #716800	; 0xaf000
   e08c6:	fb92 f3f0 	sdiv	r3, r2, r0
   e08ca:	fb00 2213 	mls	r2, r0, r3, r2
   e08ce:	f04f 003c 	mov.w	r0, #60	; 0x3c
   e08d2:	bfac      	ite	ge
   e08d4:	f604 246c 	addwge	r4, r4, #2668	; 0xa6c
   e08d8:	f604 246b 	addwlt	r4, r4, #2667	; 0xa6b
   e08dc:	608b      	str	r3, [r1, #8]
   e08de:	fb92 f3f0 	sdiv	r3, r2, r0
   e08e2:	fb00 2213 	mls	r2, r0, r3, r2
   e08e6:	604b      	str	r3, [r1, #4]
   e08e8:	600a      	str	r2, [r1, #0]
   e08ea:	2307      	movs	r3, #7
   e08ec:	1ce2      	adds	r2, r4, #3
   e08ee:	fb92 f3f3 	sdiv	r3, r2, r3
   e08f2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   e08f6:	1ad3      	subs	r3, r2, r3
   e08f8:	618b      	str	r3, [r1, #24]
   e08fa:	4b33      	ldr	r3, [pc, #204]	; (e09c8 <gmtime_r+0x124>)
   e08fc:	4d33      	ldr	r5, [pc, #204]	; (e09cc <gmtime_r+0x128>)
   e08fe:	fb94 f5f5 	sdiv	r5, r4, r5
   e0902:	fb03 4405 	mla	r4, r3, r5, r4
   e0906:	f648 62ac 	movw	r2, #36524	; 0x8eac
   e090a:	fbb4 f2f2 	udiv	r2, r4, r2
   e090e:	4422      	add	r2, r4
   e0910:	f240 57b4 	movw	r7, #1460	; 0x5b4
   e0914:	fbb4 f3f7 	udiv	r3, r4, r7
   e0918:	1ad2      	subs	r2, r2, r3
   e091a:	482d      	ldr	r0, [pc, #180]	; (e09d0 <gmtime_r+0x12c>)
   e091c:	fbb4 f0f0 	udiv	r0, r4, r0
   e0920:	f648 6694 	movw	r6, #36500	; 0x8e94
   e0924:	1a13      	subs	r3, r2, r0
   e0926:	fbb3 f6f6 	udiv	r6, r3, r6
   e092a:	4434      	add	r4, r6
   e092c:	f240 126d 	movw	r2, #365	; 0x16d
   e0930:	fbb3 f0f2 	udiv	r0, r3, r2
   e0934:	fbb3 f3f7 	udiv	r3, r3, r7
   e0938:	1ae3      	subs	r3, r4, r3
   e093a:	fb02 3310 	mls	r3, r2, r0, r3
   e093e:	2499      	movs	r4, #153	; 0x99
   e0940:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   e0944:	3202      	adds	r2, #2
   e0946:	fbb2 f2f4 	udiv	r2, r2, r4
   e094a:	2a0a      	cmp	r2, #10
   e094c:	fb04 f402 	mul.w	r4, r4, r2
   e0950:	f104 0602 	add.w	r6, r4, #2
   e0954:	f04f 0405 	mov.w	r4, #5
   e0958:	fbb6 f4f4 	udiv	r4, r6, r4
   e095c:	bf34      	ite	cc
   e095e:	2602      	movcc	r6, #2
   e0960:	f06f 0609 	mvncs.w	r6, #9
   e0964:	4416      	add	r6, r2
   e0966:	f44f 72c8 	mov.w	r2, #400	; 0x190
   e096a:	fb02 0505 	mla	r5, r2, r5, r0
   e096e:	1c5f      	adds	r7, r3, #1
   e0970:	2e01      	cmp	r6, #1
   e0972:	bf98      	it	ls
   e0974:	3501      	addls	r5, #1
   e0976:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
   e097a:	eba7 0704 	sub.w	r7, r7, r4
   e097e:	d302      	bcc.n	e0986 <gmtime_r+0xe2>
   e0980:	f5a3 7299 	sub.w	r2, r3, #306	; 0x132
   e0984:	e014      	b.n	e09b0 <gmtime_r+0x10c>
   e0986:	0782      	lsls	r2, r0, #30
   e0988:	d105      	bne.n	e0996 <gmtime_r+0xf2>
   e098a:	2464      	movs	r4, #100	; 0x64
   e098c:	fbb0 f2f4 	udiv	r2, r0, r4
   e0990:	fb04 0212 	mls	r2, r4, r2, r0
   e0994:	b94a      	cbnz	r2, e09aa <gmtime_r+0x106>
   e0996:	f44f 72c8 	mov.w	r2, #400	; 0x190
   e099a:	fbb0 f4f2 	udiv	r4, r0, r2
   e099e:	fb02 0014 	mls	r0, r2, r4, r0
   e09a2:	fab0 f280 	clz	r2, r0
   e09a6:	0952      	lsrs	r2, r2, #5
   e09a8:	e000      	b.n	e09ac <gmtime_r+0x108>
   e09aa:	2201      	movs	r2, #1
   e09ac:	333b      	adds	r3, #59	; 0x3b
   e09ae:	441a      	add	r2, r3
   e09b0:	f2a5 756c 	subw	r5, r5, #1900	; 0x76c
   e09b4:	2300      	movs	r3, #0
   e09b6:	61ca      	str	r2, [r1, #28]
   e09b8:	614d      	str	r5, [r1, #20]
   e09ba:	610e      	str	r6, [r1, #16]
   e09bc:	60cf      	str	r7, [r1, #12]
   e09be:	620b      	str	r3, [r1, #32]
   e09c0:	4608      	mov	r0, r1
   e09c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   e09c4:	00015180 	.word	0x00015180
   e09c8:	fffdc54f 	.word	0xfffdc54f
   e09cc:	00023ab1 	.word	0x00023ab1
   e09d0:	00023ab0 	.word	0x00023ab0

000e09d4 <__env_lock>:
   e09d4:	4770      	bx	lr

000e09d6 <__env_unlock>:
   e09d6:	4770      	bx	lr

000e09d8 <dynalib_user>:
   e09d8:	4021 000d 405d 000d 4089 000d 408d 000d     !@..]@...@...@..
   e09e8:	0000 0000                                   ....

000e09ec <_ZTVN8particle13__SPISettingsE>:
	...
   e09f4:	4565 000d                                   eE..

000e09f8 <_ZL19OV2640_352x288_JPEG>:
   e09f8:	00ff 0001 0012 0040 0017 0011 0018 0043     ......@.......C.
   e0a08:	0019 0000 001a 004b 0032 0009 004f 00ca     ......K.2...O...
   e0a18:	0050 00a8 005a 0023 006d 0000 0039 0012     P...Z.#.m...9...
   e0a28:	0035 00da 0022 001a 0037 00c3 0023 0000     5..."...7...#...
   e0a38:	0034 00c0 0036 001a 0006 0088 0007 00c0     4...6...........
   e0a48:	000d 0087 000e 0041 004c 0000 00ff 0000     ......A.L.......
   e0a58:	00e0 0004 00c0 0064 00c1 004b 0086 0035     ......d...K...5.
   e0a68:	0050 0089 0051 00c8 0052 0096 0053 0000     P...Q...R...S...
   e0a78:	0054 0000 0055 0000 0057 0000 005a 0058     T...U...W...Z.X.
   e0a88:	005b 0048 005c 0000 00e0 0000 00ff 00ff     [.H.\...........

000e0a98 <_ZL19OV2640_160x120_JPEG>:
   e0a98:	00ff 0001 0012 0040 0017 0011 0018 0043     ......@.......C.
   e0aa8:	0019 0000 001a 004b 0032 0009 004f 00ca     ......K.2...O...
   e0ab8:	0050 00a8 005a 0023 006d 0000 0039 0012     P...Z.#.m...9...
   e0ac8:	0035 00da 0022 001a 0037 00c3 0023 0000     5..."...7...#...
   e0ad8:	0034 00c0 0036 001a 0006 0088 0007 00c0     4...6...........
   e0ae8:	000d 0087 000e 0041 004c 0000 00ff 0000     ......A.L.......
   e0af8:	00e0 0004 00c0 0064 00c1 004b 0086 0035     ......d...K...5.
   e0b08:	0050 0092 0051 00c8 0052 0096 0053 0000     P...Q...R...S...
   e0b18:	0054 0000 0055 0000 0057 0000 005a 0028     T...U...W...Z.(.
   e0b28:	005b 001e 005c 0000 00e0 0000 00ff 00ff     [...\...........

000e0b38 <_ZL19OV2640_800x600_JPEG>:
   e0b38:	00ff 0001 0011 0001 0012 0000 0017 0011     ................
   e0b48:	0018 0075 0032 0036 0019 0001 001a 0097     ..u.2.6.........
   e0b58:	0003 000f 0037 0040 004f 00bb 0050 009c     ....7.@.O...P...
   e0b68:	005a 0057 006d 0080 003d 0034 0039 0002     Z.W.m...=.4.9...
   e0b78:	0035 0088 0022 000a 0037 0040 0034 00a0     5..."...7.@.4...
   e0b88:	0006 0002 000d 00b7 000e 0001 00ff 0000     ................
   e0b98:	00e0 0004 00c0 00c8 00c1 0096 0086 0035     ..............5.
   e0ba8:	0050 0089 0051 0090 0052 002c 0053 0000     P...Q...R.,.S...
   e0bb8:	0054 0000 0055 0088 0057 0000 005a 00c8     T...U...W...Z...
   e0bc8:	005b 0096 005c 0000 00d3 0002 00e0 0000     [...\...........
   e0bd8:	00ff 00ff                                   ....

000e0bdc <_ZL21OV2640_1280x1024_JPEG>:
   e0bdc:	00ff 0001 0011 0001 0012 0000 0017 0011     ................
   e0bec:	0018 0075 0032 0036 0019 0001 001a 0097     ..u.2.6.........
   e0bfc:	0003 000f 0037 0040 004f 00bb 0050 009c     ....7.@.O...P...
   e0c0c:	005a 0057 006d 0080 003d 0034 0039 0002     Z.W.m...=.4.9...
   e0c1c:	0035 0088 0022 000a 0037 0040 0034 00a0     5..."...7.@.4...
   e0c2c:	0006 0002 000d 00b7 000e 0001 00ff 0000     ................
   e0c3c:	00e0 0004 00c0 00c8 00c1 0096 0086 003d     ..............=.
   e0c4c:	0050 0000 0051 0090 0052 002c 0053 0000     P...Q...R.,.S...
   e0c5c:	0054 0000 0055 0088 0057 0000 005a 0040     T...U...W...Z.@.
   e0c6c:	005b 00f0 005c 0001 00d3 0002 00e0 0000     [...\...........
   e0c7c:	00ff 00ff                                   ....

000e0c80 <_ZL19OV2640_640x480_JPEG>:
   e0c80:	00ff 0001 0011 0001 0012 0000 0017 0011     ................
   e0c90:	0018 0075 0032 0036 0019 0001 001a 0097     ..u.2.6.........
   e0ca0:	0003 000f 0037 0040 004f 00bb 0050 009c     ....7.@.O...P...
   e0cb0:	005a 0057 006d 0080 003d 0034 0039 0002     Z.W.m...=.4.9...
   e0cc0:	0035 0088 0022 000a 0037 0040 0034 00a0     5..."...7.@.4...
   e0cd0:	0006 0002 000d 00b7 000e 0001 00ff 0000     ................
   e0ce0:	00e0 0004 00c0 00c8 00c1 0096 0086 003d     ..............=.
   e0cf0:	0050 0089 0051 0090 0052 002c 0053 0000     P...Q...R.,.S...
   e0d00:	0054 0000 0055 0088 0057 0000 005a 00a0     T...U...W...Z...
   e0d10:	005b 0078 005c 0000 00d3 0004 00e0 0000     [.x.\...........
   e0d20:	00ff 00ff                                   ....

000e0d24 <_ZL13OV2640_YUV422>:
   e0d24:	00ff 0000 0005 0000 00da 0010 00d7 0003     ................
   e0d34:	00df 0000 0033 0080 003c 0040 00e1 0077     ....3...<.@...w.
   e0d44:	0000 0000 00ff 00ff 6564 6166 6c75 2074     ........default 
   e0d54:	4d00 4253 4c00 4253 3c00 5053 5349 7465     .MSB.LSB.<SPISet
   e0d64:	6974 676e 2073 6564 6166 6c75 3e74 3c00     tings default>.<
   e0d74:	5053 5349 7465 6974 676e 2073 7325 6c25     SPISettings %s%l
   e0d84:	2075 7325 4d20 444f 2545 3e64 0000          u %s MODE%d>..

000e0d92 <_ZL11OV2640_JPEG>:
   e0d92:	00e0 0014 00e1 0077 00e5 001f 00d7 0003     ......w.........
   e0da2:	00da 0010 00e0 0000 00ff 0001 0004 0008     ................
   e0db2:	00ff 00ff                                   ....

000e0db6 <_ZL16OV2640_JPEG_INIT>:
   e0db6:	00ff 0000 002c 00ff 002e 00df 00ff 0001     ....,...........
   e0dc6:	003c 0032 0011 0000 0009 0002 0004 0028     <.2...........(.
   e0dd6:	0013 00e5 0014 0048 002c 000c 0033 0078     ......H.,...3.x.
   e0de6:	003a 0033 003b 00fb 003e 0000 0043 0011     :.3.;...>...C...
   e0df6:	0016 0010 0039 0092 0035 00da 0022 001a     ....9...5..."...
   e0e06:	0037 00c3 0023 0000 0034 00c0 0036 001a     7...#...4...6...
   e0e16:	0006 0088 0007 00c0 000d 0087 000e 0041     ..............A.
   e0e26:	004c 0000 0048 0000 005b 0000 0042 0003     L...H...[...B...
   e0e36:	004a 0081 0021 0099 0024 0040 0025 0038     J...!...$.@.%.8.
   e0e46:	0026 0082 005c 0000 0063 0000 0061 0070     &...\...c...a.p.
   e0e56:	0062 0080 007c 0005 0020 0080 0028 0030     b...|... ...(.0.
   e0e66:	006c 0000 006d 0080 006e 0000 0070 0002     l...m...n...p...
   e0e76:	0071 0094 0073 00c1 0012 0040 0017 0011     q...s.....@.....
   e0e86:	0018 0043 0019 0000 001a 004b 0032 0009     ..C.......K.2...
   e0e96:	0037 00c0 004f 0060 0050 00a8 006d 0000     7...O.`.P...m...
   e0ea6:	003d 0038 0046 003f 004f 0060 000c 003c     =.8.F.?.O.`...<.
   e0eb6:	00ff 0000 00e5 007f 00f9 00c0 0041 0024     ............A.$.
   e0ec6:	00e0 0014 0076 00ff 0033 00a0 0042 0020     ....v...3...B. .
   e0ed6:	0043 0018 004c 0000 0087 00d5 0088 003f     C...L.........?.
   e0ee6:	00d7 0003 00d9 0010 00d3 0082 00c8 0008     ................
   e0ef6:	00c9 0080 007c 0000 007d 0000 007c 0003     ....|...}...|...
   e0f06:	007d 0048 007d 0048 007c 0008 007d 0020     }.H.}.H.|...}. .
   e0f16:	007d 0010 007d 000e 0090 0000 0091 000e     }...}...........
   e0f26:	0091 001a 0091 0031 0091 005a 0091 0069     ......1...Z...i.
   e0f36:	0091 0075 0091 007e 0091 0088 0091 008f     ..u...~.........
   e0f46:	0091 0096 0091 00a3 0091 00af 0091 00c4     ................
   e0f56:	0091 00d7 0091 00e8 0091 0020 0092 0000     .......... .....
   e0f66:	0093 0006 0093 00e3 0093 0005 0093 0005     ................
   e0f76:	0093 0000 0093 0004 0093 0000 0093 0000     ................
   e0f86:	0093 0000 0093 0000 0093 0000 0093 0000     ................
   e0f96:	0093 0000 0096 0000 0097 0008 0097 0019     ................
   e0fa6:	0097 0002 0097 000c 0097 0024 0097 0030     ..........$...0.
   e0fb6:	0097 0028 0097 0026 0097 0002 0097 0098     ..(...&.........
   e0fc6:	0097 0080 0097 0000 0097 0000 00c3 00ed     ................
   e0fd6:	00a4 0000 00a8 0000 00c5 0011 00c6 0051     ..............Q.
   e0fe6:	00bf 0080 00c7 0010 00b6 0066 00b8 00a5     ..........f.....
   e0ff6:	00b7 0064 00b9 007c 00b3 00af 00b4 0097     ..d...|.........
   e1006:	00b5 00ff 00b0 00c5 00b1 0094 00b2 000f     ................
   e1016:	00c4 005c 00c0 0064 00c1 004b 008c 0000     ..\...d...K.....
   e1026:	0086 003d 0050 0000 0051 00c8 0052 0096     ..=.P...Q...R...
   e1036:	0053 0000 0054 0000 0055 0000 005a 00c8     S...T...U...Z...
   e1046:	005b 0096 005c 0000 00d3 0000 00c3 00ed     [...\...........
   e1056:	007f 0000 00da 0000 00e5 001f 00e1 0067     ..............g.
   e1066:	00e0 0000 00dd 007f 0005 0000 0012 0040     ..............@.
   e1076:	00d3 0004 00c0 0016 00c1 0012 008c 0000     ................
   e1086:	0086 003d 0050 0000 0051 002c 0052 0024     ..=.P...Q.,.R.$.
   e1096:	0053 0000 0054 0000 0055 0000 005a 002c     S...T...U...Z.,.
   e10a6:	005b 0024 005c 0000 00ff 00ff               [.$.\.......

000e10b2 <_ZL11OV2640_QVGA>:
   e10b2:	00ff 0000 002c 00ff 002e 00df 00ff 0001     ....,...........
   e10c2:	003c 0032 0011 0000 0009 0002 0004 00a8     <.2.............
   e10d2:	0013 00e5 0014 0048 002c 000c 0033 0078     ......H.,...3.x.
   e10e2:	003a 0033 003b 00fb 003e 0000 0043 0011     :.3.;...>...C...
   e10f2:	0016 0010 0039 0002 0035 0088 0022 000a     ....9...5..."...
   e1102:	0037 0040 0023 0000 0034 00a0 0006 0002     7.@.#...4.......
   e1112:	0006 0088 0007 00c0 000d 00b7 000e 0001     ................
   e1122:	004c 0000 004a 0081 0021 0099 0024 0040     L...J...!...$.@.
   e1132:	0025 0038 0026 0082 005c 0000 0063 0000     %.8.&...\...c...
   e1142:	0046 0022 000c 003a 005d 0055 005e 007d     F."...:.].U.^.}.
   e1152:	005f 007d 0060 0055 0061 0070 0062 0080     _.}.`.U.a.p.b...
   e1162:	007c 0005 0020 0080 0028 0030 006c 0000     |... ...(.0.l...
   e1172:	006d 0080 006e 0000 0070 0002 0071 0094     m...n...p...q...
   e1182:	0073 00c1 003d 0034 0012 0004 005a 0057     s...=.4.....Z.W.
   e1192:	004f 00bb 0050 009c 00ff 0000 00e5 007f     O...P...........
   e11a2:	00f9 00c0 0041 0024 00e0 0014 0076 00ff     ....A.$.....v...
   e11b2:	0033 00a0 0042 0020 0043 0018 004c 0000     3...B. .C...L...
   e11c2:	0087 00d0 0088 003f 00d7 0003 00d9 0010     ......?.........
   e11d2:	00d3 0082 00c8 0008 00c9 0080 007c 0000     ............|...
   e11e2:	007d 0000 007c 0003 007d 0048 007d 0048     }...|...}.H.}.H.
   e11f2:	007c 0008 007d 0020 007d 0010 007d 000e     |...}. .}...}...
   e1202:	0090 0000 0091 000e 0091 001a 0091 0031     ..............1.
   e1212:	0091 005a 0091 0069 0091 0075 0091 007e     ..Z...i...u...~.
   e1222:	0091 0088 0091 008f 0091 0096 0091 00a3     ................
   e1232:	0091 00af 0091 00c4 0091 00d7 0091 00e8     ................
   e1242:	0091 0020 0092 0000 0093 0006 0093 00e3     .. .............
   e1252:	0093 0003 0093 0003 0093 0000 0093 0002     ................
   e1262:	0093 0000 0093 0000 0093 0000 0093 0000     ................
   e1272:	0093 0000 0093 0000 0093 0000 0096 0000     ................
   e1282:	0097 0008 0097 0019 0097 0002 0097 000c     ................
   e1292:	0097 0024 0097 0030 0097 0028 0097 0026     ..$...0...(...&.
   e12a2:	0097 0002 0097 0098 0097 0080 0097 0000     ................
   e12b2:	0097 0000 00a4 0000 00a8 0000 00c5 0011     ................
   e12c2:	00c6 0051 00bf 0080 00c7 0010 00b6 0066     ..Q...........f.
   e12d2:	00b8 00a5 00b7 0064 00b9 007c 00b3 00af     ......d...|.....
   e12e2:	00b4 0097 00b5 00ff 00b0 00c5 00b1 0094     ................
   e12f2:	00b2 000f 00c4 005c 00a6 0000 00a7 0020     ......\....... .
   e1302:	00a7 00d8 00a7 001b 00a7 0031 00a7 0000     ..........1.....
   e1312:	00a7 0018 00a7 0020 00a7 00d8 00a7 0019     ...... .........
   e1322:	00a7 0031 00a7 0000 00a7 0018 00a7 0020     ..1........... .
   e1332:	00a7 00d8 00a7 0019 00a7 0031 00a7 0000     ..........1.....
   e1342:	00a7 0018 007f 0000 00e5 001f 00e1 0077     ..............w.
   e1352:	00dd 007f 00c2 000e 00ff 0000 00e0 0004     ................
   e1362:	00c0 00c8 00c1 0096 0086 003d 0051 0090     ..........=.Q...
   e1372:	0052 002c 0053 0000 0054 0000 0055 0088     R.,.S...T...U...
   e1382:	0057 0000 0050 0092 005a 0050 005b 003c     W...P...Z.P.[.<.
   e1392:	005c 0000 00d3 0004 00e0 0000 00ff 0000     \...............
   e13a2:	0005 0000 00da 0008 00d7 0003 00e0 0000     ................
   e13b2:	0005 0000 00ff 00ff                         ........

000e13ba <_ZL21OV2640_1600x1200_JPEG>:
   e13ba:	00ff 0001 0011 0001 0012 0000 0017 0011     ................
   e13ca:	0018 0075 0032 0036 0019 0001 001a 0097     ..u.2.6.........
   e13da:	0003 000f 0037 0040 004f 00bb 0050 009c     ....7.@.O...P...
   e13ea:	005a 0057 006d 0080 003d 0034 0039 0002     Z.W.m...=.4.9...
   e13fa:	0035 0088 0022 000a 0037 0040 0034 00a0     5..."...7.@.4...
   e140a:	0006 0002 000d 00b7 000e 0001 00ff 0000     ................
   e141a:	00e0 0004 00c0 00c8 00c1 0096 0086 003d     ..............=.
   e142a:	0050 0000 0051 0090 0052 002c 0053 0000     P...Q...R.,.S...
   e143a:	0054 0000 0055 0088 0057 0000 005a 0090     T...U...W...Z...
   e144a:	005b 002c 005c 0005 00d3 0002 00e0 0000     [.,.\...........
   e145a:	00ff 00ff                                   ....

000e145e <_ZL19OV2640_176x144_JPEG>:
   e145e:	00ff 0001 0012 0040 0017 0011 0018 0043     ......@.......C.
   e146e:	0019 0000 001a 004b 0032 0009 004f 00ca     ......K.2...O...
   e147e:	0050 00a8 005a 0023 006d 0000 0039 0012     P...Z.#.m...9...
   e148e:	0035 00da 0022 001a 0037 00c3 0023 0000     5..."...7...#...
   e149e:	0034 00c0 0036 001a 0006 0088 0007 00c0     4...6...........
   e14ae:	000d 0087 000e 0041 004c 0000 00ff 0000     ......A.L.......
   e14be:	00e0 0004 00c0 0064 00c1 004b 0086 0035     ......d...K...5.
   e14ce:	0050 0092 0051 00c8 0052 0096 0053 0000     P...Q...R...S...
   e14de:	0054 0000 0055 0000 0057 0000 005a 002c     T...U...W...Z.,.
   e14ee:	005b 0024 005c 0000 00e0 0000 00ff 00ff     [.$.\...........

000e14fe <_ZL20OV2640_1024x768_JPEG>:
   e14fe:	00ff 0001 0011 0001 0012 0000 0017 0011     ................
   e150e:	0018 0075 0032 0036 0019 0001 001a 0097     ..u.2.6.........
   e151e:	0003 000f 0037 0040 004f 00bb 0050 009c     ....7.@.O...P...
   e152e:	005a 0057 006d 0080 003d 0034 0039 0002     Z.W.m...=.4.9...
   e153e:	0035 0088 0022 000a 0037 0040 0034 00a0     5..."...7.@.4...
   e154e:	0006 0002 000d 00b7 000e 0001 00ff 0000     ................
   e155e:	00c0 00c8 00c1 0096 008c 0000 0086 003d     ..............=.
   e156e:	0050 0000 0051 0090 0052 002c 0053 0000     P...Q...R.,.S...
   e157e:	0054 0000 0055 0088 005a 0000 005b 00c0     T...U...Z...[...
   e158e:	005c 0001 00d3 0002 00ff 00ff               \...........

000e159a <_ZL19OV2640_320x240_JPEG>:
   e159a:	00ff 0001 0012 0040 0017 0011 0018 0043     ......@.......C.
   e15aa:	0019 0000 001a 004b 0032 0009 004f 00ca     ......K.2...O...
   e15ba:	0050 00a8 005a 0023 006d 0000 0039 0012     P...Z.#.m...9...
   e15ca:	0035 00da 0022 001a 0037 00c3 0023 0000     5..."...7...#...
   e15da:	0034 00c0 0036 001a 0006 0088 0007 00c0     4...6...........
   e15ea:	000d 0087 000e 0041 004c 0000 00ff 0000     ......A.L.......
   e15fa:	00e0 0004 00c0 0064 00c1 004b 0086 0035     ......d...K...5.
   e160a:	0050 0089 0051 00c8 0052 0096 0053 0000     P...Q...R...S...
   e161a:	0054 0000 0055 0000 0057 0000 005a 0050     T...U...W...Z.P.
   e162a:	005b 003c 005c 0000 00e0 0000 00ff 00ff     [.<.\...........

000e163a <_ZL5exif2>:
   e163a:	ea01 001c 0007 0800 000c 0800 0050 0000     ............P...
   e164a:	1c00 00ea 0000 ff08                              .......

000e1651 <_ZL5exif1>:
   e1651:	d8ff e0ff 1000 464a 4649 0100 0101 0000     ......JFIF......
   e1661:	0000 0000 e1ff f610 7845 6669 0000 4d4d     ........Exif..MM
   e1671:	2a00 0000 0800 0300 6987 0400 0000 0100     .*.......i......
   e1681:	0000 3e08 9e9c 0100 0000 9000 0000 5e10     ...>...........^
   e1691:	1cea 0700 0000 0c08 0000 3200 0000 0000     ...........2....
   e16a1:	ea1c 0000 0800                              ......

000e16a7 <_ZL5exif4>:
   e16a7:	0000 e1ff fc0d 7468 7074 2f3a 6e2f 2e73     ......http://ns.
   e16b7:	6461 626f 2e65 6f63 2f6d 6178 2f70 2e31     adobe.com/xap/1.
   e16c7:	2f30 3c00 783f 6170 6b63 7465 6220 6765     0/.<?xpacket beg
   e16d7:	6e69 273d bbef 27bf 6920 3d64 5727 4d35     in='...' id='W5M
   e16e7:	4d30 4370 6865 4869 727a 5365 4e7a 6354     0MpCehiHzreSzNTc
   e16f7:	6b7a 3963 2764 3e3f 0a0d 783c 783a 706d     zkc9d'?>..<x:xmp
   e1707:	656d 6174 7820 6c6d 736e 783a 223d 6461     meta xmlns:x="ad
   e1717:	626f 3a65 736e 6d3a 7465 2f61 3e22 723c     obe:ns:meta/"><r
   e1727:	6664 523a 4644 7820 6c6d 736e 723a 6664     df:RDF xmlns:rdf
   e1737:	223d 7468 7074 2f3a 772f 7777 772e 2e33     ="http://www.w3.
   e1747:	726f 2f67 3931 3939 302f 2f32 3232 722d     org/1999/02/22-r
   e1757:	6664 732d 6e79 6174 2d78 736e 2223 3c3e     df-syntax-ns#"><
   e1767:	6472 3a66 6544 6373 6972 7470 6f69 206e     rdf:Description 
   e1777:	6472 3a66 6261 756f 3d74 7522 6975 3a64     rdf:about="uuid:
   e1787:	6166 3566 6462 3564 622d 3361 2d64 3131     faf5bdd5-ba3d-11
   e1797:	6164 612d 3364 2d31 3364 6433 3537 3831     da-ad31-d33d7518
   e17a7:	6632 6231 2022 6d78 6e6c 3a73 6364 223d     2f1b" xmlns:dc="
   e17b7:	7468 7074 2f3a 702f 7275 2e6c 726f 2f67     http://purl.org/
   e17c7:	6364 652f 656c 656d 746e 2f73 2e31 2f31     dc/elements/1.1/
   e17d7:	2f22 3c3e 6472 3a66 6544 6373 6972 7470     "/><rdf:Descript
   e17e7:	6f69 206e 6472 3a66 6261 756f 3d74 7522     ion rdf:about="u
   e17f7:	6975 3a64 6166 3566 6462 3564 622d 3361     uid:faf5bdd5-ba3
   e1807:	2d64 3131 6164 612d 3364 2d31 3364 6433     d-11da-ad31-d33d
   e1817:	3537 3831 6632 6231 2022 6d78 6e6c 3a73     75182f1b" xmlns:
   e1827:	694d 7263 736f 666f 5074 6f68 6f74 223d     MicrosoftPhoto="
   e1837:	7468 7074 2f3a 6e2f 2e73 696d 7263 736f     http://ns.micros
   e1847:	666f 2e74 6f63 2f6d 6870 746f 2f6f 2e31     oft.com/photo/1.
   e1857:	2f30 2f22 3c3e 6472 3a66 6544 6373 6972     0/"/><rdf:Descri
   e1867:	7470 6f69 206e 6472 3a66 6261 756f 3d74     ption rdf:about=
   e1877:	7522 6975 3a64 6166 3566 6462 3564 622d     "uuid:faf5bdd5-b
   e1887:	3361 2d64 3131 6164 612d 3364 2d31 3364     a3d-11da-ad31-d3
   e1897:	6433 3537 3831 6632 6231 2022 6d78 6e6c     3d75182f1b" xmln
   e18a7:	3a73 6364 223d 7468 7074 2f3a 702f 7275     s:dc="http://pur
   e18b7:	2e6c 726f 2f67 6364 652f 656c 656d 746e     l.org/dc/element
   e18c7:	2f73 2e31 2f31 3e22 643c 3a63 7573 6a62     s/1.1/"><dc:subj
   e18d7:	6365 3e74 723c 6664 423a 6761 7820 6c6d     ect><rdf:Bag xml
   e18e7:	736e 723a 6664 223d 7468 7074 2f3a 772f     ns:rdf="http://w
   e18f7:	7777 772e 2e33 726f 2f67 3931 3939 302f     ww.w3.org/1999/0
   e1907:	2f32 3232 722d 6664 732d 6e79 6174 2d78     2/22-rdf-syntax-
   e1917:	736e 2223 3c3e 6472 3a66 696c 3c3e               ns#"><rdf:li>

000e1924 <_ZL5exif6>:
   e1924:	2f3c 6472 3a66 696c 3c3e 722f 6664 423a     </rdf:li></rdf:B
   e1934:	6761 0d3e 090a 0909 2f3c 6364 733a 6275     ag>.....</dc:sub
   e1944:	656a 7463 3c3e 722f 6664 443a 7365 7263     ject></rdf:Descr
   e1954:	7069 6974 6e6f 3c3e 6472 3a66 6544 6373     iption><rdf:Desc
   e1964:	6972 7470 6f69 206e 6472 3a66 6261 756f     ription rdf:abou
   e1974:	3d74 7522 6975 3a64 6166 3566 6462 3564     t="uuid:faf5bdd5
   e1984:	622d 3361 2d64 3131 6164 612d 3364 2d31     -ba3d-11da-ad31-
   e1994:	3364 6433 3537 3831 6632 6231 2022 6d78     d33d75182f1b" xm
   e19a4:	6e6c 3a73 694d 7263 736f 666f 5074 6f68     lns:MicrosoftPho
   e19b4:	6f74 223d 7468 7074 2f3a 6e2f 2e73 696d     to="http://ns.mi
   e19c4:	7263 736f 666f 2e74 6f63 2f6d 6870 746f     crosoft.com/phot
   e19d4:	2f6f 2e31 2f30 3e22 4d3c 6369 6f72 6f73     o/1.0/"><Microso
   e19e4:	7466 6850 746f 3a6f 614c 7473 654b 7779     ftPhoto:LastKeyw
   e19f4:	726f 5864 504d 3c3e 6472 3a66 6142 2067     ordXMP><rdf:Bag 
   e1a04:	6d78 6e6c 3a73 6472 3d66 6822 7474 3a70     xmlns:rdf="http:
   e1a14:	2f2f 7777 2e77 3377 6f2e 6772 312f 3939     //www.w3.org/199
   e1a24:	2f39 3230 322f 2d32 6472 2d66 7973 746e     9/02/22-rdf-synt
   e1a34:	7861 6e2d 2373 3e22 723c 6664 6c3a 3e69     ax-ns#"><rdf:li>

000e1a44 <_ZL5exif9>:
   e1a44:	3f3c 7078 6361 656b 2074 6e65 3d64 7727     <?xpacket end='w
   e1a54:	3f27 ff3e                                   '?>.

000e1a58 <_ZL5exif8>:
   e1a58:	2f3c 6472 3a66 696c 3c3e 722f 6664 423a     </rdf:li></rdf:B
   e1a68:	6761 0d3e 090a 0909 2f3c 694d 7263 736f     ag>.....</Micros
   e1a78:	666f 5074 6f68 6f74 4c3a 7361 4b74 7965     oftPhoto:LastKey
   e1a88:	6f77 6472 4d58 3e50 2f3c 6472 3a66 6544     wordXMP></rdf:De
   e1a98:	6373 6972 7470 6f69 3e6e 2f3c 6472 3a66     scription></rdf:
   e1aa8:	4452 3e46 2f3c 3a78 6d78 6d70 7465 3e61     RDF></x:xmpmeta>
   e1ab8:	0a0d 7061 7770 7464 5300 2044 6143 6472     ..appwdt.SD Card
   e1ac8:	6920 696e 6974 6c61 7a69 7461 6f69 206e      initialization 
   e1ad8:	6166 6c69 6465 2121 5220 7365 7465 6974     failed!! Resetti
   e1ae8:	676e 6920 206e 3531 7320 6365 6e6f 7364     ng in 15 seconds
   e1af8:	4c00 474f 2f53 2e00 5854 0054 7245 6f72     .LOGS/..TXT.Erro
   e1b08:	2072 6e69 6c20 676f 6420 7269 2e2e 002e     r in log dir....
   e1b18:	4453 6d20 646b 7269 6620 6961 656c 0064     SD mkdir failed.
   e1b28:	6f4e 4c20 676f 6420 7269 002e 6f63 6c75     No Log dir..coul
   e1b38:	2064 6f6e 2074 706f 6e65 6c20 676f 6620     d not open log f
   e1b48:	6c69 3a65 0020 5243 5449 4349 4c41 4520     ile: .CRITICAL E
   e1b58:	5252 524f 2020 2020 003b 4157 4e52 4e49     RROR    ;.WARNIN
   e1b68:	2047 2020 3b20 4900 464e 204f 2020 3b20     G    ;.INFO    ;
   e1b78:	2500 3430 2564 3230 2564 3230 3b64 3025     .%04d%02d%02d;%0
   e1b88:	6432 3025 6432 3025 6432 003b 6157 6374     2d%02d%02d;.Watc
   e1b98:	6468 676f 7420 6d69 6f65 7475 4600 4350     hdog timeout.FPC
   e1ba8:	0020 6170 7472 6369 656c 642f 7665 6369      .particle/devic
   e1bb8:	2f65 616e 656d 7000 7261 6974 6c63 2f65     e/name.particle/
   e1bc8:	6564 6976 6563 692f 0070 6944 6572 7463     device/ip.Direct
   e1bd8:	726f 2079 6f64 7365 6e20 746f 6520 6978     ory does not exi
   e1be8:	7473 202c 7274 6979 676e 7420 206f 7263     st, trying to cr
   e1bf8:	6165 6574 6920 2e74 2e2e 4e50 4453 424c     eate it...PNSDLB
   e1c08:	5300 2044 6b6d 6964 2072 6166 6c69 6465     .SD mkdir failed
   e1c18:	5020 534e 4c44 0042 6f63 6c75 2064 6f6e      PNSDLB.could no
   e1c28:	2074 706f 6e65 6c20 676f 6620 6c69 0065     t open log file.
   e1c38:	6f43 6c75 6e64 7427 6320 6e6f 656e 7463     Couldn't connect
   e1c48:	7420 206f 4200 6461 6620 7074 7520 6573      to .Bad ftp use
   e1c58:	6e72 6d61 0065 6142 2064 7466 2070 6170     rname.Bad ftp pa
   e1c68:	7373 6f77 6472 6300 756f 646c 6e20 746f     ssword.could not
   e1c78:	7320 7465 6420 7269 6365 6f74 7972 6600      set directory.f
   e1c88:	7074 6d20 646b 7269 6620 6961 656c 3a64     tp mkdir failed:
   e1c98:	0020 7466 2070 6b6d 6964 2072 7573 6363      .ftp mkdir succ
   e1ca8:	7365 3a73 0020 7325 255f 2564 3230 2564     ess: .%s_%d%02d%
   e1cb8:	0073 252f 2f73 6425 252f 2f64 7325 4c00     s./%s/%d/%d/%s.L
   e1cc8:	474f 0053 252f 2f73 7325 2f00 7325 252f     OGS./%s/%s./%s/%
   e1cd8:	2f64 6425 542f 4d45 2f50 7325 6300 756f     d/%d/TEMP/%s.cou
   e1ce8:	646c 6e20 746f 6620 6e69 2064 203a 6300     ld not find : .c
   e1cf8:	756f 646c 6e20 746f 6420 6c65 7465 2065     ould not delete 
   e1d08:	6966 656c 4600 0064 6654 6c69 3a65 0020     file.Fd.Tfile: .
   e1d18:	5320 3a44 4100 4300 756f 646c 6e20 746f      SD:.A.Could not
   e1d28:	6f20 6570 206e 6946 656c 6f20 206e 4453      open File on SD
   e1d38:	2e2e 202e 6241 726f 6974 676e 4300 756f     ... Aborting.Cou
   e1d48:	646c 276e 2074 7473 706f 6620 6c69 2065     ldn't stop file 
   e1d58:	7075 6f6c 6461 4600 6c69 2065 6973 657a     upload.File size
   e1d68:	6f20 206e 6573 7672 7265 3a20 0020 6f4c      on server : .Lo
   e1d78:	6163 206c 6966 656c 7320 7a69 2065 203a     cal file size : 
   e1d88:	4300 756f 646c 276e 2074 7571 7469 4620     .Couldn't quit F
   e1d98:	5054 5400 2054 2000 7042 2c73 7220 7465     TP.TT . Bps, ret
   e1da8:	6972 7365 203a 4300 656c 6e61 6e69 2067     ries: .Cleaning 
   e1db8:	6c6f 2064 6870 746f 736f 6f20 206e 4453     old photos on SD
   e1dc8:	2e2e 002e 7473 7461 7375 6300 536c 0044     ....status.clSD.
   e1dd8:	6452 0020 202c 6652 4300 656c 6e61 6e69     Rd ., Rf.Cleanin
   e1de8:	2067 6c6f 2064 6f6c 7367 6f20 206e 4453     g old logs on SD
   e1df8:	2e2e 002e 6c63 004c 5053 2049 6e69 6574     ....clL.SPI inte
   e1e08:	6672 6361 2065 7245 6f72 2172 7220 7365     rface Error! res
   e1e18:	7465 6974 676e 6920 206e 3531 7320 6365     etting in 15 sec
   e1e28:	6e6f 7364 202c 796d 6143 2e6d 6572 6461     onds, myCam.read
   e1e38:	725f 6765 7320 6961 2064 5300 4950 4520     _reg said .SPI E
   e1e48:	7272 726f 4300 6e61 7427 6620 6e69 2064     rror.Can't find 
   e1e58:	564f 3632 3034 6d20 646f 6c75 2165 6320     OV2640 module! c
   e1e68:	6d61 7265 2061 6173 7379 0020 6425 253a     amera says .%d:%
   e1e78:	0064 6850 746f 206f 6974 656d 756f 0074     d.Photo timeout.
   e1e88:	7349 0020 4554 504d 6400 7269 003a 3125     Is .TEMP.dir:.%1
   e1e98:	322e 0066 3225 0064 3025 6434 3025 6432     .2f.%2d.%04d%02d
   e1ea8:	3025 6432 2500 3230 2564 3230 2564 3230     %02d.%02d%02d%02
   e1eb8:	0064 4520 6978 2066 6e69 656a 7463 6f69     d. Exif injectio
   e1ec8:	206e 6f64 656e 4300 7061 7574 6572 6420     n done.Capture d
   e1ed8:	6e6f 0065 2222 5c5c 0862 0c66 0a6e 0d72     one.""\\b.f.n.r.
   e1ee8:	0974 6e00 6c75 006c 2d65 7400 7572 0065     t..null.e-.true.
   e1ef8:	6166 736c 0065 6146 6c69 6465 7420 206f     false.Failed to 
   e1f08:	7263 6165 6574 6320 6e6f 6966 2067 6966     create config fi
   e1f18:	656c 5300 7461 7375 4200 4844 7300 6174     le.Satus.BDH.sta
   e1f28:	6974 6e6f 614e 656d 5000 6275 696c 4963     tionName.PublicI
   e1f38:	0050 6143 7470 7275 5f65 6f4d 6564 4200     P.Capture_Mode.B
   e1f48:	7461 5f74 6f6c 5f77 5053 6600 7074 685f     att_low_SP.ftp_h
   e1f58:	736f 6e74 6d61 0065 7466 5f70 7375 7265     ostname.ftp_user
   e1f68:	616e 656d 6600 7074 705f 7361 7773 726f     name.ftp_passwor
   e1f78:	0064 7466 5f70 6964 0072 6146 6c69 6465     d.ftp_dir.Failed
   e1f88:	7420 206f 7277 7469 2065 6f74 6620 6c69      to write to fil
   e1f98:	0065 6146 6c69 6465 7420 206f 706f 6e65     e.Failed to open
   e1fa8:	6320 6e6f 6966 2067 6966 656c 6f20 206e      config file on 
   e1fb8:	4453 202c 7375 6e69 2067 6564 6166 6c75     SD, using defaul
   e1fc8:	0074 7453 7461 7375 4600 6961 656c 2064     t.Status.Failed 
   e1fd8:	6f74 7020 7261 6573 6320 6e6f 6966 2067     to parse config 
   e1fe8:	6966 656c 202c 7375 6e69 2067 6564 6166     file, using defa
   e1ff8:	6c75 0074 7075 4300 756f 646c 276e 2074     ult.up.Couldn't 
   e2008:	6f63 6e6e 6365 2074 6f74 6620 7074 6820     connect to ftp h
   e2018:	736f 0074 6142 2064 7375 7265 616e 656d     ost.Bad username
   e2028:	4200 6461 7020 7361 7773 726f 0064 412f     .Bad password./A
   e2038:	7475 436f 6d61 4544 2f48 6f63 666e 6769     utoCamDEH/config
   e2048:	002f 432f 4e4f 4946 2e47 534a 004e 6f43     /./CONFIG.JSN.Co
   e2058:	6c75 6e64 7427 7220 7465 6972 7665 2065     uldn't retrieve 
   e2068:	4f43 464e 4749 4a2e 4e53 6600 6c69 2065     CONFIG.JSN.file 
   e2078:	6f63 666e 6769 6a2e 6e73 6420 656f 6e73     config.jsn doesn
   e2088:	7427 6520 6978 7473 4600 6961 656c 2064     't exist.Failed 
   e2098:	6f74 6320 6572 7461 2065 656e 2077 6f63     to create new co
   e20a8:	666e 6769 7500 2770 6465 5700 0075 7557     nfig.up'ed.Wu.Wu
   e20b8:	5320 5f53 7542 7474 6e6f 6300 756f 646c      SS_Button.could
   e20c8:	6e20 746f 6320 6e6f 656e 7463 5300 4253      not connect.SSB
   e20d8:	7475 6f74 5f6e 6f6c 676e 7270 7365 2073     utton_longpress 
   e20e8:	3d3e 3120 3030 3030 202c 5300 6769 616e     >= 10000, .Signa
   e20f8:	206c 7551 7265 3a79 0020 4264 6300 756f     l Query: .dB.cou
   e2108:	646c 6e20 746f 6320 6e6f 656e 7463 7420     ld not connect t
   e2118:	206f 6c63 756f 0064 4357 0043 6954 656d     o cloud.WCC.Time
   e2128:	756f 2c74 4f20 004d 6954 656d 756f 2c74     out, OM.Timeout,
   e2138:	4320 004f 4f53 3b43 0020 563b 3b62 3b00      CO.SOC; .;Vb;.;
   e2148:	5352 4953 003b 513b 6175 3b6c 0020 6142     RSSI;.;Qual; .Ba
   e2158:	7474 535f 434f 5200 5353 0049 6e75 6564     tt_SOC.RSSI.unde
   e2168:	0066 3025 6432 3025 6432 3025 6432 3025     f.%02d%02d%02d%0
   e2178:	6432 6a2e 6770 4700 6172 5062 6369 6620     2d.jpg.GrabPic f
   e2188:	6961 656c 2c64 6e20 6d61 2065 666f 6620     ailed, name of f
   e2198:	6c69 3a65 0020 6142 7474 7265 2079 6f4c     ile: .Battery Lo
   e21a8:	2c77 7720 6961 6974 676e 6620 726f 7220     w, waiting for r
   e21b8:	6365 6168 6772 3a65 0020 5620 4900 7973     echarge: . V.Isy
   e21c8:	636e 6620 6961 006c 7349 6e79 2063 6166     nc fail.Isync fa
   e21d8:	6c69 6120 6167 6e69 4900 7553 0063 742e     il again.ISuc..t
   e21e8:	7478 4c00 7973 636e 6620 6961 006c 734c     xt.Lsync fail.Ls
   e21f8:	6e79 2063 6166 6c69 6120 6167 6e69 4c00     ync fail again.L
   e2208:	7553 0063 7325 252f 2f64 6425 742f 6d65     Suc.%s/%d/%d/tem
   e2218:	2f70 6c00 6f6f 696b 676e 6620 726f 203a     p/.looking for: 
   e2228:	6600 6c6f 6564 2072 6574 706d 6520 6978     .folder temp exi
   e2238:	7473 0073 6f66 646c 7265 7420 6d65 2070     sts.folder temp 
   e2248:	6f64 7365 276e 2074 7865 7369 7374 5300     doesn't exists.S
   e2258:	656c 7065 6e69 0067 6954 656d 5320 6e79     leeping.Time Syn
   e2268:	6563 2164 5400 7953 636e 5400 6d69 2065     ced!.TSync.Time 
   e2278:	7953 636e 6620 6961 656c 2164 4e00 6d61     Sync failed!.Nam
   e2288:	2065 666f 6f20 6666 696c 656e 7020 6369     e of offline pic
   e2298:	203a 4200 6361 756b 2070 6950 2063 7564     : .Backup Pic du
   e22a8:	706d 4420 6e6f 0065 7247 6261 5020 6369     mp Done.Grab Pic
   e22b8:	4300 656c 6e61 4453 5200 7365 7465 4320     .CleanSD.Reset C
   e22c8:	646f 3a65 0020 6e49 7469 0020 3156 342e     ode: .Init .V1.4
   e22d8:	3233 5200 4354 6920 2073 4f4e 2054 7572     32.RTC is NOT ru
   e22e8:	6e6e 6e69 2167 3100 3a31 3535 343a 0039     nning!.11:55:49.
   e22f8:	6f4e 2076 3320 3220 3230 0030 3431 2e32     Nov  3 2020.142.
   e2308:	3132 2e33 3631 2e36 3831 0034 7062 0031     213.166.184.bp1.
   e2318:	6c42 7579 6548 3774 2f00 7541 6f74 6143     BlyuHet7./AutoCa
   e2328:	446d 4845 5500 444e 4645 005f 3030 3030     mDEH.UNDEF_.0000
   e2338:	0030 6f6e 495f 0050 3c7c 5e3e 3d2b 2f3f     0.no_IP.|<>^+=?/
   e2348:	5d5b 2c3b 222a 005c                         [];,*"\.

000e2350 <_ZTV6SdFile>:
	...
   e2358:	9659 000d 965b 000d 9ffd 000d cdf9 000d     Y...[...........

000e2368 <_ZTVN5SDLib4FileE>:
	...
   e2370:	4c03 000d 942d 000d a5a5 000d a5bb 000d     .L..-...........
   e2380:	a6e3 000d a615 000d a627 000d a5eb 000d     ........'.......
   e2390:	a5e1 000d 4953 455a 0020 444d 4d54 0020     ....SIZE .MDTM .
   e23a0:	5750 0044 5355 5245 0020 4150 5353 0020     PWD.USER .PASS .
   e23b0:	5743 2044 4d00 444b 0020 4d52 2044 5400     CWD .MKD .RMD .T
   e23c0:	5059 2045 4400 4c45 2045 4300 5544 0050     YPE .DELE .CDUP.
   e23d0:	5551 5449 4100 4f42 0052 4150 5653 2800     QUIT.ABOR.PASV.(
   e23e0:	292c 4c00 5349 2054 5300 4f54 2052 5200     ,).LIST .STOR .R
   e23f0:	5445 2052 1f00                                   ETR .

000e23f5 <_ZL11daysInMonth>:
   e23f5:	1c1f 1e1f 1e1f 1f1f 1f1e 1f1e 0000 0000          ...............

000e2404 <_ZTVN5spark13EthernetClassE>:
	...
   e240c:	bfe9 000d bfdf 000d bfd5 000d bfcb 000d     ................
   e241c:	bfbf 000d bfb3 000d bfa7 000d bf9f 000d     ................
   e242c:	bf95 000d bf8b 000d e9e3 000d               ............

000e2438 <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
   e2438:	0800 1810 2820 3830                         .... (08

000e2440 <_ZTVSt19_Sp_counted_deleterIPN8particle17BlePeerDeviceImplENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
   e2448:	c84d 000d c853 000d ca2f 000d c861 000d     M...S.../...a...
   e2458:	c84f 000d 6977 6972 676e 622e 656c 5300     O...wiring.ble.S
   e2468:	6174 7472 6420 7369 6f63 6576 6972 676e     tart discovering
   e2478:	7320 7265 6976 6563 2e73 5300 6174 7472      services..Start
   e2488:	6420 7369 6f63 6576 6972 676e 6320 6168      discovering cha
   e2498:	6172 7463 7265 7369 6974 7363 002e 6550     racteristics..Pe
   e24a8:	7265 6420 7665 6369 2065 7369 6d20 7369     er device is mis
   e24b8:	6973 676e 0021 6146 6c69 6465 7420 206f     sing!.Failed to 
   e24c8:	7061 6570 646e 7020 6565 2072 6543 746e     append peer Cent
   e24d8:	6172 206c 6564 6976 6563 002e 6f43 6e6e     ral device..Conn
   e24e8:	6365 6574 2064 7962 4320 6e65 7274 6c61     ected by Central
   e24f8:	6420 7665 6369 2e65 4400 7369 6f63 6e6e      device..Disconn
   e2508:	6365 6574 2064 7962 7220 6d65 746f 2065     ected by remote 
   e2518:	6564 6976 6563 002e 6143 6e6e 746f 6120     device..Cannot a
   e2528:	6464 6e20 7765 7020 6565 2072 6564 6976     dd new peer devi
   e2538:	6563 002e 654e 2077 6570 6972 6870 7265     ce..New peripher
   e2548:	6c61 6920 2073 6f63 6e6e 6365 6574 2e64     al is connected.
   e2558:	4600 6961 656c 2064 6f74 6120 7070 6e65     .Failed to appen
   e2568:	2064 6964 6373 766f 7265 6465 6320 6168     d discovered cha
   e2578:	6172 7463 7265 7369 6974 2e63 4600 6961     racteristic..Fai
   e2588:	656c 2064 6f74 6120 7070 6e65 2064 6964     led to append di
   e2598:	6373 766f 7265 6465 7320 7265 6976 6563     scovered service
   e25a8:	002e 6146 6c69 6465 7420 206f 7061 6570     ..Failed to appe
   e25b8:	646e 6c20 636f 6c61 6320 6168 6172 7463     nd local charact
   e25c8:	7265 7369 6974 2e63 4400 7075 696c 6163     eristic..Duplica
   e25d8:	6574 2064 6863 7261 6361 6574 6972 7473     ted characterist
   e25e8:	6369 6320 6e61 6f6e 2074 6562 6120 6464     ic cannot be add
   e25f8:	6465 002e                                   ed..

000e25fc <_ZTV5Print>:
	...
   e260c:	40a9 000d cdf9 000d 6162 6475 5300 7265     .@......baud.Ser
   e261c:	6169 006c 6553 6972 6c61 0031 7974 6570     ial.Serial1.type
   e262c:	7000 7261 6d61 6300 646d 6900 0064 6e68     .param.cmd.id.hn
   e263c:	0064 7473 6d72 6600 6c69 0074 766c 006c     d.strm.filt.lvl.
   e264c:	6461 4864 6e61 6c64 7265 7200 6d65 766f     addHandler.remov
   e265c:	4865 6e61 6c64 7265 6500 756e 486d 6e61     eHandler.enumHan
   e266c:	6c64 7265 0073 534a 4e4f 7453 6572 6d61     dlers.JSONStream
   e267c:	6f4c 4867 6e61 6c64 7265 6100 7070 2500     LogHandler.app.%
   e268c:	3130 7530 0020 205d 2800 3a29 0020 5b20     010u .] .(): . [
   e269c:	6300 646f 2065 203d 2500 0069 6564 6174     .code = .%i.deta
   e26ac:	6c69 2073 203d 0d00 000a 6e6c 6600 006e     ils = ....ln.fn.
   e26bc:	6f63 6564 6400 7465 6961 006c 6f6e 656e     code.detail.none
   e26cc:	7400 6172 6563 6900 666e 006f 6177 6e72     .trace.info.warn
   e26dc:	6500 7272 726f 7000 6e61 6369 6100 6c6c     .error.panic.all
   e26ec:	2500 302b 6433 253a 3230 0075 5925 252d     .%+03d:%02u.%Y-%
   e26fc:	2d6d 6425 2554 3a48 4d25 253a 2553 007a     m-%dT%H:%M:%S%z.
   e270c:	7361 7463 6d69 0065                         asctime.

000e2714 <_ZTV14CellularSignal>:
	...
   e271c:	d249 000d d2a9 000d d24b 000d d2ed 000d     I.......K.......
   e272c:	d251 000d d2b9 000d d27d 000d d377 000d     Q.......}...w...
   e273c:	fffc ffff 0000 0000 d3a1 000d               ............

000e2748 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   e2750:	d6c9 000d d6cf 000d d713 000d d6dd 000d     ................
   e2760:	d6cb 000d                                   ....

000e2764 <_ZTV9IPAddress>:
	...
   e276c:	dcc1 000d dcb1 000d dcb3 000d               ............

000e2778 <_ZTV9USBSerial>:
	...
   e2780:	dddf 000d de2f 000d de3d 000d cdf9 000d     ..../...=.......
   e2790:	de1b 000d dde1 000d ddf7 000d de29 000d     ............)...
   e27a0:	de0d 000d dddb 000d                         ........

000e27a8 <_ZTVN5spark13CellularClassE>:
	...
   e27b0:	df29 000d df1f 000d df15 000d 4cbd 000d     )............L..
   e27c0:	4ca5 000d 4cb1 000d df09 000d df01 000d     .L...L..........
   e27d0:	def7 000d deed 000d e9e3 000d               ............

000e27dc <_ZTV11USARTSerial>:
	...
   e27e4:	dfd9 000d e029 000d e037 000d cdf9 000d     ....)...7.......
   e27f4:	dfed 000d e00f 000d dffb 000d e023 000d     ............#...
   e2804:	dfdb 000d dfdf 000d                         ........

000e280c <_ZTV7TwoWire>:
	...
   e2814:	e139 000d e183 000d e15b 000d e13b 000d     9.......[...;...
   e2824:	e163 000d e16b 000d e173 000d e17b 000d     c...k...s...{...

000e2834 <_ZTVN5spark9MeshClassE>:
	...
   e283c:	e2d1 000d e2c7 000d e2bd 000d e2b3 000d     ................
   e284c:	e2a7 000d e29b 000d e28f 000d e287 000d     ................
   e285c:	e27d 000d e273 000d e9e3 000d               }...s.......

000e2868 <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
   e2870:	e475 000d e47b 000d e963 000d e489 000d     u...{...c.......
   e2880:	e477 000d                                   w...

000e2884 <_ZTV9TCPClient>:
	...
   e288c:	d165 000d d185 000d e3ed 000d e407 000d     e...............
   e289c:	e809 000d e55b 000d e52d 000d e431 000d     ....[...-...1...
   e28ac:	e6e5 000d e5e1 000d e58f 000d e7d9 000d     ................
   e28bc:	e433 000d e46b 000d e419 000d e48d 000d     3...k...........
   e28cc:	e50d 000d 6977 6972 676e 7200 6365 2076     ....wiring.recv 
   e28dc:	7265 6f72 2072 203d 6425 0000               error = %d..

000e28e8 <_ZTVN5spark12NetworkClassE>:
	...
   e28f0:	e97b 000d e985 000d e98f 000d e999 000d     {...............
   e2900:	e9a3 000d e9af 000d e9bb 000d e9c7 000d     ................
   e2910:	e9cf 000d e9d9 000d e9e3 000d               ............

000e291c <_ZSt7nothrow>:
	...

000e291d <_ctype_>:
   e291d:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   e292d:	2020 2020 2020 2020 2020 2020 2020 2020                     
   e293d:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   e294d:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   e295d:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   e296d:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   e297d:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   e298d:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   e299d:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

000e2a20 <__sf_fake_stdin>:
	...

000e2a40 <__sf_fake_stdout>:
	...

000e2a60 <__sf_fake_stderr>:
	...

000e2a80 <__month_lengths>:
   e2a80:	001f 0000 001c 0000 001f 0000 001e 0000     ................
   e2a90:	001f 0000 001e 0000 001f 0000 001f 0000     ................
   e2aa0:	001e 0000 001f 0000 001e 0000 001f 0000     ................
   e2ab0:	001f 0000 001d 0000 001f 0000 001e 0000     ................
   e2ac0:	001f 0000 001e 0000 001f 0000 001f 0000     ................
   e2ad0:	001e 0000 001f 0000 001e 0000 001f 0000     ................
   e2ae0:	5a54 4700 544d 2500 3031 5e5b 2d30 2c39     TZ.GMT.%10[^0-9,
   e2af0:	2d2b 255d 006e 254d 7568 6e25 252e 7568     +-]%n.M%hu%n.%hu
   e2b00:	6e25 252e 7568 6e25 2f00 6825 2575 3a6e     %n.%hu%n./%hu%n:
   e2b10:	6825 2575 3a6e 6825 2575 006e               %hu%n:%hu%n.

000e2b1c <link_const_variable_data_end>:
   e2b1c:	000d44f5 	.word	0x000d44f5
   e2b20:	000d4bd5 	.word	0x000d4bd5
   e2b24:	000d943d 	.word	0x000d943d
   e2b28:	000da08d 	.word	0x000da08d
   e2b2c:	000da581 	.word	0x000da581
   e2b30:	000da72f 	.word	0x000da72f
   e2b34:	000da733 	.word	0x000da733
   e2b38:	000db1e3 	.word	0x000db1e3
   e2b3c:	000db655 	.word	0x000db655
   e2b40:	000dbff5 	.word	0x000dbff5
   e2b44:	000dc2e1 	.word	0x000dc2e1
   e2b48:	000dcdd1 	.word	0x000dcdd1
   e2b4c:	000dcf89 	.word	0x000dcf89
   e2b50:	000dd129 	.word	0x000dd129
   e2b54:	000dd22d 	.word	0x000dd22d
   e2b58:	000ddfa9 	.word	0x000ddfa9
   e2b5c:	000de39d 	.word	0x000de39d
   e2b60:	000deab1 	.word	0x000deab1
   e2b64:	000ded7d 	.word	0x000ded7d
   e2b68:	000dee01 	.word	0x000dee01
   e2b6c:	000deec5 	.word	0x000deec5
   e2b70:	000def89 	.word	0x000def89

000e2b74 <link_constructors_end>:
	...
